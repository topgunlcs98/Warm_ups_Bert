▁public ▁class ▁Tr ending St ick ers Layout ▁extends ▁FrameLayout ▁implements ▁Notification Center ▁. ▁Notification Center Delegate ▁{ ▁public ▁abstract ▁static ▁class ▁Delegate ▁{ ▁private ▁String ▁[ ▁] ▁last Search Keyboard Language ▁= ▁new ▁String ▁[ ▁0 ▁] ▁; ▁public ▁void ▁on St icker Set Add ▁( ▁TLRPC ▁. ▁Sticker Set Co ver ed ▁st icker Set ▁, ▁boolean ▁primary ▁) ▁{ ▁} ▁public ▁void ▁on St icker Set Remove ▁( ▁TLRPC ▁. ▁Sticker Set Co ver ed ▁st icker Set ▁) ▁{ ▁} ▁public ▁boolean ▁on List View Intercept Touch Event ▁( ▁Rec ycler List View ▁list View ▁, ▁MotionEvent ▁event ▁) ▁{ ▁return ▁false ▁; ▁} ▁public ▁boolean ▁on List View Touch Event ▁( ▁Rec ycler List View ▁list View ▁, ▁Rec ycler List View ▁. ▁On Item ClickListener ▁on Item ClickListener ▁, ▁MotionEvent ▁event ▁) ▁{ ▁return ▁false ▁; ▁} ▁public ▁String ▁[ ▁] ▁getLast Search Keyboard Language ▁( ▁) ▁{ ▁return ▁last Search Keyboard Language ▁; ▁} ▁public ▁void ▁setLast Search Keyboard Language ▁( ▁String ▁[ ▁] ▁language ▁) ▁{ ▁last Search Keyboard Language ▁= ▁language ▁; ▁} ▁public ▁boolean ▁can Send St icker ▁( ▁) ▁{ ▁return ▁false ▁; ▁} ▁public ▁void ▁on St icker Selected ▁( ▁TLRPC ▁. ▁Document ▁st icker ▁, ▁Object ▁parent ▁, ▁boolean ▁clear s Input Field ▁, ▁boolean ▁notify ▁, ▁int ▁schedule Date ▁) ▁{ ▁} ▁public ▁boolean ▁can Schedule ▁( ▁) ▁{ ▁return ▁false ▁; ▁} ▁public ▁boolean ▁isIn Schedule Mode ▁( ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁private ▁final ▁int ▁current Account ▁= ▁User Config ▁. ▁selected Account ▁; ▁private ▁final ▁Delegate ▁delegate ▁; ▁private ▁final ▁TLRPC ▁. ▁Sticker Set Co ver ed ▁[ ▁] ▁primary Install ing St icker Sets ▁; ▁private ▁final ▁Long Sparse Array ▁< ▁TLRPC ▁. ▁Sticker Set Co ver ed ▁> ▁install ing St icker Sets ▁; ▁private ▁final ▁Long Sparse Array ▁< ▁TLRPC ▁. ▁Sticker Set Co ver ed ▁> ▁remo ving St icker Sets ▁; ▁private ▁final ▁View ▁shadow View ▁; ▁private ▁final ▁Search Field ▁search View ▁; ▁private ▁final ▁Rec ycler List View ▁list View ▁; ▁private ▁final ▁GridLayout Manager ▁layout Manager ▁; ▁private ▁final ▁Tr ending St ick ers Adapter ▁adapter ▁; ▁private ▁final ▁St ick ers Search Adapter ▁search Adapter ▁; ▁private ▁final ▁FrameLayout ▁search Layout ▁; ▁private ▁Base Fragment ▁parent Fragment ▁; ▁private ▁Rec ycler List View ▁. ▁On Scroll Listener ▁on Scroll Listener ▁; ▁private ▁int ▁top Offset ▁; ▁private ▁boolean ▁m otion Event Catch ed By List View ▁; ▁private ▁boolean ▁shadow Visible ▁; ▁private ▁boolean ▁ignore Layout ▁; ▁private ▁boolean ▁was Layout ▁; ▁private ▁boolean ▁loaded ▁; ▁private ▁int ▁hash ▁; ▁ValueAnimator ▁gl ue To Top Animator ▁; ▁private ▁boolean ▁gl ue d To Top ▁; ▁private ▁boolean ▁scroll From Animator ▁;
▁public ▁class ▁Ex ist ing Pairs UnitTest ▁{ ▁@ ▁Test ▁public ▁void ▁when Tr ad ition al Loop _ thenReturn All Existing Pairs ▁( ▁) ▁{ ▁final ▁int ▁[ ▁] ▁input ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁3 ▁, ▁3 ▁, ▁8 ▁} ▁; ▁final ▁int ▁sum ▁= ▁6 ▁; ▁final ▁List ▁< ▁Integer ▁> ▁pair s ▁= ▁Ex ist ing Pairs ▁. ▁find Pair sWith For Loop ▁( ▁input ▁, ▁sum ▁) ▁; ▁assertThat ▁( ▁pair s ▁) ▁. ▁hasSize ▁( ▁4 ▁) ▁. ▁contains ▁( ▁2 ▁, ▁4 ▁, ▁3 ▁, ▁3 ▁) ▁. ▁doesNotContain ▁( ▁8 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁when Stream Api _ thenReturn All Existing Pairs ▁( ▁) ▁{ ▁final ▁int ▁[ ▁] ▁input ▁= ▁{ ▁2 ▁, ▁4 ▁, ▁3 ▁, ▁3 ▁, ▁8 ▁} ▁; ▁final ▁int ▁sum ▁= ▁6 ▁; ▁final ▁List ▁< ▁Integer ▁> ▁pair s ▁= ▁Ex ist ing Pairs ▁. ▁find Pair sWith Stream Api ▁( ▁input ▁, ▁sum ▁) ▁; ▁assertThat ▁( ▁pair s ▁) ▁. ▁hasSize ▁( ▁4 ▁) ▁. ▁contains ▁( ▁2 ▁, ▁4 ▁, ▁3 ▁, ▁3 ▁) ▁. ▁doesNotContain ▁( ▁8 ▁) ▁; ▁} ▁}
▁@ ▁Override ▁protected ▁T ▁do Forward ▁( ▁String ▁value ▁) ▁{ ▁return ▁Enum ▁. ▁valueOf ▁( ▁enum Class ▁, ▁value ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁String ▁do Backward ▁( ▁T ▁enum Value ▁) ▁{ ▁return ▁enum Value ▁. ▁name ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁@ ▁CheckForNull ▁Object ▁object ▁) ▁{ ▁if ▁( ▁object ▁instanceof ▁String Converter ▁) ▁{ ▁String Converter ▁< ▁? ▁> ▁that ▁= ▁( ▁String Converter ▁< ▁? ▁> ▁) ▁object ▁; ▁return ▁this ▁. ▁enum Class ▁. ▁equals ▁( ▁that ▁. ▁enum Class ▁) ▁; ▁} ▁return ▁false ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁enum Class ▁. ▁hashCode ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁enum Class ▁. ▁getName ▁( ▁) ▁+ ▁STR ▁; ▁} ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁0 L ▁; ▁} ▁}
▁monitor ingService ▁= ▁new ▁Monitoring Service ▁( ▁settings ▁, ▁clusterService ▁, ▁threadPool ▁, ▁emptySet ▁( ▁) ▁, ▁exporter ▁) ▁; ▁monitor ingService ▁. ▁start ▁( ▁) ▁; ▁assertBusy ▁( ▁( ▁) ▁-> ▁assertTrue ▁( ▁monitor ingService ▁. ▁is Started ▁( ▁) ▁) ▁) ▁; ▁assertFalse ▁( ▁STR ▁, ▁monitor ingService ▁. ▁is Monitoring Active ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁exporter ▁. ▁getEx ports Count ▁( ▁) ▁) ▁; ▁monitor ingService ▁. ▁set Monitoring Active ▁( ▁true ▁) ▁; ▁assertTrue ▁( ▁monitor ingService ▁. ▁is Monitoring Active ▁( ▁) ▁) ▁; ▁assertBusy ▁( ▁( ▁) ▁-> ▁assertThat ▁( ▁exporter ▁. ▁getEx ports Count ▁( ▁) ▁, ▁greaterThan ▁( ▁0 ▁) ▁) ▁) ▁; ▁monitor ingService ▁. ▁set Monitoring Active ▁( ▁false ▁) ▁; ▁} ▁public ▁void ▁test Skip Execution ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁CountDownLatch ▁latch ▁= ▁new ▁CountDownLatch ▁( ▁1 ▁) ▁; ▁final ▁Blocking Exporter ▁exporter ▁= ▁new ▁Blocking Exporter ▁( ▁latch ▁) ▁; ▁final ▁Settings ▁settings ▁= ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁STR ▁, ▁true ▁) ▁. ▁put ▁( ▁STR ▁, ▁Monitoring Service ▁. ▁MIN _ INTERVAL ▁) ▁. ▁build ▁( ▁) ▁; ▁monitor ingService ▁= ▁new ▁Monitoring Service ▁( ▁settings ▁, ▁clusterService ▁, ▁threadPool ▁, ▁emptySet ▁( ▁) ▁, ▁exporter ▁) ▁; ▁monitor ingService ▁. ▁start ▁( ▁) ▁; ▁assertBusy ▁( ▁( ▁) ▁-> ▁assertTrue ▁( ▁monitor ingService ▁. ▁is Started ▁( ▁) ▁) ▁) ▁; ▁assertBusy ▁( ▁( ▁) ▁-> ▁assertThat ▁( ▁exporter ▁. ▁getEx ports Count ▁( ▁) ▁, ▁equalTo ▁( ▁1 ▁) ▁) ▁) ▁; ▁monitor ingService ▁. ▁cancel Execution ▁( ▁) ▁; ▁latch ▁. ▁countDown ▁( ▁) ▁; ▁assertThat ▁( ▁exporter ▁. ▁getEx ports Count ▁( ▁) ▁, ▁equalTo ▁( ▁1 ▁) ▁) ▁; ▁} ▁class ▁Counting Exporter ▁extends ▁Exporter s ▁{ ▁private ▁final ▁AtomicInteger ▁ex ports ▁= ▁new ▁AtomicInteger ▁( ▁0 ▁) ▁; ▁Counting Exporter ▁( ▁) ▁{ ▁super ▁( ▁Settings ▁. ▁EMPTY ▁, ▁Collections ▁. ▁emptyMap ▁( ▁) ▁, ▁clusterService ▁, ▁licenseState ▁, ▁threadPool ▁. ▁getThread Context ▁( ▁) ▁, ▁ssl Service ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁export ▁( ▁Collection ▁< ▁Monitoring Doc ▁> ▁docs ▁, ▁ActionListener ▁< ▁Void ▁> ▁listener ▁) ▁{ ▁ex ports ▁. ▁incrementAndGet ▁( ▁) ▁; ▁listener ▁. ▁onResponse ▁( ▁null ▁) ▁; ▁} ▁int ▁getEx ports Count ▁( ▁) ▁{ ▁return ▁ex ports ▁. ▁get ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁do Start ▁( ▁) ▁{ ▁} ▁@ ▁Override ▁protected ▁void ▁do Stop ▁( ▁) ▁{ ▁} ▁@ ▁Override ▁protected ▁void ▁do Close ▁( ▁) ▁{ ▁} ▁} ▁class ▁Blocking Exporter ▁extends ▁Counting Exporter ▁{ ▁private ▁final ▁CountDownLatch ▁latch ▁; ▁Blocking Exporter ▁( ▁CountDownLatch ▁latch ▁) ▁{ ▁this ▁. ▁latch ▁= ▁latch ▁; ▁} ▁@ ▁Override ▁public ▁void ▁export ▁( ▁Collection ▁< ▁Monitoring Doc ▁> ▁docs ▁, ▁ActionListener ▁< ▁Void ▁> ▁listener ▁) ▁{ ▁super ▁. ▁export ▁( ▁docs ▁, ▁ActionListener ▁. ▁wrap ▁( ▁r ▁-> ▁{ ▁try ▁{ ▁latch ▁. ▁await ▁( ▁) ▁; ▁listener ▁. ▁onResponse ▁( ▁null ▁) ▁; ▁}
▁@ ▁ChannelHandler ▁. ▁Sh arable ▁class ▁Nio HttpRequest Creator ▁extends ▁Message ToMessage Decoder ▁< ▁Full HttpRequest ▁> ▁{ ▁@ ▁Override ▁protected ▁void ▁decode ▁( ▁ChannelHandler Context ▁ctx ▁, ▁Full HttpRequest ▁msg ▁, ▁List ▁< ▁Object ▁> ▁out ▁) ▁{ ▁if ▁( ▁msg ▁. ▁decoder Result ▁( ▁) ▁. ▁is Failure ▁( ▁) ▁) ▁{ ▁final ▁Throwable ▁cause ▁= ▁msg ▁. ▁decoder Result ▁( ▁) ▁. ▁cause ▁( ▁) ▁; ▁final ▁Exception ▁non Error ▁; ▁if ▁( ▁cause ▁instanceof ▁Error ▁) ▁{ ▁Exceptions Helper ▁. ▁maybe D ie On Another Thread ▁( ▁cause ▁) ▁; ▁non Error ▁= ▁new ▁Exception ▁( ▁cause ▁) ▁; ▁} ▁else ▁{ ▁non Error ▁= ▁( ▁Exception ▁) ▁cause ▁; ▁} ▁out ▁. ▁add ▁( ▁new ▁Nio HttpRequest ▁( ▁msg ▁. ▁retain ▁( ▁) ▁, ▁non Error ▁) ▁) ▁; ▁} ▁else ▁{ ▁out ▁. ▁add ▁( ▁new ▁Nio HttpRequest ▁( ▁msg ▁. ▁retain ▁( ▁) ▁) ▁) ▁; ▁} ▁} ▁}
▁messageDigest ▁. ▁update ▁( ▁getResource Class Bytes ▁( ▁) ▁) ▁; ▁array Pool ▁. ▁put ▁( ▁dimensions ▁) ▁; ▁} ▁private ▁byte ▁[ ▁] ▁getResource Class Bytes ▁( ▁) ▁{ ▁byte ▁[ ▁] ▁result ▁= ▁RESOURCE _ CLASS _ BYTES ▁. ▁get ▁( ▁decoded Resource Class ▁) ▁; ▁if ▁( ▁result ▁== ▁null ▁) ▁{ ▁result ▁= ▁decoded Resource Class ▁. ▁getName ▁( ▁) ▁. ▁getBytes ▁( ▁CHARSET ▁) ▁; ▁RESOURCE _ CLASS _ BYTES ▁. ▁put ▁( ▁decoded Resource Class ▁, ▁result ▁) ▁; ▁} ▁return ▁result ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁STR ▁+ ▁source Key ▁+ ▁STR ▁+ ▁signature ▁+ ▁STR ▁+ ▁width ▁+ ▁STR ▁+ ▁height ▁+ ▁STR ▁+ ▁decoded Resource Class ▁+ ▁STR ▁+ ▁transformation ▁+ ▁CHAR ▁+ ▁STR ▁+ ▁options ▁+ ▁CHAR ▁; ▁} ▁}
▁public ▁abstract ▁class ▁Auto Lookup ▁{ ▁public ▁static ▁final ▁long ▁KEY _ TY PING _ TIMEOUT ▁= ▁8 00 ▁; ▁private ▁static ▁final ▁int ▁MAX _ SEARCH _ RO WS ▁= ▁5 0000 ▁; ▁private ▁long ▁key Timeout ▁= ▁KEY _ TY PING _ TIMEOUT ▁; ▁private ▁Predicate ▁< ▁Long ▁> ▁key Timeout Predicate ▁= ▁elapsedTime ▁-> ▁elapsedTime ▁> ▁key Timeout ▁; ▁private ▁Auto Lookup Item ▁last Lookup ▁; ▁private ▁int ▁lookup Column ▁= ▁0 ▁; ▁public ▁abstract ▁int ▁getCurrent Row ▁( ▁) ▁; ▁public ▁abstract ▁int ▁getRowCount ▁( ▁) ▁; ▁public ▁abstract ▁String ▁getValue String ▁( ▁int ▁row ▁, ▁int ▁col ▁) ▁; ▁public ▁abstract ▁boolean ▁is Sorted ▁( ▁int ▁column ▁) ▁; ▁protected ▁boolean ▁can Binary Search Column ▁( ▁int ▁column ▁) ▁{ ▁return ▁is Sorted ▁( ▁column ▁) ▁; ▁} ▁public ▁abstract ▁boolean ▁is Sorted Asc ending ▁( ▁) ▁; ▁public ▁abstract ▁void ▁match Found ▁( ▁int ▁row ▁) ▁; ▁public ▁void ▁setTimeout ▁( ▁long ▁timeout ▁) ▁{ ▁key Timeout ▁= ▁timeout ▁; ▁last Lookup ▁= ▁null ▁; ▁} ▁public ▁void ▁set Column ▁( ▁int ▁column ▁) ▁{ ▁this ▁. ▁lookup Column ▁= ▁column ▁; ▁last Lookup ▁= ▁null ▁; ▁} ▁public ▁void ▁setTimeout Predicate ▁( ▁Predicate ▁< ▁Long ▁> ▁p ▁) ▁{ ▁this ▁. ▁key Timeout Predicate ▁= ▁p ▁; ▁} ▁public ▁void ▁key Typed ▁( ▁KeyEvent ▁e ▁) ▁{ ▁if ▁( ▁getRowCount ▁( ▁) ▁== ▁0 ▁) ▁{ ▁return ▁; ▁} ▁Auto Lookup Item ▁lookup ▁= ▁last Lookup ▁; ▁if ▁( ▁lookup ▁== ▁null ▁) ▁{ ▁lookup ▁= ▁new ▁Auto Lookup Item ▁( ▁) ▁; ▁} ▁lookup ▁. ▁key Typed ▁( ▁e ▁) ▁; ▁if ▁( ▁lookup ▁. ▁should Skip ▁( ▁) ▁) ▁{ ▁return ▁; ▁} ▁int ▁row ▁= ▁lookup Text ▁( ▁lookup ▁. ▁getText ▁( ▁) ▁) ▁; ▁lookup ▁. ▁set Found Match ▁( ▁row ▁>= ▁0 ▁) ▁; ▁if ▁( ▁row ▁>= ▁0 ▁) ▁{ ▁match Found ▁( ▁row ▁) ▁; ▁} ▁last Lookup ▁= ▁lookup ▁; ▁} ▁private ▁int ▁lookup Text ▁( ▁String ▁text ▁) ▁{ ▁if ▁( ▁text ▁== ▁null ▁) ▁{ ▁return ▁- ▁1 ▁; ▁} ▁int ▁row ▁= ▁getCurrent Row ▁( ▁) ▁; ▁if ▁( ▁row ▁>= ▁0 ▁&& ▁row ▁< ▁getRowCount ▁( ▁) ▁- ▁1 ▁) ▁{ ▁if ▁( ▁text ▁. ▁length ▁( ▁) ▁== ▁1 ▁) ▁{ ▁++ ▁row ▁; ▁} ▁int ▁col ▁= ▁lookup Column ▁; ▁if ▁( ▁text Matches ▁( ▁text ▁, ▁row ▁, ▁col ▁) ▁) ▁{ ▁return ▁row ▁; ▁} ▁} ▁if ▁( ▁can Binary Search Column ▁( ▁lookup Column ▁) ▁) ▁{ ▁return ▁auto Lookup Binary ▁( ▁text ▁) ▁; ▁} ▁return ▁auto Lookup Linear ▁( ▁text ▁) ▁; ▁} ▁private ▁boolean ▁text Matches ▁( ▁String ▁text ▁, ▁int ▁row ▁, ▁int ▁col ▁) ▁{ ▁String ▁value ▁= ▁getValue String ▁( ▁row ▁, ▁col ▁) ▁; ▁return ▁StringUtils ▁. ▁startsWith IgnoreCase ▁( ▁value ▁, ▁text ▁) ▁; ▁}
▁@ ▁Raw Pointer To ▁( ▁Jfr Buffer ▁. ▁class ▁) ▁public ▁interface ▁Jfr Buffers ▁extends ▁PointerBase ▁{ ▁Jfr Buffers ▁address Of ▁( ▁long ▁index ▁) ▁; ▁void ▁write ▁( ▁Jfr Buffer ▁value ▁) ▁; ▁Jfr Buffer ▁read ▁( ▁) ▁; ▁}
▁public ▁class ▁PG AlterTable Test 2 ▁extends ▁PGTest ▁{ ▁public ▁void ▁test _0 ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁PGSQL StatementParser ▁parser ▁= ▁new ▁PGSQL StatementParser ▁( ▁sql ▁) ▁; ▁List ▁< ▁SQLStatement ▁> ▁statementList ▁= ▁parser ▁. ▁parseStatement List ▁( ▁) ▁; ▁SQLStatement ▁statemen ▁= ▁statementList ▁. ▁get ▁( ▁0 ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁1 ▁, ▁statementList ▁. ▁size ▁( ▁) ▁) ▁; ▁PGSchema StatVisitor ▁visitor ▁= ▁new ▁PGSchema StatVisitor ▁( ▁) ▁; ▁statemen ▁. ▁accept ▁( ▁visitor ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁visitor ▁. ▁getTables ▁( ▁) ▁. ▁containsKey ▁( ▁new ▁TableStat ▁. ▁Name ▁( ▁STR ▁) ▁) ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁visitor ▁. ▁getTables ▁( ▁) ▁. ▁get ▁( ▁new ▁TableStat ▁. ▁Name ▁( ▁STR ▁) ▁) ▁. ▁get Alter Count ▁( ▁) ▁== ▁1 ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁visitor ▁. ▁getColumns ▁( ▁) ▁. ▁size ▁( ▁) ▁== ▁1 ▁) ▁; ▁} ▁}
▁public ▁abstract ▁class ▁Server Exception ▁extends ▁Exception ▁{ ▁public ▁Server Exception ▁( ▁String ▁message ▁) ▁{ ▁super ▁( ▁message ▁) ▁; ▁} ▁public ▁Server Exception ▁( ▁String ▁message ▁, ▁Throwable ▁cause ▁) ▁{ ▁super ▁( ▁message ▁, ▁cause ▁) ▁; ▁} ▁}
▁public ▁class ▁Get Transform StatsResponse Tests ▁extends ▁Abstract Response TestCase ▁< ▁Get Transform StatsAction ▁. ▁Response ▁, ▁org ▁. ▁elasticsearch ▁. ▁client ▁. ▁transform ▁. ▁Get Transform StatsResponse ▁> ▁{ ▁private ▁static ▁Node Attributes ▁random Node Attributes ▁( ▁) ▁{ ▁return ▁new ▁Node Attributes ▁( ▁randomAlpha OfLength ▁( ▁10 ▁) ▁, ▁randomAlpha OfLength ▁( ▁10 ▁) ▁, ▁randomAlpha OfLength ▁( ▁10 ▁) ▁, ▁randomAlpha OfLength ▁( ▁10 ▁) ▁, ▁randomBoolean ▁( ▁) ▁? ▁Collections ▁. ▁emptyMap ▁( ▁) ▁: ▁Collections ▁. ▁singletonMap ▁( ▁randomAlpha OfLength ▁( ▁10 ▁) ▁, ▁randomAlpha OfLength ▁( ▁10 ▁) ▁) ▁) ▁; ▁} ▁private ▁static ▁Transform Stats ▁random Transform Stats ▁( ▁) ▁{ ▁return ▁new ▁Transform Stats ▁( ▁randomAlpha OfLength ▁( ▁10 ▁) ▁, ▁randomFrom ▁( ▁Transform Stats ▁. ▁State ▁. ▁values ▁( ▁) ▁) ▁, ▁randomBoolean ▁( ▁) ▁? ▁null ▁: ▁randomAlpha OfLength ▁( ▁100 ▁) ▁, ▁randomBoolean ▁( ▁) ▁? ▁null ▁: ▁random Node Attributes ▁( ▁) ▁, ▁Transform Indexer Stats Tests ▁. ▁random Stats ▁( ▁) ▁, ▁Transform Checkpointing Info Tests ▁. ▁random Transform Checkpointing Info ▁( ▁) ▁) ▁; ▁} ▁public ▁static ▁Response ▁random StatsResponse ▁( ▁) ▁{ ▁List ▁< ▁Transform Stats ▁> ▁stats ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁int ▁total Stats ▁= ▁randomInt ▁( ▁10 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁total Stats ▁; ▁++ ▁i ▁) ▁{ ▁stats ▁. ▁add ▁( ▁random Transform Stats ▁( ▁) ▁) ▁; ▁} ▁int ▁total Errors ▁= ▁randomInt ▁( ▁10 ▁) ▁; ▁List ▁< ▁Task Operation Failure ▁> ▁task Failures ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁total Errors ▁) ▁; ▁List ▁< ▁Elasticsearch Exception ▁> ▁node Failures ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁total Errors ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁total Errors ▁; ▁i ▁++ ▁) ▁{ ▁task Failures ▁. ▁add ▁( ▁new ▁Task Operation Failure ▁( ▁STR ▁, ▁randomLong Between ▁( ▁1 ▁, ▁10 ▁) ▁, ▁new ▁Exception ▁( ▁STR ▁) ▁) ▁) ▁; ▁node Failures ▁. ▁add ▁( ▁new ▁Failed NodeException ▁( ▁STR ▁, ▁STR ▁, ▁new ▁Exception ▁( ▁STR ▁) ▁) ▁) ▁; ▁} ▁return ▁new ▁Response ▁( ▁stats ▁, ▁randomLong Between ▁( ▁stats ▁. ▁size ▁( ▁) ▁, ▁10 _000_000 L ▁) ▁, ▁task Failures ▁, ▁node Failures ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Response ▁create Server TestInstance ▁( ▁XContentType ▁xContentType ▁) ▁{ ▁return ▁random StatsResponse ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Get Transform StatsResponse ▁doParse To ClientInstance ▁( ▁XContentParser ▁parser ▁) ▁throws ▁IOException ▁{ ▁return ▁org ▁. ▁elasticsearch ▁. ▁client ▁. ▁transform ▁. ▁Get Transform StatsResponse ▁. ▁fromXContent ▁( ▁parser ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁assert Instances ▁( ▁Response ▁server TestInstance ▁, ▁Get Transform StatsResponse ▁clientInstance ▁) ▁{ ▁assertEquals ▁( ▁server TestInstance ▁. ▁get Transform s Stats ▁( ▁) ▁. ▁size ▁( ▁) ▁, ▁clientInstance ▁. ▁get Transform s Stats ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Iterator ▁< ▁Transform Stats ▁> ▁server It ▁= ▁server TestInstance ▁. ▁get Transform s Stats ▁( ▁) ▁. ▁iterator ▁( ▁) ▁;
▁criteria ▁. ▁add ▁( ▁new ▁C riterion ▁( ▁condition ▁, ▁value 1 ▁, ▁value 2 ▁) ▁) ▁; ▁} ▁public ▁C riteria ▁and P ay V est Id IsNull ▁( ▁) ▁{ ▁add C riterion ▁( ▁STR ▁) ▁; ▁return ▁( ▁C riteria ▁) ▁this ▁; ▁} ▁public ▁C riteria ▁and P ay V est Id Is NotNull ▁( ▁) ▁{ ▁add C riterion ▁( ▁STR ▁) ▁; ▁return ▁( ▁C riteria ▁) ▁this ▁; ▁} ▁public ▁C riteria ▁and P ay V est Id EqualTo ▁( ▁Integer ▁value ▁) ▁{ ▁add C riterion ▁( ▁STR ▁, ▁value ▁, ▁STR ▁) ▁; ▁return ▁( ▁C riteria ▁) ▁this ▁; ▁} ▁public ▁C riteria ▁and P ay V est Id Not EqualTo ▁( ▁Integer ▁value ▁) ▁{ ▁add C riterion ▁( ▁STR ▁, ▁value ▁, ▁STR ▁) ▁; ▁return ▁( ▁C riteria ▁) ▁this ▁; ▁} ▁public ▁C riteria ▁and P ay V est Id GreaterThan ▁( ▁Integer ▁value ▁) ▁{ ▁add C riterion ▁( ▁STR ▁, ▁value ▁, ▁STR ▁) ▁; ▁return ▁( ▁C riteria ▁) ▁this ▁; ▁} ▁public ▁C riteria ▁and P ay V est Id GreaterThan OrEqualTo ▁( ▁Integer ▁value ▁) ▁{ ▁add C riterion ▁( ▁STR ▁, ▁value ▁, ▁STR ▁) ▁; ▁return ▁( ▁C riteria ▁) ▁this ▁; ▁} ▁public ▁C riteria ▁and P ay V est Id LessThan ▁( ▁Integer ▁value ▁) ▁{ ▁add C riterion ▁( ▁STR ▁, ▁value ▁, ▁STR ▁) ▁; ▁return ▁( ▁C riteria ▁) ▁this ▁; ▁} ▁public ▁C riteria ▁and P ay V est Id LessThan OrEqualTo ▁( ▁Integer ▁value ▁) ▁{ ▁add C riterion ▁( ▁STR ▁, ▁value ▁, ▁STR ▁) ▁; ▁return ▁( ▁C riteria ▁) ▁this ▁; ▁} ▁public ▁C riteria ▁and P ay V est Id In ▁( ▁List ▁< ▁Integer ▁> ▁values ▁) ▁{ ▁add C riterion ▁( ▁STR ▁, ▁values ▁, ▁STR ▁) ▁; ▁return ▁( ▁C riteria ▁) ▁this ▁; ▁} ▁public ▁C riteria ▁and P ay V est Id Not In ▁( ▁List ▁< ▁Integer ▁> ▁values ▁) ▁{ ▁add C riterion ▁( ▁STR ▁, ▁values ▁, ▁STR ▁) ▁; ▁return ▁( ▁C riteria ▁) ▁this ▁; ▁} ▁public ▁C riteria ▁and P ay V est Id Between ▁( ▁Integer ▁value 1 ▁, ▁Integer ▁value 2 ▁) ▁{ ▁add C riterion ▁( ▁STR ▁, ▁value 1 ▁, ▁value 2 ▁, ▁STR ▁) ▁; ▁return ▁( ▁C riteria ▁) ▁this ▁; ▁} ▁public ▁C riteria ▁and P ay V est Id Not Between ▁( ▁Integer ▁value 1 ▁, ▁Integer ▁value 2 ▁) ▁{ ▁add C riterion ▁( ▁STR ▁, ▁value 1 ▁, ▁value 2 ▁, ▁STR ▁) ▁; ▁return ▁( ▁C riteria ▁) ▁this ▁; ▁} ▁public ▁C riteria ▁and P ay Type Id IsNull ▁( ▁) ▁{ ▁add C riterion ▁( ▁STR ▁) ▁; ▁return ▁( ▁C riteria ▁) ▁this ▁; ▁} ▁public ▁C riteria ▁and P ay Type Id Is NotNull ▁( ▁) ▁{ ▁add C riterion ▁( ▁STR ▁) ▁; ▁return ▁( ▁C riteria ▁) ▁this ▁; ▁}
▁test Url ▁( ▁STR ▁, ▁main Controller ▁, ▁handler Mapping ▁, ▁STR ▁) ▁; ▁test Url ▁( ▁STR ▁, ▁main Controller ▁, ▁handler Mapping ▁, ▁STR ▁) ▁; ▁test Url ▁( ▁STR ▁, ▁null ▁, ▁handler Mapping ▁, ▁null ▁) ▁; ▁test Url ▁( ▁STR ▁, ▁main Controller ▁, ▁handler Mapping ▁, ▁STR ▁) ▁; ▁test Url ▁( ▁STR ▁, ▁null ▁, ▁handler Mapping ▁, ▁null ▁) ▁; ▁test Url ▁( ▁STR ▁, ▁main Controller ▁, ▁handler Mapping ▁, ▁STR ▁) ▁; ▁test Url ▁( ▁STR ▁, ▁null ▁, ▁handler Mapping ▁, ▁null ▁) ▁; ▁test Url ▁( ▁STR ▁, ▁null ▁, ▁handler Mapping ▁, ▁null ▁) ▁; ▁} ▁void ▁test Url ▁( ▁String ▁url ▁, ▁Object ▁bean ▁, ▁Handler Mapping ▁handler Mapping ▁, ▁String ▁path Within Mapping ▁) ▁{ ▁MockServer HttpRequest ▁request ▁= ▁MockServer HttpRequest ▁. ▁method ▁( ▁HttpMethod ▁. ▁GET ▁, ▁URI ▁. ▁create ▁( ▁url ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁Server WebExchange ▁exchange ▁= ▁MockServer WebExchange ▁. ▁from ▁( ▁request ▁) ▁; ▁Object ▁actual ▁= ▁handler Mapping ▁. ▁getHandler ▁( ▁exchange ▁) ▁. ▁block ▁( ▁) ▁; ▁if ▁( ▁bean ▁!= ▁null ▁) ▁{ ▁assertThat ▁( ▁actual ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁assertThat ▁( ▁actual ▁) ▁. ▁isSameAs ▁( ▁bean ▁) ▁; ▁Path Container ▁path ▁= ▁exchange ▁. ▁getAttribute ▁( ▁PATH _ WITH IN _ HANDLER _ MAPPING _ ATTRIBUTE ▁) ▁; ▁assertThat ▁( ▁path ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁assertThat ▁( ▁path ▁. ▁value ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁path Within Mapping ▁) ▁; ▁} ▁else ▁{ ▁assertThat ▁( ▁actual ▁) ▁. ▁isNull ▁( ▁) ▁; ▁} ▁} ▁@ ▁Test ▁void ▁uri Template Variables ▁( ▁) ▁{ ▁Object ▁handler ▁= ▁new ▁Object ▁( ▁) ▁; ▁Simple Url HandlerMapping ▁mapping ▁= ▁new ▁Simple Url HandlerMapping ▁( ▁) ▁; ▁mapping ▁. ▁register Handlers ▁( ▁Collections ▁. ▁singletonMap ▁( ▁STR ▁, ▁handler ▁) ▁) ▁; ▁Server WebExchange ▁exchange ▁= ▁MockServer WebExchange ▁. ▁from ▁( ▁MockServer HttpRequest ▁. ▁get ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁Object ▁expected ▁= ▁mapping ▁. ▁getHandler ▁( ▁exchange ▁) ▁. ▁block ▁( ▁) ▁; ▁assertThat ▁( ▁expected ▁) ▁. ▁isSameAs ▁( ▁handler ▁) ▁; ▁Map ▁< ▁String ▁, ▁String ▁> ▁vars ▁= ▁exchange ▁. ▁getAttribute ▁( ▁Handler Mapping ▁. ▁URI _ TEMPLATE _ VARIABLE S _ ATTRIBUTE ▁) ▁; ▁assertThat ▁( ▁vars ▁) ▁. ▁isNotNull ▁( ▁) ▁. ▁containsEntry ▁( ▁STR ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Configuration ▁static ▁class ▁Web Config ▁{ ▁@ ▁Bean ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁Simple Url HandlerMapping ▁handler Mapping ▁( ▁) ▁{ ▁Simple Url HandlerMapping ▁h m ▁= ▁new ▁Simple Url HandlerMapping ▁( ▁) ▁; ▁h m ▁. ▁register Handler ▁( ▁STR ▁, ▁other Controller ▁( ▁) ▁) ▁; ▁h m ▁. ▁register Handler ▁( ▁STR ▁, ▁main Controller ▁( ▁) ▁) ▁; ▁h m ▁. ▁register Handler ▁( ▁STR ▁, ▁main Controller ▁( ▁) ▁) ▁; ▁h m ▁. ▁register Handler ▁( ▁STR ▁, ▁main Controller ▁( ▁) ▁) ▁; ▁return ▁h m ▁; ▁}
▁@ ▁Internal ▁public ▁final ▁class ▁Or Input TypeStrategy ▁implements ▁InputType Strategy ▁{ ▁private ▁final ▁List ▁< ▁? ▁extends ▁InputType Strategy ▁> ▁input Strategies ▁; ▁public ▁Or Input TypeStrategy ▁( ▁List ▁< ▁? ▁extends ▁InputType Strategy ▁> ▁input Strategies ▁) ▁{ ▁Preconditions ▁. ▁checkArgument ▁( ▁input Strategies ▁. ▁size ▁( ▁) ▁> ▁0 ▁) ▁; ▁this ▁. ▁input Strategies ▁= ▁input Strategies ▁; ▁} ▁@ ▁Override ▁public ▁Argument Count ▁getArgument Count ▁( ▁) ▁{ ▁final ▁List ▁< ▁Argument Count ▁> ▁counts ▁= ▁new ▁Abstract List ▁< ▁Argument Count ▁> ▁( ▁) ▁{ ▁public ▁Argument Count ▁get ▁( ▁int ▁index ▁) ▁{ ▁return ▁input Strategies ▁. ▁get ▁( ▁index ▁) ▁. ▁getArgument Count ▁( ▁) ▁; ▁} ▁public ▁int ▁size ▁( ▁) ▁{ ▁return ▁input Strategies ▁. ▁size ▁( ▁) ▁; ▁} ▁} ▁; ▁final ▁Integer ▁min ▁= ▁common Min ▁( ▁counts ▁) ▁; ▁final ▁Integer ▁max ▁= ▁common Max ▁( ▁counts ▁) ▁; ▁final ▁Argument Count ▁composite Count ▁= ▁new ▁Argument Count ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁boolean ▁isValid Count ▁( ▁int ▁count ▁) ▁{ ▁for ▁( ▁Argument Count ▁c ▁: ▁counts ▁) ▁{ ▁if ▁( ▁c ▁. ▁isValid Count ▁( ▁count ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁return ▁false ▁; ▁} ▁@ ▁Override ▁public ▁Optional ▁< ▁Integer ▁> ▁getMin Count ▁( ▁) ▁{ ▁return ▁Optional ▁. ▁ofNullable ▁( ▁min ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Optional ▁< ▁Integer ▁> ▁getMax Count ▁( ▁) ▁{ ▁return ▁Optional ▁. ▁ofNullable ▁( ▁max ▁) ▁; ▁} ▁} ▁; ▁if ▁( ▁min ▁== ▁null ▁|| ▁max ▁== ▁null ▁) ▁{ ▁return ▁composite Count ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁min ▁; ▁i ▁<= ▁max ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁! ▁composite Count ▁. ▁isValid Count ▁( ▁i ▁) ▁) ▁{ ▁return ▁composite Count ▁; ▁} ▁} ▁if ▁( ▁min ▁. ▁equals ▁( ▁max ▁) ▁) ▁{ ▁return ▁Constant Argument Count ▁. ▁of ▁( ▁min ▁) ▁; ▁} ▁return ▁Constant Argument Count ▁. ▁between ▁( ▁min ▁, ▁max ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Optional ▁< ▁List ▁< ▁DataType ▁> ▁> ▁infer Input Types ▁( ▁Call Context ▁callContext ▁, ▁boolean ▁throw OnFailure ▁) ▁{ ▁final ▁List ▁< ▁LogicalType ▁> ▁actual Types ▁= ▁callContext ▁. ▁getArgument DataTypes ▁( ▁) ▁. ▁stream ▁( ▁) ▁. ▁map ▁( ▁DataType ▁:: ▁getLogicalType ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toList ▁( ▁) ▁) ▁; ▁Optional ▁< ▁List ▁< ▁DataType ▁> ▁> ▁close st DataTypes ▁= ▁Optional ▁. ▁empty ▁( ▁) ▁; ▁for ▁( ▁InputType Strategy ▁input Strategy ▁: ▁input Strategies ▁) ▁{ ▁final ▁Optional ▁< ▁List ▁< ▁DataType ▁> ▁> ▁in ferred DataTypes ▁= ▁input Strategy ▁. ▁infer Input Types ▁( ▁callContext ▁, ▁false ▁) ▁; ▁if ▁( ▁! ▁in ferred DataTypes ▁. ▁isPresent ▁( ▁) ▁) ▁{ ▁continue ▁; ▁} ▁final ▁List ▁< ▁LogicalType ▁> ▁in ferred Types ▁= ▁in ferred DataTypes ▁. ▁get ▁( ▁) ▁. ▁stream ▁( ▁) ▁. ▁map ▁( ▁DataType ▁:: ▁getLogicalType ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toList ▁( ▁) ▁) ▁;
▁public ▁class ▁Rest Put Auto FollowPattern Action ▁extends ▁BaseRestHandler ▁{ ▁@ ▁Override ▁public ▁List ▁< ▁Route ▁> ▁routes ▁( ▁) ▁{ ▁return ▁List ▁. ▁of ▁( ▁new ▁Route ▁( ▁PUT ▁, ▁STR ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁protected ▁RestChannel Consumer ▁prepareRequest ▁( ▁RestRequest ▁restRequest ▁, ▁NodeClient ▁client ▁) ▁throws ▁IOException ▁{ ▁Request ▁request ▁= ▁createRequest ▁( ▁restRequest ▁) ▁; ▁return ▁channel ▁-> ▁client ▁. ▁execute ▁( ▁INSTANCE ▁, ▁request ▁, ▁new ▁RestToXContent Listener ▁< ▁> ▁( ▁channel ▁) ▁) ▁; ▁} ▁private ▁static ▁Request ▁createRequest ▁( ▁RestRequest ▁restRequest ▁) ▁throws ▁IOException ▁{ ▁try ▁( ▁XContentParser ▁parser ▁= ▁restRequest ▁. ▁content Or Source Param Parser ▁( ▁) ▁) ▁{ ▁return ▁Request ▁. ▁fromXContent ▁( ▁parser ▁, ▁restRequest ▁. ▁param ▁( ▁STR ▁) ▁) ▁; ▁} ▁} ▁}
▁public ▁final ▁class ▁Http Utils ▁{ ▁static ▁final ▁int ▁SC _ SW IT CH ING _ PROTOCOL S ▁= ▁101 ▁; ▁static ▁final ▁int ▁SC _ B AD _ G ATE WAY ▁= ▁50 2 ▁; ▁static ▁final ▁Tag Extractor ▁< ▁HttpServer Request ▁> ▁SERVER _ REQUEST _ TAG _ EX TR ACT OR ▁= ▁new ▁Tag Extractor ▁< ▁HttpServer Request ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁int ▁len ▁( ▁HttpServer Request ▁req ▁) ▁{ ▁return ▁2 ▁; ▁} ▁@ ▁Override ▁public ▁String ▁name ▁( ▁HttpServer Request ▁req ▁, ▁int ▁index ▁) ▁{ ▁switch ▁( ▁index ▁) ▁{ ▁case ▁0 ▁: ▁return ▁STR ▁; ▁case ▁1 ▁: ▁return ▁STR ▁; ▁} ▁throw ▁new ▁Index OutOfBounds Exception ▁( ▁STR ▁+ ▁index ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁value ▁( ▁HttpServer Request ▁req ▁, ▁int ▁index ▁) ▁{ ▁switch ▁( ▁index ▁) ▁{ ▁case ▁0 ▁: ▁return ▁req ▁. ▁absolute URI ▁( ▁) ▁; ▁case ▁1 ▁: ▁return ▁req ▁. ▁method ▁( ▁) ▁. ▁name ▁( ▁) ▁; ▁} ▁throw ▁new ▁Index OutOfBounds Exception ▁( ▁STR ▁+ ▁index ▁) ▁; ▁} ▁} ▁; ▁static ▁final ▁Tag Extractor ▁< ▁HttpServer Response ▁> ▁SERVER _ RESPONSE _ TAG _ EX TR ACT OR ▁= ▁new ▁Tag Extractor ▁< ▁HttpServer Response ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁int ▁len ▁( ▁HttpServer Response ▁resp ▁) ▁{ ▁return ▁1 ▁; ▁} ▁@ ▁Override ▁public ▁String ▁name ▁( ▁HttpServer Response ▁resp ▁, ▁int ▁index ▁) ▁{ ▁if ▁( ▁index ▁== ▁0 ▁) ▁{ ▁return ▁STR ▁; ▁} ▁throw ▁new ▁Index OutOfBounds Exception ▁( ▁STR ▁+ ▁index ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁value ▁( ▁HttpServer Response ▁resp ▁, ▁int ▁index ▁) ▁{ ▁if ▁( ▁index ▁== ▁0 ▁) ▁{ ▁return ▁STR ▁+ ▁resp ▁. ▁getStatusCode ▁( ▁) ▁; ▁} ▁throw ▁new ▁Index OutOfBounds Exception ▁( ▁STR ▁+ ▁index ▁) ▁; ▁} ▁} ▁; ▁static ▁final ▁Tag Extractor ▁< ▁HttpRequest Head ▁> ▁CLIENT _ HTTP _ REQUEST _ TAG _ EX TR ACT OR ▁= ▁new ▁Tag Extractor ▁< ▁HttpRequest Head ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁int ▁len ▁( ▁HttpRequest Head ▁req ▁) ▁{ ▁return ▁2 ▁; ▁} ▁@ ▁Override ▁public ▁String ▁name ▁( ▁HttpRequest Head ▁req ▁, ▁int ▁index ▁) ▁{ ▁switch ▁( ▁index ▁) ▁{ ▁case ▁0 ▁: ▁return ▁STR ▁; ▁case ▁1 ▁: ▁return ▁STR ▁; ▁} ▁throw ▁new ▁Index OutOfBounds Exception ▁( ▁STR ▁+ ▁index ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁value ▁( ▁HttpRequest Head ▁req ▁, ▁int ▁index ▁) ▁{ ▁switch ▁( ▁index ▁) ▁{ ▁case ▁0 ▁: ▁return ▁req ▁. ▁absolute URI ▁; ▁case ▁1 ▁: ▁return ▁req ▁. ▁method ▁. ▁name ▁( ▁) ▁; ▁} ▁throw ▁new ▁Index OutOfBounds Exception ▁( ▁STR ▁+ ▁index ▁) ▁; ▁} ▁} ▁; ▁static ▁final ▁Tag Extractor ▁< ▁HttpResponse Head ▁> ▁CLIENT _ RESPONSE _ TAG _ EX TR ACT OR ▁= ▁new ▁Tag Extractor ▁< ▁HttpResponse Head ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁int ▁len ▁( ▁HttpResponse Head ▁resp ▁) ▁{ ▁return ▁1 ▁; ▁}
▁public ▁class ▁WrapIDebug Registers 2 ▁extends ▁WrapIDebug Registers ▁implements ▁IDebug Registers 2 ▁{ ▁public ▁static ▁class ▁ByReference ▁extends ▁WrapIDebug Registers 2 ▁implements ▁Structure ▁. ▁ByReference ▁{ ▁} ▁public ▁WrapIDebug Registers 2 ▁( ▁) ▁{ ▁} ▁public ▁WrapIDebug Registers 2 ▁( ▁Pointer ▁pv Instance ▁) ▁{ ▁super ▁( ▁pv Instance ▁) ▁; ▁} ▁@ ▁Override ▁public ▁HRESULT ▁Get Description W ide ▁( ▁ULONG ▁Register ▁, ▁char ▁[ ▁] ▁Name Buffer ▁, ▁ULONG ▁Name BufferSize ▁, ▁ULONG ByReference ▁Name Size ▁, ▁DEBUG _ REG ISTER _ DESCRIPTION ▁. ▁ByReference ▁Des c ▁) ▁{ ▁return ▁_ invokeHR ▁( ▁VTIndices 2 ▁. ▁GET _ DESCRIPTION _ W IDE ▁, ▁getPointer ▁( ▁) ▁, ▁Register ▁, ▁Name Buffer ▁, ▁Name BufferSize ▁, ▁Name Size ▁, ▁Des c ▁) ▁; ▁} ▁@ ▁Override ▁public ▁HRESULT ▁Get Index ByName W ide ▁( ▁WString ▁Name ▁, ▁ULONG ByReference ▁Index ▁) ▁{ ▁return ▁_ invokeHR ▁( ▁VTIndices 2 ▁. ▁GET _ INDEX _ BY _ NAME _ W IDE ▁, ▁getPointer ▁( ▁) ▁, ▁Name ▁, ▁Index ▁) ▁; ▁} ▁@ ▁Override ▁public ▁HRESULT ▁Get Number P seudo Registers ▁( ▁ULONG ByReference ▁Number ▁) ▁{ ▁return ▁_ invokeHR ▁( ▁VTIndices 2 ▁. ▁GET _ NUMBER _ P SE U DO _ REG IST ERS ▁, ▁getPointer ▁( ▁) ▁, ▁Number ▁) ▁; ▁} ▁@ ▁Override ▁public ▁HRESULT ▁Get P seudo Description ▁( ▁ULONG ▁Register ▁, ▁byte ▁[ ▁] ▁Name Buffer ▁, ▁ULONG ▁Name BufferSize ▁, ▁ULONG ByReference ▁Name Size ▁, ▁ULONGLONG ByReference ▁Type Module ▁, ▁ULONG ByReference ▁Type Id ▁) ▁{ ▁return ▁_ invokeHR ▁( ▁VTIndices 2 ▁. ▁GET _ P SE U DO _ DESCRIPTION ▁, ▁getPointer ▁( ▁) ▁, ▁Register ▁, ▁Name Buffer ▁, ▁Name BufferSize ▁, ▁Name Size ▁, ▁Type Module ▁, ▁Type Id ▁) ▁; ▁} ▁@ ▁Override ▁public ▁HRESULT ▁Get P seudo Description W ide ▁( ▁ULONG ▁Register ▁, ▁char ▁[ ▁] ▁Name Buffer ▁, ▁ULONG ▁Name BufferSize ▁, ▁ULONG ByReference ▁Name Size ▁, ▁ULONGLONG ByReference ▁Type Module ▁, ▁ULONG ByReference ▁Type Id ▁) ▁{ ▁return ▁_ invokeHR ▁( ▁VTIndices 2 ▁. ▁GET _ P SE U DO _ DESCRIPTION _ W IDE ▁, ▁getPointer ▁( ▁) ▁, ▁Register ▁, ▁Name Buffer ▁, ▁Name BufferSize ▁, ▁Name Size ▁, ▁Type Module ▁, ▁Type Id ▁) ▁; ▁} ▁@ ▁Override ▁public ▁HRESULT ▁Get P seudo Index ByName ▁( ▁String ▁Name ▁, ▁ULONG ByReference ▁Index ▁) ▁{ ▁return ▁_ invokeHR ▁( ▁VTIndices 2 ▁. ▁GET _ P SE U DO _ INDEX _ BY _ NAME ▁, ▁getPointer ▁( ▁) ▁, ▁Name ▁, ▁Index ▁) ▁; ▁} ▁@ ▁Override ▁public ▁HRESULT ▁Get P seudo Index ByName W ide ▁( ▁WString ▁Name ▁, ▁ULONG ByReference ▁Index ▁) ▁{ ▁return ▁_ invokeHR ▁( ▁VTIndices 2 ▁. ▁GET _ P SE U DO _ INDEX _ BY _ NAME _ W IDE ▁, ▁getPointer ▁( ▁) ▁, ▁Name ▁, ▁Index ▁) ▁; ▁}
▁Statement ▁s ▁= ▁c ▁. ▁createStatement ▁( ▁) ▁) ▁{ ▁s ▁. ▁set Fetch Size ▁( ▁4 ▁) ▁; ▁try ▁( ▁ResultSet ▁rs ▁= ▁s ▁. ▁executeQuery ▁( ▁STR ▁) ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁20 ▁; ▁i ▁++ ▁) ▁{ ▁assertEquals ▁( ▁4 ▁, ▁rs ▁. ▁getF etch Size ▁( ▁) ▁) ▁; ▁assertTrue ▁( ▁STR ▁+ ▁i ▁, ▁rs ▁. ▁next ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁i ▁, ▁rs ▁. ▁getInt ▁( ▁1 ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁1 ▁, ▁rs ▁. ▁getInt ▁( ▁2 ▁) ▁) ▁; ▁} ▁assertFalse ▁( ▁rs ▁. ▁next ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁public ▁void ▁test Nested Document s ▁( ▁) ▁throws ▁SQLException ▁{ ▁try ▁( ▁Connection ▁c ▁= ▁es Jdbc ▁( ▁) ▁; ▁Statement ▁s ▁= ▁c ▁. ▁createStatement ▁( ▁) ▁) ▁{ ▁s ▁. ▁set Fetch Size ▁( ▁5 ▁) ▁; ▁try ▁( ▁ResultSet ▁rs ▁= ▁s ▁. ▁executeQuery ▁( ▁STR ▁) ▁) ▁{ ▁assertTrue ▁( ▁STR ▁, ▁rs ▁. ▁next ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁20 ▁; ▁i ▁++ ▁) ▁{ ▁assertEquals ▁( ▁15 ▁, ▁rs ▁. ▁getF etch Size ▁( ▁) ▁) ▁; ▁assert Nested Document s ▁( ▁rs ▁, ▁i ▁) ▁; ▁} ▁assertFalse ▁( ▁rs ▁. ▁next ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁private ▁void ▁assert Nested Document s ▁( ▁ResultSet ▁rs ▁, ▁int ▁i ▁) ▁throws ▁SQLException ▁{ ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁i ▁ % ▁5 ▁; ▁j ▁++ ▁) ▁{ ▁assertEquals ▁( ▁i ▁, ▁rs ▁. ▁getInt ▁( ▁1 ▁) ▁) ▁; ▁assertEquals ▁( ▁j ▁, ▁rs ▁. ▁getInt ▁( ▁2 ▁) ▁) ▁; ▁assertTrue ▁( ▁STR ▁+ ▁rs ▁. ▁getRow ▁( ▁) ▁, ▁( ▁i ▁+ ▁j ▁== ▁23 ▁|| ▁rs ▁. ▁next ▁( ▁) ▁) ▁) ▁; ▁} ▁} ▁public ▁void ▁test P ivot P aging ▁( ▁) ▁throws ▁IOException ▁, ▁SQLException ▁{ ▁add P ivot Data ▁( ▁) ▁; ▁try ▁( ▁Connection ▁c ▁= ▁es Jdbc ▁( ▁) ▁; ▁Statement ▁s ▁= ▁c ▁. ▁createStatement ▁( ▁) ▁) ▁{ ▁String ▁query ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁; ▁s ▁. ▁set Fetch Size ▁( ▁3 ▁) ▁; ▁try ▁( ▁ResultSet ▁rs ▁= ▁s ▁. ▁executeQuery ▁( ▁query ▁) ▁) ▁{ ▁assertEquals ▁( ▁8 ▁, ▁rs ▁. ▁getMetaData ▁( ▁) ▁. ▁getColumnCount ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁{ ▁assertTrue ▁( ▁rs ▁. ▁next ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁rs ▁. ▁getF etch Size ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁Long ▁. ▁valueOf ▁( ▁i ▁) ▁, ▁rs ▁. ▁getObject ▁( ▁STR ▁) ▁) ▁; ▁} ▁assertFalse ▁( ▁rs ▁. ▁next ▁( ▁) ▁) ▁; ▁} ▁s ▁. ▁set Fetch Size ▁( ▁20 ▁) ▁; ▁try ▁( ▁ResultSet ▁rs ▁= ▁s ▁. ▁executeQuery ▁( ▁query ▁) ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁{ ▁assertTrue ▁( ▁rs ▁. ▁next ▁( ▁) ▁) ▁;
▁user 1 ▁. ▁setId ▁( ▁3 ▁) ▁; ▁List ▁< ▁User ▁> ▁users ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁users ▁. ▁add ▁( ▁user 1 ▁) ▁; ▁users ▁. ▁add ▁( ▁null ▁) ▁; ▁String ▁name ▁= ▁mapper ▁. ▁select WithNull Item Check ▁( ▁users ▁) ▁; ▁Assertions ▁. ▁assertEquals ▁( ▁STR ▁, ▁name ▁) ▁; ▁} ▁} ▁@ ▁Test ▁void ▁should Report Missing PropertyName ▁( ▁) ▁{ ▁try ▁( ▁SqlSession ▁sqlSession ▁= ▁sqlSession Factory ▁. ▁openSession ▁( ▁) ▁) ▁{ ▁Mapper ▁mapper ▁= ▁sqlSession ▁. ▁getMapper ▁( ▁Mapper ▁. ▁class ▁) ▁; ▁when ▁( ▁( ▁) ▁-> ▁mapper ▁. ▁t y po In Item Property ▁( ▁Collections ▁. ▁singletonList ▁( ▁new ▁User ▁( ▁) ▁) ▁) ▁) ▁; ▁then ▁( ▁ca ught Exception ▁( ▁) ▁) ▁. ▁isInstanceOf ▁( ▁Persistence Exception ▁. ▁class ▁) ▁. ▁hasMessage Containing ▁( ▁STR ▁) ▁; ▁} ▁} ▁@ ▁Test ▁void ▁should Remove Item Variable In The Context ▁( ▁) ▁{ ▁try ▁( ▁SqlSession ▁sqlSession ▁= ▁sqlSession Factory ▁. ▁openSession ▁( ▁) ▁) ▁{ ▁Mapper ▁mapper ▁= ▁sqlSession ▁. ▁getMapper ▁( ▁Mapper ▁. ▁class ▁) ▁; ▁int ▁result ▁= ▁mapper ▁. ▁item Variable Conflict ▁( ▁5 ▁, ▁Arrays ▁. ▁asList ▁( ▁1 ▁, ▁2 ▁) ▁, ▁Arrays ▁. ▁asList ▁( ▁3 ▁, ▁4 ▁) ▁) ▁; ▁Assertions ▁. ▁assertEquals ▁( ▁5 ▁, ▁result ▁) ▁; ▁} ▁} ▁@ ▁Test ▁void ▁should Remove Index Variable In The Context ▁( ▁) ▁{ ▁try ▁( ▁SqlSession ▁sqlSession ▁= ▁sqlSession Factory ▁. ▁openSession ▁( ▁) ▁) ▁{ ▁Mapper ▁mapper ▁= ▁sqlSession ▁. ▁getMapper ▁( ▁Mapper ▁. ▁class ▁) ▁; ▁int ▁result ▁= ▁mapper ▁. ▁index Variable Conflict ▁( ▁4 ▁, ▁Arrays ▁. ▁asList ▁( ▁6 ▁, ▁7 ▁) ▁, ▁Arrays ▁. ▁asList ▁( ▁8 ▁, ▁9 ▁) ▁) ▁; ▁Assertions ▁. ▁assertEquals ▁( ▁4 ▁, ▁result ▁) ▁; ▁} ▁} ▁}
▁private ▁final ▁Listener Set ▁< ▁Target Breakpoint Action ▁> ▁actions ▁= ▁new ▁Listener Set ▁< ▁> ▁( ▁Target Breakpoint Action ▁. ▁class ▁) ▁{ ▁protected ▁Map ▁< ▁Target Breakpoint Action ▁, ▁Target Breakpoint Action ▁> ▁create Map ▁( ▁) ▁{ ▁return ▁Collections ▁. ▁synchronized Map ▁( ▁new ▁LinkedHashMap ▁< ▁> ▁( ▁) ▁) ▁; ▁} ▁} ▁; ▁public ▁DbgModelTarget Breakpoint Spec Impl ▁( ▁DbgModelTarget Breakpoint Container ▁break points ▁, ▁Dbg BreakpointInfo ▁info ▁) ▁{ ▁super ▁( ▁break points ▁. ▁getModel ▁( ▁) ▁, ▁break points ▁, ▁key Breakpoint ▁( ▁info ▁) ▁, ▁STR ▁) ▁; ▁this ▁. ▁getModel ▁( ▁) ▁. ▁add Model Object ▁( ▁info ▁. ▁getDebug Breakpoint ▁( ▁) ▁, ▁this ▁) ▁; ▁update Info ▁( ▁null ▁, ▁info ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁update Info ▁( ▁Dbg BreakpointInfo ▁old Info ▁, ▁Dbg BreakpointInfo ▁new Info ▁, ▁String ▁reason ▁) ▁{ ▁synchronized ▁( ▁this ▁) ▁{ ▁assert ▁old Info ▁== ▁getB reak point Info ▁( ▁) ▁; ▁set BreakpointInfo ▁( ▁new Info ▁) ▁; ▁} ▁change Attribute Set ▁( ▁STR ▁) ▁; ▁setEnabled ▁( ▁new Info ▁. ▁isEnabled ▁( ▁) ▁, ▁reason ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Dbg BreakpointInfo ▁getB reak point Info ▁( ▁) ▁{ ▁return ▁info ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Breakpoint Id ▁( ▁String ▁id ▁) ▁{ ▁throw ▁new ▁AssertionError ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set BreakpointInfo ▁( ▁Dbg BreakpointInfo ▁info ▁) ▁{ ▁this ▁. ▁info ▁= ▁info ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setEnabled ▁( ▁boolean ▁enabled ▁, ▁String ▁reason ▁) ▁{ ▁set Breakpoint Enabled ▁( ▁enabled ▁) ▁; ▁change Attributes ▁( ▁List ▁. ▁of ▁( ▁) ▁, ▁List ▁. ▁of ▁( ▁) ▁, ▁Map ▁. ▁of ▁( ▁ENABLED _ ATTRIBUTE _ NAME ▁, ▁enabled ▁) ▁, ▁reason ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is Breakpoint Enabled ▁( ▁) ▁{ ▁return ▁enabled ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Breakpoint Enabled ▁( ▁boolean ▁enabled ▁) ▁{ ▁this ▁. ▁enabled ▁= ▁enabled ▁; ▁} ▁@ ▁Override ▁public ▁Listener Set ▁< ▁Target Breakpoint Action ▁> ▁get Actions ▁( ▁) ▁{ ▁return ▁actions ▁; ▁} ▁protected ▁Completable Future ▁< ▁Dbg BreakpointInfo ▁> ▁getInfo ▁( ▁) ▁{ ▁return ▁getManager ▁( ▁) ▁. ▁list Breakpoint s ▁( ▁) ▁. ▁thenApply ▁( ▁__ ▁-> ▁getManager ▁( ▁) ▁. ▁getK nown Breakpoint s ▁( ▁) ▁. ▁get ▁( ▁getNumber ▁( ▁) ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Completable Future ▁< ▁Void ▁> ▁request Elements ▁( ▁boolean ▁refresh ▁) ▁{ ▁return ▁getInfo ▁( ▁) ▁. ▁then Accept ▁( ▁i ▁-> ▁{ ▁synchronized ▁( ▁this ▁) ▁{ ▁set BreakpointInfo ▁( ▁i ▁) ▁; ▁} ▁change Attribute Set ▁( ▁STR ▁) ▁; ▁} ▁) ▁; ▁} ▁}
▁this ▁. ▁f 7 ▁= ▁f 7 ▁; ▁this ▁. ▁f 8 ▁= ▁f 8 ▁; ▁this ▁. ▁f 9 ▁= ▁f 9 ▁; ▁this ▁. ▁f 10 ▁= ▁f 10 ▁; ▁this ▁. ▁f 11 ▁= ▁f 11 ▁; ▁this ▁. ▁f 12 ▁= ▁f 12 ▁; ▁this ▁. ▁f 13 ▁= ▁f 13 ▁; ▁this ▁. ▁f 14 ▁= ▁f 14 ▁; ▁this ▁. ▁f 15 ▁= ▁f 15 ▁; ▁this ▁. ▁f 16 ▁= ▁f 16 ▁; ▁this ▁. ▁f 17 ▁= ▁f 17 ▁; ▁this ▁. ▁f 18 ▁= ▁f 18 ▁; ▁this ▁. ▁f 19 ▁= ▁f 19 ▁; ▁this ▁. ▁f 20 ▁= ▁f 20 ▁; ▁this ▁. ▁f 21 ▁= ▁f 21 ▁; ▁this ▁. ▁f 22 ▁= ▁f 22 ▁; ▁this ▁. ▁f 23 ▁= ▁f 23 ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 0 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 1 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 2 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 3 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 4 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 5 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 6 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 7 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 8 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 9 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 10 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 11 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 12 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 13 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 14 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 15 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 16 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 17 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 18 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 19 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 20 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 21 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 22 ▁) ▁+ ▁STR ▁+ ▁StringUtils ▁. ▁array Aware ToString ▁( ▁this ▁. ▁f 23 ▁) ▁+ ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁o ▁) ▁{ ▁if ▁( ▁this ▁== ▁o ▁) ▁{ ▁return ▁true ▁; ▁}
▁inOrder ▁. ▁verify ▁( ▁o ▁) ▁. ▁onNext ▁( ▁3 ▁) ▁; ▁inOrder ▁. ▁verify ▁( ▁o ▁) ▁. ▁onComplete ▁( ▁) ▁; ▁verify ▁( ▁o ▁, ▁never ▁( ▁) ▁) ▁. ▁onError ▁( ▁any ▁( ▁Throwable ▁. ▁class ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁retry Tw ice And G ive Up ▁( ▁) ▁{ ▁Observable ▁< ▁Integer ▁> ▁source ▁= ▁Observable ▁. ▁unsafe Create ▁( ▁new ▁Observable Source ▁< ▁Integer ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁subscribe ▁( ▁Observer ▁< ▁? ▁super ▁Integer ▁> ▁t 1 ▁) ▁{ ▁t 1 ▁. ▁onSubscribe ▁( ▁Disposable ▁. ▁empty ▁( ▁) ▁) ▁; ▁t 1 ▁. ▁onNext ▁( ▁0 ▁) ▁; ▁t 1 ▁. ▁onNext ▁( ▁1 ▁) ▁; ▁t 1 ▁. ▁onError ▁( ▁new ▁TestException ▁( ▁) ▁) ▁; ▁} ▁} ▁) ▁; ▁Observer ▁< ▁Integer ▁> ▁o ▁= ▁TestHelper ▁. ▁mock Observer ▁( ▁) ▁; ▁InOrder ▁inOrder ▁= ▁inOrder ▁( ▁o ▁) ▁; ▁source ▁. ▁retry ▁( ▁retry Tw ice ▁) ▁. ▁subscribe ▁( ▁o ▁) ▁; ▁inOrder ▁. ▁verify ▁( ▁o ▁) ▁. ▁onNext ▁( ▁0 ▁) ▁; ▁inOrder ▁. ▁verify ▁( ▁o ▁) ▁. ▁onNext ▁( ▁1 ▁) ▁; ▁inOrder ▁. ▁verify ▁( ▁o ▁) ▁. ▁onNext ▁( ▁0 ▁) ▁; ▁inOrder ▁. ▁verify ▁( ▁o ▁) ▁. ▁onNext ▁( ▁1 ▁) ▁; ▁inOrder ▁. ▁verify ▁( ▁o ▁) ▁. ▁onNext ▁( ▁0 ▁) ▁; ▁inOrder ▁. ▁verify ▁( ▁o ▁) ▁. ▁onNext ▁( ▁1 ▁) ▁; ▁inOrder ▁. ▁verify ▁( ▁o ▁) ▁. ▁onError ▁( ▁any ▁( ▁TestException ▁. ▁class ▁) ▁) ▁; ▁verify ▁( ▁o ▁, ▁never ▁( ▁) ▁) ▁. ▁onComplete ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁retry On Specific Exception ▁( ▁) ▁{ ▁Observable ▁< ▁Integer ▁> ▁source ▁= ▁Observable ▁. ▁unsafe Create ▁( ▁new ▁Observable Source ▁< ▁Integer ▁> ▁( ▁) ▁{ ▁int ▁count ▁; ▁@ ▁Override ▁public ▁void ▁subscribe ▁( ▁Observer ▁< ▁? ▁super ▁Integer ▁> ▁t 1 ▁) ▁{ ▁t 1 ▁. ▁onSubscribe ▁( ▁Disposable ▁. ▁empty ▁( ▁) ▁) ▁; ▁count ▁++ ▁; ▁t 1 ▁. ▁onNext ▁( ▁0 ▁) ▁; ▁t 1 ▁. ▁onNext ▁( ▁1 ▁) ▁; ▁if ▁( ▁count ▁== ▁1 ▁) ▁{ ▁t 1 ▁. ▁onError ▁( ▁new ▁IOException ▁( ▁) ▁) ▁; ▁return ▁; ▁} ▁t 1 ▁. ▁onNext ▁( ▁2 ▁) ▁; ▁t 1 ▁. ▁onNext ▁( ▁3 ▁) ▁; ▁t 1 ▁. ▁onComplete ▁( ▁) ▁; ▁} ▁} ▁) ▁; ▁Observer ▁< ▁Integer ▁> ▁o ▁= ▁TestHelper ▁. ▁mock Observer ▁( ▁) ▁; ▁InOrder ▁inOrder ▁= ▁inOrder ▁( ▁o ▁) ▁; ▁source ▁. ▁retry ▁( ▁retry On Test Exception ▁) ▁. ▁subscribe ▁( ▁o ▁) ▁; ▁inOrder ▁. ▁verify ▁( ▁o ▁) ▁. ▁onNext ▁( ▁0 ▁) ▁; ▁inOrder ▁. ▁verify ▁( ▁o ▁) ▁. ▁onNext ▁( ▁1 ▁) ▁; ▁inOrder ▁. ▁verify ▁( ▁o ▁) ▁. ▁onNext ▁( ▁0 ▁) ▁; ▁inOrder ▁. ▁verify ▁( ▁o ▁) ▁. ▁onNext ▁( ▁1 ▁) ▁; ▁inOrder ▁. ▁verify ▁( ▁o ▁) ▁. ▁onNext ▁( ▁2 ▁) ▁;
▁public ▁class ▁Non Default Constructor Test 0 ▁extends ▁TestCase ▁{ ▁public ▁void ▁test _ non _ default _ con structor ▁( ▁) ▁throws ▁Exception ▁{ ▁Model ▁model ▁= ▁JSON ▁. ▁parseObject ▁( ▁STR ▁, ▁Model ▁. ▁class ▁) ▁; ▁assertNotNull ▁( ▁model ▁) ▁; ▁assertEquals ▁( ▁1001 ▁, ▁model ▁. ▁id ▁) ▁; ▁assertNotNull ▁( ▁model ▁. ▁value ▁) ▁; ▁assertEquals ▁( ▁200 1 ▁, ▁model ▁. ▁value ▁. ▁id ▁) ▁; ▁} ▁public ▁static ▁class ▁Model ▁{ ▁private ▁final ▁int ▁id ▁; ▁private ▁final ▁Value ▁value ▁; ▁public ▁Model ▁( ▁int ▁id ▁, ▁Value ▁value ▁) ▁{ ▁this ▁. ▁id ▁= ▁id ▁; ▁this ▁. ▁value ▁= ▁value ▁; ▁} ▁} ▁public ▁static ▁class ▁Value ▁{ ▁private ▁final ▁int ▁id ▁; ▁public ▁Value ▁( ▁int ▁id ▁) ▁{ ▁this ▁. ▁id ▁= ▁id ▁; ▁} ▁} ▁}
▁@ ▁javax ▁. ▁annotation ▁. ▁concurrent ▁. ▁Not Thread Safe ▁@ ▁Tag ▁( ▁TagNames ▁. ▁FILE _ IO ▁) ▁@ ▁NativeTag ▁@ ▁Tag ▁( ▁TagNames ▁. ▁PY TH ON ▁) ▁public ▁class ▁Python Collections Test ▁{ ▁@ ▁Test ▁public ▁void ▁test Python Dict From Map ▁( ▁) ▁throws ▁Python Exception ▁{ ▁try ▁( ▁Python G IL ▁python G IL ▁= ▁Python G IL ▁. ▁lock ▁( ▁) ▁) ▁{ ▁Map ▁map ▁= ▁new ▁HashMap ▁( ▁) ▁; ▁map ▁. ▁put ▁( ▁STR ▁, ▁1 ▁) ▁; ▁map ▁. ▁put ▁( ▁1 ▁, ▁STR ▁) ▁; ▁map ▁. ▁put ▁( ▁STR ▁, ▁Arrays ▁. ▁asList ▁( ▁1 ▁, ▁2.0 ▁, ▁3 ▁, ▁4 f ▁) ▁) ▁; ▁Map ▁inner Map ▁= ▁new ▁HashMap ▁( ▁) ▁; ▁inner Map ▁. ▁put ▁( ▁STR ▁, ▁2 ▁) ▁; ▁inner Map ▁. ▁put ▁( ▁2 ▁, ▁STR ▁) ▁; ▁map ▁. ▁put ▁( ▁STR ▁, ▁inner Map ▁) ▁; ▁map ▁. ▁put ▁( ▁STR ▁, ▁Arrays ▁. ▁asList ▁( ▁4 ▁, ▁STR ▁, ▁inner Map ▁, ▁false ▁, ▁true ▁) ▁) ▁; ▁Python Object ▁d ict ▁= ▁Python Types ▁. ▁convert ▁( ▁map ▁) ▁; ▁Map ▁map 2 ▁= ▁Python Types ▁. ▁DI CT ▁. ▁toJava ▁( ▁d ict ▁) ▁; ▁assertEquals ▁( ▁map ▁. ▁toString ▁( ▁) ▁, ▁map 2 ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Python List From List ▁( ▁) ▁throws ▁Python Exception ▁{ ▁try ▁( ▁Python G IL ▁python G IL ▁= ▁Python G IL ▁. ▁lock ▁( ▁) ▁) ▁{ ▁List ▁< ▁Object ▁> ▁list ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁list ▁. ▁add ▁( ▁1 ▁) ▁; ▁list ▁. ▁add ▁( ▁STR ▁) ▁; ▁list ▁. ▁add ▁( ▁Arrays ▁. ▁asList ▁( ▁STR ▁, ▁1.0 ▁, ▁2 f ▁, ▁10 ▁, ▁true ▁, ▁false ▁) ▁) ▁; ▁Map ▁map ▁= ▁new ▁HashMap ▁( ▁) ▁; ▁map ▁. ▁put ▁( ▁STR ▁, ▁1 ▁) ▁; ▁map ▁. ▁put ▁( ▁1 ▁, ▁STR ▁) ▁; ▁map ▁. ▁put ▁( ▁STR ▁, ▁Arrays ▁. ▁asList ▁( ▁1 ▁, ▁2.0 ▁, ▁3 ▁, ▁4 f ▁) ▁) ▁; ▁list ▁. ▁add ▁( ▁map ▁) ▁; ▁Python Object ▁d ict ▁= ▁Python Types ▁. ▁convert ▁( ▁list ▁) ▁; ▁List ▁list 2 ▁= ▁Python Types ▁. ▁LIST ▁. ▁toJava ▁( ▁d ict ▁) ▁; ▁assertEquals ▁( ▁list ▁. ▁toString ▁( ▁) ▁, ▁list 2 ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁} ▁}
▁@ ▁Override ▁public ▁String ▁name ▁( ▁HttpResponse Head ▁resp ▁, ▁int ▁index ▁) ▁{ ▁if ▁( ▁index ▁== ▁0 ▁) ▁{ ▁return ▁STR ▁; ▁} ▁throw ▁new ▁Index OutOfBounds Exception ▁( ▁STR ▁+ ▁index ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁value ▁( ▁HttpResponse Head ▁resp ▁, ▁int ▁index ▁) ▁{ ▁if ▁( ▁index ▁== ▁0 ▁) ▁{ ▁return ▁STR ▁+ ▁resp ▁. ▁statusCode ▁; ▁} ▁throw ▁new ▁Index OutOfBounds Exception ▁( ▁STR ▁+ ▁index ▁) ▁; ▁} ▁} ▁; ▁static ▁final ▁Stream Priority ▁DEFAULT _ STREAM _ PRIORITY ▁= ▁new ▁Stream Priority ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Stream Priority ▁set Weight ▁( ▁short ▁weight ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Stream Priority ▁set Dependency ▁( ▁int ▁dependency ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Stream Priority ▁set Exclusive ▁( ▁boolean ▁exclusive ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁STR ▁) ▁; ▁} ▁} ▁; ▁private ▁Http Utils ▁( ▁) ▁{ ▁} ▁private ▁static ▁int ▁indexOf Slash ▁( ▁CharSequence ▁str ▁, ▁int ▁start ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁str ▁. ▁charAt ▁( ▁i ▁) ▁== ▁CHAR ▁) ▁{ ▁return ▁i ▁; ▁} ▁} ▁return ▁- ▁1 ▁; ▁} ▁private ▁static ▁boolean ▁matches ▁( ▁CharSequence ▁path ▁, ▁int ▁start ▁, ▁String ▁wh at ▁) ▁{ ▁return ▁matches ▁( ▁path ▁, ▁start ▁, ▁wh at ▁, ▁false ▁) ▁; ▁} ▁private ▁static ▁boolean ▁matches ▁( ▁CharSequence ▁path ▁, ▁int ▁start ▁, ▁String ▁wh at ▁, ▁boolean ▁exact ▁) ▁{ ▁if ▁( ▁exact ▁) ▁{ ▁if ▁( ▁path ▁. ▁length ▁( ▁) ▁- ▁start ▁!= ▁wh at ▁. ▁length ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁if ▁( ▁path ▁. ▁length ▁( ▁) ▁- ▁start ▁>= ▁wh at ▁. ▁length ▁( ▁) ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁wh at ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁path ▁. ▁charAt ▁( ▁start ▁+ ▁i ▁) ▁!= ▁wh at ▁. ▁charAt ▁( ▁i ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁String ▁normalize Path ▁( ▁String ▁path name ▁) ▁{ ▁if ▁( ▁path name ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁if ▁( ▁path name ▁. ▁length ▁( ▁) ▁== ▁0 ▁) ▁{ ▁return ▁STR ▁; ▁} ▁StringBuilder ▁i buf ▁= ▁new ▁StringBuilder ▁( ▁path name ▁. ▁length ▁( ▁) ▁+ ▁1 ▁) ▁; ▁if ▁( ▁path name ▁. ▁charAt ▁( ▁0 ▁) ▁!= ▁CHAR ▁) ▁{ ▁i buf ▁. ▁append ▁( ▁CHAR ▁) ▁; ▁} ▁i buf ▁. ▁append ▁( ▁path name ▁) ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁< ▁i buf ▁. ▁length ▁( ▁) ▁) ▁{ ▁if ▁( ▁i buf ▁. ▁charAt ▁( ▁i ▁) ▁== ▁CHAR ▁) ▁{ ▁decode Un reserved ▁( ▁i buf ▁, ▁i ▁) ▁; ▁} ▁i ▁++ ▁; ▁}
▁@ ▁GwtIncompatible ▁public ▁final ▁class ▁NavigableSet TestSuiteBuilder ▁< ▁E ▁> ▁extends ▁SortedSet TestSuiteBuilder ▁< ▁E ▁> ▁{ ▁public ▁static ▁< ▁E ▁> ▁NavigableSet TestSuiteBuilder ▁< ▁E ▁> ▁using ▁( ▁Test SortedSet Generator ▁< ▁E ▁> ▁generator ▁) ▁{ ▁NavigableSet TestSuiteBuilder ▁< ▁E ▁> ▁builder ▁= ▁new ▁NavigableSet TestSuiteBuilder ▁< ▁E ▁> ▁( ▁) ▁; ▁builder ▁. ▁using Generator ▁( ▁generator ▁) ▁; ▁return ▁builder ▁; ▁} ▁@ ▁Override ▁protected ▁List ▁< ▁TestSuite ▁> ▁create D erived Suites ▁( ▁Feature Specific TestSuiteBuilder ▁< ▁? ▁, ▁? ▁extends ▁One Size Test Container Generator ▁< ▁Collection ▁< ▁E ▁> ▁, ▁E ▁> ▁> ▁parent Builder ▁) ▁{ ▁List ▁< ▁TestSuite ▁> ▁derived Suites ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁super ▁. ▁create D erived Suites ▁( ▁parent Builder ▁) ▁) ▁; ▁if ▁( ▁! ▁parent Builder ▁. ▁getFeatures ▁( ▁) ▁. ▁contains ▁( ▁SUB SET _ VIEW ▁) ▁) ▁{ ▁derived Suites ▁. ▁add ▁( ▁create Subset Suite ▁( ▁parent Builder ▁, ▁Bound ▁. ▁NO _ BOUND ▁, ▁Bound ▁. ▁IN CLUSIVE ▁) ▁) ▁; ▁derived Suites ▁. ▁add ▁( ▁create Subset Suite ▁( ▁parent Builder ▁, ▁Bound ▁. ▁EX CLUSIVE ▁, ▁Bound ▁. ▁NO _ BOUND ▁) ▁) ▁; ▁derived Suites ▁. ▁add ▁( ▁create Subset Suite ▁( ▁parent Builder ▁, ▁Bound ▁. ▁EX CLUSIVE ▁, ▁Bound ▁. ▁EX CLUSIVE ▁) ▁) ▁; ▁derived Suites ▁. ▁add ▁( ▁create Subset Suite ▁( ▁parent Builder ▁, ▁Bound ▁. ▁EX CLUSIVE ▁, ▁Bound ▁. ▁IN CLUSIVE ▁) ▁) ▁; ▁derived Suites ▁. ▁add ▁( ▁create Subset Suite ▁( ▁parent Builder ▁, ▁Bound ▁. ▁IN CLUSIVE ▁, ▁Bound ▁. ▁IN CLUSIVE ▁) ▁) ▁; ▁} ▁if ▁( ▁! ▁parent Builder ▁. ▁getFeatures ▁( ▁) ▁. ▁contains ▁( ▁DE S CENDING _ VIEW ▁) ▁) ▁{ ▁derived Suites ▁. ▁add ▁( ▁create Desc ending Suite ▁( ▁parent Builder ▁) ▁) ▁; ▁} ▁return ▁derived Suites ▁; ▁} ▁public ▁static ▁final ▁class ▁NavigableSet Subset Test Set Generator ▁< ▁E ▁> ▁extends ▁SortedSet Subset Test Set Generator ▁< ▁E ▁> ▁{ ▁public ▁NavigableSet Subset Test Set Generator ▁( ▁Test SortedSet Generator ▁< ▁E ▁> ▁delegate ▁, ▁Bound ▁to ▁, ▁Bound ▁from ▁) ▁{ ▁super ▁( ▁delegate ▁, ▁to ▁, ▁from ▁) ▁; ▁} ▁@ ▁Override ▁NavigableSet ▁< ▁E ▁> ▁create Sub Set ▁( ▁SortedSet ▁< ▁E ▁> ▁sorted Set ▁, ▁E ▁first Exclusive ▁, ▁E ▁last Exclusive ▁) ▁{ ▁NavigableSet ▁< ▁E ▁> ▁set ▁= ▁( ▁NavigableSet ▁< ▁E ▁> ▁) ▁sorted Set ▁; ▁if ▁( ▁from ▁== ▁Bound ▁. ▁NO _ BOUND ▁&& ▁to ▁== ▁Bound ▁. ▁IN CLUSIVE ▁) ▁{ ▁return ▁set ▁. ▁head Set ▁( ▁last Inclusive ▁, ▁true ▁) ▁; ▁} ▁else ▁if ▁( ▁from ▁== ▁Bound ▁. ▁EX CLUSIVE ▁&& ▁to ▁== ▁Bound ▁. ▁NO _ BOUND ▁) ▁{ ▁return ▁set ▁. ▁tail Set ▁( ▁first Exclusive ▁, ▁false ▁) ▁; ▁} ▁else ▁if ▁( ▁from ▁== ▁Bound ▁. ▁EX CLUSIVE ▁&& ▁to ▁== ▁Bound ▁. ▁EX CLUSIVE ▁) ▁{ ▁return ▁set ▁. ▁sub Set ▁( ▁first Exclusive ▁, ▁false ▁, ▁last Exclusive ▁, ▁false ▁) ▁; ▁}
▁assertEquals ▁( ▁STR ▁, ▁new ▁Command Facade With Primary Second ary ▁( ▁20 ▁) ▁. ▁execute ▁( ▁) ▁) ▁; ▁} ▁finally ▁{ ▁context ▁. ▁shutdown ▁( ▁) ▁; ▁Configuration Manager ▁. ▁getConfig Instance ▁( ▁) ▁. ▁clear ▁( ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Second ary ▁( ▁) ▁{ ▁HystrixRequest Context ▁context ▁= ▁HystrixRequest Context ▁. ▁initialize Context ▁( ▁) ▁; ▁try ▁{ ▁Configuration Manager ▁. ▁getConfig Instance ▁( ▁) ▁. ▁setProperty ▁( ▁STR ▁, ▁false ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁new ▁Command Facade With Primary Second ary ▁( ▁20 ▁) ▁. ▁execute ▁( ▁) ▁) ▁; ▁} ▁finally ▁{ ▁context ▁. ▁shutdown ▁( ▁) ▁; ▁Configuration Manager ▁. ▁getConfig Instance ▁( ▁) ▁. ▁clear ▁( ▁) ▁; ▁} ▁} ▁} ▁}
▁if ▁( ▁getClass ▁( ▁) ▁!= ▁obj ▁. ▁getClass ▁( ▁) ▁) ▁return ▁false ▁; ▁Server MetaData Bo ▁other ▁= ▁( ▁Server MetaData Bo ▁) ▁obj ▁; ▁if ▁( ▁server Info ▁== ▁null ▁) ▁{ ▁if ▁( ▁other ▁. ▁server Info ▁!= ▁null ▁) ▁return ▁false ▁; ▁} ▁else ▁if ▁( ▁! ▁server Info ▁. ▁equals ▁( ▁other ▁. ▁server Info ▁) ▁) ▁return ▁false ▁; ▁if ▁( ▁service Infos ▁== ▁null ▁) ▁{ ▁if ▁( ▁other ▁. ▁service Infos ▁!= ▁null ▁) ▁return ▁false ▁; ▁} ▁else ▁if ▁( ▁! ▁service Infos ▁. ▁equals ▁( ▁other ▁. ▁service Infos ▁) ▁) ▁return ▁false ▁; ▁if ▁( ▁vm Args ▁== ▁null ▁) ▁{ ▁if ▁( ▁other ▁. ▁vm Args ▁!= ▁null ▁) ▁return ▁false ▁; ▁} ▁else ▁if ▁( ▁! ▁vm Args ▁. ▁equals ▁( ▁other ▁. ▁vm Args ▁) ▁) ▁return ▁false ▁; ▁return ▁true ▁; ▁} ▁public ▁static ▁class ▁Builder ▁{ ▁private ▁String ▁server Info ▁; ▁private ▁List ▁< ▁String ▁> ▁vm Args ▁; ▁private ▁List ▁< ▁ServiceInfo Bo ▁> ▁service Infos ▁; ▁public ▁Builder ▁( ▁) ▁{ ▁} ▁public ▁Builder ▁( ▁final ▁byte ▁[ ▁] ▁value ▁) ▁{ ▁final ▁Buffer ▁buffer ▁= ▁new ▁Fixed Buffer ▁( ▁value ▁) ▁; ▁this ▁. ▁server Info ▁= ▁buffer ▁. ▁read 2 Prefixed String ▁( ▁) ▁; ▁final ▁int ▁num V m Args ▁= ▁buffer ▁. ▁readVInt ▁( ▁) ▁; ▁this ▁. ▁vm Args ▁= ▁new ▁ArrayList ▁< ▁String ▁> ▁( ▁num V m Args ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁num V m Args ▁; ▁i ▁++ ▁) ▁{ ▁this ▁. ▁vm Args ▁. ▁add ▁( ▁buffer ▁. ▁read 2 Prefixed String ▁( ▁) ▁) ▁; ▁} ▁final ▁int ▁num Service Infos ▁= ▁buffer ▁. ▁readVInt ▁( ▁) ▁; ▁this ▁. ▁service Infos ▁= ▁new ▁ArrayList ▁< ▁ServiceInfo Bo ▁> ▁( ▁num Service Infos ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁num Service Infos ▁; ▁i ▁++ ▁) ▁{ ▁ServiceInfo Bo ▁service Info Bo ▁= ▁new ▁ServiceInfo Bo ▁. ▁Builder ▁( ▁buffer ▁. ▁read Prefixed Bytes ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁this ▁. ▁service Infos ▁. ▁add ▁( ▁service Info Bo ▁) ▁; ▁} ▁} ▁public ▁void ▁server Info ▁( ▁String ▁server Info ▁) ▁{ ▁this ▁. ▁server Info ▁= ▁server Info ▁; ▁} ▁public ▁void ▁vm Args ▁( ▁List ▁< ▁String ▁> ▁vm Args ▁) ▁{ ▁this ▁. ▁vm Args ▁= ▁vm Args ▁; ▁} ▁public ▁void ▁service Infos ▁( ▁List ▁< ▁ServiceInfo Bo ▁> ▁service Infos ▁) ▁{ ▁this ▁. ▁service Infos ▁= ▁service Infos ▁; ▁} ▁public ▁Server MetaData Bo ▁build ▁( ▁) ▁{ ▁if ▁( ▁this ▁. ▁server Info ▁== ▁null ▁) ▁{ ▁this ▁. ▁server Info ▁= ▁STR ▁; ▁} ▁if ▁( ▁this ▁. ▁vm Args ▁== ▁null ▁) ▁{ ▁this ▁. ▁vm Args ▁= ▁Collections ▁. ▁emptyList ▁( ▁) ▁; ▁} ▁if ▁( ▁this ▁. ▁service Infos ▁== ▁null ▁) ▁{ ▁this ▁. ▁service Infos ▁= ▁Collections ▁. ▁emptyList ▁( ▁) ▁; ▁} ▁return ▁new ▁Server MetaData Bo ▁( ▁this ▁) ▁;
▁@ ▁JsonIgnore Properties ▁( ▁ignore Unknown ▁= ▁true ▁) ▁public ▁class ▁Person ▁{ ▁@ ▁JsonProperty ▁( ▁STR ▁) ▁private ▁String ▁id ▁; ▁@ ▁JsonProperty ▁( ▁STR ▁) ▁private ▁String ▁name ▁; ▁@ ▁JsonProperty ▁( ▁STR ▁) ▁private ▁Link ▁k now s ▁; ▁public ▁Person ▁( ▁) ▁{ ▁} ▁public ▁Person ▁( ▁String ▁id ▁, ▁String ▁name ▁, ▁Link ▁k now s ▁) ▁{ ▁this ▁. ▁id ▁= ▁id ▁; ▁this ▁. ▁name ▁= ▁name ▁; ▁this ▁. ▁k now s ▁= ▁k now s ▁; ▁} ▁public ▁String ▁getId ▁( ▁) ▁{ ▁return ▁id ▁; ▁} ▁public ▁void ▁setId ▁( ▁String ▁id ▁) ▁{ ▁this ▁. ▁id ▁= ▁id ▁; ▁} ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁name ▁; ▁} ▁public ▁void ▁setName ▁( ▁String ▁name ▁) ▁{ ▁this ▁. ▁name ▁= ▁name ▁; ▁} ▁public ▁Link ▁getK now s ▁( ▁) ▁{ ▁return ▁k now s ▁; ▁} ▁public ▁void ▁set K now s ▁( ▁Link ▁k now s ▁) ▁{ ▁this ▁. ▁k now s ▁= ▁k now s ▁; ▁} ▁public ▁static ▁class ▁Link ▁{ ▁@ ▁JsonProperty ▁( ▁STR ▁) ▁private ▁String ▁id ▁; ▁public ▁Link ▁( ▁) ▁{ ▁} ▁public ▁Link ▁( ▁String ▁id ▁) ▁{ ▁this ▁. ▁id ▁= ▁id ▁; ▁} ▁public ▁String ▁getId ▁( ▁) ▁{ ▁return ▁id ▁; ▁} ▁public ▁void ▁setId ▁( ▁String ▁id ▁) ▁{ ▁this ▁. ▁id ▁= ▁id ▁; ▁} ▁} ▁}
▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁throw ▁new ▁Channel Exception ▁( ▁e ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁KQueue Datagram Channel Config ▁setR c v Alloc Transport Pro vides G uess ▁( ▁boolean ▁transport Pro vides G uess ▁) ▁{ ▁super ▁. ▁setR c v Alloc Transport Pro vides G uess ▁( ▁transport Pro vides G uess ▁) ▁; ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁KQueue Datagram Channel Config ▁setMessage Size Estimator ▁( ▁Message Size Estimator ▁estim ator ▁) ▁{ ▁super ▁. ▁setMessage Size Estimator ▁( ▁estim ator ▁) ▁; ▁return ▁this ▁; ▁} ▁@ ▁Override ▁@ ▁Deprecated ▁public ▁KQueue Datagram Channel Config ▁setWrite Buffer Low WaterMark ▁( ▁int ▁write Buffer Low WaterMark ▁) ▁{ ▁super ▁. ▁setWrite Buffer Low WaterMark ▁( ▁write Buffer Low WaterMark ▁) ▁; ▁return ▁this ▁; ▁} ▁@ ▁Override ▁@ ▁Deprecated ▁public ▁KQueue Datagram Channel Config ▁setWrite Buffer High WaterMark ▁( ▁int ▁write Buffer High WaterMark ▁) ▁{ ▁super ▁. ▁setWrite Buffer High WaterMark ▁( ▁write Buffer High WaterMark ▁) ▁; ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁KQueue Datagram Channel Config ▁setWrite Buffer WaterMark ▁( ▁Write Buffer WaterMark ▁write Buffer WaterMark ▁) ▁{ ▁super ▁. ▁setWrite Buffer WaterMark ▁( ▁write Buffer WaterMark ▁) ▁; ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁KQueue Datagram Channel Config ▁setAuto Close ▁( ▁boolean ▁auto Close ▁) ▁{ ▁super ▁. ▁setAuto Close ▁( ▁auto Close ▁) ▁; ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁KQueue Datagram Channel Config ▁setAuto Read ▁( ▁boolean ▁auto Read ▁) ▁{ ▁super ▁. ▁setAuto Read ▁( ▁auto Read ▁) ▁; ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁KQueue Datagram Channel Config ▁set Recv ByteBufAllocator ▁( ▁Rec v ByteBufAllocator ▁allocator ▁) ▁{ ▁super ▁. ▁set Recv ByteBufAllocator ▁( ▁allocator ▁) ▁; ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁KQueue Datagram Channel Config ▁setWrite Sp in Count ▁( ▁int ▁write Sp in Count ▁) ▁{ ▁super ▁. ▁setWrite Sp in Count ▁( ▁write Sp in Count ▁) ▁; ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁KQueue Datagram Channel Config ▁set Allocator ▁( ▁ByteBuf Allocator ▁allocator ▁) ▁{ ▁super ▁. ▁set Allocator ▁( ▁allocator ▁) ▁; ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁KQueue Datagram Channel Config ▁set Connect TimeoutMillis ▁( ▁int ▁connect TimeoutMillis ▁) ▁{ ▁super ▁. ▁set Connect TimeoutMillis ▁( ▁connect TimeoutMillis ▁) ▁; ▁return ▁this ▁; ▁} ▁@ ▁Override ▁@ ▁Deprecated ▁public ▁KQueue Datagram Channel Config ▁setMax Messages Per Read ▁( ▁int ▁max Messages Per Read ▁) ▁{ ▁super ▁. ▁setMax Messages Per Read ▁( ▁max Messages Per Read ▁) ▁; ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getSend BufferSize ▁( ▁) ▁{ ▁try ▁{ ▁return ▁( ▁( ▁KQueue Datagram Channel ▁) ▁channel ▁) ▁. ▁socket ▁. ▁getSend BufferSize ▁( ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁throw ▁new ▁Channel Exception ▁( ▁e ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁KQueue Datagram Channel Config ▁setS end BufferSize ▁( ▁int ▁send BufferSize ▁) ▁{ ▁try ▁{ ▁( ▁( ▁KQueue Datagram Channel ▁) ▁channel ▁) ▁. ▁socket ▁. ▁setS end BufferSize ▁( ▁send BufferSize ▁) ▁; ▁return ▁this ▁; ▁}
▁public ▁class ▁Score Function Builder Tests ▁extends ▁ESTestCase ▁{ ▁public ▁void ▁test Illegal Arguments ▁( ▁) ▁{ ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁Random Score Function Builder ▁( ▁) ▁. ▁seed ▁( ▁null ▁) ▁) ▁; ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁Script Score Function Builder ▁( ▁( ▁Script ▁) ▁null ▁) ▁) ▁; ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁FieldValue Factor Function Builder ▁( ▁( ▁String ▁) ▁null ▁) ▁) ▁; ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁FieldValue Factor Function Builder ▁( ▁STR ▁) ▁. ▁modifier ▁( ▁null ▁) ▁) ▁; ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁G au ss Dec ay Function Builder ▁( ▁null ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁) ▁; ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁G au ss Dec ay Function Builder ▁( ▁STR ▁, ▁STR ▁, ▁null ▁, ▁STR ▁) ▁) ▁; ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁G au ss Dec ay Function Builder ▁( ▁STR ▁, ▁STR ▁, ▁null ▁, ▁STR ▁, ▁randomDouble ▁( ▁) ▁) ▁) ▁; ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁Linear Dec ay Function Builder ▁( ▁null ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁) ▁; ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁Linear Dec ay Function Builder ▁( ▁STR ▁, ▁STR ▁, ▁null ▁, ▁STR ▁) ▁) ▁; ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁Linear Dec ay Function Builder ▁( ▁STR ▁, ▁STR ▁, ▁null ▁, ▁STR ▁, ▁randomDouble ▁( ▁) ▁) ▁) ▁; ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁Exponential Dec ay Function Builder ▁( ▁null ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁) ▁; ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁Exponential Dec ay Function Builder ▁( ▁STR ▁, ▁STR ▁, ▁null ▁, ▁STR ▁) ▁) ▁; ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁Exponential Dec ay Function Builder ▁( ▁STR ▁, ▁STR ▁, ▁null ▁, ▁STR ▁, ▁randomDouble ▁( ▁) ▁) ▁) ▁; ▁} ▁public ▁void ▁test Random Score Function With Seed No Field ▁( ▁) ▁throws ▁Exception ▁{ ▁Random Score Function Builder ▁builder ▁= ▁new ▁Random Score Function Builder ▁( ▁) ▁; ▁builder ▁. ▁seed ▁( ▁42 ▁) ▁; ▁Search ExecutionContext ▁context ▁= ▁Mockito ▁. ▁mock ▁( ▁Search ExecutionContext ▁. ▁class ▁) ▁; ▁Settings ▁indexSettings ▁= ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁IndexMetadata ▁. ▁SETTING _ VERSION _ CREATED ▁, ▁Version ▁. ▁CURRENT ▁) ▁. ▁put ▁( ▁IndexMetadata ▁. ▁SETTING _ NUMBER _ OF _ SHAR DS ▁, ▁1 ▁) ▁. ▁put ▁( ▁IndexMetadata ▁. ▁SETTING _ NUMBER _ OF _ REP LIC AS ▁, ▁1 ▁) ▁. ▁build ▁( ▁) ▁;
▁@ ▁JsonIgnore Properties ▁( ▁ignore Unknown ▁= ▁true ▁) ▁public ▁class ▁Disk Balancer Cluster ▁{ ▁private ▁static ▁final ▁Logger ▁LOG ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Disk Balancer Cluster ▁. ▁class ▁) ▁; ▁private ▁static ▁final ▁Object Reader ▁RE ADER ▁= ▁new ▁ObjectMapper ▁( ▁) ▁. ▁reader For ▁( ▁Disk Balancer Cluster ▁. ▁class ▁) ▁; ▁private ▁final ▁Set ▁< ▁String ▁> ▁ex clusion List ▁; ▁private ▁final ▁Set ▁< ▁String ▁> ▁in clusion List ▁; ▁private ▁Cluster Connector ▁cluster Connector ▁; ▁private ▁List ▁< ▁Disk Balancer DataNode ▁> ▁nodes ▁; ▁private ▁String ▁output path ▁; ▁@ ▁JsonIgnore ▁private ▁List ▁< ▁Disk Balancer DataNode ▁> ▁node sTo Process ▁; ▁@ ▁JsonIgnore ▁private ▁final ▁Map ▁< ▁String ▁, ▁Disk Balancer DataNode ▁> ▁ip List ▁; ▁@ ▁JsonIgnore ▁private ▁final ▁Map ▁< ▁String ▁, ▁Disk Balancer DataNode ▁> ▁host Names ▁; ▁@ ▁JsonIgnore ▁private ▁final ▁Map ▁< ▁String ▁, ▁Disk Balancer DataNode ▁> ▁host UUID ▁; ▁private ▁float ▁threshold ▁; ▁public ▁Disk Balancer Cluster ▁( ▁) ▁{ ▁nodes ▁= ▁new ▁LinkedList ▁< ▁> ▁( ▁) ▁; ▁ex clusion List ▁= ▁new ▁TreeSet ▁< ▁> ▁( ▁) ▁; ▁in clusion List ▁= ▁new ▁TreeSet ▁< ▁> ▁( ▁) ▁; ▁ip List ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁host Names ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁host UUID ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁} ▁public ▁Disk Balancer Cluster ▁( ▁Cluster Connector ▁connector ▁) ▁throws ▁IOException ▁{ ▁this ▁( ▁) ▁; ▁Preconditions ▁. ▁checkNotNull ▁( ▁connector ▁) ▁; ▁cluster Connector ▁= ▁connector ▁; ▁} ▁public ▁static ▁Disk Balancer Cluster ▁parse Json ▁( ▁String ▁json ▁) ▁throws ▁IOException ▁{ ▁return ▁RE ADER ▁. ▁readValue ▁( ▁json ▁) ▁; ▁} ▁public ▁void ▁read ClusterInfo ▁( ▁) ▁throws ▁Exception ▁{ ▁Preconditions ▁. ▁checkNotNull ▁( ▁cluster Connector ▁) ▁; ▁LOG ▁. ▁debug ▁( ▁STR ▁, ▁cluster Connector ▁. ▁getConnector Info ▁( ▁) ▁) ▁; ▁nodes ▁= ▁cluster Connector ▁. ▁getNodes ▁( ▁) ▁; ▁for ▁( ▁Disk Balancer DataNode ▁node ▁: ▁nodes ▁) ▁{ ▁if ▁( ▁node ▁. ▁getData Node IP ▁( ▁) ▁!= ▁null ▁&& ▁! ▁node ▁. ▁getData Node IP ▁( ▁) ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁ip List ▁. ▁put ▁( ▁node ▁. ▁getData Node IP ▁( ▁) ▁, ▁node ▁) ▁; ▁} ▁if ▁( ▁node ▁. ▁getData Node Name ▁( ▁) ▁!= ▁null ▁&& ▁! ▁node ▁. ▁getData Node Name ▁( ▁) ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁host Names ▁. ▁put ▁( ▁node ▁. ▁getData Node Name ▁( ▁) ▁. ▁toLowerCase ▁( ▁Locale ▁. ▁US ▁) ▁, ▁node ▁) ▁; ▁} ▁if ▁( ▁node ▁. ▁getData Node UUID ▁( ▁) ▁!= ▁null ▁&& ▁! ▁node ▁. ▁getData Node UUID ▁( ▁) ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁host UUID ▁. ▁put ▁( ▁node ▁. ▁getData Node UUID ▁( ▁) ▁, ▁node ▁) ▁; ▁} ▁} ▁} ▁public ▁List ▁< ▁Disk Balancer DataNode ▁> ▁getNodes ▁( ▁) ▁{ ▁return ▁nodes ▁; ▁} ▁public ▁void ▁set Nodes ▁( ▁List ▁< ▁Disk Balancer DataNode ▁> ▁cluster Nodes ▁) ▁{ ▁this ▁. ▁nodes ▁= ▁cluster Nodes ▁; ▁}
▁assertThat ▁( ▁buffer ▁. ▁readable Byte Count ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁9 ▁) ▁; ▁byte ▁[ ▁] ▁result ▁= ▁new ▁byte ▁[ ▁9 ▁] ▁; ▁buffer ▁. ▁read ▁( ▁result ▁) ▁; ▁assertThat ▁( ▁result ▁) ▁. ▁isEqualTo ▁( ▁STR ▁. ▁getBytes ▁( ▁) ▁) ▁; ▁release ▁( ▁buffer ▁) ▁; ▁} ▁@ ▁Parameterized DataBuffer Alloc ating Test ▁void ▁toString Null Charset ▁( ▁String ▁displayName ▁, ▁DataBuffer Factory ▁bufferFactory ▁) ▁{ ▁super ▁. ▁bufferFactory ▁= ▁bufferFactory ▁; ▁DataBuffer ▁buffer ▁= ▁create DataBuffer ▁( ▁1 ▁) ▁; ▁try ▁{ ▁assertThat IllegalArgument Exception ▁( ▁) ▁. ▁isThrownBy ▁( ▁( ▁) ▁-> ▁buffer ▁. ▁toString ▁( ▁null ▁) ▁) ▁; ▁} ▁finally ▁{ ▁release ▁( ▁buffer ▁) ▁; ▁} ▁} ▁@ ▁Parameterized DataBuffer Alloc ating Test ▁void ▁toString Utf 8 ▁( ▁String ▁displayName ▁, ▁DataBuffer Factory ▁bufferFactory ▁) ▁{ ▁super ▁. ▁bufferFactory ▁= ▁bufferFactory ▁; ▁String ▁spring ▁= ▁STR ▁; ▁byte ▁[ ▁] ▁bytes ▁= ▁spring ▁. ▁getBytes ▁( ▁Standard Charsets ▁. ▁UTF _8 ▁) ▁; ▁DataBuffer ▁buffer ▁= ▁create DataBuffer ▁( ▁bytes ▁. ▁length ▁) ▁; ▁buffer ▁. ▁write ▁( ▁bytes ▁) ▁; ▁String ▁result ▁= ▁buffer ▁. ▁toString ▁( ▁Standard Charsets ▁. ▁UTF _8 ▁) ▁; ▁assertThat ▁( ▁result ▁) ▁. ▁isEqualTo ▁( ▁spring ▁) ▁; ▁release ▁( ▁buffer ▁) ▁; ▁} ▁@ ▁Parameterized DataBuffer Alloc ating Test ▁void ▁toString Section ▁( ▁String ▁displayName ▁, ▁DataBuffer Factory ▁bufferFactory ▁) ▁{ ▁super ▁. ▁bufferFactory ▁= ▁bufferFactory ▁; ▁String ▁spring ▁= ▁STR ▁; ▁byte ▁[ ▁] ▁bytes ▁= ▁spring ▁. ▁getBytes ▁( ▁Standard Charsets ▁. ▁UTF _8 ▁) ▁; ▁DataBuffer ▁buffer ▁= ▁create DataBuffer ▁( ▁bytes ▁. ▁length ▁) ▁; ▁buffer ▁. ▁write ▁( ▁bytes ▁) ▁; ▁String ▁result ▁= ▁buffer ▁. ▁toString ▁( ▁1 ▁, ▁3 ▁, ▁Standard Charsets ▁. ▁UTF _8 ▁) ▁; ▁assertThat ▁( ▁result ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁release ▁( ▁buffer ▁) ▁; ▁} ▁@ ▁Parameterized DataBuffer Alloc ating Test ▁void ▁inputStream ▁( ▁String ▁displayName ▁, ▁DataBuffer Factory ▁bufferFactory ▁) ▁throws ▁Exception ▁{ ▁super ▁. ▁bufferFactory ▁= ▁bufferFactory ▁; ▁DataBuffer ▁buffer ▁= ▁create DataBuffer ▁( ▁4 ▁) ▁; ▁buffer ▁. ▁write ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁CHAR ▁, ▁CHAR ▁, ▁CHAR ▁, ▁CHAR ▁, ▁CHAR ▁} ▁) ▁; ▁buffer ▁. ▁read Position ▁( ▁1 ▁) ▁; ▁InputStream ▁inputStream ▁= ▁buffer ▁. ▁as InputStream ▁( ▁) ▁; ▁assertThat ▁( ▁inputStream ▁. ▁available ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁4 ▁) ▁; ▁int ▁result ▁= ▁inputStream ▁. ▁read ▁( ▁) ▁; ▁assertThat ▁( ▁result ▁) ▁. ▁isEqualTo ▁( ▁( ▁byte ▁) ▁CHAR ▁) ▁; ▁assertThat ▁( ▁inputStream ▁. ▁available ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁3 ▁) ▁; ▁byte ▁[ ▁] ▁bytes ▁= ▁new ▁byte ▁[ ▁2 ▁] ▁; ▁int ▁len ▁= ▁inputStream ▁. ▁read ▁( ▁bytes ▁) ▁; ▁assertThat ▁( ▁len ▁) ▁. ▁isEqualTo ▁( ▁2 ▁) ▁; ▁assertThat ▁( ▁bytes ▁) ▁. ▁isEqualTo ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁CHAR ▁, ▁CHAR ▁} ▁) ▁; ▁assertThat ▁( ▁inputStream ▁. ▁available ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁1 ▁) ▁; ▁Arrays ▁. ▁fill ▁( ▁bytes ▁, ▁( ▁byte ▁) ▁0 ▁) ▁;
▁public ▁void ▁show Filter Button ▁( ▁) ▁{ ▁if ▁( ▁isVisible ▁( ▁) ▁) ▁{ ▁return ▁; ▁} ▁this ▁. ▁trans par ency ▁= ▁FULL Y _ TRANS PARENT ▁; ▁setVisible ▁( ▁true ▁) ▁; ▁re an imate ▁( ▁) ▁; ▁} ▁private ▁void ▁re an imate ▁( ▁) ▁{ ▁if ▁( ▁! ▁Animation Utils ▁. ▁is Animation Enabled ▁( ▁) ▁) ▁{ ▁trans par ency ▁= ▁FULL Y _ OP A QUE ▁; ▁return ▁; ▁} ▁if ▁( ▁animator ▁!= ▁null ▁) ▁{ ▁return ▁; ▁} ▁animator ▁= ▁Property Setter ▁. ▁create Animator ▁( ▁FA DE _ IN _ MS ▁, ▁this ▁, ▁STR ▁, ▁FULL Y _ TRANS PARENT ▁, ▁FULL Y _ OP A QUE ▁) ▁; ▁animator ▁. ▁set Ac celer ation ▁( ▁0 f ▁) ▁; ▁animator ▁. ▁set De celer ation ▁( ▁0.8 f ▁) ▁; ▁animator ▁. ▁add Target ▁( ▁new ▁T iming Target Adapter ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁end ▁( ▁) ▁{ ▁animator ▁= ▁null ▁; ▁} ▁} ▁) ▁; ▁animator ▁. ▁start ▁( ▁) ▁; ▁} ▁private ▁void ▁cancel Animation ▁( ▁) ▁{ ▁if ▁( ▁animator ▁!= ▁null ▁) ▁{ ▁animator ▁. ▁cancel ▁( ▁) ▁; ▁animator ▁= ▁null ▁; ▁} ▁} ▁public ▁void ▁hide Filter Button ▁( ▁) ▁{ ▁cancel Animation ▁( ▁) ▁; ▁setVisible ▁( ▁false ▁) ▁; ▁} ▁private ▁void ▁reset Bounds ▁( ▁) ▁{ ▁SystemUtilities ▁. ▁run If Swing Or Post Swing Later ▁( ▁( ▁) ▁-> ▁do Reset Bounds ▁( ▁) ▁) ▁; ▁} ▁private ▁void ▁do Reset Bounds ▁( ▁) ▁{ ▁Container ▁my Parent ▁= ▁getParent ▁( ▁) ▁; ▁if ▁( ▁my Parent ▁== ▁null ▁) ▁{ ▁return ▁; ▁} ▁Rectangle ▁text Bounds ▁= ▁textField ▁. ▁getBounds ▁( ▁) ▁; ▁Insets ▁text In sets ▁= ▁textField ▁. ▁getIn sets ▁( ▁) ▁; ▁Point ▁location ▁= ▁text Bounds ▁. ▁getLocation ▁( ▁) ▁; ▁Dimension ▁size ▁= ▁getPreferred Size ▁( ▁) ▁; ▁int ▁half ▁= ▁( ▁text Bounds ▁. ▁height ▁- ▁size ▁. ▁height ▁) ▁ / ▁2 ▁; ▁int ▁y ▁= ▁text Bounds ▁. ▁y ▁+ ▁half ▁; ▁int ▁end ▁= ▁location ▁. ▁x ▁+ ▁text Bounds ▁. ▁width ▁; ▁int ▁x ▁= ▁end ▁- ▁text In sets ▁. ▁right ▁- ▁size ▁. ▁width ▁; ▁checkFor Touch y Text ▁( ▁x ▁) ▁; ▁setBounds ▁( ▁x ▁, ▁y ▁, ▁size ▁. ▁width ▁, ▁size ▁. ▁height ▁) ▁; ▁my Parent ▁. ▁validate ▁( ▁) ▁; ▁} ▁private ▁void ▁checkFor Touch y Text ▁( ▁int ▁x ▁) ▁{ ▁if ▁( ▁touch es Text ▁( ▁x ▁) ▁) ▁{ ▁trans par ency ▁= ▁PART IAL LY _ H IDDEN ▁; ▁return ▁; ▁} ▁if ▁( ▁trans par ency ▁== ▁PART IAL LY _ H IDDEN ▁) ▁{ ▁trans par ency ▁= ▁FULL Y _ OP A QUE ▁; ▁} ▁} ▁private ▁boolean ▁touch es Text ▁( ▁int ▁x ▁) ▁{ ▁Font Metrics ▁fm ▁= ▁textField ▁. ▁getFont Metrics ▁( ▁textField ▁. ▁getFont ▁( ▁) ▁) ▁; ▁Rectangle ▁text Bounds ▁= ▁textField ▁. ▁getBounds ▁( ▁) ▁;
▁public ▁class ▁P ick TableLayout ▁{ ▁private ▁final ▁Metadata ▁metadata ▁; ▁public ▁P ick TableLayout ▁( ▁Metadata ▁metadata ▁) ▁{ ▁this ▁. ▁metadata ▁= ▁requireNonNull ▁( ▁metadata ▁, ▁STR ▁) ▁; ▁} ▁public ▁Set ▁< ▁Rule ▁< ▁? ▁> ▁> ▁rules ▁( ▁) ▁{ ▁return ▁ImmutableSet ▁. ▁of ▁( ▁check Rules Are Fi red Before Add Ex ch anges Rule ▁( ▁) ▁, ▁pick TableLayout For Predicate ▁( ▁) ▁, ▁pick TableLayout Without Predicate ▁( ▁) ▁) ▁; ▁} ▁public ▁P ick TableLayout For Predicate ▁pick TableLayout For Predicate ▁( ▁) ▁{ ▁return ▁new ▁P ick TableLayout For Predicate ▁( ▁metadata ▁) ▁; ▁} ▁public ▁P ick TableLayout Without Predicate ▁pick TableLayout Without Predicate ▁( ▁) ▁{ ▁return ▁new ▁P ick TableLayout Without Predicate ▁( ▁metadata ▁) ▁; ▁} ▁private ▁static ▁final ▁class ▁P ick TableLayout For Predicate ▁implements ▁Rule ▁< ▁Filter Node ▁> ▁{ ▁private ▁final ▁Metadata ▁metadata ▁; ▁private ▁P ick TableLayout For Predicate ▁( ▁Metadata ▁metadata ▁) ▁{ ▁this ▁. ▁metadata ▁= ▁requireNonNull ▁( ▁metadata ▁, ▁STR ▁) ▁; ▁} ▁private ▁static ▁final ▁Capture ▁< ▁Table Scan Node ▁> ▁TABLE _ SC AN ▁= ▁new Capture ▁( ▁) ▁; ▁private ▁static ▁final ▁Pattern ▁< ▁Filter Node ▁> ▁PATTERN ▁= ▁filter ▁( ▁) ▁. ▁with ▁( ▁source ▁( ▁) ▁. ▁matching ▁( ▁table Scan ▁( ▁) ▁. ▁c aptured As ▁( ▁TABLE _ SC AN ▁) ▁) ▁) ▁; ▁@ ▁Override ▁public ▁Pattern ▁< ▁Filter Node ▁> ▁getPattern ▁( ▁) ▁{ ▁return ▁PATTERN ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁isEnabled ▁( ▁Session ▁session ▁) ▁{ ▁return ▁is New Optimizer Enabled ▁( ▁session ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Result ▁apply ▁( ▁Filter Node ▁filter Node ▁, ▁Capture s ▁capture s ▁, ▁Context ▁context ▁) ▁{ ▁Table Scan Node ▁table Scan ▁= ▁capture s ▁. ▁get ▁( ▁TABLE _ SC AN ▁) ▁; ▁if ▁( ▁! ▁metadata ▁. ▁is Legacy Get Layout Supported ▁( ▁context ▁. ▁getSession ▁( ▁) ▁, ▁table Scan ▁. ▁getTable ▁( ▁) ▁) ▁) ▁{ ▁return ▁Result ▁. ▁empty ▁( ▁) ▁; ▁} ▁PlanNode ▁rew ritten ▁= ▁push Predicate Into Table Scan ▁( ▁table Scan ▁, ▁filter Node ▁. ▁getPre dicate ▁( ▁) ▁, ▁false ▁, ▁context ▁. ▁getSession ▁( ▁) ▁, ▁context ▁. ▁getId Allocator ▁( ▁) ▁, ▁metadata ▁) ▁; ▁if ▁( ▁are P l ans Same ▁( ▁filter Node ▁, ▁table Scan ▁, ▁rew ritten ▁) ▁) ▁{ ▁return ▁Result ▁. ▁empty ▁( ▁) ▁; ▁} ▁return ▁Result ▁. ▁of PlanNode ▁( ▁rew ritten ▁) ▁; ▁} ▁private ▁boolean ▁are P l ans Same ▁( ▁Filter Node ▁filter ▁, ▁Table Scan Node ▁table Scan ▁, ▁PlanNode ▁rew ritten ▁) ▁{ ▁if ▁( ▁! ▁( ▁rew ritten ▁instanceof ▁Filter Node ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁Filter Node ▁rew ritten Filter ▁= ▁( ▁Filter Node ▁) ▁rew ritten ▁; ▁if ▁( ▁! ▁Objects ▁. ▁equals ▁( ▁filter ▁. ▁getPre dicate ▁( ▁) ▁, ▁rew ritten Filter ▁. ▁getPre dicate ▁( ▁) ▁) ▁) ▁{ ▁return ▁false ▁; ▁}
▁@ ▁RunWith ▁( ▁JUnit 4 ▁. ▁class ▁) ▁public ▁class ▁Test Timeout Converter Test ▁{ ▁private ▁Map ▁< ▁Test Timeout ▁, ▁Duration ▁> ▁timeout s ▁; ▁protected ▁void ▁setTimeout s ▁( ▁String ▁option ▁) ▁throws ▁Options ParsingException ▁{ ▁timeout s ▁= ▁new ▁Test Timeout Converter ▁( ▁) ▁. ▁convert ▁( ▁option ▁) ▁; ▁} ▁protected ▁void ▁assert Timeout ▁( ▁Test Timeout ▁timeout ▁, ▁int ▁expected ▁) ▁{ ▁assertThat ▁( ▁timeout s ▁) ▁. ▁containsEntry ▁( ▁timeout ▁, ▁Duration ▁. ▁ofSeconds ▁( ▁expected ▁) ▁) ▁; ▁} ▁protected ▁void ▁assert Default Timeout ▁( ▁Test Timeout ▁timeout ▁) ▁{ ▁assert Timeout ▁( ▁timeout ▁, ▁timeout ▁. ▁getTimeout Seconds ▁( ▁) ▁) ▁; ▁} ▁protected ▁void ▁assertFailure ▁( ▁String ▁option ▁) ▁{ ▁assertThrows ▁( ▁STR ▁+ ▁option ▁+ ▁STR ▁, ▁Options ParsingException ▁. ▁class ▁, ▁( ▁) ▁-> ▁setTimeout s ▁( ▁option ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testDefault Timeout ▁( ▁) ▁throws ▁Exception ▁{ ▁setTimeout s ▁( ▁STR ▁) ▁; ▁assert Default Timeout ▁( ▁Test Timeout ▁. ▁SHORT ▁) ▁; ▁assert Default Timeout ▁( ▁Test Timeout ▁. ▁MOD ER ATE ▁) ▁; ▁assert Default Timeout ▁( ▁Test Timeout ▁. ▁LONG ▁) ▁; ▁assert Default Timeout ▁( ▁Test Timeout ▁. ▁E TERNAL ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testUn iversal Timeout ▁( ▁) ▁throws ▁Exception ▁{ ▁setTimeout s ▁( ▁STR ▁) ▁; ▁assert Timeout ▁( ▁Test Timeout ▁. ▁SHORT ▁, ▁1 ▁) ▁; ▁assert Timeout ▁( ▁Test Timeout ▁. ▁MOD ER ATE ▁, ▁1 ▁) ▁; ▁assert Timeout ▁( ▁Test Timeout ▁. ▁LONG ▁, ▁1 ▁) ▁; ▁assert Timeout ▁( ▁Test Timeout ▁. ▁E TERNAL ▁, ▁1 ▁) ▁; ▁setTimeout s ▁( ▁STR ▁) ▁; ▁assert Timeout ▁( ▁Test Timeout ▁. ▁SHORT ▁, ▁2 ▁) ▁; ▁assert Timeout ▁( ▁Test Timeout ▁. ▁MOD ER ATE ▁, ▁2 ▁) ▁; ▁assert Timeout ▁( ▁Test Timeout ▁. ▁LONG ▁, ▁2 ▁) ▁; ▁assert Timeout ▁( ▁Test Timeout ▁. ▁E TERNAL ▁, ▁2 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Separ ate Timeout s ▁( ▁) ▁throws ▁Exception ▁{ ▁setTimeout s ▁( ▁STR ▁) ▁; ▁assert Timeout ▁( ▁Test Timeout ▁. ▁SHORT ▁, ▁1 ▁) ▁; ▁assert Default Timeout ▁( ▁Test Timeout ▁. ▁MOD ER ATE ▁) ▁; ▁assert Default Timeout ▁( ▁Test Timeout ▁. ▁LONG ▁) ▁; ▁assert Timeout ▁( ▁Test Timeout ▁. ▁E TERNAL ▁, ▁3 ▁) ▁; ▁setTimeout s ▁( ▁STR ▁) ▁; ▁assert Default Timeout ▁( ▁Test Timeout ▁. ▁SHORT ▁) ▁; ▁assert Default Timeout ▁( ▁Test Timeout ▁. ▁MOD ER ATE ▁) ▁; ▁assert Timeout ▁( ▁Test Timeout ▁. ▁LONG ▁, ▁3 ▁) ▁; ▁assert Timeout ▁( ▁Test Timeout ▁. ▁E TERNAL ▁, ▁20 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test In correct Strings ▁( ▁) ▁throws ▁Exception ▁{ ▁assertFailure ▁( ▁STR ▁) ▁; ▁assertFailure ▁( ▁STR ▁) ▁; ▁assertFailure ▁( ▁STR ▁) ▁; ▁assertFailure ▁( ▁STR ▁) ▁; ▁assertFailure ▁( ▁STR ▁) ▁; ▁assertFailure ▁( ▁STR ▁) ▁; ▁assertFailure ▁( ▁STR ▁) ▁; ▁assertFailure ▁( ▁STR ▁) ▁; ▁assertFailure ▁( ▁STR ▁) ▁; ▁} ▁}
▁private ▁String ▁parse Args ▁( ▁HA Service Protocol ▁. ▁HA ServiceState ▁state ▁, ▁String ▁cmd ▁) ▁{ ▁String ▁[ ▁] ▁args ▁= ▁cmd ▁. ▁split ▁( ▁ARG _ DELIMITER ▁) ▁; ▁if ▁( ▁args ▁. ▁length ▁== ▁1 ▁) ▁{ ▁return ▁args ▁[ ▁0 ▁] ▁; ▁} ▁if ▁( ▁args ▁. ▁length ▁> ▁2 ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁STR ▁+ ▁Arrays ▁. ▁asList ▁( ▁args ▁) ▁) ▁; ▁} ▁if ▁( ▁HA Service Protocol ▁. ▁HA ServiceState ▁. ▁ACTIVE ▁. ▁equals ▁( ▁state ▁) ▁) ▁{ ▁return ▁args ▁[ ▁0 ▁] ▁; ▁} ▁else ▁if ▁( ▁HA Service Protocol ▁. ▁HA ServiceState ▁. ▁ST AN DB Y ▁. ▁equals ▁( ▁state ▁) ▁) ▁{ ▁return ▁args ▁[ ▁1 ▁] ▁; ▁} ▁else ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁state ▁) ▁; ▁} ▁} ▁static ▁String ▁ab brev iate ▁( ▁String ▁cmd ▁, ▁int ▁len ▁) ▁{ ▁if ▁( ▁cmd ▁. ▁length ▁( ▁) ▁> ▁len ▁&& ▁len ▁>= ▁5 ▁) ▁{ ▁int ▁first Half ▁= ▁( ▁len ▁- ▁3 ▁) ▁ / ▁2 ▁; ▁int ▁rem ▁= ▁len ▁- ▁first Half ▁- ▁3 ▁; ▁return ▁cmd ▁. ▁substring ▁( ▁0 ▁, ▁first Half ▁) ▁+ ▁STR ▁+ ▁cmd ▁. ▁substring ▁( ▁cmd ▁. ▁length ▁( ▁) ▁- ▁rem ▁) ▁; ▁} ▁else ▁{ ▁return ▁cmd ▁; ▁} ▁} ▁private ▁static ▁String ▁try Get Pid ▁( ▁Process ▁p ▁) ▁{ ▁try ▁{ ▁Class ▁< ▁? ▁extends ▁Process ▁> ▁clazz ▁= ▁p ▁. ▁getClass ▁( ▁) ▁; ▁if ▁( ▁clazz ▁. ▁getName ▁( ▁) ▁. ▁equals ▁( ▁STR ▁) ▁) ▁{ ▁Field ▁f ▁= ▁clazz ▁. ▁getDeclared Field ▁( ▁STR ▁) ▁; ▁f ▁. ▁setAccessible ▁( ▁true ▁) ▁; ▁return ▁String ▁. ▁valueOf ▁( ▁f ▁. ▁getInt ▁( ▁p ▁) ▁) ▁; ▁} ▁else ▁{ ▁LOG ▁. ▁trace ▁( ▁STR ▁+ ▁p ▁+ ▁STR ▁) ▁; ▁return ▁null ▁; ▁} ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁LOG ▁. ▁trace ▁( ▁STR ▁+ ▁p ▁, ▁t ▁) ▁; ▁return ▁null ▁; ▁} ▁} ▁private ▁void ▁setConf As Env Vars ▁( ▁Map ▁< ▁String ▁, ▁String ▁> ▁env ▁) ▁{ ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁String ▁> ▁pair ▁: ▁getConf ▁( ▁) ▁) ▁{ ▁env ▁. ▁put ▁( ▁pair ▁. ▁getKey ▁( ▁) ▁. ▁replace ▁( ▁CHAR ▁, ▁CHAR ▁) ▁, ▁pair ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁} ▁private ▁void ▁add Target Info As Env Vars ▁( ▁HA Service Target ▁target ▁, ▁Map ▁< ▁String ▁, ▁String ▁> ▁environment ▁) ▁{ ▁String ▁prefix ▁; ▁HA Service Protocol ▁. ▁HA ServiceState ▁target State ▁= ▁target ▁. ▁get Transition Target HA Status ▁( ▁) ▁; ▁if ▁( ▁target State ▁== ▁null ▁|| ▁HA Service Protocol ▁. ▁HA ServiceState ▁. ▁ACTIVE ▁. ▁equals ▁( ▁target State ▁) ▁) ▁{ ▁prefix ▁= ▁TARGET _ PREFIX ▁; ▁} ▁else ▁if ▁( ▁HA Service Protocol ▁. ▁HA ServiceState ▁. ▁ST AN DB Y ▁. ▁equals ▁( ▁target State ▁) ▁) ▁{ ▁prefix ▁= ▁SOURCE _ PREFIX ▁; ▁}
▁@ ▁GwtCompatible ▁( ▁emulated ▁= ▁true ▁) ▁public ▁class ▁Case Format Test ▁extends ▁TestCase ▁{ ▁public ▁void ▁test Identity ▁( ▁) ▁{ ▁for ▁( ▁Case Format ▁from ▁: ▁Case Format ▁. ▁values ▁( ▁) ▁) ▁{ ▁assertSame ▁( ▁from ▁+ ▁STR ▁+ ▁from ▁, ▁STR ▁, ▁from ▁. ▁to ▁( ▁from ▁, ▁STR ▁) ▁) ▁; ▁for ▁( ▁Case Format ▁to ▁: ▁Case Format ▁. ▁values ▁( ▁) ▁) ▁{ ▁assertEquals ▁( ▁from ▁+ ▁STR ▁+ ▁to ▁, ▁STR ▁, ▁from ▁. ▁to ▁( ▁to ▁, ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁from ▁+ ▁STR ▁+ ▁to ▁, ▁STR ▁, ▁from ▁. ▁to ▁( ▁to ▁, ▁STR ▁) ▁) ▁; ▁} ▁} ▁} ▁@ ▁GwtIncompatible ▁public ▁void ▁testNull Arguments ▁( ▁) ▁{ ▁NullPointer Tester ▁tester ▁= ▁new ▁NullPointer Tester ▁( ▁) ▁; ▁tester ▁. ▁testAll Public Static Methods ▁( ▁Case Format ▁. ▁class ▁) ▁; ▁for ▁( ▁Case Format ▁format ▁: ▁Case Format ▁. ▁values ▁( ▁) ▁) ▁{ ▁tester ▁. ▁testAll Public InstanceMethods ▁( ▁format ▁) ▁; ▁} ▁} ▁public ▁void ▁test Lower H y ph en To Lower H y ph en ▁( ▁) ▁{ ▁assertEquals ▁( ▁STR ▁, ▁LOW ER _ HY PH EN ▁. ▁to ▁( ▁LOW ER _ HY PH EN ▁, ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁LOW ER _ HY PH EN ▁. ▁to ▁( ▁LOW ER _ HY PH EN ▁, ▁STR ▁) ▁) ▁; ▁} ▁public ▁void ▁test Lower H y ph en To Lower Under s core ▁( ▁) ▁{ ▁assertEquals ▁( ▁STR ▁, ▁LOW ER _ HY PH EN ▁. ▁to ▁( ▁LOW ER _ UN DER S CORE ▁, ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁LOW ER _ HY PH EN ▁. ▁to ▁( ▁LOW ER _ UN DER S CORE ▁, ▁STR ▁) ▁) ▁; ▁} ▁public ▁void ▁test Lower H y ph en To Lower C amel ▁( ▁) ▁{ ▁assertEquals ▁( ▁STR ▁, ▁LOW ER _ HY PH EN ▁. ▁to ▁( ▁LOW ER _ C AME L ▁, ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁LOW ER _ HY PH EN ▁. ▁to ▁( ▁LOW ER _ C AME L ▁, ▁STR ▁) ▁) ▁; ▁} ▁public ▁void ▁test Lower H y ph en To Upper C amel ▁( ▁) ▁{ ▁assertEquals ▁( ▁STR ▁, ▁LOW ER _ HY PH EN ▁. ▁to ▁( ▁U PPER _ C AME L ▁, ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁LOW ER _ HY PH EN ▁. ▁to ▁( ▁U PPER _ C AME L ▁, ▁STR ▁) ▁) ▁; ▁} ▁public ▁void ▁test Lower H y ph en To Upper Under s core ▁( ▁) ▁{ ▁assertEquals ▁( ▁STR ▁, ▁LOW ER _ HY PH EN ▁. ▁to ▁( ▁U PPER _ UN DER S CORE ▁, ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁LOW ER _ HY PH EN ▁. ▁to ▁( ▁U PPER _ UN DER S CORE ▁, ▁STR ▁) ▁) ▁; ▁}
▁b ▁++ ▁) ▁{ ▁if ▁( ▁b ▁== ▁start ▁+ ▁current Items In Row ▁- ▁1 ▁) ▁{ ▁item Spans ▁. ▁put ▁( ▁b ▁, ▁item Spans ▁. ▁get ▁( ▁b ▁) ▁+ ▁span Left ▁) ▁; ▁} ▁else ▁{ ▁item Spans ▁. ▁put ▁( ▁b ▁, ▁item Spans ▁. ▁get ▁( ▁b ▁) ▁+ ▁span Per Item ▁) ▁; ▁} ▁span Left ▁-= ▁span Per Item ▁; ▁} ▁item sTo Row ▁. ▁put ▁( ▁a ▁- ▁1 ▁, ▁rows Count ▁) ▁; ▁} ▁if ▁( ▁a ▁== ▁items Count ▁) ▁{ ▁break ▁; ▁} ▁rows Count ▁++ ▁; ▁current Items Span Amount ▁= ▁0 ▁; ▁current Items In Row ▁= ▁0 ▁; ▁span Left ▁= ▁span Count ▁; ▁} ▁else ▁{ ▁if ▁( ▁span Left ▁< ▁required Span ▁) ▁{ ▁required Span ▁= ▁span Left ▁; ▁} ▁} ▁if ▁( ▁rows Count ▁== ▁0 ▁) ▁{ ▁first Row Max ▁= ▁Math ▁. ▁max ▁( ▁first Row Max ▁, ▁a ▁) ▁; ▁} ▁if ▁( ▁a ▁== ▁items Count ▁- ▁1 ▁&& ▁! ▁last Row Full Width ▁) ▁{ ▁item sTo Row ▁. ▁put ▁( ▁a ▁, ▁rows Count ▁) ▁; ▁} ▁current Items Span Amount ▁+= ▁required Span ▁; ▁current Items In Row ▁++ ▁; ▁span Left ▁-= ▁required Span ▁; ▁item Spans ▁. ▁put ▁( ▁a ▁, ▁required Span ▁) ▁; ▁} ▁rows Count ▁++ ▁; ▁} ▁private ▁Size ▁size For Item ▁( ▁int ▁i ▁) ▁{ ▁return ▁fix Size ▁( ▁getSize For Item ▁( ▁i ▁) ▁) ▁; ▁} ▁protected ▁Size ▁fix Size ▁( ▁Size ▁size ▁) ▁{ ▁if ▁( ▁size ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁if ▁( ▁size ▁. ▁width ▁== ▁0 ▁) ▁{ ▁size ▁. ▁width ▁= ▁100 ▁; ▁} ▁if ▁( ▁size ▁. ▁height ▁== ▁0 ▁) ▁{ ▁size ▁. ▁height ▁= ▁100 ▁; ▁} ▁float ▁aspect ▁= ▁size ▁. ▁width ▁ / ▁size ▁. ▁height ▁; ▁if ▁( ▁aspect ▁> ▁4.0 f ▁|| ▁aspect ▁< ▁0.2 f ▁) ▁{ ▁size ▁. ▁height ▁= ▁size ▁. ▁width ▁= ▁Math ▁. ▁max ▁( ▁size ▁. ▁width ▁, ▁size ▁. ▁height ▁) ▁; ▁} ▁return ▁size ▁; ▁} ▁protected ▁Size ▁getSize For Item ▁( ▁int ▁i ▁) ▁{ ▁return ▁new ▁Size ▁( ▁100 ▁, ▁100 ▁) ▁; ▁} ▁private ▁void ▁check Layout ▁( ▁) ▁{ ▁if ▁( ▁item Spans ▁. ▁size ▁( ▁) ▁!= ▁getFlow Item Count ▁( ▁) ▁|| ▁calc ulated Width ▁!= ▁getWidth ▁( ▁) ▁) ▁{ ▁calc ulated Width ▁= ▁getWidth ▁( ▁) ▁; ▁prepare Layout ▁( ▁getWidth ▁( ▁) ▁) ▁; ▁} ▁} ▁public ▁int ▁getSpan Size For Item ▁( ▁int ▁i ▁) ▁{ ▁check Layout ▁( ▁) ▁; ▁return ▁item Spans ▁. ▁get ▁( ▁i ▁) ▁; ▁} ▁public ▁int ▁get Rows Count ▁( ▁int ▁width ▁) ▁{ ▁if ▁( ▁rows Count ▁== ▁0 ▁) ▁{ ▁prepare Layout ▁( ▁width ▁) ▁; ▁} ▁return ▁rows Count ▁; ▁} ▁public ▁boolean ▁isLast In Row ▁( ▁int ▁i ▁) ▁{ ▁check Layout ▁( ▁) ▁;
▁if ▁( ▁mongo Client ▁== ▁null ▁) ▁{ ▁Stream Network Transport ▁stream Network Transport ▁= ▁new ▁Stream Network Transport ▁( ▁app ▁. ▁os App ▁, ▁this ▁. ▁os User ▁) ▁; ▁Os Mongo Client ▁os Mongo Client ▁= ▁new ▁Os Mongo Client ▁( ▁os User ▁, ▁serviceName ▁, ▁stream Network Transport ▁) ▁; ▁mongo Client ▁= ▁new ▁MongoClient Impl ▁( ▁os Mongo Client ▁, ▁app ▁. ▁get Configuration ▁( ▁) ▁. ▁getDefault Codec Registry ▁( ▁) ▁) ▁; ▁} ▁return ▁mongo Client ▁; ▁} ▁@ ▁Suppress FBWarnings ▁( ▁STR ▁) ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁@ ▁Nullable ▁Object ▁o ▁) ▁{ ▁if ▁( ▁this ▁== ▁o ▁) ▁return ▁true ▁; ▁if ▁( ▁o ▁== ▁null ▁|| ▁getClass ▁( ▁) ▁!= ▁o ▁. ▁getClass ▁( ▁) ▁) ▁return ▁false ▁; ▁User ▁user ▁= ▁( ▁User ▁) ▁o ▁; ▁if ▁( ▁! ▁os User ▁. ▁getIdentity ▁( ▁) ▁. ▁equals ▁( ▁user ▁. ▁os User ▁. ▁getIdentity ▁( ▁) ▁) ▁) ▁return ▁false ▁; ▁return ▁app ▁. ▁get Configuration ▁( ▁) ▁. ▁getAppId ▁( ▁) ▁. ▁equals ▁( ▁user ▁. ▁app ▁. ▁get Configuration ▁( ▁) ▁. ▁getAppId ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁int ▁result ▁= ▁os User ▁. ▁hashCode ▁( ▁) ▁; ▁result ▁= ▁31 ▁ * ▁result ▁+ ▁app ▁. ▁hashCode ▁( ▁) ▁; ▁return ▁result ▁; ▁} ▁private ▁void ▁check Log ged In ▁( ▁) ▁{ ▁if ▁( ▁! ▁isLog ged In ▁( ▁) ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁} ▁} ▁private ▁static ▁native ▁void ▁native Remove User ▁( ▁long ▁native App Ptr ▁, ▁long ▁native User Ptr ▁, ▁Os Java Network Transport ▁. ▁Network Transport JNI ResultCallback ▁callback ▁) ▁; ▁private ▁static ▁native ▁void ▁native Link User ▁( ▁long ▁native App Ptr ▁, ▁long ▁native User Ptr ▁, ▁long ▁native Credentials Ptr ▁, ▁Os Java Network Transport ▁. ▁Network Transport JNI ResultCallback ▁callback ▁) ▁; ▁private ▁static ▁native ▁void ▁native Log Out ▁( ▁long ▁app Native Ptr ▁, ▁long ▁user Native Ptr ▁, ▁Os Java Network Transport ▁. ▁Network Transport JNI ResultCallback ▁callback ▁) ▁; ▁}
▁public ▁final ▁class ▁Encoder ▁{ ▁private ▁static ▁final ▁int ▁[ ▁] ▁AL PH AN UM ERIC _ TABLE ▁= ▁{ ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁36 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁37 ▁, ▁3 8 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁3 9 ▁, ▁40 ▁, ▁- ▁1 ▁, ▁41 ▁, ▁42 ▁, ▁43 ▁, ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁, ▁9 ▁, ▁44 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁10 ▁, ▁11 ▁, ▁12 ▁, ▁13 ▁, ▁14 ▁, ▁15 ▁, ▁16 ▁, ▁17 ▁, ▁18 ▁, ▁19 ▁, ▁20 ▁, ▁21 ▁, ▁22 ▁, ▁23 ▁, ▁24 ▁, ▁25 ▁, ▁26 ▁, ▁27 ▁, ▁28 ▁, ▁29 ▁, ▁30 ▁, ▁31 ▁, ▁32 ▁, ▁33 ▁, ▁34 ▁, ▁35 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁} ▁; ▁static ▁final ▁Charset ▁DEFAULT _ BYTE _ MODE _ ENCODING ▁= ▁Standard Charsets ▁. ▁ISO _88 59 _1 ▁; ▁private ▁Encoder ▁( ▁) ▁{ ▁} ▁private ▁static ▁int ▁calculate Mask P en alty ▁( ▁Byte Matrix ▁matrix ▁) ▁{ ▁return ▁Mask Util ▁. ▁apply Mask P en alty Rule 1 ▁( ▁matrix ▁) ▁+ ▁Mask Util ▁. ▁apply Mask P en alty Rule 2 ▁( ▁matrix ▁) ▁+ ▁Mask Util ▁. ▁apply Mask P en alty Rule 3 ▁( ▁matrix ▁) ▁+ ▁Mask Util ▁. ▁apply Mask P en alty Rule 4 ▁( ▁matrix ▁) ▁; ▁} ▁public ▁static ▁Q R Code ▁encode ▁( ▁String ▁content ▁, ▁Error Corre ction Level ▁ec Level ▁) ▁throws ▁Writer Exception ▁{ ▁return ▁encode ▁( ▁content ▁, ▁ec Level ▁, ▁null ▁) ▁; ▁} ▁public ▁static ▁Q R Code ▁encode ▁( ▁String ▁content ▁, ▁Error Corre ction Level ▁ec Level ▁, ▁Map ▁< ▁Encode Hint Type ▁, ▁? ▁> ▁hints ▁) ▁throws ▁Writer Exception ▁{ ▁Charset ▁encoding ▁= ▁DEFAULT _ BYTE _ MODE _ ENCODING ▁; ▁boolean ▁has Encoding Hint ▁= ▁hints ▁!= ▁null ▁&& ▁hints ▁. ▁containsKey ▁( ▁Encode Hint Type ▁. ▁CHAR ACTER _ SET ▁) ▁; ▁if ▁( ▁has Encoding Hint ▁) ▁{ ▁encoding ▁= ▁Charset ▁. ▁forName ▁( ▁hints ▁. ▁get ▁( ▁Encode Hint Type ▁. ▁CHAR ACTER _ SET ▁) ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁Mode ▁mode ▁= ▁choose Mode ▁( ▁content ▁, ▁encoding ▁) ▁;
▁byte ▁[ ▁] ▁bytes Forward ▁( ▁long ▁addr ▁) ▁{ ▁byte ▁[ ▁] ▁bytes ▁= ▁new ▁byte ▁[ ▁4 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁bytes ▁[ ▁i ▁] ▁= ▁( ▁byte ▁) ▁( ▁( ▁addr ▁>> ▁( ▁24 ▁- ▁( ▁i ▁ * ▁8 ▁) ▁) ▁) ▁& ▁0 xff ▁) ▁; ▁} ▁return ▁bytes ▁; ▁} ▁byte ▁[ ▁] ▁bytes Re versed ▁( ▁long ▁addr ▁) ▁{ ▁byte ▁[ ▁] ▁bytes ▁= ▁new ▁byte ▁[ ▁4 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁3 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁bytes ▁[ ▁3 ▁- ▁i ▁] ▁= ▁( ▁byte ▁) ▁( ▁( ▁addr ▁>> ▁( ▁24 ▁- ▁( ▁i ▁ * ▁8 ▁) ▁) ▁) ▁& ▁0 xff ▁) ▁; ▁} ▁return ▁bytes ▁; ▁} ▁public ▁int ▁getEnd ian ▁( ▁) ▁{ ▁if ▁( ▁currentProgram ▁. ▁getLanguage ▁( ▁) ▁. ▁is BigEndian ▁( ▁) ▁) ▁{ ▁return ▁1 ▁; ▁} ▁return ▁0 ▁; ▁} ▁class ▁P ossible Ptr s ▁{ ▁private ▁Address ▁addr Of Ptr ▁; ▁private ▁Address ▁possible Ptr ▁; ▁private ▁long ▁distance From Last ▁; ▁P ossible Ptr s ▁( ▁Address ▁addr Of Ptr ▁, ▁Address ▁possible Ptr ▁, ▁long ▁distance From Last ▁) ▁{ ▁this ▁. ▁addr Of Ptr ▁= ▁addr Of Ptr ▁; ▁this ▁. ▁possible Ptr ▁= ▁possible Ptr ▁; ▁this ▁. ▁distance From Last ▁= ▁distance From Last ▁; ▁} ▁public ▁Address ▁get Addr Of Ptr ▁( ▁) ▁{ ▁return ▁addr Of Ptr ▁; ▁} ▁public ▁Address ▁getP ossible Pointer ▁( ▁) ▁{ ▁return ▁possible Ptr ▁; ▁} ▁public ▁long ▁getDist ance From Last ▁( ▁) ▁{ ▁return ▁distance From Last ▁; ▁} ▁} ▁class ▁Table ▁{ ▁private ▁Address ▁top Addr ▁; ▁private ▁long ▁distance ▁; ▁private ▁int ▁num Pointer s ▁; ▁Address ▁ref ▁; ▁Table ▁( ▁Address ▁top Addr ▁, ▁long ▁distance ▁, ▁int ▁num Pointer s ▁, ▁Address ▁ref ▁) ▁{ ▁this ▁. ▁top Addr ▁= ▁top Addr ▁; ▁this ▁. ▁distance ▁= ▁distance ▁; ▁this ▁. ▁num Pointer s ▁= ▁num Pointer s ▁; ▁this ▁. ▁ref ▁= ▁ref ▁; ▁} ▁public ▁Address ▁getTop Addr ▁( ▁) ▁{ ▁return ▁top Addr ▁; ▁} ▁public ▁long ▁getDist ance ▁( ▁) ▁{ ▁return ▁distance ▁; ▁} ▁public ▁int ▁getNum Pointer s ▁( ▁) ▁{ ▁return ▁num Pointer s ▁; ▁} ▁public ▁Address ▁getRef ▁( ▁) ▁{ ▁return ▁ref ▁; ▁} ▁} ▁}
▁private ▁static ▁PointF ▁jsonObject To Point ▁( ▁JsonReader ▁reader ▁, ▁float ▁scale ▁) ▁throws ▁IOException ▁{ ▁float ▁x ▁= ▁0 f ▁; ▁float ▁y ▁= ▁0 f ▁; ▁reader ▁. ▁begin Object ▁( ▁) ▁; ▁while ▁( ▁reader ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁switch ▁( ▁reader ▁. ▁select Name ▁( ▁PO INT _ NAMES ▁) ▁) ▁{ ▁case ▁0 ▁: ▁x ▁= ▁value From Object ▁( ▁reader ▁) ▁; ▁break ▁; ▁case ▁1 ▁: ▁y ▁= ▁value From Object ▁( ▁reader ▁) ▁; ▁break ▁; ▁default ▁: ▁reader ▁. ▁skip Name ▁( ▁) ▁; ▁reader ▁. ▁skip Value ▁( ▁) ▁; ▁} ▁} ▁reader ▁. ▁endObject ▁( ▁) ▁; ▁return ▁new ▁PointF ▁( ▁x ▁ * ▁scale ▁, ▁y ▁ * ▁scale ▁) ▁; ▁} ▁static ▁float ▁value From Object ▁( ▁JsonReader ▁reader ▁) ▁throws ▁IOException ▁{ ▁JsonReader ▁. ▁Token ▁token ▁= ▁reader ▁. ▁peek ▁( ▁) ▁; ▁switch ▁( ▁token ▁) ▁{ ▁case ▁NUMBER ▁: ▁return ▁( ▁float ▁) ▁reader ▁. ▁nextDouble ▁( ▁) ▁; ▁case ▁BE GIN _ ARRAY ▁: ▁reader ▁. ▁begin Array ▁( ▁) ▁; ▁float ▁val ▁= ▁( ▁float ▁) ▁reader ▁. ▁nextDouble ▁( ▁) ▁; ▁while ▁( ▁reader ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁reader ▁. ▁skip Value ▁( ▁) ▁; ▁} ▁reader ▁. ▁endArray ▁( ▁) ▁; ▁return ▁val ▁; ▁default ▁: ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁token ▁) ▁; ▁} ▁} ▁}
▁reset Dist Cache Config Properties ▁( ▁jobConf ▁) ▁; ▁return ▁jobConf ▁; ▁} ▁private ▁void ▁reset Dist Cache Config Properties ▁( ▁Configuration ▁jobConf ▁) ▁{ ▁jobConf ▁. ▁setString s ▁( ▁MRJobConfig ▁. ▁CACHE _ FILES ▁, ▁STR ▁) ▁; ▁jobConf ▁. ▁setString s ▁( ▁MRJobConfig ▁. ▁CACHE _ FILES _ SI Z ES ▁, ▁STR ▁) ▁; ▁jobConf ▁. ▁setString s ▁( ▁MRJobConfig ▁. ▁CACHE _ FILE _ TIMESTAMP S ▁, ▁STR ▁) ▁; ▁jobConf ▁. ▁setString s ▁( ▁JobContext ▁. ▁CACHE _ FILE _ VI SI B IL IT IES ▁, ▁STR ▁) ▁; ▁jobConf ▁. ▁setString s ▁( ▁STR ▁, ▁STR ▁) ▁; ▁jobConf ▁. ▁setString s ▁( ▁STR ▁, ▁STR ▁) ▁; ▁jobConf ▁. ▁setString s ▁( ▁STR ▁, ▁STR ▁) ▁; ▁jobConf ▁. ▁setString s ▁( ▁STR ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁( ▁timeout ▁= ▁200 000 ▁) ▁public ▁void ▁test Generate Dist Cache Data ▁( ▁) ▁throws ▁Exception ▁{ ▁long ▁[ ▁] ▁sorted File Sizes ▁= ▁new ▁long ▁[ ▁5 ▁] ▁; ▁Configuration ▁jobConf ▁= ▁run Setup Generate Dist Cache Data ▁( ▁true ▁, ▁sorted File Sizes ▁) ▁; ▁G ri dm ix Job ▁g ri dm ix Job ▁= ▁new ▁Generate Dist Cache Data ▁( ▁jobConf ▁) ▁; ▁Job ▁job ▁= ▁g ri dm ix Job ▁. ▁call ▁( ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁0 ▁, ▁job ▁. ▁getNum Reduce Tasks ▁( ▁) ▁) ▁; ▁assertTrue ▁( ▁STR ▁, ▁job ▁. ▁waitFor Completion ▁( ▁false ▁) ▁) ▁; ▁validate Dist Cache Data ▁( ▁jobConf ▁, ▁sorted File Sizes ▁) ▁; ▁} ▁private ▁void ▁validate Setup Gen D C ▁( ▁Configuration ▁jobConf ▁, ▁long ▁[ ▁] ▁sorted File Sizes ▁) ▁throws ▁IOException ▁, ▁Interrupted Exception ▁{ ▁long ▁sumOf File Sizes ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁sorted File Sizes ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁sumOf File Sizes ▁+= ▁sorted File Sizes ▁[ ▁i ▁] ▁; ▁} ▁FileSystem ▁fs ▁= ▁FileSystem ▁. ▁get ▁( ▁jobConf ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁sorted File Sizes ▁. ▁length ▁, ▁jobConf ▁. ▁getInt ▁( ▁Generate Dist Cache Data ▁. ▁GR ID MI X _ DI ST CACHE _ FILE _ COUNT ▁, ▁- ▁1 ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁sumOf File Sizes ▁, ▁jobConf ▁. ▁getLong ▁( ▁Generate Dist Cache Data ▁. ▁GR ID MI X _ DI ST CACHE _ BYTE _ COUNT ▁, ▁- ▁1 ▁) ▁) ▁; ▁Path ▁files List File ▁= ▁new ▁Path ▁( ▁jobConf ▁. ▁get ▁( ▁Generate Dist Cache Data ▁. ▁GR ID MI X _ DI ST CACHE _ FILE _ LIST ▁) ▁) ▁; ▁FileStatus ▁stat ▁= ▁fs ▁. ▁getFileStatus ▁( ▁files List File ▁) ▁; ▁assertEquals ▁( ▁STR ▁+ ▁files List File ▁, ▁new ▁FsPermission ▁( ▁( ▁short ▁) ▁0 64 4 ▁) ▁, ▁stat ▁. ▁getPerm ission ▁( ▁) ▁) ▁; ▁InputSplit ▁split ▁= ▁new ▁FileSplit ▁( ▁files List File ▁, ▁0 ▁, ▁stat ▁. ▁getLen ▁( ▁) ▁, ▁( ▁String ▁[ ▁] ▁) ▁null ▁) ▁;
▁@ ▁Override ▁public ▁DataType ▁getResultType ▁( ▁) ▁{ ▁return ▁DataTypes ▁. ▁DECIMAL ▁( ▁decimal Type ▁. ▁getPre cision ▁( ▁) ▁, ▁decimal Type ▁. ▁getScale ▁( ▁) ▁) ▁; ▁} ▁} ▁public ▁static ▁class ▁Boolean Max AggFunction ▁extends ▁Max AggFunction ▁{ ▁@ ▁Override ▁public ▁DataType ▁getResultType ▁( ▁) ▁{ ▁return ▁DataTypes ▁. ▁BOOLEAN ▁( ▁) ▁; ▁} ▁} ▁public ▁static ▁class ▁String Max AggFunction ▁extends ▁Max AggFunction ▁{ ▁@ ▁Override ▁public ▁DataType ▁getResultType ▁( ▁) ▁{ ▁return ▁DataTypes ▁. ▁STRING ▁( ▁) ▁; ▁} ▁} ▁public ▁static ▁class ▁Date Max AggFunction ▁extends ▁Max AggFunction ▁{ ▁@ ▁Override ▁public ▁DataType ▁getResultType ▁( ▁) ▁{ ▁return ▁DataTypes ▁. ▁DATE ▁( ▁) ▁; ▁} ▁} ▁public ▁static ▁class ▁Time Max AggFunction ▁extends ▁Max AggFunction ▁{ ▁@ ▁Override ▁public ▁DataType ▁getResultType ▁( ▁) ▁{ ▁return ▁DataTypes ▁. ▁TIME ▁( ▁Time Type ▁. ▁DEFAULT _ PRE CISION ▁) ▁; ▁} ▁} ▁public ▁static ▁class ▁Timestamp Max AggFunction ▁extends ▁Max AggFunction ▁{ ▁private ▁final ▁Timestamp Type ▁type ▁; ▁public ▁Timestamp Max AggFunction ▁( ▁Timestamp Type ▁type ▁) ▁{ ▁this ▁. ▁type ▁= ▁type ▁; ▁} ▁@ ▁Override ▁public ▁DataType ▁getResultType ▁( ▁) ▁{ ▁return ▁DataTypes ▁. ▁TIMESTAMP ▁( ▁type ▁. ▁getPre cision ▁( ▁) ▁) ▁; ▁} ▁} ▁public ▁static ▁class ▁Timestamp L t z Max AggFunction ▁extends ▁Max AggFunction ▁{ ▁private ▁final ▁Local Z oned Timestamp Type ▁type ▁; ▁public ▁Timestamp L t z Max AggFunction ▁( ▁Local Z oned Timestamp Type ▁type ▁) ▁{ ▁this ▁. ▁type ▁= ▁type ▁; ▁} ▁@ ▁Override ▁public ▁DataType ▁getResultType ▁( ▁) ▁{ ▁return ▁DataTypes ▁. ▁TIMESTAMP _ L T Z ▁( ▁type ▁. ▁getPre cision ▁( ▁) ▁) ▁; ▁} ▁} ▁}
▁private ▁Throwable ▁get Throwable ▁( ▁Async Event ▁async Event ▁) ▁{ ▁try ▁{ ▁if ▁( ▁async Event ▁. ▁get Throwable ▁( ▁) ▁!= ▁null ▁) ▁{ ▁return ▁async Event ▁. ▁get Throwable ▁( ▁) ▁; ▁} ▁final ▁ServletRequest ▁request ▁= ▁async Event ▁. ▁getSup plied Request ▁( ▁) ▁; ▁if ▁( ▁request ▁!= ▁null ▁) ▁{ ▁final ▁Object ▁error Exception ▁= ▁request ▁. ▁getAttribute ▁( ▁Request Dispatcher ▁. ▁ERROR _ EXCEPTION ▁) ▁; ▁if ▁( ▁error Exception ▁instanceof ▁Throwable ▁) ▁{ ▁return ▁( ▁Throwable ▁) ▁error Exception ▁; ▁} ▁} ▁} ▁catch ▁( ▁Exception ▁ignored ▁) ▁{ ▁} ▁return ▁null ▁; ▁} ▁}
▁while ▁( ▁packet Buffer ▁. ▁bytes Left ▁( ▁) ▁>= ▁T s Extractor ▁. ▁T S _ P ACKET _ SI Z E ▁) ▁{ ▁int ▁start Of Packet ▁= ▁T s Util ▁. ▁find Sync Byte Position ▁( ▁packet Buffer ▁. ▁getData ▁( ▁) ▁, ▁packet Buffer ▁. ▁getPosition ▁( ▁) ▁, ▁limit ▁) ▁; ▁int ▁endOf Packet ▁= ▁start Of Packet ▁+ ▁T s Extractor ▁. ▁T S _ P ACKET _ SI Z E ▁; ▁if ▁( ▁endOf Packet ▁> ▁limit ▁) ▁{ ▁break ▁; ▁} ▁long ▁pcr Value ▁= ▁T s Util ▁. ▁read P cr From Packet ▁( ▁packet Buffer ▁, ▁start Of Packet ▁, ▁pcr Pid ▁) ▁; ▁if ▁( ▁pcr Value ▁!= ▁C ▁. ▁TIME _ UNSET ▁) ▁{ ▁long ▁pcr TimeUs ▁= ▁pcr Timestamp Adj uster ▁. ▁adjust Ts Timestamp ▁( ▁pcr Value ▁) ▁; ▁if ▁( ▁pcr TimeUs ▁> ▁target P cr TimeUs ▁) ▁{ ▁if ▁( ▁last P cr TimeUs InRange ▁== ▁C ▁. ▁TIME _ UNSET ▁) ▁{ ▁return ▁Timestamp SearchResult ▁. ▁over est im ated Result ▁( ▁pcr TimeUs ▁, ▁buffer Start Offset ▁) ▁; ▁} ▁else ▁{ ▁return ▁Timestamp SearchResult ▁. ▁target Found Result ▁( ▁buffer Start Offset ▁+ ▁start Of Last Packet Position ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁pcr TimeUs ▁+ ▁SE E K _ TO LER ANCE _ US ▁> ▁target P cr TimeUs ▁) ▁{ ▁long ▁start Of Packet In Stream ▁= ▁buffer Start Offset ▁+ ▁start Of Packet ▁; ▁return ▁Timestamp SearchResult ▁. ▁target Found Result ▁( ▁start Of Packet In Stream ▁) ▁; ▁} ▁last P cr TimeUs InRange ▁= ▁pcr TimeUs ▁; ▁start Of Last Packet Position ▁= ▁start Of Packet ▁; ▁} ▁packet Buffer ▁. ▁setPosition ▁( ▁endOf Packet ▁) ▁; ▁endOf Last Packet Position ▁= ▁endOf Packet ▁; ▁} ▁if ▁( ▁last P cr TimeUs InRange ▁!= ▁C ▁. ▁TIME _ UNSET ▁) ▁{ ▁long ▁endOf Last Packet Position In Stream ▁= ▁buffer Start Offset ▁+ ▁endOf Last Packet Position ▁; ▁return ▁Timestamp SearchResult ▁. ▁under est im ated Result ▁( ▁last P cr TimeUs InRange ▁, ▁endOf Last Packet Position In Stream ▁) ▁; ▁} ▁else ▁{ ▁return ▁Timestamp SearchResult ▁. ▁NO _ TIMESTAMP _ IN _ RANGE _ RESULT ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁on Seek Finished ▁( ▁) ▁{ ▁packet Buffer ▁. ▁reset ▁( ▁Util ▁. ▁EMPTY _ BYTE _ ARRAY ▁) ▁; ▁} ▁} ▁}
▁assertThat ▁( ▁d rm Session ▁. ▁getState ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Drm Session ▁. ▁STATE _ OPEN ED _ WITH _ KEYS ▁) ▁; ▁Shadow Looper ▁. ▁idle Main Looper ▁( ▁10 ▁, ▁SECONDS ▁) ▁; ▁assertThat ▁( ▁d rm Session ▁. ▁getState ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Drm Session ▁. ▁STATE _ OPEN ED _ WITH _ KEYS ▁) ▁; ▁d rm Session ▁. ▁release ▁( ▁null ▁) ▁; ▁assertThat ▁( ▁d rm Session ▁. ▁getState ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Drm Session ▁. ▁STATE _ RE LEASE D ▁) ▁; ▁} ▁@ ▁Test ▁( ▁timeout ▁= ▁10_000 ▁) ▁public ▁void ▁max Concurrent Sessions Exceeded _ all Keep Alive Sessions Eager ly Released ▁( ▁) ▁throws ▁Exception ▁{ ▁ImmutableList ▁< ▁Drm Init Data ▁. ▁S cheme Data ▁> ▁second Scheme Data s ▁= ▁ImmutableList ▁. ▁of ▁( ▁D RM _ SCHEME _ DAT AS ▁. ▁get ▁( ▁0 ▁) ▁. ▁copy With Data ▁( ▁TestUtil ▁. ▁create ByteArray ▁( ▁4 ▁, ▁5 ▁, ▁6 ▁) ▁) ▁) ▁; ▁Fake Ex o Media D rm ▁. ▁License Server ▁license Server ▁= ▁Fake Ex o Media D rm ▁. ▁License Server ▁. ▁allow ing Scheme Data s ▁( ▁D RM _ SCHEME _ DAT AS ▁, ▁second Scheme Data s ▁) ▁; ▁Format ▁second Format With D rm Init Data ▁= ▁new ▁Format ▁. ▁Builder ▁( ▁) ▁. ▁setD rm Init Data ▁( ▁new ▁Drm Init Data ▁( ▁second Scheme Data s ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁Drm SessionManager ▁d rm SessionManager ▁= ▁new ▁Default D rm SessionManager ▁. ▁Builder ▁( ▁) ▁. ▁set Uuid And Ex o Media D rm Provider ▁( ▁D RM _ SCHEME _ UUID ▁, ▁uuid ▁-> ▁new ▁Fake Ex o Media D rm ▁( ▁1 ▁) ▁) ▁. ▁set Session Keep al ive Ms ▁( ▁10_000 ▁) ▁. ▁set Multi Session ▁( ▁true ▁) ▁. ▁build ▁( ▁license Server ▁) ▁; ▁d rm SessionManager ▁. ▁prepare ▁( ▁) ▁; ▁Drm Session ▁first D rm Session ▁= ▁checkNotNull ▁( ▁d rm SessionManager ▁. ▁acquire Session ▁( ▁checkNotNull ▁( ▁Looper ▁. ▁my Looper ▁( ▁) ▁) ▁, ▁null ▁, ▁FORMAT _ WITH _ D RM _ INIT _ DATA ▁) ▁) ▁; ▁waitFor Opened With Keys ▁( ▁first D rm Session ▁) ▁; ▁first D rm Session ▁. ▁release ▁( ▁null ▁) ▁; ▁assertThat ▁( ▁first D rm Session ▁. ▁getState ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Drm Session ▁. ▁STATE _ OPEN ED _ WITH _ KEYS ▁) ▁; ▁Drm Session ▁second D rm Session ▁= ▁checkNotNull ▁( ▁d rm SessionManager ▁. ▁acquire Session ▁( ▁checkNotNull ▁( ▁Looper ▁. ▁my Looper ▁( ▁) ▁) ▁, ▁null ▁, ▁second Format With D rm Init Data ▁) ▁) ▁; ▁assertThat ▁( ▁first D rm Session ▁. ▁getState ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Drm Session ▁. ▁STATE _ RE LEASE D ▁) ▁; ▁waitFor Opened With Keys ▁( ▁second D rm Session ▁) ▁;
▁public ▁class ▁VT Exact Symbol Match 1 Test ▁extends ▁AbstractG hidra He aded IntegrationTest ▁{ ▁private ▁VT Test Env ▁env ▁; ▁private ▁VTSession ▁session ▁; ▁private ▁Program ▁src Prog ▁; ▁private ▁Program ▁dest Prog ▁; ▁public ▁VT Exact Symbol Match 1 Test ▁( ▁) ▁{ ▁super ▁( ▁) ▁; ▁} ▁@ ▁Before ▁public ▁void ▁setUp ▁( ▁) ▁throws ▁Exception ▁{ ▁env ▁= ▁new ▁VT Test Env ▁( ▁) ▁; ▁PluginTool ▁tool ▁= ▁env ▁. ▁show Tool ▁( ▁) ▁; ▁session ▁= ▁env ▁. ▁create Session ▁( ▁STR ▁, ▁STR ▁, ▁new ▁Symbol Name Program Correlator Factory ▁( ▁) ▁) ▁; ▁assertNotNull ▁( ▁session ▁) ▁; ▁src Prog ▁= ▁env ▁. ▁getSource Program ▁( ▁) ▁; ▁dest Prog ▁= ▁env ▁. ▁getDestination Program ▁( ▁) ▁; ▁JFrame ▁tool Frame ▁= ▁tool ▁. ▁getTool Frame ▁( ▁) ▁; ▁tool Frame ▁. ▁setSize ▁( ▁8 00 ▁, ▁8 00 ▁) ▁; ▁} ▁@ ▁After ▁public ▁void ▁tearDown ▁( ▁) ▁throws ▁Exception ▁{ ▁env ▁. ▁dispose ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Exact Symbol Correlator ▁( ▁) ▁{ ▁assertTrue ▁( ▁isMatch ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁) ▁) ▁; ▁assertTrue ▁( ▁verify External Addresses Name ▁( ▁src Prog ▁, ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁STR ▁) ▁) ▁; ▁assertTrue ▁( ▁verify External Addresses Name ▁( ▁dest Prog ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁, ▁STR ▁) ▁) ▁; ▁assertTrue ▁( ▁isMatch ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁) ▁) ▁; ▁assertTrue ▁( ▁verify External Addresses Name ▁( ▁src Prog ▁, ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁STR ▁) ▁) ▁; ▁assertTrue ▁( ▁verify External Addresses Name ▁( ▁dest Prog ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁, ▁STR ▁) ▁) ▁; ▁assertTrue ▁( ▁isMatch ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁) ▁) ▁; ▁assertFalse ▁( ▁isMatch ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁) ▁) ▁; ▁assertFalse ▁( ▁isMatch ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁) ▁) ▁; ▁assertFalse ▁( ▁isMatch ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁) ▁) ▁; ▁assertFalse ▁( ▁isMatch ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁) ▁) ▁; ▁assertFalse ▁( ▁isMatch ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁) ▁) ▁; ▁assertFalse ▁( ▁isMatch ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁) ▁) ▁; ▁} ▁public ▁boolean ▁verify External Addresses Name ▁( ▁Program ▁prog ▁, ▁Address ▁ext Addr ▁, ▁String ▁name ▁) ▁{ ▁Symbol Iterator ▁symbols ▁= ▁prog ▁. ▁getSymbolTable ▁( ▁) ▁. ▁getSymbol s ▁( ▁name ▁) ▁;
▁private ▁static ▁void ▁execute ▁( ▁String ▁testName ▁, ▁String ▁... ▁additional V m Options ▁) ▁throws ▁IOException ▁, ▁Interrupted Exception ▁{ ▁Sub process Util ▁. ▁Sub process ▁sub process ▁= ▁Sub process Util ▁. ▁java ▁( ▁configure ▁( ▁getV m Args ▁( ▁) ▁, ▁additional V m Options ▁) ▁, ▁STR ▁, ▁String ▁. ▁format ▁( ▁STR ▁, ▁Trace Compilation Test ▁. ▁class ▁. ▁getName ▁( ▁) ▁, ▁testName ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁String ▁. ▁join ▁( ▁STR ▁, ▁sub process ▁. ▁output ▁) ▁, ▁0 ▁, ▁sub process ▁. ▁exitCode ▁) ▁; ▁} ▁private ▁static ▁List ▁< ▁String ▁> ▁configure ▁( ▁List ▁< ▁String ▁> ▁vm Args ▁, ▁String ▁... ▁additional V m Options ▁) ▁{ ▁List ▁< ▁String ▁> ▁new V m Args ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁new V m Args ▁. ▁addAll ▁( ▁vm Args ▁. ▁stream ▁( ▁) ▁. ▁filter ▁( ▁new ▁Predicate ▁< ▁String ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁boolean ▁test ▁( ▁String ▁vm Arg ▁) ▁{ ▁return ▁! ▁vm Arg ▁. ▁contains ▁( ▁STR ▁) ▁&& ▁! ▁vm Arg ▁. ▁contains ▁( ▁STR ▁) ▁&& ▁! ▁vm Arg ▁. ▁contains ▁( ▁STR ▁) ▁&& ▁! ▁vm Arg ▁. ▁contains ▁( ▁STR ▁) ▁&& ▁! ▁vm Arg ▁. ▁contains ▁( ▁STR ▁) ▁; ▁} ▁} ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toList ▁( ▁) ▁) ▁) ▁; ▁for ▁( ▁String ▁additional V m Option ▁: ▁additional V m Options ▁) ▁{ ▁new V m Args ▁. ▁add ▁( ▁1 ▁, ▁additional V m Option ▁) ▁; ▁} ▁new V m Args ▁. ▁add ▁( ▁1 ▁, ▁String ▁. ▁format ▁( ▁STR ▁, ▁CONFIG URE D _ PROPERTY ▁) ▁) ▁; ▁return ▁new V m Args ▁; ▁} ▁private ▁static ▁List ▁< ▁String ▁> ▁getV m Args ▁( ▁) ▁{ ▁List ▁< ▁String ▁> ▁vm Args ▁= ▁Sub process Util ▁. ▁get VM CommandLine ▁( ▁) ▁; ▁vm Args ▁. ▁add ▁( ▁Sub process Util ▁. ▁PACKAGE _ OPEN ING _ OPTIONS ▁) ▁; ▁return ▁vm Args ▁; ▁} ▁private ▁void ▁test Helper ▁( ▁Supplier ▁< ▁RootNode ▁> ▁root Provider ▁, ▁Map ▁< ▁String ▁, ▁String ▁> ▁additional Options ▁, ▁List ▁< ▁String ▁> ▁expected ▁, ▁List ▁< ▁String ▁> ▁un expected ▁) ▁throws ▁Exception ▁{ ▁test Helper ▁( ▁root Provider ▁, ▁additional Options ▁, ▁expected ▁, ▁un expected ▁, ▁null ▁) ▁; ▁} ▁private ▁void ▁test Helper ▁( ▁Supplier ▁< ▁RootNode ▁> ▁root Provider ▁, ▁Map ▁< ▁String ▁, ▁String ▁> ▁additional Options ▁, ▁List ▁< ▁String ▁> ▁expected ▁, ▁List ▁< ▁String ▁> ▁un expected ▁, ▁Consumer ▁< ▁LogRecord ▁> ▁on Publish Action ▁) ▁throws ▁Exception ▁{ ▁Pattern ▁[ ▁] ▁expected Patterns ▁= ▁expected ▁. ▁stream ▁( ▁) ▁. ▁map ▁( ▁Trace Compilation Test ▁:: ▁to Pattern ▁) ▁. ▁toArray ▁( ▁( ▁len ▁) ▁-> ▁new ▁Pattern ▁[ ▁len ▁] ▁) ▁;
▁public ▁abstract ▁class ▁Mer ging Window Assigner ▁< ▁W ▁extends ▁Window ▁> ▁extends ▁Window Assigner ▁< ▁W ▁> ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁public ▁abstract ▁void ▁merge Windows ▁( ▁W ▁new Window ▁, ▁NavigableSet ▁< ▁W ▁> ▁sorted Windows ▁, ▁Merge Callback ▁< ▁W ▁> ▁callback ▁) ▁; ▁public ▁interface ▁Merge Callback ▁< ▁W ▁> ▁{ ▁void ▁merge ▁( ▁W ▁merge Result ▁, ▁Collection ▁< ▁W ▁> ▁toBe Merged ▁) ▁; ▁} ▁}
▁private ▁static ▁class ▁High Level Client ▁extends ▁Rest HighLevelClient ▁{ ▁private ▁High Level Client ▁( ▁RestClient ▁restClient ▁) ▁{ ▁super ▁( ▁restClient ▁, ▁( ▁client ▁) ▁-> ▁{ ▁} ▁, ▁new ▁SearchModule ▁( ▁Settings ▁. ▁EMPTY ▁, ▁Collections ▁. ▁emptyList ▁( ▁) ▁) ▁. ▁getNamed XContent s ▁( ▁) ▁) ▁; ▁} ▁} ▁protected ▁static ▁XContentBuilder ▁build Random XContent Pipeline ▁( ▁XContentBuilder ▁pipeline Builder ▁) ▁throws ▁IOException ▁{ ▁pipeline Builder ▁. ▁startObject ▁( ▁) ▁; ▁{ ▁pipeline Builder ▁. ▁field ▁( ▁Pipeline ▁. ▁DESCRIPTION _ KEY ▁, ▁STR ▁) ▁; ▁pipeline Builder ▁. ▁startArray ▁( ▁Pipeline ▁. ▁PROCESS OR S _ KEY ▁) ▁; ▁{ ▁pipeline Builder ▁. ▁startObject ▁( ▁) ▁. ▁startObject ▁( ▁STR ▁) ▁; ▁{ ▁pipeline Builder ▁. ▁field ▁( ▁STR ▁, ▁STR ▁) ▁. ▁field ▁( ▁STR ▁, ▁STR ▁) ▁; ▁} ▁pipeline Builder ▁. ▁endObject ▁( ▁) ▁. ▁endObject ▁( ▁) ▁; ▁pipeline Builder ▁. ▁startObject ▁( ▁) ▁. ▁startObject ▁( ▁STR ▁) ▁; ▁{ ▁pipeline Builder ▁. ▁field ▁( ▁STR ▁, ▁STR ▁) ▁. ▁field ▁( ▁STR ▁, ▁STR ▁) ▁; ▁} ▁pipeline Builder ▁. ▁endObject ▁( ▁) ▁. ▁endObject ▁( ▁) ▁; ▁} ▁pipeline Builder ▁. ▁endArray ▁( ▁) ▁; ▁} ▁pipeline Builder ▁. ▁endObject ▁( ▁) ▁; ▁return ▁pipeline Builder ▁; ▁} ▁protected ▁static ▁XContentBuilder ▁build Random XContent Pipeline ▁( ▁) ▁throws ▁IOException ▁{ ▁XContentType ▁xContentType ▁= ▁randomFrom ▁( ▁XContentType ▁. ▁values ▁( ▁) ▁) ▁; ▁XContentBuilder ▁pipeline Builder ▁= ▁XContentBuilder ▁. ▁builder ▁( ▁xContentType ▁. ▁xContent ▁( ▁) ▁) ▁; ▁return ▁build Random XContent Pipeline ▁( ▁pipeline Builder ▁) ▁; ▁} ▁protected ▁static ▁void ▁create Field Add ing P iple ine ▁( ▁String ▁id ▁, ▁String ▁fieldName ▁, ▁String ▁value ▁) ▁throws ▁IOException ▁{ ▁XContentBuilder ▁pipeline ▁= ▁jsonBuilder ▁( ▁) ▁. ▁startObject ▁( ▁) ▁. ▁startArray ▁( ▁STR ▁) ▁. ▁startObject ▁( ▁) ▁. ▁startObject ▁( ▁STR ▁) ▁. ▁field ▁( ▁STR ▁, ▁fieldName ▁) ▁. ▁field ▁( ▁STR ▁, ▁value ▁) ▁. ▁endObject ▁( ▁) ▁. ▁endObject ▁( ▁) ▁. ▁endArray ▁( ▁) ▁. ▁endObject ▁( ▁) ▁; ▁create Pipeline ▁( ▁new ▁Put PipelineRequest ▁( ▁id ▁, ▁BytesReference ▁. ▁bytes ▁( ▁pipeline ▁) ▁, ▁XContentType ▁. ▁JSON ▁) ▁) ▁; ▁} ▁protected ▁static ▁void ▁create Pipeline ▁( ▁String ▁pipeline Id ▁) ▁throws ▁IOException ▁{ ▁XContentBuilder ▁builder ▁= ▁build Random XContent Pipeline ▁( ▁) ▁; ▁create Pipeline ▁( ▁new ▁Put PipelineRequest ▁( ▁pipeline Id ▁, ▁BytesReference ▁. ▁bytes ▁( ▁builder ▁) ▁, ▁builder ▁. ▁contentType ▁( ▁) ▁) ▁) ▁; ▁} ▁protected ▁static ▁void ▁create Pipeline ▁( ▁Put PipelineRequest ▁put PipelineRequest ▁) ▁throws ▁IOException ▁{ ▁assertTrue ▁( ▁execute ▁( ▁put PipelineRequest ▁, ▁high Level Client ▁( ▁) ▁. ▁ingest ▁( ▁) ▁:: ▁put Pipeline ▁, ▁high Level Client ▁( ▁) ▁. ▁ingest ▁( ▁) ▁:: ▁put Pipeline Async ▁) ▁. ▁isA cknowledged ▁( ▁) ▁) ▁; ▁} ▁protected ▁static ▁void ▁cluster UpdateSettings ▁( ▁Settings ▁persistent Settings ▁, ▁Settings ▁transient Settings ▁) ▁throws ▁IOException ▁{ ▁Cluster UpdateSettings Request ▁request ▁= ▁new ▁Cluster UpdateSettings Request ▁( ▁) ▁; ▁request ▁. ▁persistent Settings ▁( ▁persistent Settings ▁) ▁;
▁public ▁class ▁Feature Utils Tests ▁extends ▁ESTestCase ▁{ ▁public ▁void ▁test Valid UTF 8 Length ▁( ▁) ▁{ ▁{ ▁String ▁str A Z ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁; ▁String ▁tr uncated ▁= ▁Feature Utils ▁. ▁truncate To Num Valid Bytes ▁( ▁str A Z ▁, ▁200 ▁) ▁; ▁assertThat ▁( ▁tr uncated ▁, ▁equalTo ▁( ▁str A Z ▁) ▁) ▁; ▁} ▁{ ▁String ▁str BE ▁= ▁STR ▁+ ▁STR ▁; ▁String ▁tr uncated ▁= ▁Feature Utils ▁. ▁truncate To Num Valid Bytes ▁( ▁str BE ▁, ▁200 ▁) ▁; ▁assertThat ▁( ▁tr uncated ▁, ▁equalTo ▁( ▁STR ▁+ ▁STR ▁) ▁) ▁; ▁} ▁{ ▁String ▁str AR ▁= ▁STR ▁; ▁String ▁tr uncated ▁= ▁Feature Utils ▁. ▁truncate To Num Valid Bytes ▁( ▁str AR ▁, ▁200 ▁) ▁; ▁assertThat ▁( ▁tr uncated ▁, ▁equalTo ▁( ▁str AR ▁) ▁) ▁; ▁} ▁{ ▁String ▁str Z H ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁; ▁String ▁tr uncated ▁= ▁Feature Utils ▁. ▁truncate To Num Valid Bytes ▁( ▁str Z H ▁, ▁200 ▁) ▁; ▁assertThat ▁( ▁tr uncated ▁, ▁equalTo ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁) ▁; ▁} ▁} ▁public ▁void ▁test Clean Text ▁( ▁) ▁{ ▁assertThat ▁( ▁Feature Utils ▁. ▁clean And Lower Text ▁( ▁STR ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁Feature Utils ▁. ▁clean And Lower Text ▁( ▁STR ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁Feature Utils ▁. ▁clean And Lower Text ▁( ▁STR ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁Feature Utils ▁. ▁clean And Lower Text ▁( ▁STR ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁Feature Utils ▁. ▁clean And Lower Text ▁( ▁STR ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁Feature Utils ▁. ▁clean And Lower Text ▁( ▁STR ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁Feature Utils ▁. ▁clean And Lower Text ▁( ▁STR ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁; ▁} ▁}
▁public ▁static ▁Type ▁resolve Type ▁( ▁Type ▁generic Type ▁, ▁@ ▁Nullable ▁Class ▁< ▁? ▁> ▁context Class ▁) ▁{ ▁if ▁( ▁context Class ▁!= ▁null ▁) ▁{ ▁if ▁( ▁generic Type ▁instanceof ▁Type Variable ▁) ▁{ ▁ResolvableType ▁resolved Type Variable ▁= ▁resolve Variable ▁( ▁( ▁Type Variable ▁< ▁? ▁> ▁) ▁generic Type ▁, ▁ResolvableType ▁. ▁forClass ▁( ▁context Class ▁) ▁) ▁; ▁if ▁( ▁resolved Type Variable ▁!= ▁ResolvableType ▁. ▁NONE ▁) ▁{ ▁Class ▁< ▁? ▁> ▁resolved ▁= ▁resolved Type Variable ▁. ▁resolve ▁( ▁) ▁; ▁if ▁( ▁resolved ▁!= ▁null ▁) ▁{ ▁return ▁resolved ▁; ▁} ▁} ▁} ▁else ▁if ▁( ▁generic Type ▁instanceof ▁Parameterized Type ▁) ▁{ ▁ResolvableType ▁resolved Type ▁= ▁ResolvableType ▁. ▁for Type ▁( ▁generic Type ▁) ▁; ▁if ▁( ▁resolved Type ▁. ▁has Un resol vable Gener ics ▁( ▁) ▁) ▁{ ▁Parameterized Type ▁parameter ized Type ▁= ▁( ▁Parameterized Type ▁) ▁generic Type ▁; ▁Class ▁< ▁? ▁> ▁[ ▁] ▁gener ics ▁= ▁new ▁Class ▁< ▁? ▁> ▁[ ▁parameter ized Type ▁. ▁getActual TypeArguments ▁( ▁) ▁. ▁length ▁] ▁; ▁Type ▁[ ▁] ▁type Arguments ▁= ▁parameter ized Type ▁. ▁getActual TypeArguments ▁( ▁) ▁; ▁ResolvableType ▁context Type ▁= ▁ResolvableType ▁. ▁forClass ▁( ▁context Class ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁type Arguments ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁Type ▁type Argument ▁= ▁type Arguments ▁[ ▁i ▁] ▁; ▁if ▁( ▁type Argument ▁instanceof ▁Type Variable ▁) ▁{ ▁ResolvableType ▁resolved Type Argument ▁= ▁resolve Variable ▁( ▁( ▁Type Variable ▁< ▁? ▁> ▁) ▁type Argument ▁, ▁context Type ▁) ▁; ▁if ▁( ▁resolved Type Argument ▁!= ▁ResolvableType ▁. ▁NONE ▁) ▁{ ▁gener ics ▁[ ▁i ▁] ▁= ▁resolved Type Argument ▁. ▁resolve ▁( ▁) ▁; ▁} ▁else ▁{ ▁gener ics ▁[ ▁i ▁] ▁= ▁ResolvableType ▁. ▁for Type ▁( ▁type Argument ▁) ▁. ▁resolve ▁( ▁) ▁; ▁} ▁} ▁else ▁{ ▁gener ics ▁[ ▁i ▁] ▁= ▁ResolvableType ▁. ▁for Type ▁( ▁type Argument ▁) ▁. ▁resolve ▁( ▁) ▁; ▁} ▁} ▁Class ▁< ▁? ▁> ▁raw Class ▁= ▁resolved Type ▁. ▁getRaw Class ▁( ▁) ▁; ▁if ▁( ▁raw Class ▁!= ▁null ▁) ▁{ ▁return ▁ResolvableType ▁. ▁forClass With Gener ics ▁( ▁raw Class ▁, ▁gener ics ▁) ▁. ▁getType ▁( ▁) ▁; ▁} ▁} ▁} ▁} ▁return ▁generic Type ▁; ▁} ▁private ▁static ▁ResolvableType ▁resolve Variable ▁( ▁Type Variable ▁< ▁? ▁> ▁type Variable ▁, ▁ResolvableType ▁context Type ▁) ▁{ ▁ResolvableType ▁resolved Type ▁; ▁if ▁( ▁context Type ▁. ▁has Gener ics ▁( ▁) ▁) ▁{ ▁resolved Type ▁= ▁ResolvableType ▁. ▁for Type ▁( ▁type Variable ▁, ▁context Type ▁) ▁; ▁if ▁( ▁resolved Type ▁. ▁resolve ▁( ▁) ▁!= ▁null ▁) ▁{ ▁return ▁resolved Type ▁; ▁} ▁} ▁ResolvableType ▁super Type ▁= ▁context Type ▁. ▁getSuper Type ▁( ▁) ▁; ▁if ▁( ▁super Type ▁!= ▁ResolvableType ▁. ▁NONE ▁) ▁{ ▁resolved Type ▁= ▁resolve Variable ▁( ▁type Variable ▁, ▁super Type ▁) ▁; ▁if ▁( ▁resolved Type ▁. ▁resolve ▁( ▁) ▁!= ▁null ▁) ▁{ ▁return ▁resolved Type ▁; ▁} ▁}
▁@ ▁GwtCompatible ▁@ ▁Ignore ▁public ▁class ▁Map Replace Tester ▁< ▁K ▁, ▁V ▁> ▁extends ▁AbstractMap Tester ▁< ▁K ▁, ▁V ▁> ▁{ ▁@ ▁MapFeature ▁. ▁Require ▁( ▁SUPPORTS _ PUT ▁) ▁@ ▁CollectionSize ▁. ▁Require ▁( ▁absent ▁= ▁ Z ERO ▁) ▁public ▁void ▁test Replace _ supported Present ▁( ▁) ▁{ ▁try ▁{ ▁assertEquals ▁( ▁v 0 ▁( ▁) ▁, ▁getMap ▁( ▁) ▁. ▁replace ▁( ▁k 0 ▁( ▁) ▁, ▁v 3 ▁( ▁) ▁) ▁) ▁; ▁expect Replacement ▁( ▁entry ▁( ▁k 0 ▁( ▁) ▁, ▁v 3 ▁( ▁) ▁) ▁) ▁; ▁} ▁catch ▁( ▁Class CastException ▁toler ated ▁) ▁{ ▁expectUnchanged ▁( ▁) ▁; ▁} ▁} ▁@ ▁MapFeature ▁. ▁Require ▁( ▁SUPPORTS _ PUT ▁) ▁@ ▁CollectionSize ▁. ▁Require ▁( ▁absent ▁= ▁ Z ERO ▁) ▁public ▁void ▁test Replace _ supported Present No Change ▁( ▁) ▁{ ▁assertEquals ▁( ▁v 0 ▁( ▁) ▁, ▁getMap ▁( ▁) ▁. ▁replace ▁( ▁k 0 ▁( ▁) ▁, ▁v 0 ▁( ▁) ▁) ▁) ▁; ▁expectUnchanged ▁( ▁) ▁; ▁} ▁@ ▁MapFeature ▁. ▁Require ▁( ▁SUPPORTS _ PUT ▁) ▁public ▁void ▁test Replace _ supported Absent ▁( ▁) ▁{ ▁assertNull ▁( ▁getMap ▁( ▁) ▁. ▁replace ▁( ▁k 3 ▁( ▁) ▁, ▁v 3 ▁( ▁) ▁) ▁) ▁; ▁expectUnchanged ▁( ▁) ▁; ▁} ▁@ ▁MapFeature ▁. ▁Require ▁( ▁value ▁= ▁SUPPORTS _ PUT ▁, ▁absent ▁= ▁ALLOWS _ NULL _ VALUES ▁) ▁@ ▁CollectionSize ▁. ▁Require ▁( ▁absent ▁= ▁ Z ERO ▁) ▁public ▁void ▁test Replace _ present NullValue Unsupported ▁( ▁) ▁{ ▁try ▁{ ▁getMap ▁( ▁) ▁. ▁replace ▁( ▁k 0 ▁( ▁) ▁, ▁null ▁) ▁; ▁fail ▁( ▁STR ▁) ▁; ▁} ▁catch ▁( ▁NullPointer Exception ▁expected ▁) ▁{ ▁} ▁expectUnchanged ▁( ▁) ▁; ▁} ▁@ ▁MapFeature ▁. ▁Require ▁( ▁value ▁= ▁SUPPORTS _ PUT ▁, ▁absent ▁= ▁ALLOWS _ NULL _ VALUE _ QUERIES ▁) ▁public ▁void ▁test Replace _ ab sent NullValue Unsupported ▁( ▁) ▁{ ▁try ▁{ ▁getMap ▁( ▁) ▁. ▁replace ▁( ▁k 3 ▁( ▁) ▁, ▁null ▁) ▁; ▁} ▁catch ▁( ▁NullPointer Exception ▁toler ated ▁) ▁{ ▁} ▁expectUnchanged ▁( ▁) ▁; ▁} ▁@ ▁MapFeature ▁. ▁Require ▁( ▁value ▁= ▁SUPPORTS _ PUT ▁, ▁absent ▁= ▁ALLOWS _ NULL _ KEY _ QUERIES ▁) ▁public ▁void ▁test Replace _ ab sent Null Key Unsupported ▁( ▁) ▁{ ▁try ▁{ ▁getMap ▁( ▁) ▁. ▁replace ▁( ▁null ▁, ▁v 3 ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁NullPointer Exception ▁toler ated ▁) ▁{ ▁} ▁expectUnchanged ▁( ▁) ▁; ▁} ▁@ ▁MapFeature ▁. ▁Require ▁( ▁absent ▁= ▁SUPPORTS _ PUT ▁) ▁@ ▁CollectionSize ▁. ▁Require ▁( ▁absent ▁= ▁ Z ERO ▁) ▁public ▁void ▁test Replace _ un supported Present ▁( ▁) ▁{ ▁try ▁{ ▁getMap ▁( ▁) ▁. ▁replace ▁( ▁k 0 ▁( ▁) ▁, ▁v 3 ▁( ▁) ▁) ▁; ▁fail ▁( ▁STR ▁) ▁; ▁} ▁catch ▁( ▁Unsupported Operation Exception ▁expected ▁) ▁{ ▁} ▁catch ▁( ▁Class CastException ▁toler ated ▁) ▁{ ▁} ▁expectUnchanged ▁( ▁) ▁; ▁} ▁}
▁for ▁( ▁Null Writable ▁ignored ▁: ▁context ▁. ▁getValues ▁( ▁) ▁) ▁{ ▁final ▁G ri dm ix Key ▁spec ▁= ▁context ▁. ▁getCurrent Key ▁( ▁) ▁; ▁duration ▁+= ▁spec ▁. ▁getRe duce Output Bytes ▁( ▁) ▁; ▁} ▁long ▁sleep Interval ▁= ▁context ▁. ▁get Configuration ▁( ▁) ▁. ▁getLong ▁( ▁GR ID MI X _ S LE EP _ INTERVAL ▁, ▁5 ▁) ▁; ▁final ▁long ▁R INTERVAL ▁= ▁TimeUnit ▁. ▁MILLISECONDS ▁. ▁convert ▁( ▁sleep Interval ▁, ▁TimeUnit ▁. ▁SECONDS ▁) ▁; ▁long ▁start ▁= ▁Time ▁. ▁monotonic Now ▁( ▁) ▁; ▁long ▁s le pt ▁= ▁0 L ▁; ▁long ▁sleep ▁= ▁0 L ▁; ▁while ▁( ▁s le pt ▁< ▁duration ▁) ▁{ ▁final ▁long ▁rem ▁= ▁duration ▁- ▁s le pt ▁; ▁sleep ▁= ▁Math ▁. ▁min ▁( ▁rem ▁, ▁R INTERVAL ▁) ▁; ▁context ▁. ▁setStatus ▁( ▁STR ▁+ ▁rem ▁+ ▁STR ▁) ▁; ▁TimeUnit ▁. ▁MILLISECONDS ▁. ▁sleep ▁( ▁sleep ▁) ▁; ▁s le pt ▁= ▁Time ▁. ▁monotonic Now ▁( ▁) ▁- ▁start ▁; ▁} ▁} ▁@ ▁Override ▁protected ▁void ▁cleanup ▁( ▁Context ▁context ▁) ▁throws ▁IOException ▁, ▁Interrupted Exception ▁{ ▁final ▁String ▁msg ▁= ▁STR ▁+ ▁duration ▁; ▁LOG ▁. ▁info ▁( ▁msg ▁) ▁; ▁context ▁. ▁setStatus ▁( ▁msg ▁) ▁; ▁} ▁} ▁public ▁static ▁class ▁S leep InputFormat ▁extends ▁InputFormat ▁< ▁LongWritable ▁, ▁LongWritable ▁> ▁{ ▁@ ▁Override ▁public ▁List ▁< ▁InputSplit ▁> ▁getSplit s ▁( ▁JobContext ▁job C t xt ▁) ▁throws ▁IOException ▁{ ▁return ▁pull Description ▁( ▁job C t xt ▁) ▁; ▁} ▁@ ▁Override ▁public ▁RecordReader ▁< ▁LongWritable ▁, ▁LongWritable ▁> ▁create RecordReader ▁( ▁InputSplit ▁split ▁, ▁final ▁TaskAttempt Context ▁context ▁) ▁throws ▁IOException ▁, ▁Interrupted Exception ▁{ ▁final ▁long ▁duration ▁= ▁split ▁. ▁getLength ▁( ▁) ▁; ▁long ▁sleep Interval ▁= ▁context ▁. ▁get Configuration ▁( ▁) ▁. ▁getLong ▁( ▁GR ID MI X _ S LE EP _ INTERVAL ▁, ▁5 ▁) ▁; ▁final ▁long ▁R INTERVAL ▁= ▁TimeUnit ▁. ▁MILLISECONDS ▁. ▁convert ▁( ▁sleep Interval ▁, ▁TimeUnit ▁. ▁SECONDS ▁) ▁; ▁if ▁( ▁R INTERVAL ▁<= ▁0 ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁STR ▁+ ▁GR ID MI X _ S LE EP _ INTERVAL ▁+ ▁STR ▁+ ▁R INTERVAL ▁) ▁; ▁} ▁return ▁new ▁RecordReader ▁< ▁LongWritable ▁, ▁LongWritable ▁> ▁( ▁) ▁{ ▁long ▁start ▁= ▁- ▁1 ▁; ▁long ▁s le pt ▁= ▁0 L ▁; ▁long ▁sleep ▁= ▁0 L ▁; ▁final ▁LongWritable ▁key ▁= ▁new ▁LongWritable ▁( ▁) ▁; ▁final ▁LongWritable ▁val ▁= ▁new ▁LongWritable ▁( ▁) ▁; ▁@ ▁Override ▁public ▁boolean ▁next KeyValue ▁( ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁start ▁== ▁- ▁1 ▁) ▁{ ▁start ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁; ▁} ▁s le pt ▁+= ▁sleep ▁; ▁sleep ▁= ▁Math ▁. ▁min ▁( ▁duration ▁- ▁s le pt ▁, ▁R INTERVAL ▁) ▁; ▁key ▁. ▁set ▁( ▁s le pt ▁+ ▁sleep ▁+ ▁start ▁) ▁; ▁val ▁. ▁set ▁( ▁duration ▁- ▁s le pt ▁) ▁; ▁return ▁s le pt ▁< ▁duration ▁; ▁}
▁public ▁class ▁Annotation Substitution Type ▁extends ▁Custom Substitution Type ▁< ▁Annotation Substitution Field ▁, ▁Annotation Substitution Method ▁> ▁{ ▁private ▁final ▁String ▁name ▁; ▁private ▁final ▁Meta AccessProvider ▁metaAccess ▁; ▁public ▁Annotation Substitution Type ▁( ▁Meta AccessProvider ▁metaAccess ▁, ▁ResolvedJava Type ▁original ▁) ▁{ ▁super ▁( ▁original ▁) ▁; ▁this ▁. ▁metaAccess ▁= ▁metaAccess ▁; ▁assert ▁original ▁. ▁getSuperclass ▁( ▁) ▁. ▁equals ▁( ▁metaAccess ▁. ▁lookupJavaType ▁( ▁Proxy ▁. ▁class ▁) ▁) ▁; ▁assert ▁metaAccess ▁. ▁lookupJavaType ▁( ▁Annotation ▁. ▁class ▁) ▁. ▁isAssignable From ▁( ▁original ▁) ▁; ▁ResolvedJava Type ▁annotation Interface Type ▁= ▁Annotation Support ▁. ▁find Annotation Interface Type For Mark ed Annotation Type ▁( ▁original ▁, ▁metaAccess ▁) ▁; ▁assert ▁annotation Interface Type ▁. ▁isAssignable From ▁( ▁original ▁) ▁; ▁assert ▁metaAccess ▁. ▁lookupJavaType ▁( ▁Annotation ▁. ▁class ▁) ▁. ▁isAssignable From ▁( ▁annotation Interface Type ▁) ▁; ▁String ▁n ▁= ▁annotation Interface Type ▁. ▁getName ▁( ▁) ▁; ▁assert ▁n ▁. ▁endsWith ▁( ▁STR ▁) ▁; ▁name ▁= ▁n ▁. ▁substring ▁( ▁0 ▁, ▁n ▁. ▁length ▁( ▁) ▁- ▁1 ▁) ▁+ ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁ResolvedJava Type ▁[ ▁] ▁get Interfaces ▁( ▁) ▁{ ▁ResolvedJava Type ▁[ ▁] ▁interfaces ▁= ▁super ▁. ▁get Interfaces ▁( ▁) ▁; ▁return ▁Arrays ▁. ▁stream ▁( ▁interfaces ▁) ▁. ▁filter ▁( ▁( ▁t ▁) ▁-> ▁! ▁Annotation Support ▁. ▁isAnnotation Marker Interface ▁( ▁t ▁, ▁metaAccess ▁) ▁) ▁. ▁toArray ▁( ▁ResolvedJava Type ▁[ ▁] ▁:: ▁new ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁name ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁toJava Name ▁( ▁true ▁) ▁+ ▁STR ▁+ ▁original ▁+ ▁STR ▁; ▁} ▁}
▁public ▁class ▁Det ailed Memory MetricSnapshot ▁{ ▁private ▁final ▁double ▁new Gen Usage ▁; ▁private ▁final ▁double ▁old Gen Usage ▁; ▁private ▁final ▁double ▁surv iv or Space Usage ▁; ▁private ▁final ▁double ▁code Cache Usage ▁; ▁private ▁final ▁double ▁perm Gen Usage ▁; ▁private ▁final ▁double ▁met as pace Usage ▁; ▁Det ailed Memory MetricSnapshot ▁( ▁double ▁ed en Space MemoryUsage ▁, ▁double ▁old Space MemoryUsage ▁, ▁double ▁surv iv or Space MemoryUsage ▁, ▁double ▁code Cache MemoryUsage ▁, ▁double ▁perm Gen MemoryUsage ▁, ▁double ▁met as pace MemoryUsage ▁) ▁{ ▁this ▁. ▁new Gen Usage ▁= ▁ed en Space MemoryUsage ▁; ▁this ▁. ▁old Gen Usage ▁= ▁old Space MemoryUsage ▁; ▁this ▁. ▁surv iv or Space Usage ▁= ▁surv iv or Space MemoryUsage ▁; ▁this ▁. ▁code Cache Usage ▁= ▁code Cache MemoryUsage ▁; ▁this ▁. ▁perm Gen Usage ▁= ▁perm Gen MemoryUsage ▁; ▁this ▁. ▁met as pace Usage ▁= ▁met as pace MemoryUsage ▁; ▁} ▁public ▁double ▁getNew Gen Usage ▁( ▁) ▁{ ▁return ▁new Gen Usage ▁; ▁} ▁public ▁double ▁getOld Gen Usage ▁( ▁) ▁{ ▁return ▁old Gen Usage ▁; ▁} ▁public ▁double ▁getCode Cache Usage ▁( ▁) ▁{ ▁return ▁code Cache Usage ▁; ▁} ▁public ▁double ▁getS urv iv or Space Usage ▁( ▁) ▁{ ▁return ▁surv iv or Space Usage ▁; ▁} ▁public ▁double ▁getPerm Gen Usage ▁( ▁) ▁{ ▁return ▁perm Gen Usage ▁; ▁} ▁public ▁double ▁get Metas pace Usage ▁( ▁) ▁{ ▁return ▁met as pace Usage ▁; ▁} ▁}
▁@ ▁Nullable ▁public ▁String ▁getSort ▁( ▁) ▁{ ▁return ▁sort ▁; ▁} ▁public ▁void ▁set Sort ▁( ▁String ▁sort ▁) ▁{ ▁this ▁. ▁sort ▁= ▁sort ▁; ▁} ▁public ▁boolean ▁get Desc Order ▁( ▁) ▁{ ▁return ▁desc ▁; ▁} ▁public ▁void ▁set Desc Order ▁( ▁boolean ▁desc ▁) ▁{ ▁this ▁. ▁desc ▁= ▁desc ▁; ▁} ▁public ▁PageParams ▁getPage Params ▁( ▁) ▁{ ▁return ▁page Params ▁; ▁} ▁public ▁void ▁setPage Params ▁( ▁PageParams ▁page Params ▁) ▁{ ▁this ▁. ▁page Params ▁= ▁Exceptions Helper ▁. ▁requireNonNull ▁( ▁page Params ▁, ▁PageParams ▁. ▁PAGE ▁. ▁getPreferred Name ▁( ▁) ▁) ▁; ▁} ▁@ ▁Nullable ▁public ▁String ▁getStart ▁( ▁) ▁{ ▁return ▁start ▁; ▁} ▁public ▁void ▁setStart ▁( ▁String ▁start ▁) ▁{ ▁this ▁. ▁start ▁= ▁Exceptions Helper ▁. ▁requireNonNull ▁( ▁start ▁, ▁START ▁. ▁getPreferred Name ▁( ▁) ▁) ▁; ▁} ▁@ ▁Nullable ▁public ▁String ▁getEnd ▁( ▁) ▁{ ▁return ▁end ▁; ▁} ▁public ▁void ▁setEnd ▁( ▁String ▁end ▁) ▁{ ▁this ▁. ▁end ▁= ▁Exceptions Helper ▁. ▁requireNonNull ▁( ▁end ▁, ▁END ▁. ▁getPreferred Name ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁ActionRequest Valid ationException ▁validate ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁void ▁writeTo ▁( ▁StreamOutput ▁out ▁) ▁throws ▁IOException ▁{ ▁super ▁. ▁writeTo ▁( ▁out ▁) ▁; ▁out ▁. ▁writeString ▁( ▁jobId ▁) ▁; ▁out ▁. ▁write OptionalString ▁( ▁snapshotId ▁) ▁; ▁out ▁. ▁write OptionalString ▁( ▁sort ▁) ▁; ▁out ▁. ▁write OptionalString ▁( ▁start ▁) ▁; ▁out ▁. ▁write OptionalString ▁( ▁end ▁) ▁; ▁out ▁. ▁writeBoolean ▁( ▁desc ▁) ▁; ▁page Params ▁. ▁writeTo ▁( ▁out ▁) ▁; ▁} ▁@ ▁Override ▁public ▁XContentBuilder ▁toXContent ▁( ▁XContentBuilder ▁builder ▁, ▁Params ▁params ▁) ▁throws ▁IOException ▁{ ▁builder ▁. ▁startObject ▁( ▁) ▁; ▁builder ▁. ▁field ▁( ▁Job ▁. ▁ID ▁. ▁getPreferred Name ▁( ▁) ▁, ▁jobId ▁) ▁; ▁if ▁( ▁snapshotId ▁!= ▁null ▁) ▁{ ▁builder ▁. ▁field ▁( ▁SNAPSHOT _ ID ▁. ▁getPreferred Name ▁( ▁) ▁, ▁snapshotId ▁) ▁; ▁} ▁if ▁( ▁start ▁!= ▁null ▁) ▁{ ▁builder ▁. ▁field ▁( ▁START ▁. ▁getPreferred Name ▁( ▁) ▁, ▁start ▁) ▁; ▁} ▁if ▁( ▁end ▁!= ▁null ▁) ▁{ ▁builder ▁. ▁field ▁( ▁END ▁. ▁getPreferred Name ▁( ▁) ▁, ▁end ▁) ▁; ▁} ▁if ▁( ▁sort ▁!= ▁null ▁) ▁{ ▁builder ▁. ▁field ▁( ▁S ORT ▁. ▁getPreferred Name ▁( ▁) ▁, ▁sort ▁) ▁; ▁} ▁builder ▁. ▁field ▁( ▁DESC ▁. ▁getPreferred Name ▁( ▁) ▁, ▁desc ▁) ▁; ▁builder ▁. ▁field ▁( ▁PageParams ▁. ▁PAGE ▁. ▁getPreferred Name ▁( ▁) ▁, ▁page Params ▁) ▁; ▁builder ▁. ▁endObject ▁( ▁) ▁; ▁return ▁builder ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁Objects ▁. ▁hash ▁( ▁jobId ▁, ▁snapshotId ▁, ▁start ▁, ▁end ▁, ▁sort ▁, ▁desc ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁obj ▁) ▁{ ▁if ▁( ▁obj ▁== ▁null ▁) ▁{ ▁return ▁false ▁; ▁} ▁if ▁( ▁getClass ▁( ▁) ▁!= ▁obj ▁. ▁getClass ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁}
▁public ▁class ▁Text Layout Graph ics ▁extends ▁Graphics 2 D ▁{ ▁private ▁int ▁trans X ▁; ▁private ▁int ▁trans Y ▁; ▁private ▁Shape ▁clip ▁; ▁private ▁StringBuilder ▁buffer ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁private ▁Font ▁last Font ▁= ▁new ▁Font ▁( ▁STR ▁, ▁Font ▁. ▁PLA IN ▁, ▁12 ▁) ▁; ▁private ▁Font Metrics ▁font Metrics ▁= ▁create Font Metrics ▁( ▁last Font ▁) ▁; ▁private ▁List ▁< ▁Text Info ▁> ▁text Infos ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁private ▁Comparator ▁< ▁Text Info ▁> ▁point Comparator ▁= ▁( ▁o 1 ▁, ▁o 2 ▁) ▁-> ▁{ ▁Text Info ▁t 1 ▁= ▁o 1 ▁; ▁Text Info ▁t 2 ▁= ▁o 2 ▁; ▁int ▁diff ▁= ▁t 1 ▁. ▁point ▁. ▁y ▁- ▁t 2 ▁. ▁point ▁. ▁y ▁; ▁if ▁( ▁diff ▁!= ▁0 ▁) ▁{ ▁return ▁diff ▁; ▁} ▁diff ▁= ▁t 1 ▁. ▁point ▁. ▁x ▁- ▁t 2 ▁. ▁point ▁. ▁x ▁; ▁return ▁diff ▁; ▁} ▁; ▁private ▁Comparator ▁< ▁Text Info ▁> ▁row Comparator ▁= ▁( ▁o 1 ▁, ▁o 2 ▁) ▁-> ▁{ ▁Text Info ▁t 1 ▁= ▁o 1 ▁; ▁Text Info ▁t 2 ▁= ▁o 2 ▁; ▁int ▁diff ▁= ▁t 1 ▁. ▁row ▁- ▁t 2 ▁. ▁row ▁; ▁if ▁( ▁diff ▁!= ▁0 ▁) ▁{ ▁return ▁diff ▁; ▁} ▁diff ▁= ▁t 1 ▁. ▁point ▁. ▁x ▁- ▁t 2 ▁. ▁point ▁. ▁x ▁; ▁return ▁diff ▁; ▁} ▁; ▁private ▁static ▁Font Metrics ▁create Font Metrics ▁( ▁Font ▁font ▁) ▁{ ▁BufferedImage ▁image ▁= ▁new ▁BufferedImage ▁( ▁1 ▁, ▁1 ▁, ▁BufferedImage ▁. ▁TYPE _ INT _ ARG B _ PRE ▁) ▁; ▁Graphics ▁g ▁= ▁image ▁. ▁getGraph ics ▁( ▁) ▁; ▁Font Metrics ▁fm ▁= ▁g ▁. ▁getFont Metrics ▁( ▁font ▁) ▁; ▁g ▁. ▁dispose ▁( ▁) ▁; ▁return ▁fm ▁; ▁} ▁@ ▁Override ▁public ▁void ▁draw String ▁( ▁String ▁str ▁, ▁float ▁x ▁, ▁float ▁y ▁) ▁{ ▁draw String ▁( ▁str ▁, ▁( ▁int ▁) ▁x ▁, ▁( ▁int ▁) ▁y ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁draw String ▁( ▁Attributed Character Iterator ▁iterator ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁draw String ▁( ▁iterator ▁. ▁toString ▁( ▁) ▁, ▁x ▁, ▁y ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁draw String ▁( ▁Attributed Character Iterator ▁iterator ▁, ▁float ▁x ▁, ▁float ▁y ▁) ▁{ ▁draw String ▁( ▁iterator ▁. ▁toString ▁( ▁) ▁, ▁( ▁int ▁) ▁x ▁, ▁( ▁int ▁) ▁y ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁draw String ▁( ▁String ▁str ▁, ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁Text Info ▁new Text Info ▁= ▁new ▁Text Info ▁( ▁) ▁; ▁new Text Info ▁. ▁point ▁= ▁new ▁Point ▁( ▁x ▁+ ▁trans X ▁, ▁y ▁+ ▁trans Y ▁) ▁; ▁new Text Info ▁. ▁text ▁= ▁str ▁; ▁new Text Info ▁. ▁font ▁= ▁last Font ▁; ▁new Text Info ▁. ▁font Metrics ▁= ▁font Metrics ▁; ▁text Infos ▁. ▁add ▁( ▁new Text Info ▁) ▁; ▁}
▁Metadata Create Index Service ▁. ▁validate Split Index ▁( ▁clusterState ▁, ▁STR ▁, ▁STR ▁, ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁STR ▁, ▁target Shards ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁test Prepare Resize Index Settings ▁( ▁) ▁{ ▁final ▁List ▁< ▁Version ▁> ▁version s ▁= ▁Arrays ▁. ▁asList ▁( ▁Version Utils ▁. ▁random Version ▁( ▁random ▁( ▁) ▁) ▁, ▁Version Utils ▁. ▁random Version ▁( ▁random ▁( ▁) ▁) ▁) ▁; ▁version s ▁. ▁sort ▁( ▁Comparator ▁. ▁comparing Long ▁( ▁l ▁-> ▁l ▁. ▁id ▁) ▁) ▁; ▁final ▁Version ▁version ▁= ▁version s ▁. ▁get ▁( ▁0 ▁) ▁; ▁final ▁Version ▁up g ra ded ▁= ▁version s ▁. ▁get ▁( ▁1 ▁) ▁; ▁final ▁Settings ▁. ▁Builder ▁indexSettings Builder ▁= ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁STR ▁, ▁version ▁) ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁; ▁if ▁( ▁randomBoolean ▁( ▁) ▁) ▁{ ▁indexSettings Builder ▁. ▁put ▁( ▁STR ▁, ▁randomInt Between ▁( ▁1 ▁, ▁1000 ▁) ▁) ▁; ▁} ▁run Prepare Resize Index Settings Test ▁( ▁indexSettings Builder ▁. ▁build ▁( ▁) ▁, ▁Settings ▁. ▁EMPTY ▁, ▁Collections ▁. ▁emptyList ▁( ▁) ▁, ▁randomBoolean ▁( ▁) ▁, ▁settings ▁-> ▁{ ▁assertThat ▁( ▁STR ▁, ▁settings ▁. ▁get ▁( ▁STR ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁STR ▁, ▁settings ▁. ▁get ▁( ▁STR ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁settings ▁. ▁get ▁( ▁STR ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁settings ▁. ▁get ▁( ▁STR ▁) ▁, ▁nullValue ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁settings ▁. ▁getAs Version ▁( ▁STR ▁, ▁null ▁) ▁, ▁equalTo ▁( ▁version ▁) ▁) ▁; ▁assertThat ▁( ▁settings ▁. ▁get ▁( ▁STR ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁; ▁} ▁) ▁; ▁} ▁public ▁void ▁test Prepare Resize Index Settings Copy Settings ▁( ▁) ▁{ ▁final ▁int ▁max Merge Count ▁= ▁randomInt Between ▁( ▁1 ▁, ▁16 ▁) ▁; ▁final ▁int ▁max ThreadCount ▁= ▁randomInt Between ▁( ▁1 ▁, ▁16 ▁) ▁; ▁final ▁Setting ▁< ▁String ▁> ▁non Copy able Existing Index Setting ▁= ▁Setting ▁. ▁simple String ▁( ▁STR ▁, ▁Setting ▁. ▁Property ▁. ▁Index Scope ▁, ▁Setting ▁. ▁Property ▁. ▁Not Copy able On Resize ▁) ▁; ▁final ▁Setting ▁< ▁String ▁> ▁non Copy able Request Index Setting ▁= ▁Setting ▁. ▁simple String ▁( ▁STR ▁, ▁Setting ▁. ▁Property ▁. ▁Index Scope ▁, ▁Setting ▁. ▁Property ▁. ▁Not Copy able On Resize ▁) ▁;
▁@ ▁GwtCompatible ▁( ▁serializable ▁= ▁true ▁, ▁emulated ▁= ▁true ▁) ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁@ ▁ElementTypes AreNonnull ByDefault ▁final ▁class ▁Singleton Immutable Set ▁< ▁E ▁> ▁extends ▁ImmutableSet ▁< ▁E ▁> ▁{ ▁final ▁transient ▁E ▁element ▁; ▁@ ▁Lazy Init ▁private ▁transient ▁int ▁cached HashCode ▁; ▁Singleton Immutable Set ▁( ▁E ▁element ▁) ▁{ ▁this ▁. ▁element ▁= ▁Preconditions ▁. ▁checkNotNull ▁( ▁element ▁) ▁; ▁} ▁Singleton Immutable Set ▁( ▁E ▁element ▁, ▁int ▁hashCode ▁) ▁{ ▁this ▁. ▁element ▁= ▁element ▁; ▁cached HashCode ▁= ▁hashCode ▁; ▁} ▁@ ▁Override ▁public ▁int ▁size ▁( ▁) ▁{ ▁return ▁1 ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁contains ▁( ▁@ ▁CheckForNull ▁Object ▁target ▁) ▁{ ▁return ▁element ▁. ▁equals ▁( ▁target ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Unmodifiable Iterator ▁< ▁E ▁> ▁iterator ▁( ▁) ▁{ ▁return ▁Iterators ▁. ▁singleton Iterator ▁( ▁element ▁) ▁; ▁} ▁@ ▁Override ▁ImmutableList ▁< ▁E ▁> ▁create AsList ▁( ▁) ▁{ ▁return ▁ImmutableList ▁. ▁of ▁( ▁element ▁) ▁; ▁} ▁@ ▁Override ▁boolean ▁is Partial View ▁( ▁) ▁{ ▁return ▁false ▁; ▁} ▁@ ▁Override ▁int ▁copy Into Array ▁( ▁@ ▁Nullable ▁Object ▁[ ▁] ▁dst ▁, ▁int ▁offset ▁) ▁{ ▁dst ▁[ ▁offset ▁] ▁= ▁element ▁; ▁return ▁offset ▁+ ▁1 ▁; ▁} ▁@ ▁Override ▁public ▁final ▁int ▁hashCode ▁( ▁) ▁{ ▁int ▁code ▁= ▁cached HashCode ▁; ▁if ▁( ▁code ▁== ▁0 ▁) ▁{ ▁cached HashCode ▁= ▁code ▁= ▁element ▁. ▁hashCode ▁( ▁) ▁; ▁} ▁return ▁code ▁; ▁} ▁@ ▁Override ▁boolean ▁is HashCode Fast ▁( ▁) ▁{ ▁return ▁cached HashCode ▁!= ▁0 ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁CHAR ▁+ ▁element ▁. ▁toString ▁( ▁) ▁+ ▁CHAR ▁; ▁} ▁}
▁Set ▁< ▁K ▁> ▁key sTo Un map ▁= ▁spec ▁. ▁keys ▁. ▁stream ▁( ▁) ▁. ▁filter ▁( ▁future ▁. ▁lookup Keys ▁( ▁) ▁:: ▁contains ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toSet ▁( ▁) ▁) ▁; ▁retry Lookup ▁( ▁key sTo Un map ▁) ▁; ▁} ▁else ▁if ▁( ▁t ▁instanceof ▁No Batch ed Find Coordinator s Exception ▁) ▁{ ▁( ▁( ▁Coordinator Strategy ▁) ▁handler ▁. ▁lookup Strategy ▁( ▁) ▁) ▁. ▁disable Batch ▁( ▁) ▁; ▁Set ▁< ▁K ▁> ▁key sTo Un map ▁= ▁spec ▁. ▁keys ▁. ▁stream ▁( ▁) ▁. ▁filter ▁( ▁future ▁. ▁lookup Keys ▁( ▁) ▁:: ▁contains ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toSet ▁( ▁) ▁) ▁; ▁retry Lookup ▁( ▁key sTo Un map ▁) ▁; ▁} ▁else ▁{ ▁Map ▁< ▁K ▁, ▁Throwable ▁> ▁errors ▁= ▁spec ▁. ▁keys ▁. ▁stream ▁( ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toMap ▁( ▁Function ▁. ▁identity ▁( ▁) ▁, ▁key ▁-> ▁t ▁) ▁) ▁; ▁if ▁( ▁spec ▁. ▁scope ▁instanceof ▁F ul fill ment Scope ▁) ▁{ ▁complete Exceptionally ▁( ▁errors ▁) ▁; ▁} ▁else ▁{ ▁complete Lookup Exceptionally ▁( ▁errors ▁) ▁; ▁} ▁} ▁} ▁private ▁void ▁clear Inf light Request ▁( ▁long ▁current TimeMs ▁, ▁Request Spec ▁< ▁K ▁> ▁spec ▁) ▁{ ▁Request State ▁request State ▁= ▁request States ▁. ▁get ▁( ▁spec ▁. ▁scope ▁) ▁; ▁if ▁( ▁request State ▁!= ▁null ▁) ▁{ ▁if ▁( ▁spec ▁. ▁scope ▁instanceof ▁F ul fill ment Scope ▁) ▁{ ▁request State ▁. ▁clear Inf light ▁( ▁current TimeMs ▁+ ▁retry Backoff Ms ▁) ▁; ▁} ▁else ▁{ ▁request State ▁. ▁clear Inf light ▁( ▁current TimeMs ▁) ▁; ▁} ▁} ▁} ▁private ▁< ▁T ▁extends ▁Api Request Scope ▁> ▁void ▁collect Requests ▁( ▁List ▁< ▁Request Spec ▁< ▁K ▁> ▁> ▁requests ▁, ▁Bi Multimap ▁< ▁T ▁, ▁K ▁> ▁multimap ▁, ▁BiFunction ▁< ▁Set ▁< ▁K ▁> ▁, ▁T ▁, ▁AbstractRequest ▁. ▁Builder ▁< ▁? ▁> ▁> ▁build Request ▁) ▁{ ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁T ▁, ▁Set ▁< ▁K ▁> ▁> ▁entry ▁: ▁multimap ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁T ▁scope ▁= ▁entry ▁. ▁getKey ▁( ▁) ▁; ▁Set ▁< ▁K ▁> ▁keys ▁= ▁entry ▁. ▁getValue ▁( ▁) ▁; ▁if ▁( ▁keys ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁continue ▁; ▁} ▁Request State ▁request State ▁= ▁request States ▁. ▁computeIfAbsent ▁( ▁scope ▁, ▁c ▁-> ▁new ▁Request State ▁( ▁) ▁) ▁; ▁if ▁( ▁request State ▁. ▁has Inf light ▁( ▁) ▁) ▁{ ▁continue ▁; ▁} ▁Set ▁< ▁K ▁> ▁copy Keys ▁= ▁Collections ▁. ▁unmodifiableSet ▁( ▁new ▁HashSet ▁< ▁> ▁( ▁keys ▁) ▁) ▁; ▁AbstractRequest ▁. ▁Builder ▁< ▁? ▁> ▁request ▁= ▁build Request ▁. ▁apply ▁( ▁copy Keys ▁, ▁scope ▁) ▁;
▁final ▁class ▁Platform ▁{ ▁static ▁CharMatcher ▁pre compute Char Matcher ▁( ▁CharMatcher ▁matcher ▁) ▁{ ▁return ▁matcher ▁; ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁static ▁long ▁system Nano Time ▁( ▁) ▁{ ▁return ▁TimeUnit ▁. ▁MILLISECONDS ▁. ▁toNanos ▁( ▁System ▁. ▁current TimeMillis ▁( ▁) ▁) ▁; ▁} ▁static ▁< ▁T ▁extends ▁Enum ▁< ▁T ▁> ▁> ▁Optional ▁< ▁T ▁> ▁getEnum IfPresent ▁( ▁Class ▁< ▁T ▁> ▁enum Class ▁, ▁String ▁value ▁) ▁{ ▁try ▁{ ▁return ▁Optional ▁. ▁of ▁( ▁Enum ▁. ▁valueOf ▁( ▁enum Class ▁, ▁value ▁) ▁) ▁; ▁} ▁catch ▁( ▁IllegalArgument Exception ▁i ae ▁) ▁{ ▁return ▁Optional ▁. ▁absent ▁( ▁) ▁; ▁} ▁} ▁static ▁String ▁format Compact 4 Digits ▁( ▁double ▁value ▁) ▁{ ▁return ▁STR ▁+ ▁( ▁( ▁Number ▁) ▁( ▁Object ▁) ▁value ▁) ▁. ▁to Precision ▁( ▁4 ▁) ▁; ▁} ▁@ ▁J s Method ▁static ▁native ▁boolean ▁string IsNull OrEmpty ▁( ▁@ ▁Nullable ▁String ▁string ▁) ▁; ▁@ ▁J s Method ▁static ▁native ▁String ▁null To Empty ▁( ▁@ ▁Nullable ▁String ▁string ▁) ▁; ▁@ ▁J s Method ▁static ▁native ▁String ▁empty To Null ▁( ▁@ ▁Nullable ▁String ▁string ▁) ▁; ▁@ ▁J s Type ▁( ▁isNative ▁= ▁true ▁, ▁name ▁= ▁STR ▁, ▁namespace ▁= ▁GLOBAL ▁) ▁private ▁interface ▁Number ▁{ ▁double ▁to Precision ▁( ▁int ▁precision ▁) ▁; ▁} ▁static ▁Common Pattern ▁compile Pattern ▁( ▁String ▁pattern ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁static ▁boolean ▁pattern Compiler Is P cre Like ▁( ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁static ▁void ▁check G wt Rpc Enabled ▁( ▁) ▁{ ▁} ▁private ▁Platform ▁( ▁) ▁{ ▁} ▁}
▁public ▁float ▁getRe stit ution Dir An g ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Slider Constraint _ get Rest it ution Dir An g ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁float ▁getD amp ing Dir An g ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Slider Constraint _ get D amp ing Dir An g ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁float ▁getS oft ness L im L in ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Slider Constraint _ get Soft ness L im L in ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁float ▁getRe stit ution L im L in ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Slider Constraint _ get Rest it ution L im L in ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁float ▁getD amp ing L im L in ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Slider Constraint _ get D amp ing L im L in ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁float ▁getS oft ness L im An g ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Slider Constraint _ get Soft ness L im An g ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁float ▁getRe stit ution L im An g ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Slider Constraint _ get Rest it ution L im An g ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁float ▁getD amp ing L im An g ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Slider Constraint _ get D amp ing L im An g ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁float ▁getS oft ness Or th o L in ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Slider Constraint _ get Soft ness Or th o L in ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁float ▁getRe stit ution Or th o L in ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Slider Constraint _ get Rest it ution Or th o L in ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁float ▁getD amp ing Or th o L in ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Slider Constraint _ get D amp ing Or th o L in ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁float ▁getS oft ness Or th o An g ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Slider Constraint _ get Soft ness Or th o An g ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁float ▁getRe stit ution Or th o An g ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Slider Constraint _ get Rest it ution Or th o An g ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁float ▁getD amp ing Or th o An g ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Slider Constraint _ get D amp ing Or th o An g ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁}
▁public ▁class ▁ExecutorService ExitCode Generator ▁implements ▁ExitCode Generator ▁{ ▁private ▁ExecutorService ▁executorService ▁; ▁public ▁ExecutorService ExitCode Generator ▁( ▁ExecutorService ▁executorService ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁int ▁get ExitCode ▁( ▁) ▁{ ▁try ▁{ ▁if ▁( ▁! ▁Objects ▁. ▁isNull ▁( ▁executorService ▁) ▁) ▁{ ▁executorService ▁. ▁shutdownNow ▁( ▁) ▁; ▁return ▁1 ▁; ▁} ▁return ▁0 ▁; ▁} ▁catch ▁( ▁Security Exception ▁ex ▁) ▁{ ▁return ▁0 ▁; ▁} ▁} ▁}
▁private ▁static ▁Animator ▁create Scale Animator ▁( ▁final ▁View ▁view ▁, ▁float ▁start Scale ▁, ▁float ▁end Scale ▁) ▁{ ▁final ▁float ▁original Scale X ▁= ▁view ▁. ▁getScale X ▁( ▁) ▁; ▁final ▁float ▁original Scale Y ▁= ▁view ▁. ▁getScale Y ▁( ▁) ▁; ▁ObjectAnimator ▁animator ▁= ▁ObjectAnimator ▁. ▁of PropertyValues Holder ▁( ▁view ▁, ▁Property Values Holder ▁. ▁ofFloat ▁( ▁View ▁. ▁SC A LE _ X ▁, ▁original Scale X ▁ * ▁start Scale ▁, ▁original Scale X ▁ * ▁end Scale ▁) ▁, ▁Property Values Holder ▁. ▁ofFloat ▁( ▁View ▁. ▁SC A LE _ Y ▁, ▁original Scale Y ▁ * ▁start Scale ▁, ▁original Scale Y ▁ * ▁end Scale ▁) ▁) ▁; ▁animator ▁. ▁addListener ▁( ▁new ▁Animator Listener Adapter ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁on Animation End ▁( ▁Animator ▁animation ▁) ▁{ ▁view ▁. ▁setScale X ▁( ▁original Scale X ▁) ▁; ▁view ▁. ▁setScale Y ▁( ▁original Scale Y ▁) ▁; ▁} ▁} ▁) ▁; ▁return ▁animator ▁; ▁} ▁}
▁private ▁static ▁void ▁delete App Dir Logs ▁( ▁long ▁c utoff Millis ▁, ▁FileSystem ▁fs ▁, ▁Application Client Protocol ▁rm Client ▁, ▁FileStatus ▁app Dir ▁) ▁{ ▁try ▁{ ▁if ▁( ▁app Dir ▁. ▁isDirectory ▁( ▁) ▁&& ▁app Dir ▁. ▁getMod ification Time ▁( ▁) ▁< ▁c utoff Millis ▁) ▁{ ▁ApplicationId ▁appId ▁= ▁ApplicationId ▁. ▁fromString ▁( ▁app Dir ▁. ▁getPath ▁( ▁) ▁. ▁getName ▁( ▁) ▁) ▁; ▁boolean ▁app Terminated ▁= ▁is Application Terminated ▁( ▁appId ▁, ▁rm Client ▁) ▁; ▁if ▁( ▁! ▁app Terminated ▁) ▁{ ▁FileStatus ▁[ ▁] ▁log Files ▁; ▁try ▁{ ▁log Files ▁= ▁fs ▁. ▁listStatus ▁( ▁app Dir ▁. ▁getPath ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁log Exception ▁( ▁STR ▁+ ▁app Dir ▁. ▁getPath ▁( ▁) ▁, ▁e ▁) ▁; ▁return ▁; ▁} ▁for ▁( ▁FileStatus ▁node ▁: ▁log Files ▁) ▁{ ▁if ▁( ▁node ▁. ▁getMod ification Time ▁( ▁) ▁< ▁c utoff Millis ▁) ▁{ ▁try ▁{ ▁fs ▁. ▁delete ▁( ▁node ▁. ▁getPath ▁( ▁) ▁, ▁true ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁ex ▁) ▁{ ▁log Exception ▁( ▁STR ▁+ ▁app Dir ▁. ▁getPath ▁( ▁) ▁, ▁ex ▁) ▁; ▁} ▁} ▁} ▁} ▁else ▁if ▁( ▁should Delete LogDir ▁( ▁app Dir ▁, ▁c utoff Millis ▁, ▁fs ▁) ▁) ▁{ ▁try ▁{ ▁LOG ▁. ▁info ▁( ▁STR ▁+ ▁app Dir ▁. ▁getPath ▁( ▁) ▁) ▁; ▁fs ▁. ▁delete ▁( ▁app Dir ▁. ▁getPath ▁( ▁) ▁, ▁true ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁log Exception ▁( ▁STR ▁+ ▁app Dir ▁. ▁getPath ▁( ▁) ▁, ▁e ▁) ▁; ▁} ▁} ▁} ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁log Exception ▁( ▁STR ▁+ ▁app Dir ▁. ▁getPath ▁( ▁) ▁, ▁e ▁) ▁; ▁} ▁} ▁private ▁static ▁boolean ▁should Delete LogDir ▁( ▁FileStatus ▁dir ▁, ▁long ▁c utoff Millis ▁, ▁FileSystem ▁fs ▁) ▁{ ▁boolean ▁should Delete ▁= ▁true ▁; ▁try ▁{ ▁for ▁( ▁FileStatus ▁node ▁: ▁fs ▁. ▁listStatus ▁( ▁dir ▁. ▁getPath ▁( ▁) ▁) ▁) ▁{ ▁if ▁( ▁node ▁. ▁getMod ification Time ▁( ▁) ▁>= ▁c utoff Millis ▁) ▁{ ▁should Delete ▁= ▁false ▁; ▁break ▁; ▁} ▁} ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁log Exception ▁( ▁STR ▁+ ▁dir ▁. ▁getPath ▁( ▁) ▁, ▁e ▁) ▁; ▁should Delete ▁= ▁false ▁; ▁} ▁return ▁should Delete ▁; ▁} ▁private ▁static ▁boolean ▁is Application Terminated ▁( ▁ApplicationId ▁appId ▁, ▁Application Client Protocol ▁rm Client ▁) ▁throws ▁IOException ▁{ ▁Application Report ▁app Report ▁= ▁null ▁; ▁try ▁{ ▁app Report ▁= ▁rm Client ▁. ▁getApplication Report ▁( ▁GetApplication ReportRequest ▁. ▁newInstance ▁( ▁appId ▁) ▁) ▁. ▁getApplication Report ▁( ▁) ▁; ▁} ▁catch ▁( ▁Application Not FoundException ▁e ▁) ▁{ ▁return ▁true ▁; ▁} ▁catch ▁( ▁YarnException ▁e ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁e ▁) ▁; ▁} ▁Yarn Application State ▁currentState ▁= ▁app Report ▁. ▁getY arn Application State ▁( ▁) ▁; ▁return ▁Ap ps ▁. ▁is Application Final State ▁( ▁currentState ▁) ▁; ▁}
▁public ▁class ▁Annotation Visitor ▁< ▁T ▁extends ▁Annotation ▁> ▁{ ▁private ▁final ▁Class ▁< ▁T ▁> ▁target Annotation ▁; ▁public ▁Annotation Visitor ▁( ▁Class ▁< ▁T ▁> ▁target Annotation ▁) ▁{ ▁this ▁. ▁target Annotation ▁= ▁Objects ▁. ▁requireNonNull ▁( ▁target Annotation ▁, ▁STR ▁) ▁; ▁} ▁public ▁void ▁visit ▁( ▁Object ▁object ▁, ▁Field Visitor ▁field Visitor ▁) ▁{ ▁Objects ▁. ▁requireNonNull ▁( ▁object ▁, ▁STR ▁) ▁; ▁Objects ▁. ▁requireNonNull ▁( ▁field Visitor ▁, ▁STR ▁) ▁; ▁final ▁Class ▁< ▁? ▁> ▁clazz ▁= ▁getCl azz ▁( ▁object ▁) ▁; ▁final ▁Field ▁[ ▁] ▁declared Fields ▁= ▁clazz ▁. ▁getDeclared Fields ▁( ▁) ▁; ▁for ▁( ▁Field ▁field ▁: ▁declared Fields ▁) ▁{ ▁final ▁boolean ▁annotation ▁= ▁find Annotation ▁( ▁field ▁) ▁; ▁if ▁( ▁! ▁annotation ▁) ▁{ ▁continue ▁; ▁} ▁final ▁Object ▁fieldValue ▁= ▁getFile d Value ▁( ▁object ▁, ▁field ▁) ▁; ▁field Visitor ▁. ▁visit ▁( ▁field ▁, ▁fieldValue ▁) ▁; ▁} ▁} ▁private ▁boolean ▁find Annotation ▁( ▁Field ▁field ▁) ▁{ ▁final ▁Annotation ▁annotation ▁= ▁field ▁. ▁getAnnotation ▁( ▁target Annotation ▁) ▁; ▁return ▁annotation ▁!= ▁null ▁; ▁} ▁protected ▁Class ▁< ▁? ▁> ▁getCl azz ▁( ▁Object ▁object ▁) ▁{ ▁return ▁ClassUtils ▁. ▁getUser Class ▁( ▁object ▁) ▁; ▁} ▁private ▁Object ▁getFile d Value ▁( ▁Object ▁object ▁, ▁Field ▁field ▁) ▁{ ▁ReflectionUtils ▁. ▁make Accessible ▁( ▁field ▁) ▁; ▁return ▁ReflectionUtils ▁. ▁getField ▁( ▁field ▁, ▁object ▁) ▁; ▁} ▁public ▁interface ▁Field Visitor ▁{ ▁void ▁visit ▁( ▁Field ▁field ▁, ▁Object ▁value ▁) ▁; ▁} ▁}
▁@ ▁Retention ▁( ▁RetentionPolicy ▁. ▁RUNTIME ▁) ▁@ ▁Target ▁( ▁{ ▁ElementType ▁. ▁METHOD ▁, ▁ElementType ▁. ▁CON STRUCTOR ▁, ▁ElementType ▁. ▁TYPE ▁, ▁ElementType ▁. ▁FIELD ▁} ▁) ▁public ▁@ interface ▁Substitute ▁{ ▁boolean ▁p oly m or ph ic Signature ▁( ▁) ▁default ▁false ▁; ▁}
▁public ▁class ▁Stamp Tool ▁{ ▁public ▁static ▁Stamp ▁m eet ▁( ▁Iterable ▁< ▁? ▁extends ▁ValueNode ▁> ▁values ▁) ▁{ ▁Stamp ▁stamp ▁= ▁m eet OrNull ▁( ▁values ▁, ▁null ▁) ▁; ▁if ▁( ▁stamp ▁== ▁null ▁) ▁{ ▁return ▁StampFactory ▁. ▁for Void ▁( ▁) ▁; ▁} ▁return ▁stamp ▁; ▁} ▁public ▁static ▁Stamp ▁m eet OrNull ▁( ▁Iterable ▁< ▁? ▁extends ▁ValueNode ▁> ▁values ▁, ▁ValueNode ▁self Value ▁) ▁{ ▁Iterator ▁< ▁? ▁extends ▁ValueNode ▁> ▁iterator ▁= ▁values ▁. ▁iterator ▁( ▁) ▁; ▁Stamp ▁stamp ▁= ▁null ▁; ▁while ▁( ▁iterator ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁ValueNode ▁nextValue ▁= ▁iterator ▁. ▁next ▁( ▁) ▁; ▁if ▁( ▁nextValue ▁!= ▁self Value ▁) ▁{ ▁if ▁( ▁stamp ▁== ▁null ▁) ▁{ ▁stamp ▁= ▁nextValue ▁. ▁stamp ▁( ▁NodeView ▁. ▁DEFAULT ▁) ▁; ▁} ▁else ▁{ ▁stamp ▁= ▁stamp ▁. ▁m eet ▁( ▁nextValue ▁. ▁stamp ▁( ▁NodeView ▁. ▁DEFAULT ▁) ▁) ▁; ▁} ▁} ▁} ▁return ▁stamp ▁; ▁} ▁public ▁static ▁Stamp ▁unsigned Compare ▁( ▁Stamp ▁stamp ▁, ▁Stamp ▁stamp 2 ▁) ▁{ ▁IntegerStamp ▁x ▁= ▁( ▁IntegerStamp ▁) ▁stamp ▁; ▁IntegerStamp ▁y ▁= ▁( ▁IntegerStamp ▁) ▁stamp 2 ▁; ▁if ▁( ▁x ▁. ▁isUn re stricted ▁( ▁) ▁&& ▁y ▁. ▁isUn re stricted ▁( ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁if ▁( ▁x ▁. ▁lowerBound ▁( ▁) ▁== ▁x ▁. ▁upperBound ▁( ▁) ▁) ▁{ ▁if ▁( ▁y ▁. ▁is Positive ▁( ▁) ▁) ▁{ ▁if ▁( ▁x ▁. ▁lowerBound ▁( ▁) ▁== ▁( ▁1 ▁<< ▁x ▁. ▁get Bits ▁( ▁) ▁) ▁- ▁1 ▁) ▁{ ▁return ▁null ▁; ▁} ▁if ▁( ▁x ▁. ▁lowerBound ▁( ▁) ▁<= ▁y ▁. ▁lowerBound ▁( ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁return ▁StampFactory ▁. ▁for Integer ▁( ▁x ▁. ▁get Bits ▁( ▁) ▁, ▁x ▁. ▁lowerBound ▁( ▁) ▁+ ▁1 ▁, ▁y ▁. ▁upperBound ▁( ▁) ▁) ▁; ▁} ▁return ▁null ▁; ▁} ▁if ▁( ▁y ▁. ▁lowerBound ▁( ▁) ▁== ▁y ▁. ▁upperBound ▁( ▁) ▁&& ▁y ▁. ▁is Strict ly Positive ▁( ▁) ▁) ▁{ ▁return ▁StampFactory ▁. ▁for Integer ▁( ▁y ▁. ▁get Bits ▁( ▁) ▁, ▁0 ▁, ▁y ▁. ▁lowerBound ▁( ▁) ▁- ▁1 ▁) ▁; ▁} ▁return ▁null ▁; ▁} ▁public ▁static ▁Stamp ▁stamp For Leading Z eros ▁( ▁IntegerStamp ▁value Stamp ▁) ▁{ ▁long ▁mask ▁= ▁Code Util ▁. ▁mask ▁( ▁value Stamp ▁. ▁get Bits ▁( ▁) ▁) ▁; ▁int ▁adjust ▁= ▁Long ▁. ▁numberOf Leading Z eros ▁( ▁mask ▁) ▁; ▁assert ▁adjust ▁== ▁0 ▁|| ▁adjust ▁== ▁32 ▁; ▁int ▁min ▁= ▁Long ▁. ▁numberOf Leading Z eros ▁( ▁value Stamp ▁. ▁up Mask ▁( ▁) ▁& ▁mask ▁) ▁- ▁adjust ▁; ▁int ▁max ▁= ▁Long ▁. ▁numberOf Leading Z eros ▁( ▁value Stamp ▁. ▁down Mask ▁( ▁) ▁& ▁mask ▁) ▁- ▁adjust ▁; ▁return ▁StampFactory ▁. ▁for Integer ▁( ▁JavaKind ▁. ▁Int ▁, ▁min ▁, ▁max ▁) ▁; ▁}
▁public ▁class ▁Full Duplex Http Service Test ▁{ ▁@ ▁Rule ▁public ▁JenkinsRule ▁r ▁= ▁new ▁JenkinsRule ▁( ▁) ▁; ▁@ ▁Rule ▁public ▁Logger Rule ▁logging ▁= ▁new ▁Logger Rule ▁( ▁) ▁. ▁record ▁( ▁Full Duplex Http Service ▁. ▁class ▁, ▁Level ▁. ▁FINE ▁) ▁. ▁record ▁( ▁Full Duplex Http Stream ▁. ▁class ▁, ▁Level ▁. ▁FINE ▁) ▁; ▁@ ▁Test ▁public ▁void ▁s mo k es ▁( ▁) ▁throws ▁Exception ▁{ ▁logging ▁. ▁record ▁( ▁STR ▁, ▁Level ▁. ▁ALL ▁) ▁; ▁Full Duplex Http Stream ▁con ▁= ▁new ▁Full Duplex Http Stream ▁( ▁r ▁. ▁getURL ▁( ▁) ▁, ▁STR ▁, ▁null ▁) ▁; ▁InputStream ▁is ▁= ▁con ▁. ▁getInputStream ▁( ▁) ▁; ▁OutputStream ▁os ▁= ▁con ▁. ▁getOutputStream ▁( ▁) ▁; ▁os ▁. ▁write ▁( ▁33 ▁) ▁; ▁os ▁. ▁flush ▁( ▁) ▁; ▁Logger ▁. ▁getLogger ▁( ▁Full Duplex Http Service Test ▁. ▁class ▁. ▁getName ▁( ▁) ▁) ▁. ▁info ▁( ▁STR ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁is ▁. ▁read ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁66 ▁, ▁is ▁. ▁read ▁( ▁) ▁) ▁; ▁} ▁@ ▁TestExtension ▁( ▁STR ▁) ▁public ▁static ▁class ▁Endpoint ▁extends ▁Inv isible Action ▁implements ▁Root Action ▁{ ▁private ▁final ▁transient ▁Map ▁< ▁UUID ▁, ▁Full Duplex Http Service ▁> ▁duplex Services ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁@ ▁Override ▁public ▁String ▁getUrl Name ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁public ▁HttpResponse ▁do Index ▁( ▁) ▁{ ▁return ▁new ▁Full Duplex Http Service ▁. ▁Response ▁( ▁duplex Services ▁) ▁{ ▁@ ▁Override ▁protected ▁Full Duplex Http Service ▁create Service ▁( ▁StaplerRequest ▁req ▁, ▁UUID ▁uuid ▁) ▁throws ▁IOException ▁, ▁Interrupted Exception ▁{ ▁return ▁new ▁Full Duplex Http Service ▁( ▁uuid ▁) ▁{ ▁@ ▁Override ▁protected ▁void ▁run ▁( ▁InputStream ▁upload ▁, ▁OutputStream ▁download ▁) ▁throws ▁IOException ▁, ▁Interrupted Exception ▁{ ▁int ▁x ▁= ▁upload ▁. ▁read ▁( ▁) ▁; ▁download ▁. ▁write ▁( ▁x ▁ * ▁2 ▁) ▁; ▁} ▁} ▁; ▁} ▁} ▁; ▁} ▁} ▁@ ▁TestExtension ▁( ▁STR ▁) ▁public ▁static ▁class ▁Endpoint Cr umb Exclusion ▁extends ▁C r umb Exclusion ▁{ ▁@ ▁Override ▁public ▁boolean ▁process ▁( ▁HttpServlet Request ▁request ▁, ▁HttpServlet Response ▁response ▁, ▁FilterChain ▁chain ▁) ▁throws ▁IOException ▁, ▁Servlet Exception ▁{ ▁if ▁( ▁STR ▁. ▁equals ▁( ▁request ▁. ▁getPath Info ▁( ▁) ▁) ▁) ▁{ ▁chain ▁. ▁doFilter ▁( ▁request ▁, ▁response ▁) ▁; ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁} ▁}
▁@ ▁Nullsafe ▁( ▁Nullsafe ▁. ▁Mode ▁. ▁STRICT ▁) ▁public ▁abstract ▁class ▁Closeable Reference ▁< ▁T ▁> ▁implements ▁Clone able ▁, ▁Closeable ▁{ ▁@ ▁Int Def ▁( ▁{ ▁REF _ TYPE _ DEFAULT ▁, ▁REF _ TYPE _ FIN ALI Z ER ▁, ▁REF _ TYPE _ REF _ COUNT ▁, ▁REF _ TYPE _ NO OP ▁} ▁) ▁public ▁@ interface ▁Closeable Ref Type ▁{ ▁} ▁public ▁static ▁final ▁int ▁REF _ TYPE _ DEFAULT ▁= ▁0 ▁; ▁public ▁static ▁final ▁int ▁REF _ TYPE _ FIN ALI Z ER ▁= ▁1 ▁; ▁public ▁static ▁final ▁int ▁REF _ TYPE _ REF _ COUNT ▁= ▁2 ▁; ▁public ▁static ▁final ▁int ▁REF _ TYPE _ NO OP ▁= ▁3 ▁; ▁private ▁static ▁Class ▁< ▁Closeable Reference ▁> ▁TAG ▁= ▁Closeable Reference ▁. ▁class ▁; ▁private ▁static ▁@ ▁Closeable Ref Type ▁int ▁s Bitmap Closeable Ref Type ▁= ▁REF _ TYPE _ DEFAULT ▁; ▁public ▁static ▁boolean ▁use Gc ▁( ▁) ▁{ ▁return ▁s Bitmap Closeable Ref Type ▁== ▁REF _ TYPE _ NO OP ▁; ▁} ▁public ▁static ▁void ▁set Disable Closeable References For Bitmap s ▁( ▁@ ▁Closeable Ref Type ▁int ▁bitmap Closeable Ref Type ▁) ▁{ ▁s Bitmap Closeable Ref Type ▁= ▁bitmap Closeable Ref Type ▁; ▁} ▁@ ▁GuardedBy ▁( ▁STR ▁) ▁protected ▁boolean ▁m Is Closed ▁= ▁false ▁; ▁protected ▁final ▁Shared Reference ▁< ▁T ▁> ▁m Shared Reference ▁; ▁protected ▁final ▁Le ak Handler ▁m Leak Handler ▁; ▁@ ▁Nullable ▁protected ▁final ▁Throwable ▁m Stack tr ace ▁; ▁public ▁interface ▁Le ak Handler ▁{ ▁void ▁report Leak ▁( ▁Shared Reference ▁< ▁Object ▁> ▁reference ▁, ▁@ ▁Nullable ▁Throwable ▁stack tr ace ▁) ▁; ▁boolean ▁requires Stack tr ace ▁( ▁) ▁; ▁} ▁private ▁static ▁final ▁Resource Re leas er ▁< ▁Closeable ▁> ▁DEFAULT _ CLOSE ABLE _ RE LE A SER ▁= ▁new ▁Resource Re leas er ▁< ▁Closeable ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁release ▁( ▁Closeable ▁value ▁) ▁{ ▁try ▁{ ▁Closeable s ▁. ▁close ▁( ▁value ▁, ▁true ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁ioe ▁) ▁{ ▁} ▁} ▁} ▁; ▁private ▁static ▁final ▁Le ak Handler ▁DEFAULT _ LE A K _ HANDLER ▁= ▁new ▁Le ak Handler ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁report Leak ▁( ▁Shared Reference ▁< ▁Object ▁> ▁reference ▁, ▁@ ▁Nullable ▁Throwable ▁stack tr ace ▁) ▁{ ▁final ▁Object ▁ref ▁= ▁reference ▁. ▁get ▁( ▁) ▁; ▁F Log ▁. ▁w ▁( ▁TAG ▁, ▁STR ▁, ▁System ▁. ▁identity HashCode ▁( ▁this ▁) ▁, ▁System ▁. ▁identity HashCode ▁( ▁reference ▁) ▁, ▁ref ▁== ▁null ▁? ▁null ▁: ▁ref ▁. ▁getClass ▁( ▁) ▁. ▁getName ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁requires Stack tr ace ▁( ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁; ▁protected ▁Closeable Reference ▁( ▁Shared Reference ▁< ▁T ▁> ▁shared Reference ▁, ▁Le ak Handler ▁le ak Handler ▁, ▁@ ▁Nullable ▁Throwable ▁stack tr ace ▁) ▁{ ▁m Shared Reference ▁= ▁Preconditions ▁. ▁checkNotNull ▁( ▁shared Reference ▁) ▁;
▁private ▁void ▁de ploy Per Job ▁( ▁Configuration ▁configuration ▁, ▁JobGraph ▁jobGraph ▁, ▁boolean ▁with Dist ▁) ▁throws ▁Exception ▁{ ▁jobGraph ▁. ▁setJob Type ▁( ▁Job Type ▁. ▁STREAM ING ▁) ▁; ▁try ▁( ▁final ▁Yarn Cluster Descriptor ▁yarn Cluster Descriptor ▁= ▁with Dist ▁? ▁create Yarn Cluster Descriptor ▁( ▁configuration ▁) ▁: ▁create Yarn Cluster Descriptor Without Lib Dir ▁( ▁configuration ▁) ▁) ▁{ ▁final ▁int ▁master Memory ▁= ▁yarn Cluster Descriptor ▁. ▁getF link Configuration ▁( ▁) ▁. ▁get ▁( ▁JobManager Options ▁. ▁TOTAL _ PROCESS _ MEMORY ▁) ▁. ▁getM eb i Bytes ▁( ▁) ▁; ▁final ▁Cluster Specification ▁cluster Specification ▁= ▁new ▁Cluster Specification ▁. ▁Cluster Specification Builder ▁( ▁) ▁. ▁set Master Memory MB ▁( ▁master Memory ▁) ▁. ▁set TaskManager Memory MB ▁( ▁1024 ▁) ▁. ▁set Slots Per TaskManager ▁( ▁1 ▁) ▁. ▁create Cluster Specification ▁( ▁) ▁; ▁File ▁testing Jar ▁= ▁TestUtils ▁. ▁find File ▁( ▁STR ▁, ▁new ▁TestUtils ▁. ▁Test Jar Finder ▁( ▁STR ▁) ▁) ▁; ▁jobGraph ▁. ▁add Jar ▁( ▁new ▁org ▁. ▁apache ▁. ▁flink ▁. ▁core ▁. ▁fs ▁. ▁Path ▁( ▁testing Jar ▁. ▁toURI ▁( ▁) ▁) ▁) ▁; ▁try ▁( ▁Cluster Client ▁< ▁ApplicationId ▁> ▁cluster Client ▁= ▁yarn Cluster Descriptor ▁. ▁de ploy Job Cluster ▁( ▁cluster Specification ▁, ▁jobGraph ▁, ▁false ▁) ▁. ▁getCluster Client ▁( ▁) ▁) ▁{ ▁for ▁( ▁Distributed Cache ▁. ▁Distributed CacheEntry ▁entry ▁: ▁jobGraph ▁. ▁getUser Artifacts ▁( ▁) ▁. ▁values ▁( ▁) ▁) ▁{ ▁assertTrue ▁( ▁String ▁. ▁format ▁( ▁STR ▁, ▁entry ▁. ▁filePath ▁) ▁, ▁Utils ▁. ▁is Remote Path ▁( ▁entry ▁. ▁filePath ▁) ▁) ▁; ▁} ▁ApplicationId ▁applicationId ▁= ▁cluster Client ▁. ▁getCluster Id ▁( ▁) ▁; ▁final ▁Completable Future ▁< ▁Job Result ▁> ▁job Result Completable Future ▁= ▁cluster Client ▁. ▁request Job Result ▁( ▁jobGraph ▁. ▁getJobID ▁( ▁) ▁) ▁; ▁final ▁Job Result ▁job Result ▁= ▁job Result Completable Future ▁. ▁get ▁( ▁) ▁; ▁assertThat ▁( ▁job Result ▁, ▁is ▁( ▁notNullValue ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁job Result ▁. ▁getSerialized Throwable ▁( ▁) ▁. ▁isPresent ▁( ▁) ▁, ▁is ▁( ▁false ▁) ▁) ▁; ▁check St aging Directory ▁( ▁configuration ▁, ▁applicationId ▁) ▁; ▁wait Application Finished Else Kill It ▁( ▁applicationId ▁, ▁yarn App Terminate Timeout ▁, ▁yarn Cluster Descriptor ▁, ▁sleep Interval In MS ▁) ▁; ▁} ▁} ▁} ▁private ▁void ▁check St aging Directory ▁( ▁Configuration ▁flinkConfig ▁, ▁ApplicationId ▁appId ▁) ▁throws ▁IOException ▁{ ▁final ▁List ▁< ▁String ▁> ▁pro vided Lib Dirs ▁= ▁flinkConfig ▁. ▁get ▁( ▁Yarn ConfigOptions ▁. ▁PRO VID ED _ LI B _ DIR S ▁) ▁; ▁final ▁boolean ▁is Provided Lib Dir sConfig ured ▁= ▁pro vided Lib Dirs ▁!= ▁null ▁&& ▁! ▁pro vided Lib Dirs ▁. ▁isEmpty ▁( ▁) ▁; ▁try ▁( ▁final ▁FileSystem ▁fs ▁= ▁FileSystem ▁. ▁get ▁( ▁YARN _ CONFIGURATION ▁) ▁) ▁{ ▁final ▁Path ▁st aging Directory ▁= ▁new ▁Path ▁( ▁fs ▁. ▁getH ome Directory ▁( ▁) ▁, ▁STR ▁+ ▁appId ▁. ▁toString ▁( ▁) ▁) ▁;
▁} ▁, ▁executor ▁) ▁; ▁assertThat ▁( ▁getF inal Value ▁( ▁c losing Future ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁waitUntil Closed ▁( ▁c losing Future ▁) ▁; ▁assert Closed ▁( ▁closeable 1 ▁) ▁; ▁} ▁public ▁void ▁test Event ually C losing _ fa iled Input ▁( ▁) ▁throws ▁Exception ▁{ ▁assert Finally Fail sWith Exception ▁( ▁C losing Future ▁. ▁event ually C losing ▁( ▁Futures ▁. ▁< ▁Closeable ▁> ▁immediate Failed Future ▁( ▁exception ▁) ▁, ▁c losing Executor ▁) ▁) ▁; ▁} ▁public ▁void ▁test Event ually C losing _ c ancelled Input ▁( ▁) ▁throws ▁Exception ▁{ ▁assert B ec om es Canceled ▁( ▁C losing Future ▁. ▁event ually C losing ▁( ▁Futures ▁. ▁< ▁Closeable ▁> ▁immediate Cancelled Future ▁( ▁) ▁, ▁c losing Executor ▁) ▁) ▁; ▁} ▁public ▁void ▁test Event ually C losing _ c ancelled Pipeline ▁( ▁) ▁throws ▁Exception ▁{ ▁C losing Future ▁< ▁Test Closeable ▁> ▁c losing Future ▁= ▁C losing Future ▁. ▁event ually C losing ▁( ▁executor ▁. ▁submit ▁( ▁wait er ▁. ▁waitFor ▁( ▁new ▁Callable ▁< ▁Test Closeable ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Test Closeable ▁call ▁( ▁) ▁throws ▁Interrupted Exception ▁{ ▁await Uninterruptibly ▁( ▁future Cancelled ▁) ▁; ▁return ▁closeable 1 ▁; ▁} ▁} ▁) ▁) ▁, ▁c losing Executor ▁) ▁; ▁wait er ▁. ▁await Started ▁( ▁) ▁; ▁cancel Final Step And Wait ▁( ▁c losing Future ▁) ▁; ▁assert St ill Open ▁( ▁closeable 1 ▁) ▁; ▁wait er ▁. ▁await Returned ▁( ▁) ▁; ▁assert Closed ▁( ▁closeable 1 ▁) ▁; ▁} ▁public ▁void ▁test Event ually C losing _ th rows ▁( ▁) ▁throws ▁Exception ▁{ ▁assert Finally Fail sWith Exception ▁( ▁C losing Future ▁. ▁event ually C losing ▁( ▁executor ▁. ▁submit ▁( ▁new ▁Callable ▁< ▁Test Closeable ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Test Closeable ▁call ▁( ▁) ▁throws ▁Exception ▁{ ▁throw ▁exception ▁; ▁} ▁} ▁) ▁, ▁c losing Executor ▁) ▁) ▁; ▁} ▁public ▁void ▁test Submit ▁( ▁) ▁throws ▁Exception ▁{ ▁C losing Future ▁< ▁String ▁> ▁c losing Future ▁= ▁C losing Future ▁. ▁submit ▁( ▁new ▁C losing Callable ▁< ▁Test Closeable ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Test Closeable ▁call ▁( ▁Deferred C loser ▁c loser ▁) ▁throws ▁Exception ▁{ ▁c loser ▁. ▁event ually Close ▁( ▁closeable 1 ▁, ▁c losing Executor ▁) ▁; ▁c loser ▁. ▁event ually Close ▁( ▁closeable 2 ▁, ▁c losing Executor ▁) ▁; ▁return ▁closeable 3 ▁; ▁} ▁} ▁, ▁executor ▁) ▁. ▁transform ▁( ▁new ▁C losing Function ▁< ▁Test Closeable ▁, ▁String ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁String ▁apply ▁( ▁Deferred C loser ▁c loser ▁, ▁Test Closeable ▁v ▁) ▁throws ▁Exception ▁{ ▁assertThat ▁( ▁v ▁) ▁. ▁isSame InstanceAs ▁( ▁closeable 3 ▁) ▁; ▁assert St ill Open ▁( ▁closeable 1 ▁, ▁closeable 2 ▁, ▁closeable 3 ▁) ▁; ▁return ▁STR ▁; ▁} ▁} ▁, ▁executor ▁) ▁;
▁public ▁class ▁Unsigned Byte Type ▁implements ▁Serialization Test Type ▁{ ▁private ▁int ▁value ▁; ▁public ▁Unsigned Byte Type ▁( ▁) ▁{ ▁this ▁. ▁value ▁= ▁0 ▁; ▁} ▁private ▁Unsigned Byte Type ▁( ▁int ▁value ▁) ▁{ ▁this ▁. ▁value ▁= ▁value ▁; ▁} ▁@ ▁Override ▁public ▁Unsigned Byte Type ▁getRandom ▁( ▁Random ▁rnd ▁) ▁{ ▁return ▁new ▁Unsigned Byte Type ▁( ▁rnd ▁. ▁nextInt ▁( ▁128 ▁) ▁+ ▁128 ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁length ▁( ▁) ▁{ ▁return ▁1 ▁; ▁} ▁@ ▁Override ▁public ▁void ▁write ▁( ▁DataOutputView ▁out ▁) ▁throws ▁IOException ▁{ ▁out ▁. ▁writeByte ▁( ▁this ▁. ▁value ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁read ▁( ▁DataInputView ▁in ▁) ▁throws ▁IOException ▁{ ▁this ▁. ▁value ▁= ▁in ▁. ▁readUnsigned Byte ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁this ▁. ▁value ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁obj ▁) ▁{ ▁if ▁( ▁obj ▁instanceof ▁Unsigned Byte Type ▁) ▁{ ▁Unsigned Byte Type ▁other ▁= ▁( ▁Unsigned Byte Type ▁) ▁obj ▁; ▁return ▁this ▁. ▁value ▁== ▁other ▁. ▁value ▁; ▁} ▁else ▁{ ▁return ▁false ▁; ▁} ▁} ▁}
▁return ▁( ▁( ▁Field ▁) ▁self ▁. ▁reflect Access ▁) ▁. ▁getType ▁( ▁) ▁. ▁isPrimitive ▁( ▁) ▁? ▁Static Fields Support ▁. ▁get Static Primitive Fields ▁( ▁) ▁: ▁Static Fields Support ▁. ▁get Static Object Fields ▁( ▁) ▁; ▁} ▁@ ▁Substitute ▁private ▁static ▁Object ▁getMember VM Info ▁( ▁Target _ java _ lang _ invoke _ Member Name ▁self ▁) ▁{ ▁throw ▁unsupported Feature ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Delete ▁private ▁static ▁native ▁void ▁set Call Site Target Normal ▁( ▁Call Site ▁s ite ▁, ▁MethodHandle ▁target ▁) ▁; ▁@ ▁Delete ▁private ▁static ▁native ▁void ▁set Call Site Target V olatile ▁( ▁Call Site ▁s ite ▁, ▁MethodHandle ▁target ▁) ▁; ▁@ ▁Delete ▁private ▁static ▁native ▁void ▁register N atives ▁( ▁) ▁; ▁@ ▁Delete ▁private ▁static ▁native ▁int ▁getNamed Con ▁( ▁int ▁which ▁, ▁Object ▁[ ▁] ▁name ▁) ▁; ▁@ ▁Delete ▁@ ▁Target Element ▁( ▁onlyWith ▁= ▁JDK 8 Or E ar lier ▁. ▁class ▁) ▁private ▁static ▁native ▁Target _ java _ lang _ invoke _ Member Name ▁resolve ▁( ▁Target _ java _ lang _ invoke _ Member Name ▁self ▁, ▁Class ▁< ▁? ▁> ▁caller ▁) ▁throws ▁Link age Error ▁, ▁ClassNot FoundException ▁; ▁@ ▁Delete ▁@ ▁Target Element ▁( ▁onlyWith ▁= ▁JDK 8 Or E ar lier ▁. ▁class ▁) ▁private ▁static ▁native ▁int ▁getConstant ▁( ▁int ▁which ▁) ▁; ▁@ ▁Substitute ▁@ ▁Target Element ▁( ▁onlyWith ▁= ▁{ ▁JDK 11 Or Later ▁. ▁class ▁, ▁JDK 15 Or E ar lier ▁. ▁class ▁} ▁) ▁static ▁Target _ java _ lang _ invoke _ Member Name ▁resolve ▁( ▁Target _ java _ lang _ invoke _ Member Name ▁self ▁, ▁Class ▁< ▁? ▁> ▁caller ▁, ▁boolean ▁spec ul ative Resolve ▁) ▁throws ▁Link age Error ▁, ▁ClassNot FoundException ▁{ ▁return ▁Util _ java _ lang _ invoke _ MethodHandle N atives ▁. ▁resolve ▁( ▁self ▁, ▁caller ▁, ▁spec ul ative Resolve ▁) ▁; ▁} ▁@ ▁Delete ▁@ ▁Target Element ▁( ▁onlyWith ▁= ▁JDK 11 Or Later ▁. ▁class ▁) ▁private ▁static ▁native ▁void ▁copy Out Bootstrap Arguments ▁( ▁Class ▁< ▁? ▁> ▁caller ▁, ▁int ▁[ ▁] ▁index Info ▁, ▁int ▁start ▁, ▁int ▁end ▁, ▁Object ▁[ ▁] ▁buf ▁, ▁int ▁pos ▁, ▁boolean ▁resolve ▁, ▁Object ▁if Not Available ▁) ▁; ▁@ ▁Substitute ▁@ ▁Target Element ▁( ▁onlyWith ▁= ▁JDK 11 Or Later ▁. ▁class ▁) ▁private ▁static ▁void ▁clear Call Site Context ▁( ▁Target _ java _ lang _ invoke _ MethodHandle N atives _ Call Site Context ▁context ▁) ▁{ ▁throw ▁un imple mented ▁( ▁STR ▁) ▁; ▁} ▁@ ▁An not ate Original ▁static ▁native ▁boolean ▁ref Kind Is Method ▁( ▁byte ▁ref Kind ▁) ▁; ▁@ ▁An not ate Original ▁static ▁native ▁String ▁ref Kind Name ▁( ▁byte ▁ref Kind ▁) ▁;
▁public ▁class ▁Show For Duration Schedule ▁implements ▁M egaphone Schedule ▁{ ▁private ▁final ▁long ▁duration ▁; ▁public ▁static ▁M egaphone Schedule ▁show For Days ▁( ▁int ▁day s ▁) ▁{ ▁return ▁new ▁Show For Duration Schedule ▁( ▁TimeUnit ▁. ▁DAYS ▁. ▁toMillis ▁( ▁day s ▁) ▁) ▁; ▁} ▁public ▁Show For Duration Schedule ▁( ▁long ▁duration ▁) ▁{ ▁this ▁. ▁duration ▁= ▁duration ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁should Display ▁( ▁int ▁seen Count ▁, ▁long ▁last Seen ▁, ▁long ▁first Visible ▁, ▁long ▁currentTime ▁) ▁{ ▁return ▁first Visible ▁== ▁0 ▁|| ▁currentTime ▁< ▁first Visible ▁+ ▁duration ▁; ▁} ▁}
▁public ▁class ▁Graph Layout XY ▁extends ▁Free form Layout ▁{ ▁private ▁D iagram Part ▁diag ram ▁; ▁public ▁Graph Layout XY ▁( ▁D iagram Part ▁diag ram ▁) ▁{ ▁this ▁. ▁diag ram ▁= ▁diag ram ▁; ▁} ▁@ ▁Override ▁public ▁void ▁layout ▁( ▁IF igure ▁container ▁) ▁{ ▁super ▁. ▁layout ▁( ▁container ▁) ▁; ▁diag ram ▁. ▁set TableModel Bounds ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁getConstraint ▁( ▁IF igure ▁child ▁) ▁{ ▁Object ▁constraint ▁= ▁constraint s ▁. ▁get ▁( ▁child ▁) ▁; ▁if ▁( ▁constraint ▁instanceof ▁Rectangle ▁) ▁{ ▁return ▁constraint ▁; ▁} ▁else ▁{ ▁Rectangle ▁current Bounds ▁= ▁child ▁. ▁getBounds ▁( ▁) ▁; ▁return ▁new ▁Rectangle ▁( ▁current Bounds ▁. ▁x ▁, ▁current Bounds ▁. ▁y ▁, ▁- ▁1 ▁, ▁- ▁1 ▁) ▁; ▁} ▁} ▁public ▁void ▁cleanup Constraints ▁( ▁) ▁{ ▁constraint s ▁. ▁clear ▁( ▁) ▁; ▁} ▁}
▁case Expr ▁. ▁setParent ▁( ▁x ▁. ▁getParent ▁( ▁) ▁) ▁; ▁return ▁case Expr ▁; ▁} ▁public ▁static ▁SQLDataType ▁transform Oracle To MySql ▁( ▁SQLDataType ▁x ▁) ▁{ ▁final ▁String ▁name ▁= ▁x ▁. ▁getName ▁( ▁) ▁; ▁final ▁long ▁name Hash ▁= ▁x ▁. ▁name HashCode 64 ▁( ▁) ▁; ▁if ▁( ▁name ▁== ▁null ▁) ▁{ ▁return ▁x ▁; ▁} ▁List ▁< ▁SQLExpr ▁> ▁argument ns ▁= ▁x ▁. ▁getArguments ▁( ▁) ▁; ▁SQLDataType ▁dataType ▁; ▁if ▁( ▁name Hash ▁== ▁F n v Hash ▁. ▁Constants ▁. ▁U ROW ID ▁) ▁{ ▁int ▁len ▁= ▁4000 ▁; ▁if ▁( ▁argument ns ▁. ▁size ▁( ▁) ▁== ▁1 ▁) ▁{ ▁SQLExpr ▁arg 0 ▁= ▁argument ns ▁. ▁get ▁( ▁0 ▁) ▁; ▁if ▁( ▁arg 0 ▁instanceof ▁SQLIntegerExpr ▁) ▁{ ▁len ▁= ▁( ▁( ▁SQLIntegerExpr ▁) ▁arg 0 ▁) ▁. ▁getNumber ▁( ▁) ▁. ▁intValue ▁( ▁) ▁; ▁} ▁} ▁dataType ▁= ▁new ▁SQLDataType Impl ▁( ▁STR ▁, ▁len ▁) ▁; ▁} ▁else ▁if ▁( ▁name Hash ▁== ▁F n v Hash ▁. ▁Constants ▁. ▁ROW ID ▁) ▁{ ▁dataType ▁= ▁new ▁SQLDataType Impl ▁( ▁STR ▁, ▁10 ▁) ▁; ▁} ▁else ▁if ▁( ▁name Hash ▁== ▁F n v Hash ▁. ▁Constants ▁. ▁BOOLEAN ▁) ▁{ ▁dataType ▁= ▁new ▁SQLDataType Impl ▁( ▁STR ▁) ▁; ▁} ▁else ▁if ▁( ▁name Hash ▁== ▁F n v Hash ▁. ▁Constants ▁. ▁INTEGER ▁) ▁{ ▁dataType ▁= ▁new ▁SQLDataType Impl ▁( ▁STR ▁) ▁; ▁} ▁else ▁if ▁( ▁name Hash ▁== ▁F n v Hash ▁. ▁Constants ▁. ▁FLOAT ▁|| ▁name Hash ▁== ▁F n v Hash ▁. ▁Constants ▁. ▁BINARY _ FLOAT ▁) ▁{ ▁dataType ▁= ▁new ▁SQLDataType Impl ▁( ▁STR ▁) ▁; ▁} ▁else ▁if ▁( ▁name Hash ▁== ▁F n v Hash ▁. ▁Constants ▁. ▁REAL ▁|| ▁name Hash ▁== ▁F n v Hash ▁. ▁Constants ▁. ▁BINARY _ D OUBLE ▁|| ▁name Hash ▁== ▁F n v Hash ▁. ▁Constants ▁. ▁DOUBLE _ PRE CISION ▁) ▁{ ▁dataType ▁= ▁new ▁SQLDataType Impl ▁( ▁STR ▁) ▁; ▁} ▁else ▁if ▁( ▁name Hash ▁== ▁F n v Hash ▁. ▁Constants ▁. ▁NUMBER ▁) ▁{ ▁if ▁( ▁argument ns ▁. ▁size ▁( ▁) ▁== ▁0 ▁) ▁{ ▁dataType ▁= ▁new ▁SQLDataType Impl ▁( ▁STR ▁, ▁3 8 ▁) ▁; ▁} ▁else ▁{ ▁SQLExpr ▁arg 0 ▁= ▁argument ns ▁. ▁get ▁( ▁0 ▁) ▁; ▁int ▁precision ▁, ▁scale ▁= ▁0 ▁; ▁if ▁( ▁arg 0 ▁instanceof ▁SQL All Column Expr ▁) ▁{ ▁precision ▁= ▁9 ▁; ▁} ▁else ▁{ ▁precision ▁= ▁( ▁( ▁SQLIntegerExpr ▁) ▁arg 0 ▁) ▁. ▁getNumber ▁( ▁) ▁. ▁intValue ▁( ▁) ▁; ▁} ▁if ▁( ▁argument ns ▁. ▁size ▁( ▁) ▁> ▁1 ▁) ▁{ ▁scale ▁= ▁( ▁( ▁SQLIntegerExpr ▁) ▁argument ns ▁. ▁get ▁( ▁1 ▁) ▁) ▁. ▁getNumber ▁( ▁) ▁. ▁intValue ▁( ▁) ▁; ▁} ▁if ▁( ▁scale ▁> ▁precision ▁) ▁{ ▁if ▁( ▁arg 0 ▁instanceof ▁SQL All Column Expr ▁) ▁{ ▁precision ▁= ▁19 ▁; ▁if ▁( ▁scale ▁> ▁precision ▁) ▁{ ▁precision ▁= ▁scale ▁;
▁public ▁class ▁Reader Context ▁{ ▁private ▁final ▁Resource ▁resource ▁; ▁private ▁final ▁Pro blem Reporter ▁pro blem Reporter ▁; ▁private ▁final ▁Reader EventListener ▁eventListener ▁; ▁private ▁final ▁Source Extractor ▁source Extractor ▁; ▁public ▁Reader Context ▁( ▁Resource ▁resource ▁, ▁Pro blem Reporter ▁pro blem Reporter ▁, ▁Reader EventListener ▁eventListener ▁, ▁Source Extractor ▁source Extractor ▁) ▁{ ▁this ▁. ▁resource ▁= ▁resource ▁; ▁this ▁. ▁pro blem Reporter ▁= ▁pro blem Reporter ▁; ▁this ▁. ▁eventListener ▁= ▁eventListener ▁; ▁this ▁. ▁source Extractor ▁= ▁source Extractor ▁; ▁} ▁public ▁final ▁Resource ▁getResource ▁( ▁) ▁{ ▁return ▁this ▁. ▁resource ▁; ▁} ▁public ▁void ▁fatal ▁( ▁String ▁message ▁, ▁@ ▁Nullable ▁Object ▁source ▁) ▁{ ▁fatal ▁( ▁message ▁, ▁source ▁, ▁null ▁, ▁null ▁) ▁; ▁} ▁public ▁void ▁fatal ▁( ▁String ▁message ▁, ▁@ ▁Nullable ▁Object ▁source ▁, ▁@ ▁Nullable ▁Throwable ▁cause ▁) ▁{ ▁fatal ▁( ▁message ▁, ▁source ▁, ▁null ▁, ▁cause ▁) ▁; ▁} ▁public ▁void ▁fatal ▁( ▁String ▁message ▁, ▁@ ▁Nullable ▁Object ▁source ▁, ▁@ ▁Nullable ▁Parse State ▁parse State ▁) ▁{ ▁fatal ▁( ▁message ▁, ▁source ▁, ▁parse State ▁, ▁null ▁) ▁; ▁} ▁public ▁void ▁fatal ▁( ▁String ▁message ▁, ▁@ ▁Nullable ▁Object ▁source ▁, ▁@ ▁Nullable ▁Parse State ▁parse State ▁, ▁@ ▁Nullable ▁Throwable ▁cause ▁) ▁{ ▁Location ▁location ▁= ▁new ▁Location ▁( ▁getResource ▁( ▁) ▁, ▁source ▁) ▁; ▁this ▁. ▁pro blem Reporter ▁. ▁fatal ▁( ▁new ▁Pro blem ▁( ▁message ▁, ▁location ▁, ▁parse State ▁, ▁cause ▁) ▁) ▁; ▁} ▁public ▁void ▁error ▁( ▁String ▁message ▁, ▁@ ▁Nullable ▁Object ▁source ▁) ▁{ ▁error ▁( ▁message ▁, ▁source ▁, ▁null ▁, ▁null ▁) ▁; ▁} ▁public ▁void ▁error ▁( ▁String ▁message ▁, ▁@ ▁Nullable ▁Object ▁source ▁, ▁@ ▁Nullable ▁Throwable ▁cause ▁) ▁{ ▁error ▁( ▁message ▁, ▁source ▁, ▁null ▁, ▁cause ▁) ▁; ▁} ▁public ▁void ▁error ▁( ▁String ▁message ▁, ▁@ ▁Nullable ▁Object ▁source ▁, ▁@ ▁Nullable ▁Parse State ▁parse State ▁) ▁{ ▁error ▁( ▁message ▁, ▁source ▁, ▁parse State ▁, ▁null ▁) ▁; ▁} ▁public ▁void ▁error ▁( ▁String ▁message ▁, ▁@ ▁Nullable ▁Object ▁source ▁, ▁@ ▁Nullable ▁Parse State ▁parse State ▁, ▁@ ▁Nullable ▁Throwable ▁cause ▁) ▁{ ▁Location ▁location ▁= ▁new ▁Location ▁( ▁getResource ▁( ▁) ▁, ▁source ▁) ▁; ▁this ▁. ▁pro blem Reporter ▁. ▁error ▁( ▁new ▁Pro blem ▁( ▁message ▁, ▁location ▁, ▁parse State ▁, ▁cause ▁) ▁) ▁; ▁} ▁public ▁void ▁warning ▁( ▁String ▁message ▁, ▁@ ▁Nullable ▁Object ▁source ▁) ▁{ ▁warning ▁( ▁message ▁, ▁source ▁, ▁null ▁, ▁null ▁) ▁; ▁} ▁public ▁void ▁warning ▁( ▁String ▁message ▁, ▁@ ▁Nullable ▁Object ▁source ▁, ▁@ ▁Nullable ▁Throwable ▁cause ▁) ▁{ ▁warning ▁( ▁message ▁, ▁source ▁, ▁null ▁, ▁cause ▁) ▁; ▁} ▁public ▁void ▁warning ▁( ▁String ▁message ▁, ▁@ ▁Nullable ▁Object ▁source ▁, ▁@ ▁Nullable ▁Parse State ▁parse State ▁) ▁{ ▁warning ▁( ▁message ▁, ▁source ▁, ▁parse State ▁, ▁null ▁) ▁; ▁}
▁Iterator ▁< ▁String ▁> ▁names Iter ▁= ▁orig Names ▁. ▁iterator ▁( ▁) ▁; ▁Iterator ▁< ▁ColumnMetaData ▁> ▁meta Iter ▁= ▁orig Meta ▁. ▁iterator ▁( ▁) ▁; ▁while ▁( ▁names Iter ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁String ▁n ▁= ▁names Iter ▁. ▁next ▁( ▁) ▁; ▁ColumnMetaData ▁t ▁= ▁meta Iter ▁. ▁next ▁( ▁) ▁; ▁if ▁( ▁! ▁set ▁. ▁contains ▁( ▁n ▁) ▁) ▁{ ▁new Meta ▁. ▁add ▁( ▁t ▁) ▁; ▁} ▁} ▁return ▁schema ▁. ▁new Schema ▁( ▁new Meta ▁) ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁Writable ▁> ▁map ▁( ▁List ▁< ▁Writable ▁> ▁writable s ▁) ▁{ ▁if ▁( ▁writable s ▁. ▁size ▁( ▁) ▁!= ▁inputSchema ▁. ▁num Columns ▁( ▁) ▁) ▁{ ▁List ▁< ▁String ▁> ▁list ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁Writable ▁w ▁: ▁writable s ▁) ▁list ▁. ▁add ▁( ▁w ▁. ▁toString ▁( ▁) ▁) ▁; ▁String ▁toString ▁= ▁StringUtils ▁. ▁join ▁( ▁list ▁, ▁STR ▁) ▁; ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁+ ▁writable s ▁. ▁size ▁( ▁) ▁+ ▁STR ▁+ ▁STR ▁+ ▁inputSchema ▁. ▁num Columns ▁( ▁) ▁+ ▁STR ▁+ ▁toString ▁( ▁) ▁+ ▁STR ▁+ ▁toString ▁) ▁; ▁} ▁List ▁< ▁Writable ▁> ▁out List ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁writable s ▁. ▁size ▁( ▁) ▁- ▁column sTo Remove ▁. ▁length ▁) ▁; ▁int ▁i ▁= ▁0 ▁; ▁for ▁( ▁Writable ▁w ▁: ▁writable s ▁) ▁{ ▁if ▁( ▁indices ToRemove ▁. ▁contains ▁( ▁i ▁++ ▁) ▁) ▁continue ▁; ▁out List ▁. ▁add ▁( ▁w ▁) ▁; ▁} ▁return ▁out List ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁map ▁( ▁Object ▁input ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁map Sequence ▁( ▁Object ▁sequence ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁Arrays ▁. ▁toString ▁( ▁column sTo Remove ▁) ▁+ ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁o ▁) ▁{ ▁if ▁( ▁this ▁== ▁o ▁) ▁return ▁true ▁; ▁if ▁( ▁o ▁== ▁null ▁|| ▁getClass ▁( ▁) ▁!= ▁o ▁. ▁getClass ▁( ▁) ▁) ▁return ▁false ▁; ▁Remove Columns Transform ▁o 2 ▁= ▁( ▁Remove Columns Transform ▁) ▁o ▁; ▁return ▁Arrays ▁. ▁equals ▁( ▁column sTo Remove ▁, ▁o 2 ▁. ▁column sTo Remove ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁Arrays ▁. ▁hashCode ▁( ▁column sTo Remove ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁output ColumnName ▁( ▁) ▁{ ▁return ▁output ColumnNames ▁( ▁) ▁[ ▁0 ▁] ▁; ▁} ▁@ ▁Override ▁public ▁String ▁[ ▁] ▁output ColumnNames ▁( ▁) ▁{ ▁return ▁left Over Columns ▁; ▁} ▁@ ▁Override ▁public ▁String ▁[ ▁] ▁columnNames ▁( ▁) ▁{ ▁return ▁inputSchema ▁. ▁getColumn Names ▁( ▁) ▁. ▁toArray ▁( ▁new ▁String ▁[ ▁inputSchema ▁. ▁num Columns ▁( ▁) ▁] ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁columnName ▁( ▁) ▁{ ▁return ▁columnNames ▁( ▁) ▁[ ▁0 ▁] ▁; ▁}
▁public ▁final ▁class ▁String Compare To AV X 5 12 Test ▁extends ▁Graal CompilerTest ▁{ ▁public ▁static ▁int ▁compareTo ▁( ▁String ▁str 1 ▁, ▁String ▁str 2 ▁) ▁{ ▁return ▁str 1 ▁. ▁compareTo ▁( ▁str 2 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Lat in 1 V s Utf 16 Bad Stride ▁( ▁) ▁{ ▁String ▁lat in 1 ▁= ▁STR ▁; ▁String ▁utf 16 ▁= ▁STR ▁; ▁test ▁( ▁STR ▁, ▁lat in 1 ▁, ▁utf 16 ▁) ▁; ▁test ▁( ▁STR ▁, ▁utf 16 ▁, ▁lat in 1 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Lat in 1 V s Utf 16 Bad Stride 2 ▁( ▁) ▁{ ▁String ▁lat in 1 ▁= ▁STR ▁; ▁String ▁utf 16 ▁= ▁STR ▁; ▁test ▁( ▁STR ▁, ▁lat in 1 ▁, ▁utf 16 ▁) ▁; ▁test ▁( ▁STR ▁, ▁utf 16 ▁, ▁lat in 1 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Lat in 1 V s Utf 16 False Equality ▁( ▁) ▁{ ▁String ▁lat in 1 ▁= ▁STR ▁; ▁String ▁utf 16 ▁= ▁STR ▁; ▁test ▁( ▁STR ▁, ▁lat in 1 ▁, ▁utf 16 ▁) ▁; ▁test ▁( ▁STR ▁, ▁utf 16 ▁, ▁lat in 1 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Lat in 1 B ey ond Range ▁( ▁) ▁{ ▁StringBuilder ▁lat in 1 Builder ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁<= ▁255 ▁; ▁++ ▁j ▁) ▁{ ▁lat in 1 Builder ▁. ▁append ▁( ▁( ▁char ▁) ▁j ▁) ▁; ▁} ▁String ▁lat in 1 ▁= ▁lat in 1 Builder ▁. ▁toString ▁( ▁) ▁; ▁test ▁( ▁STR ▁, ▁lat in 1 ▁, ▁String ▁. ▁valueOf ▁( ▁lat in 1 ▁. ▁toCharArray ▁( ▁) ▁) ▁) ▁; ▁} ▁}
▁@ ▁Override ▁public ▁List ▁< ▁Address ▁> ▁unresolved In direct Flow ▁( ▁PcodeOp ▁op ▁, ▁int ▁instr Op Index ▁, ▁Varnode ▁destination ▁, ▁Context State ▁currentState ▁, ▁Results State ▁results ▁, ▁TaskMonitor ▁monitor ▁) ▁throws ▁Cancelled Exception ▁{ ▁return ▁null ▁; ▁} ▁} ▁, ▁currentProgram ▁, ▁true ▁, ▁monitor ▁) ▁; ▁AddressSetView ▁ex am ined Set ▁= ▁results ▁. ▁getEx am ined Set ▁( ▁) ▁; ▁if ▁( ▁ex am ined Set ▁!= ▁null ▁) ▁{ ▁PluginTool ▁tool ▁= ▁state ▁. ▁getTool ▁( ▁) ▁; ▁if ▁( ▁tool ▁!= ▁null ▁) ▁{ ▁tool ▁. ▁fire PluginEvent ▁( ▁new ▁Program Selection PluginEvent ▁( ▁STR ▁, ▁new ▁Program Selection ▁( ▁ex am ined Set ▁) ▁, ▁currentProgram ▁) ▁) ▁; ▁} ▁} ▁List ▁< ▁Register ▁> ▁reg List ▁= ▁sort ▁( ▁results ▁. ▁getMod ified Registers ▁( ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁reg List ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁sort ▁( ▁results ▁. ▁getPre served Registers ▁( ▁) ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁sort ▁( ▁results ▁. ▁getInput Registers ▁( ▁) ▁) ▁) ▁; ▁for ▁( ▁Results State ▁. ▁Frame Pointer Candidate ▁candidate ▁: ▁results ▁. ▁getFrame Pointer Candidates ▁( ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁candidate ▁) ▁; ▁} ▁for ▁( ▁Sequence Number ▁seq ▁: ▁results ▁. ▁get Return Addresses ▁( ▁) ▁) ▁{ ▁int ▁index ▁= ▁0 ▁; ▁Iterator ▁< ▁Context State ▁> ▁context States ▁= ▁results ▁. ▁getContext States ▁( ▁seq ▁) ▁; ▁while ▁( ▁context States ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁dump Stack State ▁( ▁seq ▁, ▁++ ▁index ▁, ▁context States ▁. ▁next ▁( ▁) ▁) ▁; ▁} ▁} ▁List ▁< ▁Register ▁> ▁registers ▁= ▁currentProgram ▁. ▁getLanguage ▁( ▁) ▁. ▁get Registers ▁( ▁) ▁; ▁try ▁{ ▁Register ▁reg ▁= ▁ask Choice ▁( ▁STR ▁, ▁STR ▁, ▁registers ▁, ▁null ▁) ▁; ▁while ▁( ▁reg ▁!= ▁null ▁) ▁{ ▁boolean ▁first ▁= ▁true ▁; ▁boolean ▁pre served ▁= ▁true ▁; ▁Varnode ▁v ▁= ▁new ▁Varnode ▁( ▁reg ▁. ▁getAddress ▁( ▁) ▁, ▁reg ▁. ▁getMinimum Byte Size ▁( ▁) ▁) ▁; ▁Set ▁< ▁Varnode ▁> ▁return Values ▁= ▁results ▁. ▁get Return Values ▁( ▁v ▁) ▁; ▁for ▁( ▁Varnode ▁val ▁: ▁return Values ▁) ▁{ ▁if ▁( ▁! ▁v ▁. ▁equals ▁( ▁val ▁) ▁) ▁{ ▁pre served ▁= ▁false ▁; ▁if ▁( ▁first ▁) ▁{ ▁first ▁= ▁false ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁reg ▁. ▁getName ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁val ▁. ▁toString ▁( ▁currentProgram ▁. ▁getLanguage ▁( ▁) ▁) ▁) ▁; ▁} ▁} ▁if ▁( ▁pre served ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁reg ▁. ▁getName ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁reg ▁= ▁ask Choice ▁( ▁STR ▁, ▁STR ▁, ▁registers ▁, ▁null ▁) ▁; ▁} ▁} ▁catch ▁( ▁Cancelled Exception ▁e ▁) ▁{ ▁} ▁}
▁assertEquals ▁( ▁s 1 ▁. ▁getCount ▁( ▁) ▁, ▁s 2 ▁. ▁getCount ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁s 1 ▁. ▁getMin ▁( ▁) ▁, ▁s 2 ▁. ▁getMin ▁( ▁) ▁, ▁0 d ▁) ▁; ▁assertEquals ▁( ▁s 1 ▁. ▁getMax ▁( ▁) ▁, ▁s 2 ▁. ▁getMax ▁( ▁) ▁, ▁0 d ▁) ▁; ▁assertEquals ▁( ▁s 1 ▁. ▁getSt d Deviation ▁( ▁) ▁, ▁s 2 ▁. ▁getSt d Deviation ▁( ▁) ▁, ▁1 e - 10 ▁) ▁; ▁assertEquals ▁( ▁s 1 ▁. ▁getSt d Deviation Pop ulation ▁( ▁) ▁, ▁s 2 ▁. ▁getSt d Deviation Pop ulation ▁( ▁) ▁, ▁1 e - 10 ▁) ▁; ▁assertEquals ▁( ▁s 1 ▁. ▁getSt d Deviation Sampling ▁( ▁) ▁, ▁s 2 ▁. ▁getSt d Deviation Sampling ▁( ▁) ▁, ▁1 e - 10 ▁) ▁; ▁assertEquals ▁( ▁s 1 ▁. ▁getSum Of Square s ▁( ▁) ▁, ▁s 2 ▁. ▁getSum Of Square s ▁( ▁) ▁, ▁1 e - 10 ▁) ▁; ▁assertEquals ▁( ▁s 1 ▁. ▁getSt d Deviation Bound ▁( ▁Bound s ▁. ▁LOW ER ▁) ▁, ▁s 2 ▁. ▁getSt d Deviation Bound ▁( ▁Bound s ▁. ▁LOW ER ▁) ▁, ▁1 e - 10 ▁) ▁; ▁assertEquals ▁( ▁s 1 ▁. ▁getSt d Deviation Bound ▁( ▁Bound s ▁. ▁U PPER ▁) ▁, ▁s 2 ▁. ▁getSt d Deviation Bound ▁( ▁Bound s ▁. ▁U PPER ▁) ▁, ▁1 e - 10 ▁) ▁; ▁assertEquals ▁( ▁s 1 ▁. ▁getSt d Deviation Bound ▁( ▁Bound s ▁. ▁LOW ER _ POP UL ATION ▁) ▁, ▁s 2 ▁. ▁getSt d Deviation Bound ▁( ▁Bound s ▁. ▁LOW ER _ POP UL ATION ▁) ▁, ▁1 e - 10 ▁) ▁; ▁assertEquals ▁( ▁s 1 ▁. ▁getSt d Deviation Bound ▁( ▁Bound s ▁. ▁U PPER _ POP UL ATION ▁) ▁, ▁s 2 ▁. ▁getSt d Deviation Bound ▁( ▁Bound s ▁. ▁U PPER _ POP UL ATION ▁) ▁, ▁1 e - 10 ▁) ▁; ▁assertEquals ▁( ▁s 1 ▁. ▁getSt d Deviation Bound ▁( ▁Bound s ▁. ▁LOW ER _ S AMP LING ▁) ▁, ▁s 2 ▁. ▁getSt d Deviation Bound ▁( ▁Bound s ▁. ▁LOW ER _ S AMP LING ▁) ▁, ▁1 e - 10 ▁) ▁; ▁assertEquals ▁( ▁s 1 ▁. ▁getSt d Deviation Bound ▁( ▁Bound s ▁. ▁U PPER _ S AMP LING ▁) ▁, ▁s 2 ▁. ▁getSt d Deviation Bound ▁( ▁Bound s ▁. ▁U PPER _ S AMP LING ▁) ▁, ▁1 e - 10 ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁test SingleValue d Field ▁( ▁) ▁throws ▁Exception ▁{ ▁double ▁sig ma ▁= ▁randomDouble ▁( ▁) ▁ * ▁randomInt Between ▁( ▁1 ▁, ▁10 ▁) ▁; ▁SearchResponse ▁searchResponse ▁= ▁client ▁( ▁) ▁. ▁prepareSearch ▁( ▁STR ▁) ▁. ▁setQuery ▁( ▁match All Query ▁( ▁) ▁) ▁. ▁add Aggregation ▁( ▁extended Stats ▁( ▁STR ▁) ▁. ▁field ▁( ▁STR ▁) ▁. ▁sig ma ▁( ▁sig ma ▁) ▁) ▁. ▁get ▁( ▁) ▁;
▁} ▁public ▁boolean ▁isD rag ging ▁( ▁) ▁{ ▁return ▁m State ▁== ▁STATE _ DR AG G ING ▁; ▁} ▁@ ▁Visible ForTesting ▁boolean ▁isVisible ▁( ▁) ▁{ ▁return ▁m State ▁== ▁STATE _ VI SIBLE ▁; ▁} ▁public ▁void ▁show ▁( ▁) ▁{ ▁switch ▁( ▁m Animation State ▁) ▁{ ▁case ▁A NI M ATION _ STATE _ FA DING _ OUT ▁: ▁m Show H ide Animator ▁. ▁cancel ▁( ▁) ▁; ▁case ▁A NI M ATION _ STATE _ OUT ▁: ▁m Animation State ▁= ▁A NI M ATION _ STATE _ FA DING _ IN ▁; ▁m Show H ide Animator ▁. ▁set Float Values ▁( ▁( ▁float ▁) ▁m Show H ide Animator ▁. ▁get Animated Value ▁( ▁) ▁, ▁1 ▁) ▁; ▁m Show H ide Animator ▁. ▁setDuration ▁( ▁SH OW _ DURATION _ MS ▁) ▁; ▁m Show H ide Animator ▁. ▁setStart Delay ▁( ▁0 ▁) ▁; ▁m Show H ide Animator ▁. ▁start ▁( ▁) ▁; ▁break ▁; ▁} ▁} ▁@ ▁Visible ForTesting ▁void ▁hide ▁( ▁int ▁duration ▁) ▁{ ▁switch ▁( ▁m Animation State ▁) ▁{ ▁case ▁A NI M ATION _ STATE _ FA DING _ IN ▁: ▁m Show H ide Animator ▁. ▁cancel ▁( ▁) ▁; ▁case ▁A NI M ATION _ STATE _ IN ▁: ▁m Animation State ▁= ▁A NI M ATION _ STATE _ FA DING _ OUT ▁; ▁m Show H ide Animator ▁. ▁set Float Values ▁( ▁( ▁float ▁) ▁m Show H ide Animator ▁. ▁get Animated Value ▁( ▁) ▁, ▁0 ▁) ▁; ▁m Show H ide Animator ▁. ▁setDuration ▁( ▁duration ▁) ▁; ▁m Show H ide Animator ▁. ▁start ▁( ▁) ▁; ▁break ▁; ▁} ▁} ▁private ▁void ▁cancel H ide ▁( ▁) ▁{ ▁m Rec yclerView ▁. ▁remove Callbacks ▁( ▁m H ide Runnable ▁) ▁; ▁} ▁private ▁void ▁reset H ide Delay ▁( ▁int ▁delay ▁) ▁{ ▁cancel H ide ▁( ▁) ▁; ▁m Rec yclerView ▁. ▁post Delayed ▁( ▁m H ide Runnable ▁, ▁delay ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁on Draw Over ▁( ▁Canvas ▁canvas ▁, ▁RecyclerView ▁parent ▁, ▁RecyclerView ▁. ▁State ▁state ▁) ▁{ ▁if ▁( ▁m Rec yclerView Width ▁!= ▁m Rec yclerView ▁. ▁getWidth ▁( ▁) ▁|| ▁m Rec yclerView Height ▁!= ▁m Rec yclerView ▁. ▁getHeight ▁( ▁) ▁) ▁{ ▁m Rec yclerView Width ▁= ▁m Rec yclerView ▁. ▁getWidth ▁( ▁) ▁; ▁m Rec yclerView Height ▁= ▁m Rec yclerView ▁. ▁getHeight ▁( ▁) ▁; ▁setState ▁( ▁STATE _ H IDDEN ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁m Animation State ▁!= ▁A NI M ATION _ STATE _ OUT ▁) ▁{ ▁if ▁( ▁m Need Vertical Scroll bar ▁) ▁{ ▁draw Vertical Scroll bar ▁( ▁canvas ▁) ▁; ▁} ▁if ▁( ▁m Need H orizontal Scroll bar ▁) ▁{ ▁draw H orizontal Scroll bar ▁( ▁canvas ▁) ▁; ▁} ▁} ▁} ▁private ▁void ▁draw Vertical Scroll bar ▁( ▁Canvas ▁canvas ▁) ▁{ ▁int ▁view Width ▁= ▁m Rec yclerView Width ▁;
▁public ▁class ▁FreeMarker Macro Tests ▁{ ▁private ▁static ▁final ▁String ▁TEMP LATE _ FILE ▁= ▁STR ▁; ▁private ▁Static WebApplication Context ▁wac ▁; ▁private ▁MockHttpServlet Request ▁request ▁; ▁private ▁MockHttpServlet Response ▁response ▁; ▁private ▁FreeMarker Configurer ▁fc ▁; ▁@ ▁BeforeEach ▁public ▁void ▁setUp ▁( ▁) ▁throws ▁Exception ▁{ ▁ServletContext ▁sc ▁= ▁new ▁Mock ServletContext ▁( ▁) ▁; ▁wac ▁= ▁new ▁Static WebApplication Context ▁( ▁) ▁; ▁wac ▁. ▁set ServletContext ▁( ▁sc ▁) ▁; ▁fc ▁= ▁new ▁FreeMarker Configurer ▁( ▁) ▁; ▁fc ▁. ▁set Template Loader Paths ▁( ▁STR ▁, ▁STR ▁+ ▁System ▁. ▁getProperty ▁( ▁STR ▁) ▁) ▁; ▁fc ▁. ▁set ServletContext ▁( ▁sc ▁) ▁; ▁fc ▁. ▁after PropertiesSet ▁( ▁) ▁; ▁wac ▁. ▁getDefault List ableBeanFactory ▁( ▁) ▁. ▁register Singleton ▁( ▁STR ▁, ▁fc ▁) ▁; ▁wac ▁. ▁refresh ▁( ▁) ▁; ▁request ▁= ▁new ▁MockHttpServlet Request ▁( ▁) ▁; ▁request ▁. ▁setAttribute ▁( ▁Dispatcher Servlet ▁. ▁WEB _ APPLICATION _ CONTEXT _ ATTRIBUTE ▁, ▁wac ▁) ▁; ▁request ▁. ▁setAttribute ▁( ▁Dispatcher Servlet ▁. ▁LO CA LE _ RESOL VER _ ATTRIBUTE ▁, ▁new ▁Accept Header Locale Resolver ▁( ▁) ▁) ▁; ▁request ▁. ▁setAttribute ▁( ▁Dispatcher Servlet ▁. ▁T HE ME _ RESOL VER _ ATTRIBUTE ▁, ▁new ▁Fixed Theme Resolver ▁( ▁) ▁) ▁; ▁response ▁= ▁new ▁MockHttpServlet Response ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Ex pose Spring Macro Helpers ▁( ▁) ▁throws ▁Exception ▁{ ▁FreeMarker View ▁f v ▁= ▁new ▁FreeMarker View ▁( ▁) ▁{ ▁@ ▁Override ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁protected ▁void ▁process Template ▁( ▁Template ▁template ▁, ▁Simple Hash ▁fm Model ▁, ▁HttpServlet Response ▁response ▁) ▁throws ▁Template Exception ▁{ ▁Map ▁model ▁= ▁fm Model ▁. ▁toMap ▁( ▁) ▁; ▁assertThat ▁( ▁model ▁. ▁get ▁( ▁FreeMarker View ▁. ▁SPRING _ MAC RO _ REQUEST _ CONTEXT _ ATTRIBUTE ▁) ▁) ▁. ▁isInstanceOf ▁( ▁RequestContext ▁. ▁class ▁) ▁; ▁RequestContext ▁rc ▁= ▁( ▁RequestContext ▁) ▁model ▁. ▁get ▁( ▁FreeMarker View ▁. ▁SPRING _ MAC RO _ REQUEST _ CONTEXT _ ATTRIBUTE ▁) ▁; ▁Bind Status ▁status ▁= ▁rc ▁. ▁getBind Status ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁status ▁. ▁getExpression ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁status ▁. ▁getValue ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁} ▁} ▁; ▁f v ▁. ▁setUrl ▁( ▁TEMP LATE _ FILE ▁) ▁; ▁f v ▁. ▁setApplication Context ▁( ▁wac ▁) ▁; ▁Map ▁< ▁String ▁, ▁Object ▁> ▁model ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁model ▁. ▁put ▁( ▁STR ▁, ▁new ▁TestBean ▁( ▁STR ▁, ▁99 ▁) ▁) ▁; ▁f v ▁. ▁render ▁( ▁model ▁, ▁request ▁, ▁response ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Spring Macro Request Context Attribute Used ▁( ▁) ▁{ ▁final ▁String ▁helper Tool ▁= ▁STR ▁; ▁FreeMarker View ▁f v ▁= ▁new ▁FreeMarker View ▁( ▁) ▁{ ▁@ ▁Override ▁protected ▁void ▁process Template ▁( ▁Template ▁template ▁, ▁Simple Hash ▁model ▁, ▁HttpServlet Response ▁response ▁) ▁{ ▁throw ▁new ▁AssertionError ▁( ▁) ▁; ▁} ▁} ▁;
▁public ▁void ▁setIn dic est ype ▁( ▁int ▁value ▁) ▁{ ▁CollisionJNI ▁. ▁btG Imp act Mesh Shape Part _ Trim esh Primitive Manager _ ind ic est ype _ set ▁( ▁swigCPtr ▁, ▁this ▁, ▁value ▁) ▁; ▁} ▁public ▁int ▁getIn dic est ype ▁( ▁) ▁{ ▁return ▁CollisionJNI ▁. ▁btG Imp act Mesh Shape Part _ Trim esh Primitive Manager _ ind ic est ype _ get ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁T rim esh Primitive Manager ▁( ▁) ▁{ ▁this ▁( ▁CollisionJNI ▁. ▁new _ bt G Imp act Mesh Shape Part _ Trim esh Primitive Manager __ SWIG _0 ▁( ▁) ▁, ▁true ▁) ▁; ▁} ▁public ▁T rim esh Primitive Manager ▁( ▁btG Imp act Mesh Shape Part ▁. ▁T rim esh Primitive Manager ▁manager ▁) ▁{ ▁this ▁( ▁CollisionJNI ▁. ▁new _ bt G Imp act Mesh Shape Part _ Trim esh Primitive Manager __ SWIG _1 ▁( ▁btG Imp act Mesh Shape Part ▁. ▁T rim esh Primitive Manager ▁. ▁getCPtr ▁( ▁manager ▁) ▁, ▁manager ▁) ▁, ▁true ▁) ▁; ▁} ▁public ▁T rim esh Primitive Manager ▁( ▁bt St rid ing Mesh Interface ▁mesh Interface ▁, ▁int ▁part ▁) ▁{ ▁this ▁( ▁CollisionJNI ▁. ▁new _ bt G Imp act Mesh Shape Part _ Trim esh Primitive Manager __ SWIG _2 ▁( ▁bt St rid ing Mesh Interface ▁. ▁getCPtr ▁( ▁mesh Interface ▁) ▁, ▁mesh Interface ▁, ▁part ▁) ▁, ▁true ▁) ▁; ▁} ▁public ▁void ▁lock ▁( ▁) ▁{ ▁CollisionJNI ▁. ▁btG Imp act Mesh Shape Part _ Trim esh Primitive Manager _ lock ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁void ▁unlock ▁( ▁) ▁{ ▁CollisionJNI ▁. ▁btG Imp act Mesh Shape Part _ Trim esh Primitive Manager _ un lock ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁int ▁get _ ver tex _ count ▁( ▁) ▁{ ▁return ▁CollisionJNI ▁. ▁btG Imp act Mesh Shape Part _ Trim esh Primitive Manager _ get _ ver tex _ count ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁void ▁get _ ind ices ▁( ▁int ▁f ace _ index ▁, ▁SWIGTYPE _ p _ un s igned _ int ▁i 0 ▁, ▁SWIGTYPE _ p _ un s igned _ int ▁i 1 ▁, ▁SWIGTYPE _ p _ un s igned _ int ▁i 2 ▁) ▁{ ▁CollisionJNI ▁. ▁btG Imp act Mesh Shape Part _ Trim esh Primitive Manager _ get _ ind ices ▁( ▁swigCPtr ▁, ▁this ▁, ▁f ace _ index ▁, ▁SWIGTYPE _ p _ un s igned _ int ▁. ▁getCPtr ▁( ▁i 0 ▁) ▁, ▁SWIGTYPE _ p _ un s igned _ int ▁. ▁getCPtr ▁( ▁i 1 ▁) ▁, ▁SWIGTYPE _ p _ un s igned _ int ▁. ▁getCPtr ▁( ▁i 2 ▁) ▁) ▁; ▁}
▁public ▁class ▁Jackson Json View UnitTest ▁{ ▁@ ▁Test ▁public ▁void ▁when Use Json View To Serialize _ thenCorrect ▁( ▁) ▁throws ▁JsonProcessing Exception ▁{ ▁final ▁User ▁user ▁= ▁new ▁User ▁( ▁1 ▁, ▁STR ▁) ▁; ▁final ▁ObjectMapper ▁mapper ▁= ▁new ▁ObjectMapper ▁( ▁) ▁; ▁mapper ▁. ▁disable ▁( ▁Mapper Feature ▁. ▁DEFAULT _ VIEW _ IN CLU SION ▁) ▁; ▁final ▁String ▁result ▁= ▁mapper ▁. ▁writer WithView ▁( ▁View s ▁. ▁Public ▁. ▁class ▁) ▁. ▁writeValue AsString ▁( ▁user ▁) ▁; ▁assertThat ▁( ▁result ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁result ▁, ▁not ▁( ▁containsString ▁( ▁STR ▁) ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁when Use Public View _ then Only Public Serialized ▁( ▁) ▁throws ▁JsonProcessing Exception ▁{ ▁final ▁Item ▁item ▁= ▁new ▁Item ▁( ▁2 ▁, ▁STR ▁, ▁STR ▁) ▁; ▁final ▁ObjectMapper ▁mapper ▁= ▁new ▁ObjectMapper ▁( ▁) ▁; ▁final ▁String ▁result ▁= ▁mapper ▁. ▁writer WithView ▁( ▁View s ▁. ▁Public ▁. ▁class ▁) ▁. ▁writeValue AsString ▁( ▁item ▁) ▁; ▁assertThat ▁( ▁result ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁result ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁result ▁, ▁not ▁( ▁containsString ▁( ▁STR ▁) ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁when Use Internal View _ then All Serialized ▁( ▁) ▁throws ▁JsonProcessing Exception ▁{ ▁final ▁Item ▁item ▁= ▁new ▁Item ▁( ▁2 ▁, ▁STR ▁, ▁STR ▁) ▁; ▁final ▁ObjectMapper ▁mapper ▁= ▁new ▁ObjectMapper ▁( ▁) ▁; ▁final ▁String ▁result ▁= ▁mapper ▁. ▁writer WithView ▁( ▁View s ▁. ▁Internal ▁. ▁class ▁) ▁. ▁writeValue AsString ▁( ▁item ▁) ▁; ▁assertThat ▁( ▁result ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁result ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁result ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁when Use Json View To Deserialize _ thenCorrect ▁( ▁) ▁throws ▁IOException ▁{ ▁final ▁String ▁json ▁= ▁STR ▁; ▁final ▁ObjectMapper ▁mapper ▁= ▁new ▁ObjectMapper ▁( ▁) ▁; ▁final ▁User ▁user ▁= ▁mapper ▁. ▁reader WithView ▁( ▁View s ▁. ▁Public ▁. ▁class ▁) ▁. ▁for Type ▁( ▁User ▁. ▁class ▁) ▁. ▁readValue ▁( ▁json ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁user ▁. ▁getId ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁user ▁. ▁getName ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁when Use Custom Json View To Serialize _ thenCorrect ▁( ▁) ▁throws ▁JsonProcessing Exception ▁{ ▁final ▁User ▁user ▁= ▁new ▁User ▁( ▁1 ▁, ▁STR ▁) ▁; ▁final ▁Serializer Factory ▁serializer Factory ▁= ▁Bean Serializer Factory ▁. ▁instance ▁. ▁with Serializer Modifier ▁( ▁new ▁My Bean Serializer Modifier ▁( ▁) ▁) ▁; ▁final ▁ObjectMapper ▁mapper ▁= ▁new ▁ObjectMapper ▁( ▁) ▁; ▁mapper ▁. ▁set Serializer Factory ▁( ▁serializer Factory ▁) ▁; ▁final ▁String ▁result ▁= ▁mapper ▁. ▁writer WithView ▁( ▁View s ▁. ▁Public ▁. ▁class ▁) ▁. ▁writeValue AsString ▁( ▁user ▁) ▁; ▁assertThat ▁( ▁result ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁result ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁} ▁}
▁sync ▁( ▁set ▁. ▁add ▁( ▁i ▁ * ▁10 ▁, ▁10 ▁, ▁TimeUnit ▁. ▁SECONDS ▁) ▁) ▁; ▁} ▁Assertions ▁. ▁assertTrue ▁( ▁sync ▁( ▁set ▁. ▁retainAll ▁( ▁Arrays ▁. ▁asList ▁( ▁1 ▁, ▁2 ▁) ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁sync ▁( ▁set ▁) ▁) ▁. ▁contains ▁( ▁1 ▁, ▁2 ▁) ▁; ▁Assertions ▁. ▁assertEquals ▁( ▁2 ▁, ▁sync ▁( ▁set ▁. ▁size ▁( ▁) ▁) ▁. ▁intValue ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testContains All ▁( ▁) ▁{ ▁R Set Cache Rx ▁< ▁Integer ▁> ▁set ▁= ▁redisson ▁. ▁getSet Cache ▁( ▁STR ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁200 ▁; ▁i ▁++ ▁) ▁{ ▁sync ▁( ▁set ▁. ▁add ▁( ▁i ▁) ▁) ▁; ▁} ▁Assertions ▁. ▁assertTrue ▁( ▁sync ▁( ▁set ▁. ▁containsAll ▁( ▁Collections ▁. ▁emptyList ▁( ▁) ▁) ▁) ▁) ▁; ▁Assertions ▁. ▁assertTrue ▁( ▁sync ▁( ▁set ▁. ▁containsAll ▁( ▁Arrays ▁. ▁asList ▁( ▁30 ▁, ▁11 ▁) ▁) ▁) ▁) ▁; ▁Assertions ▁. ▁assertFalse ▁( ▁sync ▁( ▁set ▁. ▁containsAll ▁( ▁Arrays ▁. ▁asList ▁( ▁30 ▁, ▁7 11 ▁, ▁11 ▁) ▁) ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testContains ▁( ▁) ▁throws ▁Interrupted Exception ▁{ ▁R Set Cache Rx ▁< ▁Test Object ▁> ▁set ▁= ▁redisson ▁. ▁getSet Cache ▁( ▁STR ▁) ▁; ▁sync ▁( ▁set ▁. ▁add ▁( ▁new ▁Test Object ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁; ▁sync ▁( ▁set ▁. ▁add ▁( ▁new ▁Test Object ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁; ▁sync ▁( ▁set ▁. ▁add ▁( ▁new ▁Test Object ▁( ▁STR ▁, ▁STR ▁) ▁, ▁1 ▁, ▁TimeUnit ▁. ▁SECONDS ▁) ▁) ▁; ▁sync ▁( ▁set ▁. ▁add ▁( ▁new ▁Test Object ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁; ▁sync ▁( ▁set ▁. ▁add ▁( ▁new ▁Test Object ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁; ▁Thread ▁. ▁sleep ▁( ▁1000 ▁) ▁; ▁Assertions ▁. ▁assertFalse ▁( ▁sync ▁( ▁set ▁. ▁contains ▁( ▁new ▁Test Object ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁) ▁; ▁Assertions ▁. ▁assertTrue ▁( ▁sync ▁( ▁set ▁. ▁contains ▁( ▁new ▁Test Object ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁) ▁; ▁Assertions ▁. ▁assertFalse ▁( ▁sync ▁( ▁set ▁. ▁contains ▁( ▁new ▁Test Object ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Duplicates ▁( ▁) ▁{ ▁R Set Cache Rx ▁< ▁Test Object ▁> ▁set ▁= ▁redisson ▁. ▁getSet Cache ▁( ▁STR ▁) ▁; ▁sync ▁( ▁set ▁. ▁add ▁( ▁new ▁Test Object ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁; ▁sync ▁( ▁set ▁. ▁add ▁( ▁new ▁Test Object ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁; ▁sync ▁( ▁set ▁. ▁add ▁( ▁new ▁Test Object ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁; ▁sync ▁( ▁set ▁. ▁add ▁( ▁new ▁Test Object ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁; ▁sync ▁( ▁set ▁. ▁add ▁( ▁new ▁Test Object ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁;
▁abstract ▁class ▁Temporal Time Join Operator TestBase ▁{ ▁protected ▁String ▁func Code ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁; ▁protected ▁Generated Join Condition ▁join Condition ▁= ▁new ▁Generated Join Condition ▁( ▁STR ▁, ▁func Code ▁, ▁new ▁Object ▁[ ▁0 ▁] ▁) ▁; ▁protected ▁Internal TypeInfo ▁< ▁RowData ▁> ▁rowType ▁= ▁Internal TypeInfo ▁. ▁of Fields ▁( ▁new ▁Big Int Type ▁( ▁) ▁, ▁new ▁Var Char Type ▁( ▁Var Char Type ▁. ▁MAX _ LENGTH ▁) ▁, ▁new ▁Var Char Type ▁( ▁Var Char Type ▁. ▁MAX _ LENGTH ▁) ▁) ▁; ▁protected ▁Internal TypeInfo ▁< ▁RowData ▁> ▁output RowType ▁= ▁Internal TypeInfo ▁. ▁of Fields ▁( ▁new ▁Big Int Type ▁( ▁) ▁, ▁new ▁Var Char Type ▁( ▁Var Char Type ▁. ▁MAX _ LENGTH ▁) ▁, ▁new ▁Var Char Type ▁( ▁Var Char Type ▁. ▁MAX _ LENGTH ▁) ▁, ▁new ▁Big Int Type ▁( ▁) ▁, ▁new ▁Var Char Type ▁( ▁Var Char Type ▁. ▁MAX _ LENGTH ▁) ▁, ▁new ▁Var Char Type ▁( ▁Var Char Type ▁. ▁MAX _ LENGTH ▁) ▁) ▁; ▁protected ▁RowData Harness Assert or ▁assert or ▁= ▁new ▁RowData Harness Assert or ▁( ▁output RowType ▁. ▁to Row Field Types ▁( ▁) ▁) ▁; ▁protected ▁int ▁key Idx ▁= ▁1 ▁; ▁protected ▁RowData KeySelector ▁keySelector ▁= ▁Hand written Selector Util ▁. ▁getRow Data Selector ▁( ▁new ▁int ▁[ ▁] ▁{ ▁key Idx ▁} ▁, ▁rowType ▁. ▁to Row Field Types ▁( ▁) ▁) ▁; ▁protected ▁TypeInformation ▁< ▁RowData ▁> ▁keyType ▁= ▁keySelector ▁. ▁getProduced Type ▁( ▁) ▁; ▁}
▁@ ▁Required ArgsConstructor ▁public ▁class ▁TraceSegment Report Service Handler Compat ▁extends ▁TraceSegment Report Service Grpc ▁. ▁TraceSegment Report ServiceImpl Base ▁implements ▁GRPC Handler ▁{ ▁private ▁final ▁TraceSegment Report Service Handler ▁delegate ▁; ▁@ ▁Override ▁public ▁StreamObserver ▁< ▁Segment Object ▁> ▁collect ▁( ▁final ▁StreamObserver ▁< ▁Commands ▁> ▁response Observer ▁) ▁{ ▁return ▁delegate ▁. ▁collect ▁( ▁response Observer ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁collect In Sync ▁( ▁final ▁Segment Collection ▁request ▁, ▁final ▁StreamObserver ▁< ▁Commands ▁> ▁response Observer ▁) ▁{ ▁delegate ▁. ▁collect In Sync ▁( ▁request ▁, ▁response Observer ▁) ▁; ▁} ▁}
▁public ▁final ▁class ▁Metadata ▁implements ▁Parcelable ▁{ ▁public ▁interface ▁Entry ▁extends ▁Parcelable ▁{ ▁@ ▁Nullable ▁default ▁Format ▁getWrapped Metadata Format ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Nullable ▁default ▁byte ▁[ ▁] ▁getWrapped Metadata Bytes ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁default ▁void ▁populate Media Metadata ▁( ▁Media Metadata ▁. ▁Builder ▁builder ▁) ▁{ ▁} ▁} ▁private ▁final ▁Entry ▁[ ▁] ▁entries ▁; ▁public ▁Metadata ▁( ▁Entry ▁... ▁entries ▁) ▁{ ▁this ▁. ▁entries ▁= ▁entries ▁; ▁} ▁public ▁Metadata ▁( ▁List ▁< ▁? ▁extends ▁Entry ▁> ▁entries ▁) ▁{ ▁this ▁. ▁entries ▁= ▁entries ▁. ▁toArray ▁( ▁new ▁Entry ▁[ ▁0 ▁] ▁) ▁; ▁} ▁Metadata ▁( ▁Parcel ▁in ▁) ▁{ ▁entries ▁= ▁new ▁Metadata ▁. ▁Entry ▁[ ▁in ▁. ▁readInt ▁( ▁) ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁entries ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁entries ▁[ ▁i ▁] ▁= ▁in ▁. ▁read Parcelable ▁( ▁Entry ▁. ▁class ▁. ▁getClassLoader ▁( ▁) ▁) ▁; ▁} ▁} ▁public ▁int ▁length ▁( ▁) ▁{ ▁return ▁entries ▁. ▁length ▁; ▁} ▁public ▁Metadata ▁. ▁Entry ▁get ▁( ▁int ▁index ▁) ▁{ ▁return ▁entries ▁[ ▁index ▁] ▁; ▁} ▁public ▁Metadata ▁copy With App ended Entries From ▁( ▁@ ▁Nullable ▁Metadata ▁other ▁) ▁{ ▁if ▁( ▁other ▁== ▁null ▁) ▁{ ▁return ▁this ▁; ▁} ▁return ▁copy With App ended Entries ▁( ▁other ▁. ▁entries ▁) ▁; ▁} ▁public ▁Metadata ▁copy With App ended Entries ▁( ▁Entry ▁... ▁entries To Append ▁) ▁{ ▁if ▁( ▁entries To Append ▁. ▁length ▁== ▁0 ▁) ▁{ ▁return ▁this ▁; ▁} ▁return ▁new ▁Metadata ▁( ▁Util ▁. ▁nullSafe Array Concat en ation ▁( ▁entries ▁, ▁entries To Append ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁@ ▁Nullable ▁Object ▁obj ▁) ▁{ ▁if ▁( ▁this ▁== ▁obj ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁obj ▁== ▁null ▁|| ▁getClass ▁( ▁) ▁!= ▁obj ▁. ▁getClass ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁Metadata ▁other ▁= ▁( ▁Metadata ▁) ▁obj ▁; ▁return ▁Arrays ▁. ▁equals ▁( ▁entries ▁, ▁other ▁. ▁entries ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁Arrays ▁. ▁hashCode ▁( ▁entries ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁Arrays ▁. ▁toString ▁( ▁entries ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁describe Contents ▁( ▁) ▁{ ▁return ▁0 ▁; ▁} ▁@ ▁Override ▁public ▁void ▁writeToParcel ▁( ▁Parcel ▁dest ▁, ▁int ▁flags ▁) ▁{ ▁dest ▁. ▁writeInt ▁( ▁entries ▁. ▁length ▁) ▁; ▁for ▁( ▁Entry ▁entry ▁: ▁entries ▁) ▁{ ▁dest ▁. ▁write Parcelable ▁( ▁entry ▁, ▁0 ▁) ▁; ▁} ▁} ▁public ▁static ▁final ▁Parcelable ▁. ▁Creator ▁< ▁Metadata ▁> ▁CREATOR ▁= ▁new ▁Parcelable ▁. ▁Creator ▁< ▁Metadata ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Metadata ▁createFrom Parcel ▁( ▁Parcel ▁in ▁) ▁{ ▁return ▁new ▁Metadata ▁( ▁in ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Metadata ▁[ ▁] ▁newArray ▁( ▁int ▁size ▁) ▁{ ▁return ▁new ▁Metadata ▁[ ▁size ▁] ▁; ▁} ▁} ▁; ▁}
▁text ▁. ▁setText ▁( ▁item ▁. ▁getText ▁( ▁1 ▁) ▁) ▁; ▁text ▁. ▁add Modify Listener ▁( ▁new ▁Modify Listener ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁modify Text ▁( ▁Modify Event ▁e ▁) ▁{ ▁Text ▁text ▁= ▁( ▁Text ▁) ▁table Editor ▁. ▁getEditor ▁( ▁) ▁; ▁item ▁. ▁setText ▁( ▁1 ▁, ▁text ▁. ▁getText ▁( ▁) ▁) ▁; ▁update Project s Selection ▁( ▁) ▁; ▁update State ▁( ▁) ▁; ▁} ▁} ▁) ▁; ▁text ▁. ▁selectAll ▁( ▁) ▁; ▁text ▁. ▁setF ocus ▁( ▁) ▁; ▁table Editor ▁. ▁set Editor ▁( ▁text ▁, ▁item ▁, ▁1 ▁) ▁; ▁} ▁} ▁) ▁; ▁UIUtils ▁. ▁pack Columns ▁( ▁project s Table ▁) ▁; ▁set Control ▁( ▁placeholder ▁) ▁; ▁} ▁private ▁boolean ▁update Project s Selection ▁( ▁) ▁{ ▁boolean ▁failed ▁= ▁false ▁; ▁for ▁( ▁Table Item ▁item ▁: ▁project s Table ▁. ▁getItems ▁( ▁) ▁) ▁{ ▁boolean ▁valid Item ▁= ▁check Project Item ▁( ▁item ▁) ▁; ▁if ▁( ▁! ▁valid Item ▁&& ▁item ▁. ▁get Checked ▁( ▁) ▁) ▁{ ▁failed ▁= ▁true ▁; ▁} ▁} ▁if ▁( ▁! ▁failed ▁) ▁{ ▁boolean ▁has Checked ▁= ▁false ▁; ▁for ▁( ▁Table Item ▁item ▁: ▁project s Table ▁. ▁getItems ▁( ▁) ▁) ▁{ ▁if ▁( ▁item ▁. ▁get Checked ▁( ▁) ▁) ▁{ ▁has Checked ▁= ▁true ▁; ▁} ▁} ▁if ▁( ▁has Checked ▁) ▁{ ▁setMessage ▁( ▁Core Messages ▁. ▁dialog _ pro ject _ imp ort _ wizard _ file _ message _ ready ▁, ▁I Message Provider ▁. ▁IN FORM ATION ▁) ▁; ▁} ▁else ▁{ ▁setMessage ▁( ▁Core Messages ▁. ▁dialog _ pro ject _ imp ort _ wizard _ file _ message _ ch oose _ pro ject ▁, ▁I Message Provider ▁. ▁IN FORM ATION ▁) ▁; ▁} ▁} ▁return ▁! ▁failed ▁; ▁} ▁private ▁boolean ▁check Project Item ▁( ▁Table Item ▁item ▁) ▁{ ▁String ▁project Name ▁= ▁item ▁. ▁getText ▁( ▁1 ▁) ▁; ▁I Project ▁project ▁= ▁DBWorkbench ▁. ▁getPlatform ▁( ▁) ▁. ▁getWorkspace ▁( ▁) ▁. ▁getE clipse Workspace ▁( ▁) ▁. ▁getRoot ▁( ▁) ▁. ▁getProject ▁( ▁project Name ▁) ▁; ▁if ▁( ▁! ▁project ▁. ▁is Accessible ▁( ▁) ▁) ▁{ ▁item ▁. ▁setF oreground ▁( ▁1 ▁, ▁null ▁) ▁; ▁return ▁true ▁; ▁} ▁else ▁{ ▁if ▁( ▁item ▁. ▁get Checked ▁( ▁) ▁) ▁{ ▁setMessage ▁( ▁NLS ▁. ▁bind ▁( ▁Core Messages ▁. ▁dialog _ pro ject _ imp ort _ wizard _ file _ message _ pro ject _ ex ists ▁, ▁project Name ▁) ▁, ▁I Message Provider ▁. ▁ERROR ▁) ▁; ▁} ▁item ▁. ▁setF oreground ▁( ▁1 ▁, ▁project s Table ▁. ▁getDisplay ▁( ▁) ▁. ▁getSystem Color ▁( ▁SWT ▁. ▁COLOR _ RED ▁) ▁) ▁; ▁return ▁false ▁; ▁} ▁} ▁private ▁void ▁update State ▁( ▁) ▁{ ▁getContainer ▁( ▁) ▁. ▁update Buttons ▁( ▁) ▁; ▁}
▁public ▁class ▁Maybe Using Test ▁extends ▁RxJavaTest ▁{ ▁@ ▁Test ▁public ▁void ▁resource Supplier Throws ▁( ▁) ▁{ ▁Maybe ▁. ▁using ▁( ▁new ▁Supplier ▁< ▁Object ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Object ▁get ▁( ▁) ▁throws ▁Exception ▁{ ▁throw ▁new ▁TestException ▁( ▁) ▁; ▁} ▁} ▁, ▁new ▁Function ▁< ▁Object ▁, ▁MaybeSource ▁< ▁Integer ▁> ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁MaybeSource ▁< ▁Integer ▁> ▁apply ▁( ▁Object ▁v ▁) ▁throws ▁Exception ▁{ ▁return ▁Maybe ▁. ▁just ▁( ▁1 ▁) ▁; ▁} ▁} ▁, ▁new ▁Consumer ▁< ▁Object ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁accept ▁( ▁Object ▁d ▁) ▁throws ▁Exception ▁{ ▁} ▁} ▁) ▁. ▁test ▁( ▁) ▁. ▁assertFailure ▁( ▁TestException ▁. ▁class ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁error Eager ▁( ▁) ▁{ ▁Maybe ▁. ▁using ▁( ▁new ▁Supplier ▁< ▁Object ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Object ▁get ▁( ▁) ▁throws ▁Exception ▁{ ▁return ▁1 ▁; ▁} ▁} ▁, ▁new ▁Function ▁< ▁Object ▁, ▁MaybeSource ▁< ▁Integer ▁> ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁MaybeSource ▁< ▁Integer ▁> ▁apply ▁( ▁Object ▁v ▁) ▁throws ▁Exception ▁{ ▁return ▁Maybe ▁. ▁error ▁( ▁new ▁TestException ▁( ▁) ▁) ▁; ▁} ▁} ▁, ▁new ▁Consumer ▁< ▁Object ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁accept ▁( ▁Object ▁d ▁) ▁throws ▁Exception ▁{ ▁} ▁} ▁, ▁true ▁) ▁. ▁test ▁( ▁) ▁. ▁assertFailure ▁( ▁TestException ▁. ▁class ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁empty Eager ▁( ▁) ▁{ ▁Maybe ▁. ▁using ▁( ▁new ▁Supplier ▁< ▁Object ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Object ▁get ▁( ▁) ▁throws ▁Exception ▁{ ▁return ▁1 ▁; ▁} ▁} ▁, ▁new ▁Function ▁< ▁Object ▁, ▁MaybeSource ▁< ▁Integer ▁> ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁MaybeSource ▁< ▁Integer ▁> ▁apply ▁( ▁Object ▁v ▁) ▁throws ▁Exception ▁{ ▁return ▁Maybe ▁. ▁empty ▁( ▁) ▁; ▁} ▁} ▁, ▁new ▁Consumer ▁< ▁Object ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁accept ▁( ▁Object ▁d ▁) ▁throws ▁Exception ▁{ ▁} ▁} ▁, ▁true ▁) ▁. ▁test ▁( ▁) ▁. ▁assertResult ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁error Non Eager ▁( ▁) ▁{ ▁Maybe ▁. ▁using ▁( ▁new ▁Supplier ▁< ▁Object ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Object ▁get ▁( ▁) ▁throws ▁Exception ▁{ ▁return ▁1 ▁; ▁} ▁} ▁, ▁new ▁Function ▁< ▁Object ▁, ▁MaybeSource ▁< ▁Integer ▁> ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁MaybeSource ▁< ▁Integer ▁> ▁apply ▁( ▁Object ▁v ▁) ▁throws ▁Exception ▁{ ▁return ▁Maybe ▁. ▁error ▁( ▁new ▁TestException ▁( ▁) ▁) ▁; ▁} ▁} ▁, ▁new ▁Consumer ▁< ▁Object ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁accept ▁( ▁Object ▁d ▁) ▁throws ▁Exception ▁{ ▁} ▁} ▁, ▁false ▁) ▁. ▁test ▁( ▁) ▁. ▁assertFailure ▁( ▁TestException ▁. ▁class ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁empty Non Eager ▁( ▁) ▁{ ▁Maybe ▁. ▁using ▁( ▁new ▁Supplier ▁< ▁Object ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Object ▁get ▁( ▁) ▁throws ▁Exception ▁{ ▁return ▁1 ▁; ▁} ▁}
▁public ▁final ▁class ▁Digest OutputStream ▁extends ▁Filter OutputStream ▁{ ▁private ▁final ▁Hasher ▁hasher ▁; ▁private ▁long ▁size ▁= ▁0 ▁; ▁public ▁Digest OutputStream ▁( ▁Hash Function ▁hash Function ▁, ▁OutputStream ▁out ▁) ▁{ ▁super ▁( ▁checkNotNull ▁( ▁out ▁) ▁) ▁; ▁this ▁. ▁hasher ▁= ▁checkNotNull ▁( ▁hash Function ▁. ▁new Hasher ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁write ▁( ▁int ▁b ▁) ▁throws ▁IOException ▁{ ▁size ▁++ ▁; ▁hasher ▁. ▁putByte ▁( ▁( ▁byte ▁) ▁b ▁) ▁; ▁out ▁. ▁write ▁( ▁b ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁write ▁( ▁byte ▁[ ▁] ▁bytes ▁, ▁int ▁off ▁, ▁int ▁len ▁) ▁throws ▁IOException ▁{ ▁size ▁+= ▁len ▁; ▁hasher ▁. ▁putBytes ▁( ▁bytes ▁, ▁off ▁, ▁len ▁) ▁; ▁out ▁. ▁write ▁( ▁bytes ▁, ▁off ▁, ▁len ▁) ▁; ▁} ▁public ▁Digest ▁digest ▁( ▁) ▁{ ▁return ▁Digest ▁. ▁newBuilder ▁( ▁) ▁. ▁set Hash ▁( ▁hasher ▁. ▁hash ▁( ▁) ▁. ▁toString ▁( ▁) ▁) ▁. ▁setSize Bytes ▁( ▁size ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁close ▁( ▁) ▁throws ▁IOException ▁{ ▁out ▁. ▁close ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁Function Signature Decompiler Hover ▁extends ▁Abstract Configur able Hover ▁implements ▁Decompiler Hover Service ▁{ ▁private ▁static ▁final ▁String ▁NAME ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁DESCRIPTION ▁= ▁STR ▁; ▁private ▁static ▁final ▁int ▁PRI ORITY ▁= ▁20 ▁; ▁protected ▁Function Signature Decompiler Hover ▁( ▁PluginTool ▁tool ▁) ▁{ ▁super ▁( ▁tool ▁, ▁PRI ORITY ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁String ▁getName ▁( ▁) ▁{ ▁return ▁NAME ▁; ▁} ▁@ ▁Override ▁protected ▁String ▁getDescription ▁( ▁) ▁{ ▁return ▁DESCRIPTION ▁; ▁} ▁@ ▁Override ▁protected ▁String ▁getOptions Category ▁( ▁) ▁{ ▁return ▁Ghidra Options ▁. ▁CATEG ORY _ DE COMP ILER _ POP UP S ▁; ▁} ▁@ ▁Override ▁public ▁JComponent ▁getH over Component ▁( ▁Program ▁program ▁, ▁ProgramLocation ▁program Location ▁, ▁FieldLocation ▁field Location ▁, ▁Field ▁field ▁) ▁{ ▁if ▁( ▁! ▁enabled ▁) ▁{ ▁return ▁null ▁; ▁} ▁if ▁( ▁! ▁( ▁field ▁instanceof ▁Clang TextField ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁Clang Token ▁token ▁= ▁( ▁( ▁Clang TextField ▁) ▁field ▁) ▁. ▁getToken ▁( ▁field Location ▁) ▁; ▁if ▁( ▁token ▁instanceof ▁Clang Func Name Token ▁) ▁{ ▁Function ▁function ▁= ▁Decompiler Utils ▁. ▁getFunction ▁( ▁program ▁, ▁( ▁Clang Func Name Token ▁) ▁token ▁) ▁; ▁if ▁( ▁function ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁String ▁content ▁= ▁Tool Tip Utils ▁. ▁getTool TipText ▁( ▁function ▁, ▁false ▁) ▁; ▁return ▁create Tool tip Component ▁( ▁content ▁) ▁; ▁} ▁else ▁if ▁( ▁token ▁instanceof ▁Clang Variable Token ▁) ▁{ ▁Varnode ▁vn ▁= ▁( ▁( ▁Clang Variable Token ▁) ▁token ▁) ▁. ▁getV arnode ▁( ▁) ▁; ▁Scalar ▁scalar ▁= ▁getSc alar ▁( ▁vn ▁) ▁; ▁Function ▁function ▁= ▁getFunction At Address ▁( ▁program ▁, ▁scalar ▁) ▁; ▁if ▁( ▁function ▁!= ▁null ▁) ▁{ ▁String ▁content ▁= ▁Tool Tip Utils ▁. ▁getTool TipText ▁( ▁function ▁, ▁false ▁) ▁; ▁content ▁= ▁content ▁. ▁replace First ▁( ▁HTML ▁, ▁HTML ▁+ ▁it al ic ▁( ▁b old ▁( ▁STR ▁) ▁) ▁+ ▁STR ▁) ▁; ▁return ▁create Tool tip Component ▁( ▁content ▁) ▁; ▁} ▁} ▁return ▁null ▁; ▁} ▁private ▁Scalar ▁getSc alar ▁( ▁Varnode ▁vn ▁) ▁{ ▁if ▁( ▁vn ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁if ▁( ▁! ▁( ▁vn ▁. ▁getHigh ▁( ▁) ▁instanceof ▁High Constant ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁High Constant ▁h v ▁= ▁( ▁High Constant ▁) ▁vn ▁. ▁getHigh ▁( ▁) ▁; ▁long ▁offset ▁= ▁vn ▁. ▁getOffset ▁( ▁) ▁; ▁int ▁sz ▁= ▁vn ▁. ▁getSize ▁( ▁) ▁; ▁boolean ▁isS igned ▁= ▁true ▁; ▁if ▁( ▁h v ▁. ▁getDataType ▁( ▁) ▁instanceof ▁Abstract Integer DataType ▁) ▁{ ▁isS igned ▁= ▁( ▁( ▁Abstract Integer DataType ▁) ▁h v ▁. ▁getDataType ▁( ▁) ▁) ▁. ▁isS igned ▁( ▁) ▁; ▁} ▁if ▁( ▁sz ▁> ▁8 ▁) ▁{ ▁return ▁null ▁; ▁} ▁return ▁new ▁Scalar ▁( ▁sz ▁ * ▁8 ▁, ▁offset ▁, ▁isS igned ▁) ▁; ▁}
▁public ▁class ▁D warf Decode Context ▁{ ▁private ▁final ▁Program ▁program ▁; ▁private ▁final ▁Address ▁addr ▁; ▁private ▁final ▁MemoryBlock ▁e h Block ▁; ▁private ▁final ▁Address ▁function EntryPoint ▁; ▁private ▁Object ▁decoded Value ▁; ▁private ▁int ▁encoded Length ▁; ▁private ▁MemBuffer ▁buffer ▁; ▁public ▁D warf Decode Context ▁( ▁Program ▁program ▁, ▁Address ▁read Addr ▁) ▁{ ▁this ▁( ▁program ▁, ▁read Addr ▁, ▁null ▁, ▁null ▁) ▁; ▁} ▁public ▁D warf Decode Context ▁( ▁Program ▁program ▁, ▁Address ▁read Addr ▁, ▁MemoryBlock ▁e h Block ▁) ▁{ ▁this ▁( ▁program ▁, ▁read Addr ▁, ▁e h Block ▁, ▁null ▁) ▁; ▁} ▁public ▁D warf Decode Context ▁( ▁Program ▁program ▁, ▁Address ▁read Addr ▁, ▁Address ▁entry Point ▁) ▁{ ▁this ▁( ▁program ▁, ▁read Addr ▁, ▁null ▁, ▁entry Point ▁) ▁; ▁} ▁public ▁D warf Decode Context ▁( ▁Program ▁program ▁, ▁Address ▁read Addr ▁, ▁Function ▁function ▁) ▁{ ▁this ▁( ▁program ▁, ▁read Addr ▁, ▁null ▁, ▁function ▁. ▁getEntryPoint ▁( ▁) ▁) ▁; ▁} ▁public ▁D warf Decode Context ▁( ▁Program ▁program ▁, ▁Address ▁read Addr ▁, ▁MemoryBlock ▁e h Block ▁, ▁Address ▁entry Point ▁) ▁{ ▁if ▁( ▁program ▁== ▁null ▁) ▁{ ▁throw ▁new ▁NullPointer Exception ▁( ▁STR ▁) ▁; ▁} ▁if ▁( ▁read Addr ▁== ▁null ▁) ▁{ ▁throw ▁new ▁NullPointer Exception ▁( ▁STR ▁) ▁; ▁} ▁this ▁. ▁program ▁= ▁program ▁; ▁this ▁. ▁addr ▁= ▁read Addr ▁; ▁this ▁. ▁e h Block ▁= ▁e h Block ▁; ▁this ▁. ▁function EntryPoint ▁= ▁entry Point ▁; ▁} ▁public ▁D warf Decode Context ▁( ▁MemBuffer ▁buffer ▁, ▁int ▁length ▁) ▁{ ▁this ▁( ▁buffer ▁, ▁length ▁, ▁null ▁, ▁null ▁) ▁; ▁} ▁public ▁D warf Decode Context ▁( ▁MemBuffer ▁buf ▁, ▁int ▁length ▁, ▁MemoryBlock ▁e h Block ▁, ▁Address ▁entry Point ▁) ▁{ ▁this ▁. ▁buffer ▁= ▁buf ▁; ▁this ▁. ▁program ▁= ▁buffer ▁. ▁getMemory ▁( ▁) ▁. ▁getProgram ▁( ▁) ▁; ▁this ▁. ▁addr ▁= ▁buffer ▁. ▁getAddress ▁( ▁) ▁; ▁this ▁. ▁e h Block ▁= ▁e h Block ▁; ▁this ▁. ▁function EntryPoint ▁= ▁entry Point ▁; ▁} ▁public ▁Program ▁getProgram ▁( ▁) ▁{ ▁return ▁program ▁; ▁} ▁public ▁Address ▁getAddress ▁( ▁) ▁{ ▁return ▁addr ▁; ▁} ▁public ▁void ▁set Decoded Value ▁( ▁Object ▁value ▁, ▁int ▁encoded Length ▁) ▁{ ▁this ▁. ▁decoded Value ▁= ▁value ▁; ▁this ▁. ▁encoded Length ▁= ▁encoded Length ▁; ▁} ▁public ▁Object ▁get Decoded Value ▁( ▁) ▁{ ▁return ▁decoded Value ▁; ▁} ▁public ▁int ▁getEncoded Length ▁( ▁) ▁{ ▁return ▁encoded Length ▁; ▁} ▁public ▁MemoryBlock ▁getE h Block ▁( ▁) ▁{ ▁return ▁e h Block ▁; ▁} ▁public ▁Address ▁getFunction EntryPoint ▁( ▁) ▁{ ▁return ▁function EntryPoint ▁; ▁} ▁}
▁public ▁class ▁Parquet TestUtils ▁{ ▁private ▁Parquet TestUtils ▁( ▁) ▁{ ▁} ▁static ▁void ▁write Par quet Column Hive ▁( ▁File ▁file ▁, ▁String ▁columnName ▁, ▁boolean ▁nullable ▁, ▁Type ▁type ▁, ▁Iterator ▁< ▁? ▁> ▁values ▁) ▁throws ▁Exception ▁{ ▁JobConf ▁jobConf ▁= ▁new ▁JobConf ▁( ▁) ▁; ▁jobConf ▁. ▁set ▁( ▁STR ▁, ▁Local FileSystem ▁. ▁class ▁. ▁getCanonical Name ▁( ▁) ▁) ▁; ▁jobConf ▁. ▁setLong ▁( ▁Parquet OutputFormat ▁. ▁BLOCK _ SI Z E ▁, ▁new ▁DataSize ▁( ▁256 ▁, ▁ME G ABYTE ▁) ▁. ▁toBytes ▁( ▁) ▁) ▁; ▁jobConf ▁. ▁setLong ▁( ▁Parquet OutputFormat ▁. ▁PAGE _ SI Z E ▁, ▁new ▁DataSize ▁( ▁100 ▁, ▁K I LO BYTE ▁) ▁. ▁toBytes ▁( ▁) ▁) ▁; ▁jobConf ▁. ▁set ▁( ▁Parquet OutputFormat ▁. ▁COMP RESSION ▁, ▁STR ▁) ▁; ▁Properties ▁properties ▁= ▁new ▁Properties ▁( ▁) ▁; ▁properties ▁. ▁setProperty ▁( ▁STR ▁, ▁columnName ▁) ▁; ▁properties ▁. ▁setProperty ▁( ▁STR ▁, ▁getH ive Type ▁( ▁type ▁) ▁) ▁; ▁RecordWriter ▁record Writer ▁= ▁create Par quet Writer ▁( ▁nullable ▁, ▁new ▁Path ▁( ▁file ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁, ▁jobConf ▁, ▁properties ▁, ▁true ▁) ▁; ▁List ▁< ▁Object Inspector ▁> ▁object Ins pect ors ▁= ▁getRow Object Ins pect ors ▁( ▁type ▁) ▁; ▁Settable Struct Object Inspector ▁table Object Inspector ▁= ▁getSt andard Struct Object Inspector ▁( ▁ImmutableList ▁. ▁of ▁( ▁columnName ▁) ▁, ▁object Ins pect ors ▁) ▁; ▁Object ▁row ▁= ▁table Object Inspector ▁. ▁create ▁( ▁) ▁; ▁Struct Field ▁structField ▁= ▁table Object Inspector ▁. ▁getStr uct Field Ref ▁( ▁columnName ▁) ▁; ▁Setter ▁setter ▁= ▁get Setter ▁( ▁type ▁, ▁table Object Inspector ▁, ▁row ▁, ▁structField ▁) ▁; ▁Serializer ▁serializer ▁= ▁initialize Serializer ▁( ▁jobConf ▁, ▁properties ▁) ▁; ▁while ▁( ▁values ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁Object ▁value ▁= ▁values ▁. ▁next ▁( ▁) ▁; ▁if ▁( ▁value ▁== ▁null ▁) ▁{ ▁table Object Inspector ▁. ▁set Struct FieldData ▁( ▁row ▁, ▁structField ▁, ▁null ▁) ▁; ▁} ▁else ▁{ ▁setter ▁. ▁set ▁( ▁value ▁) ▁; ▁} ▁record Writer ▁. ▁write ▁( ▁serializer ▁. ▁serialize ▁( ▁row ▁, ▁table Object Inspector ▁) ▁) ▁; ▁} ▁record Writer ▁. ▁close ▁( ▁false ▁) ▁; ▁} ▁private ▁static ▁String ▁getH ive Type ▁( ▁Type ▁type ▁) ▁{ ▁if ▁( ▁type ▁. ▁equals ▁( ▁BOOLEAN ▁) ▁|| ▁type ▁. ▁equals ▁( ▁BIGINT ▁) ▁|| ▁type ▁. ▁equals ▁( ▁Sm all int Type ▁. ▁SMALL INT ▁) ▁|| ▁type ▁. ▁equals ▁( ▁T iny int Type ▁. ▁TINY INT ▁) ▁|| ▁type ▁. ▁equals ▁( ▁DOUBLE ▁) ▁) ▁{ ▁return ▁type ▁. ▁getType Signature ▁( ▁) ▁. ▁toString ▁( ▁) ▁; ▁} ▁if ▁( ▁type ▁. ▁equals ▁( ▁INTEGER ▁) ▁) ▁{ ▁return ▁STR ▁; ▁} ▁if ▁( ▁type ▁. ▁equals ▁( ▁REAL ▁) ▁) ▁{ ▁return ▁STR ▁; ▁} ▁if ▁( ▁type ▁. ▁equals ▁( ▁TIMESTAMP ▁) ▁) ▁{ ▁return ▁STR ▁; ▁}
▁public ▁class ▁Drop Out In verted ▁extends ▁Base Random Op ▁{ ▁private ▁double ▁p ▁; ▁public ▁Drop Out In verted ▁( ▁) ▁{ ▁} ▁public ▁Drop Out In verted ▁( ▁SameDiff ▁sameDiff ▁, ▁SDVariable ▁input ▁, ▁double ▁p ▁) ▁{ ▁super ▁( ▁sameDiff ▁, ▁input ▁) ▁; ▁this ▁. ▁p ▁= ▁p ▁; ▁this ▁. ▁extraArgs ▁= ▁new ▁Object ▁[ ▁] ▁{ ▁p ▁} ▁; ▁} ▁public ▁Drop Out In verted ▁( ▁@ ▁NonNull ▁INDArray ▁x ▁, ▁double ▁p ▁) ▁{ ▁this ▁( ▁x ▁, ▁x ▁, ▁p ▁) ▁; ▁} ▁public ▁Drop Out In verted ▁( ▁@ ▁NonNull ▁INDArray ▁x ▁, ▁@ ▁NonNull ▁INDArray ▁z ▁, ▁double ▁p ▁) ▁{ ▁super ▁( ▁x ▁, ▁null ▁, ▁z ▁) ▁; ▁this ▁. ▁p ▁= ▁p ▁; ▁this ▁. ▁extraArgs ▁= ▁new ▁Object ▁[ ▁] ▁{ ▁p ▁} ▁; ▁} ▁@ ▁Override ▁public ▁int ▁opNum ▁( ▁) ▁{ ▁return ▁2 ▁; ▁} ▁@ ▁Override ▁public ▁String ▁opName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁void ▁initFrom Tensor Flow ▁( ▁NodeDef ▁nodeDef ▁, ▁SameDiff ▁initWith ▁, ▁Map ▁< ▁String ▁, ▁AttrValue ▁> ▁attributes ForNode ▁, ▁GraphDef ▁graph ▁) ▁{ ▁super ▁. ▁initFrom Tensor Flow ▁( ▁nodeDef ▁, ▁initWith ▁, ▁attributes ForNode ▁, ▁graph ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁initFrom On nx ▁( ▁On nx ▁. ▁Node Proto ▁node ▁, ▁SameDiff ▁initWith ▁, ▁Map ▁< ▁String ▁, ▁On nx ▁. ▁Attribute Proto ▁> ▁attributes ForNode ▁, ▁On nx ▁. ▁Graph Proto ▁graph ▁) ▁{ ▁super ▁. ▁initFrom On nx ▁( ▁node ▁, ▁initWith ▁, ▁attributes ForNode ▁, ▁graph ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁onnxName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁SDVariable ▁> ▁doDiff ▁( ▁List ▁< ▁SDVariable ▁> ▁f 1 ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁Long ShapeDescriptor ▁> ▁calculateOutput Shape ▁( ▁Op Context ▁oc ▁) ▁{ ▁return ▁calculateOutput Shape ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁Long ShapeDescriptor ▁> ▁calculateOutput Shape ▁( ▁) ▁{ ▁Long ShapeDescriptor ▁long ShapeDescriptor ▁= ▁Long ShapeDescriptor ▁. ▁from Shape ▁( ▁shape ▁, ▁dataType ▁) ▁; ▁return ▁Arrays ▁. ▁asList ▁( ▁long ShapeDescriptor ▁) ▁; ▁} ▁}
▁public ▁class ▁String Terms Aggregator From Filters ▁extends ▁Adapt ing Aggregator ▁{ ▁static ▁String Terms Aggregator From Filters ▁adapt Into Filters OrNull ▁( ▁String ▁name ▁, ▁Aggregator Factories ▁factories ▁, ▁Aggregation Context ▁context ▁, ▁Aggregator ▁parent ▁, ▁boolean ▁show Term DocCount Error ▁, ▁Cardinality UpperBound ▁cardinality ▁, ▁Map ▁< ▁String ▁, ▁Object ▁> ▁metadata ▁, ▁ValuesSource Config ▁valuesSource Config ▁, ▁Bucket Order ▁order ▁, ▁Bucket Count Threshold s ▁bucketCount Threshold s ▁, ▁Long Predicate ▁accepted Or ds ▁, ▁SortedSet DocValues ▁values ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁false ▁== ▁valuesSource Config ▁. ▁align es With Search Index ▁( ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁Terms Enum ▁terms ▁= ▁values ▁. ▁terms Enum ▁( ▁) ▁; ▁Filter By Filter Aggregator ▁. ▁Adapter Builder ▁< ▁String Terms Aggregator From Filters ▁> ▁filter By Filter Builder ▁= ▁new ▁Filter By Filter Aggregator ▁. ▁Adapter Builder ▁< ▁String Terms Aggregator From Filters ▁> ▁( ▁name ▁, ▁false ▁, ▁null ▁, ▁context ▁, ▁parent ▁, ▁cardinality ▁, ▁metadata ▁) ▁{ ▁@ ▁Override ▁protected ▁String Terms Aggregator From Filters ▁adapt ▁( ▁Checked Function ▁< ▁Aggregator Factories ▁, ▁Filter By Filter Aggregator ▁, ▁IOException ▁> ▁delegate ▁) ▁throws ▁IOException ▁{ ▁return ▁new ▁String Terms Aggregator From Filters ▁( ▁parent ▁, ▁factories ▁, ▁delegate ▁, ▁show Term DocCount Error ▁, ▁valuesSource Config ▁. ▁format ▁( ▁) ▁, ▁order ▁, ▁bucketCount Threshold s ▁, ▁terms ▁) ▁; ▁} ▁} ▁; ▁String ▁field ▁= ▁valuesSource Config ▁. ▁field Context ▁( ▁) ▁. ▁field ▁( ▁) ▁; ▁for ▁( ▁long ▁ord ▁= ▁0 ▁; ▁ord ▁< ▁values ▁. ▁getValue Count ▁( ▁) ▁; ▁ord ▁++ ▁) ▁{ ▁if ▁( ▁accepted Or ds ▁. ▁test ▁( ▁ord ▁) ▁== ▁false ▁) ▁{ ▁continue ▁; ▁} ▁terms ▁. ▁seek Exact ▁( ▁ord ▁) ▁; ▁Term QueryBuilder ▁builder ▁= ▁new ▁Term QueryBuilder ▁( ▁field ▁, ▁valuesSource Config ▁. ▁format ▁( ▁) ▁. ▁format ▁( ▁terms ▁. ▁term ▁( ▁) ▁) ▁) ▁; ▁filter By Filter Builder ▁. ▁add ▁( ▁Long ▁. ▁toString ▁( ▁ord ▁) ▁, ▁context ▁. ▁build Query ▁( ▁builder ▁) ▁) ▁; ▁} ▁return ▁filter By Filter Builder ▁. ▁build ▁( ▁) ▁; ▁} ▁private ▁final ▁boolean ▁show Term DocCount Error ▁; ▁private ▁final ▁DocValueFormat ▁format ▁; ▁private ▁final ▁Bucket Order ▁order ▁; ▁private ▁final ▁Bucket Count Threshold s ▁bucketCount Threshold s ▁; ▁private ▁final ▁Terms Enum ▁terms ▁; ▁public ▁String Terms Aggregator From Filters ▁( ▁Aggregator ▁parent ▁, ▁Aggregator Factories ▁sub Aggregator s ▁, ▁Checked Function ▁< ▁Aggregator Factories ▁, ▁Filter By Filter Aggregator ▁, ▁IOException ▁> ▁delegate ▁, ▁boolean ▁show Term DocCount Error ▁, ▁DocValueFormat ▁format ▁, ▁Bucket Order ▁order ▁, ▁Bucket Count Threshold s ▁bucketCount Threshold s ▁, ▁Terms Enum ▁terms ▁) ▁throws ▁IOException ▁{ ▁super ▁( ▁parent ▁, ▁sub Aggregator s ▁, ▁delegate ▁) ▁; ▁this ▁. ▁show Term DocCount Error ▁= ▁show Term DocCount Error ▁; ▁this ▁. ▁format ▁= ▁format ▁; ▁this ▁. ▁order ▁= ▁order ▁; ▁this ▁. ▁bucketCount Threshold s ▁= ▁bucketCount Threshold s ▁; ▁this ▁. ▁terms ▁= ▁terms ▁; ▁}
▁Assert ▁. ▁assertEquals ▁( ▁path ▁. ▁make Qualified ▁( ▁fs ▁. ▁getUri ▁( ▁) ▁, ▁fs ▁. ▁getWork ingDirectory ▁( ▁) ▁) ▁, ▁stat uses ▁[ ▁0 ▁] ▁. ▁getPath ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test User Representation Configuration ▁( ▁) ▁throws ▁IOException ▁{ ▁Path ▁path ▁= ▁new ▁Path ▁( ▁parent ▁, ▁STR ▁) ▁; ▁Ad l FileSystem ▁fs ▁= ▁( ▁Ad l FileSystem ▁) ▁ad l Store ▁; ▁fs ▁. ▁setUser Group Representation As UP N ▁( ▁false ▁) ▁; ▁fs ▁. ▁createNewFile ▁( ▁path ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁fs ▁. ▁isFile ▁( ▁path ▁) ▁) ▁; ▁FileStatus ▁file Status ▁= ▁fs ▁. ▁getFileStatus ▁( ▁path ▁) ▁; ▁UUID ▁. ▁fromString ▁( ▁file Status ▁. ▁getGroup ▁( ▁) ▁) ▁; ▁UUID ▁. ▁fromString ▁( ▁file Status ▁. ▁getOwner ▁( ▁) ▁) ▁; ▁fs ▁. ▁setUser Group Representation As UP N ▁( ▁true ▁) ▁; ▁file Status ▁= ▁fs ▁. ▁getFileStatus ▁( ▁path ▁) ▁; ▁try ▁{ ▁UUID ▁. ▁fromString ▁( ▁file Status ▁. ▁getGroup ▁( ▁) ▁) ▁; ▁UUID ▁. ▁fromString ▁( ▁file Status ▁. ▁getOwner ▁( ▁) ▁) ▁; ▁fail ▁( ▁STR ▁) ▁; ▁} ▁catch ▁( ▁IllegalArgument Exception ▁e ▁) ▁{ ▁} ▁} ▁}
▁for ▁( ▁Leaf ReaderContext ▁context ▁: ▁searcher ▁. ▁getIndex Reader ▁( ▁) ▁. ▁le aves ▁( ▁) ▁) ▁{ ▁Bulk Scorer ▁scorer ▁= ▁weight ▁. ▁bulk Scorer ▁( ▁context ▁) ▁; ▁if ▁( ▁scorer ▁!= ▁null ▁) ▁{ ▁try ▁{ ▁scorer ▁. ▁score ▁( ▁collector ▁. ▁getLe af Collector ▁( ▁context ▁) ▁, ▁context ▁. ▁reader ▁( ▁) ▁. ▁getL ive Docs ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁Collection Terminated Exception ▁e ▁) ▁{ ▁} ▁} ▁} ▁} ▁@ ▁Override ▁protected ▁Completion Suggestion ▁empty Suggestion ▁( ▁String ▁name ▁, ▁Completion Suggestion Context ▁s uggestion ▁, ▁Char s Ref Builder ▁sp are ▁) ▁throws ▁IOException ▁{ ▁Completion Suggestion ▁completion Suggestion ▁= ▁new ▁Completion Suggestion ▁( ▁name ▁, ▁s uggestion ▁. ▁getSize ▁( ▁) ▁, ▁s uggestion ▁. ▁is Skip Duplicates ▁( ▁) ▁) ▁; ▁sp are ▁. ▁copy UTF 8 Bytes ▁( ▁s uggestion ▁. ▁getText ▁( ▁) ▁) ▁; ▁Completion Suggestion ▁. ▁Entry ▁completion S uggest Entry ▁= ▁new ▁Completion Suggestion ▁. ▁Entry ▁( ▁new ▁Text ▁( ▁sp are ▁. ▁toString ▁( ▁) ▁) ▁, ▁0 ▁, ▁sp are ▁. ▁length ▁( ▁) ▁) ▁; ▁completion Suggestion ▁. ▁add Term ▁( ▁completion S uggest Entry ▁) ▁; ▁return ▁completion Suggestion ▁; ▁} ▁}
▁public ▁class ▁Hbase ColumnFamily ▁{ ▁public ▁static ▁final ▁AgentInfo ▁AGENT INFO _ INFO ▁= ▁new ▁AgentInfo ▁( ▁Hbase Table ▁. ▁AGENT INFO ▁, ▁Bytes ▁. ▁toBytes ▁( ▁STR ▁) ▁) ▁; ▁public ▁static ▁class ▁AgentInfo ▁extends ▁Hbase ColumnFamily ▁{ ▁public ▁byte ▁[ ▁] ▁ QUAL IFIER _ IDENT IFIER ▁= ▁Bytes ▁. ▁toBytes ▁( ▁STR ▁) ▁; ▁public ▁byte ▁[ ▁] ▁ QUAL IFIER _ SERVER _ META _ DATA ▁= ▁Bytes ▁. ▁toBytes ▁( ▁STR ▁) ▁; ▁public ▁byte ▁[ ▁] ▁ QUAL IFIER _ JVM ▁= ▁Bytes ▁. ▁toBytes ▁( ▁STR ▁) ▁; ▁private ▁AgentInfo ▁( ▁Hbase Table ▁h Base Table ▁, ▁byte ▁[ ▁] ▁columnFamily Name ▁) ▁{ ▁super ▁( ▁h Base Table ▁, ▁columnFamily Name ▁) ▁; ▁} ▁} ▁public ▁static ▁final ▁AgentEvent ▁AGENT _ EVENT _ EVENT S ▁= ▁new ▁AgentEvent ▁( ▁Hbase Table ▁. ▁AGENT _ EVENT ▁, ▁Bytes ▁. ▁toBytes ▁( ▁STR ▁) ▁) ▁; ▁public ▁static ▁class ▁AgentEvent ▁extends ▁Hbase ColumnFamily ▁{ ▁private ▁AgentEvent ▁( ▁Hbase Table ▁h Base Table ▁, ▁byte ▁[ ▁] ▁columnFamily Name ▁) ▁{ ▁super ▁( ▁h Base Table ▁, ▁columnFamily Name ▁) ▁; ▁} ▁} ▁public ▁static ▁final ▁Agent LifeCycle Status ▁AGENT _ LI F EC YCLE _ STATUS ▁= ▁new ▁Agent LifeCycle Status ▁( ▁Hbase Table ▁. ▁AGENT _ LI F EC YCLE ▁, ▁Bytes ▁. ▁toBytes ▁( ▁STR ▁) ▁) ▁; ▁public ▁static ▁class ▁Agent LifeCycle Status ▁extends ▁Hbase ColumnFamily ▁{ ▁public ▁byte ▁[ ▁] ▁ QUAL IFIER _ STATE S ▁= ▁Bytes ▁. ▁toBytes ▁( ▁STR ▁) ▁; ▁private ▁Agent LifeCycle Status ▁( ▁Hbase Table ▁h Base Table ▁, ▁byte ▁[ ▁] ▁columnFamily Name ▁) ▁{ ▁super ▁( ▁h Base Table ▁, ▁columnFamily Name ▁) ▁; ▁} ▁} ▁public ▁static ▁final ▁AgentStat Statistics ▁AGENT _ STAT _ STAT ISTICS ▁= ▁new ▁AgentStat Statistics ▁( ▁Hbase Table ▁. ▁AGENT _ STAT _ VER 2 ▁, ▁Bytes ▁. ▁toBytes ▁( ▁STR ▁) ▁) ▁; ▁public ▁static ▁class ▁AgentStat Statistics ▁extends ▁Hbase ColumnFamily ▁{ ▁public ▁final ▁int ▁TIME SPAN _ MS ▁= ▁5 ▁ * ▁60 ▁ * ▁1000 ▁; ▁private ▁AgentStat Statistics ▁( ▁Hbase Table ▁h Base Table ▁, ▁byte ▁[ ▁] ▁columnFamily Name ▁) ▁{ ▁super ▁( ▁h Base Table ▁, ▁columnFamily Name ▁) ▁; ▁} ▁} ▁public ▁static ▁final ▁Agent UriStat Statistics ▁AGENT _ URI _ STAT _ STAT ISTICS ▁= ▁new ▁Agent UriStat Statistics ▁( ▁Hbase Table ▁. ▁AGENT _ URI _ STAT ▁, ▁Bytes ▁. ▁toBytes ▁( ▁STR ▁) ▁) ▁; ▁public ▁static ▁class ▁Agent UriStat Statistics ▁extends ▁Hbase ColumnFamily ▁{ ▁public ▁final ▁int ▁TIME SPAN _ MS ▁= ▁5 ▁ * ▁60 ▁ * ▁1000 ▁; ▁private ▁Agent UriStat Statistics ▁( ▁Hbase Table ▁h Base Table ▁, ▁byte ▁[ ▁] ▁columnFamily Name ▁) ▁{ ▁super ▁( ▁h Base Table ▁, ▁columnFamily Name ▁) ▁; ▁} ▁} ▁public ▁static ▁final ▁Api Metadata ▁API _ METADATA _ API ▁= ▁new ▁Api Metadata ▁( ▁Hbase Table ▁. ▁API _ METADATA ▁, ▁Bytes ▁. ▁toBytes ▁( ▁STR ▁) ▁) ▁;
▁Tree Viewer ▁items Viewer ▁= ▁( ▁Tree Viewer ▁) ▁item List ▁. ▁getItems Viewer ▁( ▁) ▁; ▁Collection ▁< ▁DBNNode ▁> ▁old Nodes ▁= ▁item List ▁. ▁getList Data ▁( ▁) ▁; ▁List ▁< ▁DBNNode ▁> ▁new Nodes ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁if ▁( ▁! ▁CommonUtils ▁. ▁isEmpty ▁( ▁old Nodes ▁) ▁) ▁{ ▁new Nodes ▁. ▁addAll ▁( ▁old Nodes ▁) ▁; ▁} ▁new Nodes ▁. ▁addAll ▁( ▁nodes ▁) ▁; ▁( ▁( ▁Results Content Provider ▁) ▁items Viewer ▁. ▁getContent Provider ▁( ▁) ▁) ▁. ▁re build Object Tree ▁( ▁new Nodes ▁) ▁; ▁item List ▁. ▁append List Data ▁( ▁nodes ▁) ▁; ▁items Viewer ▁. ▁expand All ▁( ▁) ▁; ▁} ▁} ▁protected ▁abstract ▁DBNNode ▁getNode From Object ▁( ▁OBJECT _ TYPE ▁object ▁) ▁; ▁public ▁void ▁clear Objects ▁( ▁) ▁{ ▁item List ▁. ▁clear List Data ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁DBNNode ▁getRoot Node ▁( ▁) ▁{ ▁return ▁item List ▁. ▁getRoot Node ▁( ▁) ▁; ▁} ▁@ ▁Nullable ▁@ ▁Override ▁public ▁View er ▁getN avigator Viewer ▁( ▁) ▁{ ▁return ▁item List ▁. ▁getN avigator Viewer ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁get UI State ▁( ▁) ▁{ ▁return ▁ui State ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setInput ▁( ▁I SearchResult ▁search ▁, ▁Object ▁ui State ▁) ▁{ ▁item List ▁. ▁set Info ▁( ▁search ▁== ▁null ▁? ▁STR ▁: ▁STR ▁+ ▁search ▁. ▁getLabel ▁( ▁) ▁+ ▁STR ▁) ▁; ▁if ▁( ▁this ▁. ▁search Result ▁!= ▁null ▁) ▁{ ▁this ▁. ▁search Result ▁. ▁removeListener ▁( ▁this ▁. ▁result Listener ▁) ▁; ▁} ▁this ▁. ▁search Result ▁= ▁search ▁; ▁this ▁. ▁ui State ▁= ▁ui State ▁; ▁if ▁( ▁this ▁. ▁search Result ▁!= ▁null ▁) ▁{ ▁this ▁. ▁search Result ▁. ▁addListener ▁( ▁this ▁. ▁result Listener ▁) ▁; ▁} ▁if ▁( ▁this ▁. ▁search Result ▁== ▁null ▁) ▁{ ▁clear Objects ▁( ▁) ▁; ▁} ▁else ▁if ▁( ▁search Result ▁instanceof ▁Abstract SearchResult ▁) ▁{ ▁populate Objects ▁( ▁( ▁( ▁Abstract SearchResult ▁) ▁search Result ▁) ▁. ▁getObjects ▁( ▁) ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁setView Part ▁( ▁I SearchResult View Part ▁part ▁) ▁{ ▁this ▁. ▁view Part ▁= ▁part ▁; ▁} ▁@ ▁Override ▁public ▁void ▁restore State ▁( ▁IM e mento ▁me mento ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁saveState ▁( ▁IM e mento ▁me mento ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁set ID ▁( ▁String ▁id ▁) ▁{ ▁this ▁. ▁id ▁= ▁id ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getID ▁( ▁) ▁{ ▁return ▁this ▁. ▁id ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getLabel ▁( ▁) ▁{ ▁return ▁search Result ▁== ▁null ▁? ▁STR ▁: ▁search Result ▁. ▁getLabel ▁( ▁) ▁; ▁}
▁public ▁interface ▁M o vable ▁{ ▁double ▁getS peed ▁( ▁) ▁; ▁}
▁if ▁( ▁th unk ed Function ▁!= ▁null ▁) ▁{ ▁th unk ed Function ▁. ▁set Return ▁( ▁type ▁, ▁storage ▁, ▁source ▁) ▁; ▁return ▁; ▁} ▁type ▁= ▁type ▁. ▁clone ▁( ▁program ▁. ▁getDataType Manager ▁( ▁) ▁) ▁; ▁if ▁( ▁storage ▁. ▁isValid ▁( ▁) ▁&& ▁( ▁storage ▁. ▁size ▁( ▁) ▁!= ▁type ▁. ▁getLength ▁( ▁) ▁) ▁) ▁{ ▁try ▁{ ▁storage ▁= ▁Variable Utilities ▁. ▁resize Storage ▁( ▁storage ▁, ▁type ▁, ▁true ▁, ▁this ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁} ▁} ▁get Return ▁( ▁) ▁. ▁set DataType ▁( ▁type ▁, ▁storage ▁, ▁true ▁, ▁source ▁) ▁; ▁} ▁finally ▁{ ▁end Update ▁( ▁) ▁; ▁manager ▁. ▁lock ▁. ▁release ▁( ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁set ReturnType ▁( ▁DataType ▁type ▁, ▁SourceType ▁source ▁) ▁throws ▁Invalid InputException ▁{ ▁manager ▁. ▁lock ▁. ▁acquire ▁( ▁) ▁; ▁try ▁{ ▁start Update ▁( ▁) ▁; ▁check Deleted ▁( ▁) ▁; ▁if ▁( ▁th unk ed Function ▁!= ▁null ▁) ▁{ ▁th unk ed Function ▁. ▁set ReturnType ▁( ▁type ▁, ▁source ▁) ▁; ▁return ▁; ▁} ▁get Return ▁( ▁) ▁. ▁set DataType ▁( ▁type ▁, ▁source ▁) ▁; ▁} ▁finally ▁{ ▁end Update ▁( ▁) ▁; ▁manager ▁. ▁lock ▁. ▁release ▁( ▁) ▁; ▁} ▁} ▁void ▁set Return Storage And DataType ▁( ▁Variable Storage ▁storage ▁, ▁DataType ▁type ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁storage ▁!= ▁null ▁&& ▁storage ▁. ▁isUn assigned Storage ▁( ▁) ▁) ▁{ ▁storage ▁= ▁null ▁; ▁} ▁long ▁type Id ▁= ▁( ▁( ▁DataTypeManager DB ▁) ▁program ▁. ▁getDataType Manager ▁( ▁) ▁) ▁. ▁getResolved ID ▁( ▁type ▁) ▁; ▁rec ▁. ▁setLongValue ▁( ▁Function Adapter ▁. ▁RETURN _ DATA _ TYPE _ ID _ COL ▁, ▁type Id ▁) ▁; ▁rec ▁. ▁setString ▁( ▁Function Adapter ▁. ▁RETURN _ STORAGE _ COL ▁, ▁storage ▁!= ▁null ▁? ▁storage ▁. ▁get Serialization String ▁( ▁) ▁: ▁null ▁) ▁; ▁manager ▁. ▁getFunction Adapter ▁( ▁) ▁. ▁update Function Record ▁( ▁rec ▁) ▁; ▁} ▁DataType ▁get Return DataType ▁( ▁) ▁{ ▁long ▁type Id ▁= ▁rec ▁. ▁getLong Value ▁( ▁Function Adapter ▁. ▁RETURN _ DATA _ TYPE _ ID _ COL ▁) ▁; ▁DataType ▁dt ▁= ▁program ▁. ▁getDataType Manager ▁( ▁) ▁. ▁getDataType ▁( ▁type Id ▁) ▁; ▁if ▁( ▁dt ▁== ▁null ▁) ▁{ ▁dt ▁= ▁DataType ▁. ▁DEFAULT ▁; ▁if ▁( ▁has Custom Variable Storage ▁( ▁) ▁) ▁{ ▁Variable Storage ▁storage ▁= ▁deserialize Storage ▁( ▁rec ▁. ▁getString ▁( ▁Function Adapter ▁. ▁RETURN _ STORAGE _ COL ▁) ▁) ▁; ▁if ▁( ▁storage ▁. ▁is Void Storage ▁( ▁) ▁) ▁{ ▁dt ▁= ▁Void DataType ▁. ▁dataType ▁; ▁} ▁else ▁{ ▁dt ▁= ▁Undefined ▁. ▁getUn defined DataType ▁( ▁storage ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁return ▁dt ▁; ▁} ▁private ▁Variable Storage ▁deserialize Storage ▁( ▁String ▁serialized Storage ▁) ▁{ ▁if ▁( ▁serialized Storage ▁== ▁null ▁) ▁{ ▁return ▁Variable Storage ▁. ▁UN ASSIGNED _ STORAGE ▁; ▁}
▁return ▁idx ▁; ▁} ▁protected ▁int ▁setValue ▁( ▁GeoShape Cell Values ▁doc Values ▁, ▁GeoShape Values ▁. ▁GeoShape Value ▁geo Value ▁, ▁GeoShape Values ▁. ▁Bound ingBox ▁bounds ▁) ▁{ ▁String ▁hash ▁= ▁Geo hash ▁. ▁string Encode ▁( ▁bounds ▁. ▁min X ▁( ▁) ▁, ▁bounds ▁. ▁min Y ▁( ▁) ▁, ▁precision ▁) ▁; ▁if ▁( ▁re late Tile ▁( ▁geo Value ▁, ▁hash ▁) ▁!= ▁Geo Relation ▁. ▁QUERY _ DIS JO INT ▁) ▁{ ▁doc Values ▁. ▁resize Cell ▁( ▁1 ▁) ▁; ▁doc Values ▁. ▁add ▁( ▁0 ▁, ▁Geo hash ▁. ▁long Encode ▁( ▁hash ▁) ▁) ▁; ▁return ▁1 ▁; ▁} ▁return ▁0 ▁; ▁} ▁private ▁Geo Relation ▁re late Tile ▁( ▁GeoShape Values ▁. ▁GeoShape Value ▁geo Value ▁, ▁String ▁hash ▁) ▁{ ▁return ▁valid Hash ▁( ▁hash ▁) ▁? ▁geo Value ▁. ▁re late ▁( ▁Geo hash ▁. ▁to BoundingBox ▁( ▁hash ▁) ▁) ▁: ▁Geo Relation ▁. ▁QUERY _ DIS JO INT ▁; ▁} ▁protected ▁int ▁set Values By R aster ization ▁( ▁String ▁hash ▁, ▁GeoShape Cell Values ▁values ▁, ▁int ▁values Index ▁, ▁GeoShape Values ▁. ▁GeoShape Value ▁geo Value ▁) ▁{ ▁String ▁[ ▁] ▁hash es ▁= ▁Geo hash ▁. ▁getSub Geo hash es ▁( ▁hash ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁hash es ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁Geo Relation ▁relation ▁= ▁re late Tile ▁( ▁geo Value ▁, ▁hash es ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁relation ▁== ▁Geo Relation ▁. ▁QUERY _ C RO S SES ▁) ▁{ ▁if ▁( ▁hash es ▁[ ▁i ▁] ▁. ▁length ▁( ▁) ▁== ▁precision ▁) ▁{ ▁values ▁. ▁resize Cell ▁( ▁values Index ▁+ ▁1 ▁) ▁; ▁values ▁. ▁add ▁( ▁values Index ▁++ ▁, ▁Geo hash ▁. ▁long Encode ▁( ▁hash es ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁else ▁{ ▁values Index ▁= ▁set Values By R aster ization ▁( ▁hash es ▁[ ▁i ▁] ▁, ▁values ▁, ▁values Index ▁, ▁geo Value ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁relation ▁== ▁Geo Relation ▁. ▁QUERY _ INS IDE ▁) ▁{ ▁if ▁( ▁hash es ▁[ ▁i ▁] ▁. ▁length ▁( ▁) ▁== ▁precision ▁) ▁{ ▁values ▁. ▁resize Cell ▁( ▁values Index ▁+ ▁1 ▁) ▁; ▁values ▁. ▁add ▁( ▁values Index ▁++ ▁, ▁Geo hash ▁. ▁long Encode ▁( ▁hash es ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁else ▁{ ▁int ▁num Tile s At Precision ▁= ▁getNum Tile s At Precision ▁( ▁precision ▁, ▁hash ▁. ▁length ▁( ▁) ▁) ▁; ▁values ▁. ▁resize Cell ▁( ▁getNew Size ▁( ▁values Index ▁, ▁num Tile s At Precision ▁+ ▁1 ▁) ▁) ▁; ▁values Index ▁= ▁set Values For Fully Contained Tile ▁( ▁hash es ▁[ ▁i ▁] ▁, ▁values ▁, ▁values Index ▁, ▁precision ▁) ▁; ▁} ▁} ▁} ▁return ▁values Index ▁; ▁} ▁private ▁int ▁getNew Size ▁( ▁int ▁values Index ▁, ▁int ▁increment ▁) ▁{ ▁long ▁new Size ▁= ▁( ▁long ▁) ▁values Index ▁+ ▁increment ▁;
▁public ▁final ▁class ▁Re con stru cted Payment ▁implements ▁Payment ▁{ ▁private ▁final ▁long ▁block Index ▁; ▁private ▁final ▁long ▁block Timestamp ▁; ▁private ▁final ▁Direction ▁direction ▁; ▁private ▁final ▁Money ▁amount ▁; ▁public ▁Re con stru cted Payment ▁( ▁long ▁block Index ▁, ▁long ▁block Timestamp ▁, ▁@ ▁NonNull ▁Direction ▁direction ▁, ▁@ ▁NonNull ▁Money ▁amount ▁) ▁{ ▁this ▁. ▁block Index ▁= ▁block Index ▁; ▁this ▁. ▁block Timestamp ▁= ▁block Timestamp ▁; ▁this ▁. ▁direction ▁= ▁direction ▁; ▁this ▁. ▁amount ▁= ▁amount ▁; ▁} ▁@ ▁NonNull ▁public ▁@ ▁Override ▁UUID ▁get Uuid ▁( ▁) ▁{ ▁return ▁Uuid Util ▁. ▁UNKNOWN _ UUID ▁; ▁} ▁@ ▁Override ▁public ▁@ ▁NonNull ▁Pay ee ▁getP ay ee ▁( ▁) ▁{ ▁return ▁Pay ee ▁. ▁UNKNOWN ▁; ▁} ▁@ ▁Override ▁public ▁long ▁getBlock Index ▁( ▁) ▁{ ▁return ▁block Index ▁; ▁} ▁@ ▁Override ▁public ▁long ▁getTimestamp ▁( ▁) ▁{ ▁return ▁block Timestamp ▁; ▁} ▁@ ▁Override ▁public ▁long ▁getBlock Timestamp ▁( ▁) ▁{ ▁return ▁block Timestamp ▁; ▁} ▁@ ▁Override ▁public ▁@ ▁NonNull ▁Direction ▁getD irection ▁( ▁) ▁{ ▁return ▁direction ▁; ▁} ▁@ ▁Override ▁public ▁@ ▁NonNull ▁State ▁getState ▁( ▁) ▁{ ▁return ▁State ▁. ▁SUCCESS F UL ▁; ▁} ▁@ ▁Override ▁public ▁@ ▁Nullable ▁Failure Reason ▁getFailure Reason ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁@ ▁NonNull ▁String ▁get Note ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁@ ▁NonNull ▁Money ▁getA mount ▁( ▁) ▁{ ▁return ▁amount ▁; ▁} ▁@ ▁Override ▁public ▁@ ▁NonNull ▁Money ▁getF ee ▁( ▁) ▁{ ▁return ▁amount ▁. ▁to Z ero ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁@ ▁NonNull ▁Payment MetaData ▁getP ayment MetaData ▁( ▁) ▁{ ▁return ▁Payment MetaData ▁. ▁getDefault Instance ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is Seen ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁}
▁class ▁Asci id o ctor Con vent ions ▁{ ▁private ▁static ▁final ▁String ▁ASC I ID O CTOR J _ VERSION ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁EXT ENSION S _ CONFIGURATION _ NAME ▁= ▁STR ▁; ▁void ▁apply ▁( ▁Project ▁project ▁) ▁{ ▁project ▁. ▁getPlugins ▁( ▁) ▁. ▁with Type ▁( ▁Asci id o ctor J Plugin ▁. ▁class ▁, ▁( ▁as ci id o ctor Plugin ▁) ▁-> ▁{ ▁configure Documentation Dependencies Repository ▁( ▁project ▁) ▁; ▁make All Warnings Fatal ▁( ▁project ▁) ▁; ▁upgrade As ci id o ctor J Version ▁( ▁project ▁) ▁; ▁create As ci id o ctor Extensions Configuration ▁( ▁project ▁) ▁; ▁project ▁. ▁getTasks ▁( ▁) ▁. ▁with Type ▁( ▁Abstract As ci id o ctor Task ▁. ▁class ▁, ▁( ▁as ci id o ctor Task ▁) ▁-> ▁configure As ci id o ctor Task ▁( ▁project ▁, ▁as ci id o ctor Task ▁) ▁) ▁; ▁} ▁) ▁; ▁} ▁private ▁void ▁configure Documentation Dependencies Repository ▁( ▁Project ▁project ▁) ▁{ ▁project ▁. ▁getRe positories ▁( ▁) ▁. ▁maven ▁( ▁( ▁maven Repo ▁) ▁-> ▁{ ▁maven Repo ▁. ▁setUrl ▁( ▁URI ▁. ▁create ▁( ▁STR ▁) ▁) ▁; ▁maven Repo ▁. ▁maven Content ▁( ▁( ▁maven Content ▁) ▁-> ▁{ ▁maven Content ▁. ▁include Group ▁( ▁STR ▁) ▁; ▁maven Content ▁. ▁include Group ▁( ▁STR ▁) ▁; ▁maven Content ▁. ▁include Group ▁( ▁STR ▁) ▁; ▁} ▁) ▁; ▁} ▁) ▁; ▁} ▁private ▁void ▁make All Warnings Fatal ▁( ▁Project ▁project ▁) ▁{ ▁project ▁. ▁get Extensions ▁( ▁) ▁. ▁getBy Type ▁( ▁Asci id o ctor J Extension ▁. ▁class ▁) ▁. ▁fatal Warnings ▁( ▁STR ▁) ▁; ▁} ▁private ▁void ▁upgrade As ci id o ctor J Version ▁( ▁Project ▁project ▁) ▁{ ▁project ▁. ▁get Extensions ▁( ▁) ▁. ▁getBy Type ▁( ▁Asci id o ctor J Extension ▁. ▁class ▁) ▁. ▁setVersion ▁( ▁ASC I ID O CTOR J _ VERSION ▁) ▁; ▁} ▁private ▁void ▁create As ci id o ctor Extensions Configuration ▁( ▁Project ▁project ▁) ▁{ ▁project ▁. ▁get Configurations ▁( ▁) ▁. ▁create ▁( ▁EXT ENSION S _ CONFIGURATION _ NAME ▁, ▁( ▁configuration ▁) ▁-> ▁{ ▁project ▁. ▁get Configurations ▁( ▁) ▁. ▁matching ▁( ▁( ▁candidate ▁) ▁-> ▁STR ▁. ▁equals ▁( ▁candidate ▁. ▁getName ▁( ▁) ▁) ▁) ▁. ▁all ▁( ▁( ▁dependency Management ▁) ▁-> ▁configuration ▁. ▁extends From ▁( ▁dependency Management ▁) ▁) ▁; ▁configuration ▁. ▁getDependencies ▁( ▁) ▁. ▁add ▁( ▁project ▁. ▁getDependencies ▁( ▁) ▁. ▁create ▁( ▁STR ▁) ▁) ▁; ▁configuration ▁. ▁getDependencies ▁( ▁) ▁. ▁add ▁( ▁project ▁. ▁getDependencies ▁( ▁) ▁. ▁create ▁( ▁STR ▁) ▁) ▁; ▁} ▁) ▁; ▁} ▁private ▁void ▁configure As ci id o ctor Task ▁( ▁Project ▁project ▁, ▁Abstract As ci id o ctor Task ▁as ci id o ctor Task ▁) ▁{ ▁as ci id o ctor Task ▁. ▁configurations ▁( ▁EXT ENSION S _ CONFIGURATION _ NAME ▁) ▁;
▁public ▁class ▁Get Settings Action Tests ▁extends ▁ESTestCase ▁{ ▁private ▁Transport Service ▁transport Service ▁; ▁private ▁ClusterService ▁clusterService ▁; ▁private ▁ThreadPool ▁threadPool ▁; ▁private ▁Settings Filter ▁settings Filter ▁; ▁private ▁final ▁String ▁indexName ▁= ▁STR ▁; ▁private ▁Test Transport Get Settings Action ▁getSettings Action ▁; ▁class ▁Test Transport Get Settings Action ▁extends ▁TransportGet Settings Action ▁{ ▁Test Transport Get Settings Action ▁( ▁) ▁{ ▁super ▁( ▁Get Settings Action Tests ▁. ▁this ▁. ▁transport Service ▁, ▁Get Settings Action Tests ▁. ▁this ▁. ▁clusterService ▁, ▁Get Settings Action Tests ▁. ▁this ▁. ▁threadPool ▁, ▁settings Filter ▁, ▁new ▁ActionFilters ▁( ▁Collections ▁. ▁emptySet ▁( ▁) ▁) ▁, ▁new ▁ Resolver ▁( ▁) ▁, ▁Index Scoped Settings ▁. ▁DEFAULT _ SCOPE D _ SETTINGS ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁master Operation ▁( ▁Task ▁task ▁, ▁Get Settings Request ▁request ▁, ▁ClusterState ▁state ▁, ▁ActionListener ▁< ▁Get Settings Response ▁> ▁listener ▁) ▁{ ▁ClusterState ▁state With Index ▁= ▁ClusterState Creation Utils ▁. ▁state ▁( ▁indexName ▁, ▁1 ▁, ▁1 ▁) ▁; ▁super ▁. ▁master Operation ▁( ▁task ▁, ▁request ▁, ▁state With Index ▁, ▁listener ▁) ▁; ▁} ▁} ▁@ ▁Before ▁public ▁void ▁setUp ▁( ▁) ▁throws ▁Exception ▁{ ▁super ▁. ▁setUp ▁( ▁) ▁; ▁settings Filter ▁= ▁new ▁Settings Module ▁( ▁Settings ▁. ▁EMPTY ▁, ▁emptyList ▁( ▁) ▁, ▁emptyList ▁( ▁) ▁, ▁emptySet ▁( ▁) ▁) ▁. ▁getSettings Filter ▁( ▁) ▁; ▁threadPool ▁= ▁new ▁Test ThreadPool ▁( ▁STR ▁) ▁; ▁clusterService ▁= ▁create Cluster Service ▁( ▁threadPool ▁) ▁; ▁C apturing Transport ▁c apturing Transport ▁= ▁new ▁C apturing Transport ▁( ▁) ▁; ▁transport Service ▁= ▁c apturing Transport ▁. ▁create Transport Service ▁( ▁clusterService ▁. ▁getSettings ▁( ▁) ▁, ▁threadPool ▁, ▁Transport Service ▁. ▁NOOP _ TRAN SPORT _ INTERCEPTOR ▁, ▁bound Address ▁-> ▁clusterService ▁. ▁local Node ▁( ▁) ▁, ▁null ▁, ▁Collections ▁. ▁emptySet ▁( ▁) ▁) ▁; ▁transport Service ▁. ▁start ▁( ▁) ▁; ▁transport Service ▁. ▁accept In coming Requests ▁( ▁) ▁; ▁getSettings Action ▁= ▁new ▁Get Settings Action Tests ▁. ▁Test Transport Get Settings Action ▁( ▁) ▁; ▁} ▁@ ▁After ▁public ▁void ▁tearDown ▁( ▁) ▁throws ▁Exception ▁{ ▁ThreadPool ▁. ▁terminate ▁( ▁threadPool ▁, ▁30 ▁, ▁TimeUnit ▁. ▁SECONDS ▁) ▁; ▁threadPool ▁= ▁null ▁; ▁clusterService ▁. ▁close ▁( ▁) ▁; ▁super ▁. ▁tearDown ▁( ▁) ▁; ▁} ▁public ▁void ▁test Include Defaults ▁( ▁) ▁{ ▁Get Settings Request ▁no Defaults Request ▁= ▁new ▁Get Settings Request ▁( ▁) ▁. ▁indices ▁( ▁indexName ▁) ▁; ▁Action TestUtils ▁. ▁execute ▁( ▁getSettings Action ▁, ▁null ▁, ▁no Defaults Request ▁, ▁ActionListener ▁. ▁wrap ▁( ▁no Defaults Response ▁-> ▁{ ▁assertNull ▁( ▁STR ▁, ▁no Defaults Response ▁. ▁get Setting ▁( ▁indexName ▁, ▁STR ▁) ▁) ▁; ▁} ▁, ▁exception ▁-> ▁{ ▁throw ▁new ▁AssertionError ▁( ▁exception ▁) ▁; ▁} ▁) ▁) ▁; ▁Get Settings Request ▁default sRequest ▁= ▁new ▁Get Settings Request ▁( ▁) ▁. ▁indices ▁( ▁indexName ▁) ▁. ▁include Defaults ▁( ▁true ▁) ▁;
▁final ▁class ▁Fixed Length Byte Key Comparator ▁< ▁IN ▁> ▁extends ▁TypeComparator ▁< ▁Tuple 2 ▁< ▁byte ▁[ ▁] ▁, ▁StreamRecord ▁< ▁IN ▁> ▁> ▁> ▁{ ▁static ▁final ▁int ▁TIMESTAMP _ BYTE _ SI Z E ▁= ▁8 ▁; ▁private ▁final ▁int ▁key Length ▁; ▁private ▁byte ▁[ ▁] ▁key Reference ▁; ▁private ▁long ▁timestamp Reference ▁; ▁Fixed Length Byte Key Comparator ▁( ▁int ▁key Length ▁) ▁{ ▁this ▁. ▁key Length ▁= ▁key Length ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hash ▁( ▁Tuple 2 ▁< ▁byte ▁[ ▁] ▁, ▁StreamRecord ▁< ▁IN ▁> ▁> ▁record ▁) ▁{ ▁return ▁record ▁. ▁hashCode ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Reference ▁( ▁Tuple 2 ▁< ▁byte ▁[ ▁] ▁, ▁StreamRecord ▁< ▁IN ▁> ▁> ▁to Compare ▁) ▁{ ▁this ▁. ▁key Reference ▁= ▁to Compare ▁. ▁f 0 ▁; ▁this ▁. ▁timestamp Reference ▁= ▁to Compare ▁. ▁f 1 ▁. ▁as Record ▁( ▁) ▁. ▁getTimestamp ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equalTo Reference ▁( ▁Tuple 2 ▁< ▁byte ▁[ ▁] ▁, ▁StreamRecord ▁< ▁IN ▁> ▁> ▁candidate ▁) ▁{ ▁return ▁Arrays ▁. ▁equals ▁( ▁key Reference ▁, ▁candidate ▁. ▁f 0 ▁) ▁&& ▁timestamp Reference ▁== ▁candidate ▁. ▁f 1 ▁. ▁as Record ▁( ▁) ▁. ▁getTimestamp ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁compareTo Reference ▁( ▁TypeComparator ▁< ▁Tuple 2 ▁< ▁byte ▁[ ▁] ▁, ▁StreamRecord ▁< ▁IN ▁> ▁> ▁> ▁referenced Comparator ▁) ▁{ ▁byte ▁[ ▁] ▁other Key ▁= ▁( ▁( ▁Fixed Length Byte Key Comparator ▁< ▁IN ▁> ▁) ▁referenced Comparator ▁) ▁. ▁key Reference ▁; ▁long ▁other Timestamp ▁= ▁( ▁( ▁Fixed Length Byte Key Comparator ▁< ▁IN ▁> ▁) ▁referenced Comparator ▁) ▁. ▁timestamp Reference ▁; ▁int ▁key C mp ▁= ▁compare ▁( ▁other Key ▁, ▁this ▁. ▁key Reference ▁) ▁; ▁if ▁( ▁key C mp ▁!= ▁0 ▁) ▁{ ▁return ▁key C mp ▁; ▁} ▁return ▁Long ▁. ▁compare ▁( ▁other Timestamp ▁, ▁this ▁. ▁timestamp Reference ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁compare ▁( ▁Tuple 2 ▁< ▁byte ▁[ ▁] ▁, ▁StreamRecord ▁< ▁IN ▁> ▁> ▁first ▁, ▁Tuple 2 ▁< ▁byte ▁[ ▁] ▁, ▁StreamRecord ▁< ▁IN ▁> ▁> ▁second ▁) ▁{ ▁int ▁key C mp ▁= ▁compare ▁( ▁first ▁. ▁f 0 ▁, ▁second ▁. ▁f 0 ▁) ▁; ▁if ▁( ▁key C mp ▁!= ▁0 ▁) ▁{ ▁return ▁key C mp ▁; ▁} ▁return ▁Long ▁. ▁compare ▁( ▁first ▁. ▁f 1 ▁. ▁as Record ▁( ▁) ▁. ▁getTimestamp ▁( ▁) ▁, ▁second ▁. ▁f 1 ▁. ▁as Record ▁( ▁) ▁. ▁getTimestamp ▁( ▁) ▁) ▁; ▁} ▁private ▁int ▁compare ▁( ▁byte ▁[ ▁] ▁first ▁, ▁byte ▁[ ▁] ▁second ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁key Length ▁; ▁i ▁++ ▁) ▁{ ▁int ▁cmp ▁= ▁Byte ▁. ▁compare ▁( ▁first ▁[ ▁i ▁] ▁, ▁second ▁[ ▁i ▁] ▁) ▁; ▁if ▁( ▁cmp ▁!= ▁0 ▁) ▁{ ▁return ▁cmp ▁< ▁0 ▁? ▁- ▁1 ▁: ▁1 ▁; ▁} ▁} ▁return ▁0 ▁; ▁}
▁public ▁String ▁getApp ▁( ▁) ▁{ ▁return ▁app ▁; ▁} ▁public ▁void ▁setApp ▁( ▁String ▁app ▁) ▁{ ▁this ▁. ▁app ▁= ▁app ▁; ▁} ▁public ▁Date ▁getTimestamp ▁( ▁) ▁{ ▁return ▁timestamp ▁; ▁} ▁public ▁void ▁setTimestamp ▁( ▁Date ▁timestamp ▁) ▁{ ▁this ▁. ▁timestamp ▁= ▁timestamp ▁; ▁} ▁public ▁String ▁getResource ▁( ▁) ▁{ ▁return ▁resource ▁; ▁} ▁public ▁void ▁setResource ▁( ▁String ▁resource ▁) ▁{ ▁this ▁. ▁resource ▁= ▁resource ▁; ▁this ▁. ▁resource Code ▁= ▁resource ▁. ▁hashCode ▁( ▁) ▁; ▁} ▁public ▁Long ▁getP ass Qps ▁( ▁) ▁{ ▁return ▁pass Qps ▁; ▁} ▁public ▁void ▁set Pass Qps ▁( ▁Long ▁pass Qps ▁) ▁{ ▁this ▁. ▁pass Qps ▁= ▁pass Qps ▁; ▁} ▁public ▁Long ▁getBlock Qps ▁( ▁) ▁{ ▁return ▁block Qps ▁; ▁} ▁public ▁void ▁set Block Qps ▁( ▁Long ▁block Qps ▁) ▁{ ▁this ▁. ▁block Qps ▁= ▁block Qps ▁; ▁} ▁public ▁Long ▁getException Qps ▁( ▁) ▁{ ▁return ▁exception Qps ▁; ▁} ▁public ▁void ▁setException Qps ▁( ▁Long ▁exception Qps ▁) ▁{ ▁this ▁. ▁exception Qps ▁= ▁exception Qps ▁; ▁} ▁public ▁double ▁getR t ▁( ▁) ▁{ ▁return ▁rt ▁; ▁} ▁public ▁void ▁setR t ▁( ▁double ▁rt ▁) ▁{ ▁this ▁. ▁rt ▁= ▁rt ▁; ▁} ▁public ▁int ▁getCount ▁( ▁) ▁{ ▁return ▁count ▁; ▁} ▁public ▁void ▁setCount ▁( ▁int ▁count ▁) ▁{ ▁this ▁. ▁count ▁= ▁count ▁; ▁} ▁public ▁int ▁getResource Code ▁( ▁) ▁{ ▁return ▁resource Code ▁; ▁} ▁public ▁Long ▁getSuccess Qps ▁( ▁) ▁{ ▁return ▁success Qps ▁; ▁} ▁public ▁void ▁setSuccess Qps ▁( ▁Long ▁success Qps ▁) ▁{ ▁this ▁. ▁success Qps ▁= ▁success Qps ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁STR ▁+ ▁id ▁+ ▁STR ▁+ ▁g mtCreate ▁+ ▁STR ▁+ ▁g mt Modified ▁+ ▁STR ▁+ ▁app ▁+ ▁CHAR ▁+ ▁STR ▁+ ▁timestamp ▁+ ▁STR ▁+ ▁resource ▁+ ▁CHAR ▁+ ▁STR ▁+ ▁pass Qps ▁+ ▁STR ▁+ ▁block Qps ▁+ ▁STR ▁+ ▁success Qps ▁+ ▁STR ▁+ ▁exception Qps ▁+ ▁STR ▁+ ▁rt ▁+ ▁STR ▁+ ▁count ▁+ ▁STR ▁+ ▁resource Code ▁+ ▁CHAR ▁; ▁} ▁}
▁public ▁class ▁J A AS Authentication Module ▁implements ▁Authentication Module ▁{ ▁private ▁boolean ▁allow User To Spec ify Name ▁; ▁private ▁String ▁login Context Name ▁; ▁private ▁File ▁j aas ConfigFile ▁; ▁public ▁J A AS Authentication Module ▁( ▁String ▁login Context Name ▁, ▁boolean ▁allow User To Spec ify Name ▁, ▁File ▁j aas ConfigFile ▁) ▁throws ▁IllegalArgument Exception ▁{ ▁this ▁. ▁login Context Name ▁= ▁login Context Name ▁; ▁this ▁. ▁allow User To Spec ify Name ▁= ▁allow User To Spec ify Name ▁; ▁this ▁. ▁j aas ConfigFile ▁= ▁j aas ConfigFile ▁; ▁if ▁( ▁j aas ConfigFile ▁== ▁null ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁if ▁( ▁! ▁j aas ConfigFile ▁. ▁exists ▁( ▁) ▁|| ▁! ▁j aas ConfigFile ▁. ▁isFile ▁( ▁) ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁j aas ConfigFile ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁; ▁} ▁get JA AS Config ▁( ▁) ▁; ▁} ▁private ▁Configuration ▁get JA AS Config ▁( ▁) ▁{ ▁try ▁{ ▁URI ▁j aas ConfigFile Uri ▁= ▁j aas ConfigFile ▁. ▁toURI ▁( ▁) ▁; ▁Configuration ▁cfg ▁= ▁Configuration ▁. ▁getInstance ▁( ▁STR ▁, ▁new ▁URI Parameter ▁( ▁j aas ConfigFile Uri ▁) ▁) ▁; ▁App Configuration Entry ▁[ ▁] ▁auth Entry ▁= ▁cfg ▁. ▁getApp Configuration Entry ▁( ▁login Context Name ▁) ▁; ▁if ▁( ▁auth Entry ▁== ▁null ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁login Context Name ▁+ ▁STR ▁+ ▁j aas ConfigFile ▁) ▁; ▁} ▁return ▁cfg ▁; ▁} ▁catch ▁( ▁NoSuchAlgorithm Exception ▁e ▁) ▁{ ▁throw ▁new ▁Runtime Exception ▁( ▁STR ▁, ▁e ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁String ▁authenticate ▁( ▁User Manager ▁user Mgr ▁, ▁Subject ▁subject ▁, ▁Callback ▁[ ▁] ▁callbacks ▁) ▁throws ▁Login Exception ▁{ ▁Ghidra Principal ▁principal ▁= ▁Ghidra Principal ▁. ▁getG hidra Principal ▁( ▁subject ▁) ▁; ▁AtomicReference ▁< ▁String ▁> ▁login Name ▁= ▁new ▁AtomicReference ▁< ▁> ▁( ▁) ▁; ▁try ▁{ ▁Configuration ▁j aas Cfg ▁= ▁get JA AS Config ▁( ▁) ▁; ▁Login Context ▁login Ctx ▁= ▁new ▁Login Context ▁( ▁login Context Name ▁, ▁null ▁, ▁login Module Callbacks ▁-> ▁{ ▁login Name ▁. ▁set ▁( ▁copy Callback Values ▁( ▁callbacks ▁, ▁login Module Callbacks ▁, ▁principal ▁) ▁) ▁; ▁} ▁, ▁j aas Cfg ▁) ▁; ▁login Ctx ▁. ▁login ▁( ▁) ▁; ▁} ▁catch ▁( ▁IllegalArgument Exception ▁e ▁) ▁{ ▁throw ▁new ▁Login Exception ▁( ▁STR ▁+ ▁e ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁Login Exception ▁e ▁) ▁{ ▁if ▁( ▁e ▁instanceof ▁Failed Login Exception ▁) ▁{ ▁throw ▁e ▁; ▁} ▁throw ▁new ▁Failed Login Exception ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁} ▁finally ▁{ ▁Password Callback ▁src P cb ▁= ▁Authentication Module ▁. ▁getFirst Callback OfType ▁( ▁Password Callback ▁. ▁class ▁, ▁callbacks ▁) ▁; ▁if ▁( ▁src P cb ▁!= ▁null ▁) ▁{ ▁src P cb ▁. ▁clear Password ▁( ▁) ▁; ▁} ▁} ▁String ▁login Name Result ▁= ▁login Name ▁. ▁get ▁( ▁) ▁;
▁public ▁class ▁Test Stream Layout ▁{ ▁private ▁static ▁Stream DataOutput ▁create Stream ▁( ▁int ▁column ▁, ▁Stream Kind ▁stream Kind ▁, ▁int ▁length ▁) ▁{ ▁Stream ▁stream ▁= ▁new ▁Stream ▁( ▁column ▁, ▁stream Kind ▁, ▁length ▁, ▁true ▁) ▁; ▁return ▁new ▁Stream DataOutput ▁( ▁Slices ▁. ▁allocate ▁( ▁1024 ▁) ▁, ▁stream ▁) ▁; ▁} ▁private ▁static ▁void ▁verify Stream ▁( ▁Stream ▁stream ▁, ▁int ▁column ▁, ▁Stream Kind ▁stream Kind ▁, ▁int ▁length ▁) ▁{ ▁assertEquals ▁( ▁stream ▁. ▁getColumn ▁( ▁) ▁, ▁column ▁) ▁; ▁assertEquals ▁( ▁stream ▁. ▁getLength ▁( ▁) ▁, ▁length ▁) ▁; ▁assertEquals ▁( ▁stream ▁. ▁getStream Kind ▁( ▁) ▁, ▁stream Kind ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test By Stream Size ▁( ▁) ▁{ ▁List ▁< ▁Stream DataOutput ▁> ▁streams ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁int ▁length ▁= ▁10_000 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁{ ▁streams ▁. ▁add ▁( ▁create Stream ▁( ▁i ▁, ▁Stream Kind ▁. ▁P RES ENT ▁, ▁length ▁- ▁i ▁) ▁) ▁; ▁streams ▁. ▁add ▁( ▁create Stream ▁( ▁i ▁, ▁Stream Kind ▁. ▁DATA ▁, ▁length ▁- ▁100 ▁- ▁i ▁) ▁) ▁; ▁} ▁Collections ▁. ▁shuffle ▁( ▁streams ▁) ▁; ▁new ▁By Stream Size ▁( ▁) ▁. ▁re order ▁( ▁streams ▁) ▁; ▁assertEquals ▁( ▁streams ▁. ▁size ▁( ▁) ▁, ▁20 ▁) ▁; ▁Iterator ▁< ▁Stream DataOutput ▁> ▁iterator ▁= ▁streams ▁. ▁iterator ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁9 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁verify Stream ▁( ▁iterator ▁. ▁next ▁( ▁) ▁. ▁getStream ▁( ▁) ▁, ▁i ▁, ▁Stream Kind ▁. ▁DATA ▁, ▁length ▁- ▁100 ▁- ▁i ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁9 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁verify Stream ▁( ▁iterator ▁. ▁next ▁( ▁) ▁. ▁getStream ▁( ▁) ▁, ▁i ▁, ▁Stream Kind ▁. ▁P RES ENT ▁, ▁length ▁- ▁i ▁) ▁; ▁} ▁assertFalse ▁( ▁iterator ▁. ▁hasNext ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test By Column Size ▁( ▁) ▁{ ▁List ▁< ▁Stream DataOutput ▁> ▁streams ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁streams ▁. ▁add ▁( ▁create Stream ▁( ▁1 ▁, ▁Stream Kind ▁. ▁DATA ▁, ▁1 _000 ▁) ▁) ▁; ▁streams ▁. ▁add ▁( ▁create Stream ▁( ▁1 ▁, ▁Stream Kind ▁. ▁P RES ENT ▁, ▁10 ▁) ▁) ▁; ▁streams ▁. ▁add ▁( ▁create Stream ▁( ▁2 ▁, ▁Stream Kind ▁. ▁DI CTION ARY _ DATA ▁, ▁300 ▁) ▁) ▁; ▁streams ▁. ▁add ▁( ▁create Stream ▁( ▁2 ▁, ▁Stream Kind ▁. ▁P RES ENT ▁, ▁10 ▁) ▁) ▁; ▁streams ▁. ▁add ▁( ▁create Stream ▁( ▁2 ▁, ▁Stream Kind ▁. ▁DATA ▁, ▁600 ▁) ▁) ▁; ▁streams ▁. ▁add ▁( ▁create Stream ▁( ▁2 ▁, ▁Stream Kind ▁. ▁LENGTH ▁, ▁100 ▁) ▁) ▁; ▁streams ▁. ▁add ▁( ▁create Stream ▁( ▁3 ▁, ▁Stream Kind ▁. ▁DATA ▁, ▁Integer ▁. ▁MAX _ VALUE ▁) ▁) ▁;
▁public ▁class ▁MySqlShow Events Statement ▁extends ▁MySql StatementImpl ▁implements ▁MySqlShow Statement ▁{ ▁private ▁SQLExpr ▁schema ▁; ▁private ▁SQLExpr ▁like ▁; ▁private ▁SQLExpr ▁where ▁; ▁public ▁SQLExpr ▁getSchema ▁( ▁) ▁{ ▁return ▁schema ▁; ▁} ▁public ▁void ▁setSchema ▁( ▁SQLExpr ▁schema ▁) ▁{ ▁this ▁. ▁schema ▁= ▁schema ▁; ▁} ▁public ▁SQLExpr ▁getL ike ▁( ▁) ▁{ ▁return ▁like ▁; ▁} ▁public ▁void ▁set Like ▁( ▁SQLExpr ▁like ▁) ▁{ ▁this ▁. ▁like ▁= ▁like ▁; ▁} ▁public ▁SQLExpr ▁getWhere ▁( ▁) ▁{ ▁return ▁where ▁; ▁} ▁public ▁void ▁set Where ▁( ▁SQLExpr ▁where ▁) ▁{ ▁this ▁. ▁where ▁= ▁where ▁; ▁} ▁public ▁void ▁accept 0 ▁( ▁MySqlASTVisitor ▁visitor ▁) ▁{ ▁if ▁( ▁visitor ▁. ▁visit ▁( ▁this ▁) ▁) ▁{ ▁acceptChild ▁( ▁visitor ▁, ▁schema ▁) ▁; ▁acceptChild ▁( ▁visitor ▁, ▁like ▁) ▁; ▁acceptChild ▁( ▁visitor ▁, ▁where ▁) ▁; ▁} ▁visitor ▁. ▁endVisit ▁( ▁this ▁) ▁; ▁} ▁}
▁@ ▁Service ▁public ▁class ▁UmsMember Receive Address ServiceImpl ▁implements ▁UmsMember Receive Address Service ▁{ ▁@ ▁Autowired ▁private ▁UmsMember Service ▁member Service ▁; ▁@ ▁Autowired ▁private ▁UmsMember Receive Address Mapper ▁address Mapper ▁; ▁@ ▁Override ▁public ▁int ▁add ▁( ▁UmsMember Receive Address ▁address ▁) ▁{ ▁UmsMember ▁current Member ▁= ▁member Service ▁. ▁getCurrent Member ▁( ▁) ▁; ▁address ▁. ▁set Member Id ▁( ▁current Member ▁. ▁getId ▁( ▁) ▁) ▁; ▁return ▁address Mapper ▁. ▁insert ▁( ▁address ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁delete ▁( ▁Long ▁id ▁) ▁{ ▁UmsMember ▁current Member ▁= ▁member Service ▁. ▁getCurrent Member ▁( ▁) ▁; ▁UmsMember Receive Address Example ▁example ▁= ▁new ▁UmsMember Receive Address Example ▁( ▁) ▁; ▁example ▁. ▁create Criteria ▁( ▁) ▁. ▁and Member Id EqualTo ▁( ▁current Member ▁. ▁getId ▁( ▁) ▁) ▁. ▁and Id EqualTo ▁( ▁id ▁) ▁; ▁return ▁address Mapper ▁. ▁delete ByExample ▁( ▁example ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁update ▁( ▁Long ▁id ▁, ▁UmsMember Receive Address ▁address ▁) ▁{ ▁address ▁. ▁setId ▁( ▁null ▁) ▁; ▁UmsMember ▁current Member ▁= ▁member Service ▁. ▁getCurrent Member ▁( ▁) ▁; ▁UmsMember Receive Address Example ▁example ▁= ▁new ▁UmsMember Receive Address Example ▁( ▁) ▁; ▁example ▁. ▁create Criteria ▁( ▁) ▁. ▁and Member Id EqualTo ▁( ▁current Member ▁. ▁getId ▁( ▁) ▁) ▁. ▁and Id EqualTo ▁( ▁id ▁) ▁; ▁if ▁( ▁address ▁. ▁getDefault Status ▁( ▁) ▁== ▁1 ▁) ▁{ ▁UmsMember Receive Address ▁record ▁= ▁new ▁UmsMember Receive Address ▁( ▁) ▁; ▁record ▁. ▁setDefault Status ▁( ▁0 ▁) ▁; ▁UmsMember Receive Address Example ▁update Example ▁= ▁new ▁UmsMember Receive Address Example ▁( ▁) ▁; ▁update Example ▁. ▁create Criteria ▁( ▁) ▁. ▁and Member Id EqualTo ▁( ▁current Member ▁. ▁getId ▁( ▁) ▁) ▁. ▁and Default Status EqualTo ▁( ▁1 ▁) ▁; ▁address Mapper ▁. ▁updateByExample Selective ▁( ▁record ▁, ▁update Example ▁) ▁; ▁} ▁return ▁address Mapper ▁. ▁updateByExample Selective ▁( ▁address ▁, ▁example ▁) ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁UmsMember Receive Address ▁> ▁list ▁( ▁) ▁{ ▁UmsMember ▁current Member ▁= ▁member Service ▁. ▁getCurrent Member ▁( ▁) ▁; ▁UmsMember Receive Address Example ▁example ▁= ▁new ▁UmsMember Receive Address Example ▁( ▁) ▁; ▁example ▁. ▁create Criteria ▁( ▁) ▁. ▁and Member Id EqualTo ▁( ▁current Member ▁. ▁getId ▁( ▁) ▁) ▁; ▁return ▁address Mapper ▁. ▁selectByExample ▁( ▁example ▁) ▁; ▁} ▁@ ▁Override ▁public ▁UmsMember Receive Address ▁getItem ▁( ▁Long ▁id ▁) ▁{ ▁UmsMember ▁current Member ▁= ▁member Service ▁. ▁getCurrent Member ▁( ▁) ▁; ▁UmsMember Receive Address Example ▁example ▁= ▁new ▁UmsMember Receive Address Example ▁( ▁) ▁; ▁example ▁. ▁create Criteria ▁( ▁) ▁. ▁and Member Id EqualTo ▁( ▁current Member ▁. ▁getId ▁( ▁) ▁) ▁. ▁and Id EqualTo ▁( ▁id ▁) ▁; ▁List ▁< ▁UmsMember Receive Address ▁> ▁address List ▁= ▁address Mapper ▁. ▁selectByExample ▁( ▁example ▁) ▁; ▁if ▁( ▁! ▁CollectionUtils ▁. ▁isEmpty ▁( ▁address List ▁) ▁) ▁{ ▁return ▁address List ▁. ▁get ▁( ▁0 ▁) ▁; ▁} ▁return ▁null ▁; ▁} ▁}
▁emit Line ▁( ▁name ▁, ▁STR ▁) ▁; ▁indent ▁++ ▁; ▁field Element ▁( ▁STR ▁, ▁key ▁) ▁; ▁try ▁{ ▁field Element ▁( ▁STR ▁, ▁entry ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁EvalException ▁ex ▁) ▁{ ▁throw ▁Starlark ▁. ▁error f ▁( ▁STR ▁, ▁Starlark ▁. ▁re pr ▁( ▁key ▁) ▁, ▁ex ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁} ▁indent ▁-- ▁; ▁emit Line ▁( ▁STR ▁) ▁; ▁} ▁return ▁; ▁} ▁if ▁( ▁v ▁instanceof ▁Sequence ▁) ▁{ ▁int ▁i ▁= ▁0 ▁; ▁for ▁( ▁Object ▁item ▁: ▁( ▁Sequence ▁< ▁? ▁> ▁) ▁v ▁) ▁{ ▁try ▁{ ▁field Element ▁( ▁name ▁, ▁item ▁) ▁; ▁} ▁catch ▁( ▁EvalException ▁ex ▁) ▁{ ▁throw ▁Starlark ▁. ▁error f ▁( ▁STR ▁, ▁Starlark ▁. ▁type ▁( ▁v ▁) ▁, ▁i ▁, ▁ex ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁} ▁i ▁++ ▁; ▁} ▁return ▁; ▁} ▁field Element ▁( ▁name ▁, ▁v ▁) ▁; ▁} ▁private ▁void ▁field Element ▁( ▁String ▁name ▁, ▁Object ▁v ▁) ▁throws ▁EvalException ▁{ ▁if ▁( ▁v ▁instanceof ▁Structure ▁) ▁{ ▁emit Line ▁( ▁name ▁, ▁STR ▁) ▁; ▁indent ▁++ ▁; ▁message ▁( ▁( ▁Structure ▁) ▁v ▁) ▁; ▁indent ▁-- ▁; ▁emit Line ▁( ▁STR ▁) ▁; ▁} ▁else ▁if ▁( ▁v ▁instanceof ▁String ▁) ▁{ ▁String ▁s ▁= ▁( ▁String ▁) ▁v ▁; ▁emit Line ▁( ▁name ▁, ▁STR ▁, ▁s ▁. ▁replace ▁( ▁STR ▁, ▁STR ▁) ▁. ▁replace ▁( ▁STR ▁, ▁STR ▁) ▁. ▁replace ▁( ▁STR ▁, ▁STR ▁) ▁, ▁STR ▁) ▁; ▁} ▁else ▁if ▁( ▁v ▁instanceof ▁Starlark Int ▁|| ▁v ▁instanceof ▁Starlark Float ▁|| ▁v ▁instanceof ▁Boolean ▁) ▁{ ▁emit Line ▁( ▁name ▁, ▁STR ▁, ▁v ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁else ▁{ ▁throw ▁Starlark ▁. ▁error f ▁( ▁STR ▁, ▁Starlark ▁. ▁type ▁( ▁v ▁) ▁) ▁; ▁} ▁} ▁private ▁void ▁emit Line ▁( ▁String ▁... ▁items ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁indent ▁; ▁i ▁++ ▁) ▁{ ▁out ▁. ▁append ▁( ▁STR ▁) ▁; ▁} ▁for ▁( ▁String ▁item ▁: ▁items ▁) ▁{ ▁out ▁. ▁append ▁( ▁item ▁) ▁; ▁} ▁out ▁. ▁append ▁( ▁CHAR ▁) ▁; ▁} ▁} ▁}
▁class ▁Extended Bean Info ▁implements ▁Bean Info ▁{ ▁private ▁static ▁final ▁Log ▁logger ▁= ▁LogFactory ▁. ▁getLog ▁( ▁Extended Bean Info ▁. ▁class ▁) ▁; ▁private ▁final ▁Bean Info ▁delegate ▁; ▁private ▁final ▁Set ▁< ▁Property Descriptor ▁> ▁property Descriptors ▁= ▁new ▁TreeSet ▁< ▁> ▁( ▁new ▁Property Descriptor Comparator ▁( ▁) ▁) ▁; ▁public ▁Extended Bean Info ▁( ▁Bean Info ▁delegate ▁) ▁{ ▁this ▁. ▁delegate ▁= ▁delegate ▁; ▁for ▁( ▁Property Descriptor ▁pd ▁: ▁delegate ▁. ▁getProperty Descriptors ▁( ▁) ▁) ▁{ ▁try ▁{ ▁this ▁. ▁property Descriptors ▁. ▁add ▁( ▁pd ▁instanceof ▁Indexed Property Descriptor ▁? ▁new ▁Simple Indexed Property Descriptor ▁( ▁( ▁Indexed Property Descriptor ▁) ▁pd ▁) ▁: ▁new ▁Simple Property Descriptor ▁( ▁pd ▁) ▁) ▁; ▁} ▁catch ▁( ▁Int ros pection Exception ▁ex ▁) ▁{ ▁if ▁( ▁logger ▁. ▁isDebugEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁debug ▁( ▁STR ▁+ ▁pd ▁. ▁getName ▁( ▁) ▁+ ▁STR ▁+ ▁ex ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁Method Descriptor ▁[ ▁] ▁method Descriptors ▁= ▁delegate ▁. ▁getMethod Descriptors ▁( ▁) ▁; ▁if ▁( ▁method Descriptors ▁!= ▁null ▁) ▁{ ▁for ▁( ▁Method ▁method ▁: ▁find Candidate Write Methods ▁( ▁method Descriptors ▁) ▁) ▁{ ▁try ▁{ ▁handle Candidate Write Method ▁( ▁method ▁) ▁; ▁} ▁catch ▁( ▁Int ros pection Exception ▁ex ▁) ▁{ ▁if ▁( ▁logger ▁. ▁isDebugEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁debug ▁( ▁STR ▁+ ▁method ▁+ ▁STR ▁+ ▁ex ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁} ▁} ▁private ▁List ▁< ▁Method ▁> ▁find Candidate Write Methods ▁( ▁Method Descriptor ▁[ ▁] ▁method Descriptors ▁) ▁{ ▁List ▁< ▁Method ▁> ▁matches ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁Method Descriptor ▁method Descriptor ▁: ▁method Descriptors ▁) ▁{ ▁Method ▁method ▁= ▁method Descriptor ▁. ▁getMethod ▁( ▁) ▁; ▁if ▁( ▁isC andidate Write Method ▁( ▁method ▁) ▁) ▁{ ▁matches ▁. ▁add ▁( ▁method ▁) ▁; ▁} ▁} ▁matches ▁. ▁sort ▁( ▁( ▁m 1 ▁, ▁m 2 ▁) ▁-> ▁m 2 ▁. ▁toString ▁( ▁) ▁. ▁compareTo ▁( ▁m 1 ▁. ▁toString ▁( ▁) ▁) ▁) ▁; ▁return ▁matches ▁; ▁} ▁public ▁static ▁boolean ▁isC andidate Write Method ▁( ▁Method ▁method ▁) ▁{ ▁String ▁methodName ▁= ▁method ▁. ▁getName ▁( ▁) ▁; ▁int ▁n Params ▁= ▁method ▁. ▁getParameter Count ▁( ▁) ▁; ▁return ▁( ▁methodName ▁. ▁length ▁( ▁) ▁> ▁3 ▁&& ▁methodName ▁. ▁startsWith ▁( ▁STR ▁) ▁&& ▁Modifier ▁. ▁isPublic ▁( ▁method ▁. ▁getModifiers ▁( ▁) ▁) ▁&& ▁( ▁! ▁void ▁. ▁class ▁. ▁isAssignable From ▁( ▁method ▁. ▁getReturnType ▁( ▁) ▁) ▁|| ▁Modifier ▁. ▁isStatic ▁( ▁method ▁. ▁getModifiers ▁( ▁) ▁) ▁) ▁&& ▁( ▁n Params ▁== ▁1 ▁|| ▁( ▁n Params ▁== ▁2 ▁&& ▁int ▁. ▁class ▁== ▁method ▁. ▁getParameter Types ▁( ▁) ▁[ ▁0 ▁] ▁) ▁) ▁) ▁; ▁} ▁private ▁void ▁handle Candidate Write Method ▁( ▁Method ▁method ▁) ▁throws ▁Int ros pection Exception ▁{ ▁int ▁n Params ▁= ▁method ▁. ▁getParameter Count ▁( ▁) ▁;
▁@ ▁Immutable ▁public ▁class ▁Partition Filter ▁{ ▁private ▁final ▁Hive TableName ▁hive TableName ▁; ▁private ▁final ▁Map ▁< ▁Column ▁, ▁Domain ▁> ▁partition Predicates ▁; ▁public ▁Partition Filter ▁( ▁Hive TableName ▁hive TableName ▁, ▁Map ▁< ▁Column ▁, ▁Domain ▁> ▁partition Predicates ▁) ▁{ ▁this ▁. ▁hive TableName ▁= ▁requireNonNull ▁( ▁hive TableName ▁, ▁STR ▁) ▁; ▁this ▁. ▁partition Predicates ▁= ▁requireNonNull ▁( ▁partition Predicates ▁, ▁STR ▁) ▁; ▁} ▁public ▁static ▁Partition Filter ▁partition Filter ▁( ▁String ▁databaseName ▁, ▁String ▁tableName ▁, ▁Map ▁< ▁Column ▁, ▁Domain ▁> ▁effective Predicate ▁) ▁{ ▁return ▁new ▁Partition Filter ▁( ▁hive TableName ▁( ▁databaseName ▁, ▁tableName ▁) ▁, ▁effective Predicate ▁) ▁; ▁} ▁public ▁Hive TableName ▁getH ive TableName ▁( ▁) ▁{ ▁return ▁hive TableName ▁; ▁} ▁public ▁Map ▁< ▁Column ▁, ▁Domain ▁> ▁getPartition Predicates ▁( ▁) ▁{ ▁return ▁partition Predicates ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁toStringHelper ▁( ▁this ▁) ▁. ▁add ▁( ▁STR ▁, ▁hive TableName ▁) ▁. ▁add ▁( ▁STR ▁, ▁partition Predicates ▁) ▁. ▁toString ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁o ▁) ▁{ ▁if ▁( ▁this ▁== ▁o ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁o ▁== ▁null ▁|| ▁getClass ▁( ▁) ▁!= ▁o ▁. ▁getClass ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁Partition Filter ▁other ▁= ▁( ▁Partition Filter ▁) ▁o ▁; ▁return ▁Objects ▁. ▁equals ▁( ▁hive TableName ▁, ▁other ▁. ▁hive TableName ▁) ▁&& ▁Objects ▁. ▁equals ▁( ▁partition Predicates ▁, ▁other ▁. ▁partition Predicates ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁Objects ▁. ▁hash ▁( ▁hive TableName ▁, ▁partition Predicates ▁) ▁; ▁} ▁}
▁public ▁static ▁long ▁get Opt imal BufferSize ▁( ▁long ▁params Length ▁, ▁int ▁num Workers ▁, ▁int ▁queue Size ▁) ▁{ ▁val ▁bufferSize ▁= ▁( ▁( ▁params Length ▁ / ▁16 ▁) ▁+ ▁655 36 ▁) ▁ * ▁num Workers ▁ * ▁queue Size ▁ * ▁4 ▁; ▁return ▁bufferSize ▁; ▁} ▁public ▁static ▁long ▁get Opt imal BufferSize ▁( ▁Model ▁model ▁, ▁int ▁num Workers ▁, ▁int ▁queue Size ▁) ▁{ ▁return ▁get Opt imal BufferSize ▁( ▁model ▁. ▁params ▁( ▁) ▁. ▁length ▁( ▁) ▁, ▁num Workers ▁, ▁queue Size ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁fallback To Single Consumer Mode ▁( ▁boolean ▁re ally Fallback ▁) ▁{ ▁if ▁( ▁external Source ▁!= ▁null ▁&& ▁external Source ▁instanceof ▁Register able ▁) ▁( ▁( ▁Register able ▁) ▁external Source ▁) ▁. ▁fallback To Single Consumer Mode ▁( ▁re ally Fallback ▁) ▁; ▁by pass Mode ▁. ▁set ▁( ▁re ally Fallback ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁register Consum ers ▁( ▁int ▁num Consum ers ▁) ▁{ ▁if ▁( ▁registered ▁. ▁get ▁( ▁) ▁) ▁{ ▁if ▁( ▁isDebug ▁) ▁log ▁. ▁info ▁( ▁STR ▁) ▁; ▁while ▁( ▁registered ▁. ▁get ▁( ▁) ▁) ▁{ ▁Thread Utils ▁. ▁un checked Sleep ▁( ▁1 ▁) ▁; ▁if ▁( ▁throwable ▁. ▁is Triggered ▁( ▁) ▁) ▁throw ▁new ▁Runtime Exception ▁( ▁throwable ▁. ▁get ▁( ▁) ▁) ▁; ▁} ▁if ▁( ▁isDebug ▁) ▁log ▁. ▁info ▁( ▁STR ▁) ▁; ▁} ▁if ▁( ▁external Source ▁!= ▁null ▁&& ▁external Source ▁instanceof ▁Register able ▁) ▁{ ▁( ▁( ▁Register able ▁) ▁external Source ▁) ▁. ▁register Consum ers ▁( ▁num Consum ers ▁) ▁; ▁} ▁current Consum ers ▁. ▁set ▁( ▁num Consum ers ▁) ▁; ▁registered ▁. ▁set ▁( ▁true ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Indexed Tail ▁getExternal Source ▁( ▁) ▁{ ▁return ▁external Source ▁; ▁} ▁@ ▁Override ▁public ▁void ▁mark External Updates ▁( ▁boolean ▁updates Available ▁) ▁{ ▁external Updates Available ▁. ▁set ▁( ▁updates Available ▁) ▁; ▁} ▁protected ▁void ▁s ynchron ize ▁( ▁int ▁consum ers ▁) ▁{ ▁s ynchron ize ▁( ▁consum ers ▁, ▁false ▁) ▁; ▁} ▁protected ▁void ▁s ynchron ize ▁( ▁int ▁consum ers ▁, ▁boolean ▁final Lock ▁) ▁{ ▁if ▁( ▁consum ers ▁== ▁1 ▁|| ▁by pass Mode ▁. ▁get ▁( ▁) ▁) ▁{ ▁if ▁( ▁final Lock ▁) ▁registered ▁. ▁set ▁( ▁false ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁isDebug ▁) ▁log ▁. ▁info ▁( ▁STR ▁, ▁Thread ▁. ▁currentThread ▁( ▁) ▁. ▁getId ▁( ▁) ▁, ▁current Consum ers ▁. ▁get ▁( ▁) ▁) ▁; ▁isDone ▁. ▁compareAndSet ▁( ▁true ▁, ▁false ▁) ▁; ▁if ▁( ▁barrier ▁. ▁incrementAndGet ▁( ▁) ▁== ▁consum ers ▁) ▁{ ▁secondary ▁. ▁set ▁( ▁0 ▁) ▁; ▁barrier ▁. ▁set ▁( ▁0 ▁) ▁; ▁isFirst ▁. ▁set ▁( ▁false ▁) ▁; ▁isDone ▁. ▁set ▁( ▁true ▁) ▁; ▁} ▁else ▁{ ▁while ▁( ▁! ▁isDone ▁. ▁get ▁( ▁) ▁) ▁{ ▁Thread Utils ▁. ▁un checked Sleep ▁( ▁1 ▁) ▁;
▁final ▁class ▁Location Template Context ▁implements ▁Template Context ▁{ ▁private ▁final ▁Template Context ▁delegate ▁; ▁private ▁final ▁ImmutableMap ▁< ▁String ▁, ▁Location Function ▁> ▁functions ▁; ▁private ▁final ▁ImmutableMap ▁< ▁RepositoryName ▁, ▁RepositoryName ▁> ▁repository Mapping ▁; ▁private ▁final ▁boolean ▁windows Path ▁; ▁private ▁Location Template Context ▁( ▁Template Context ▁delegate ▁, ▁Label ▁root ▁, ▁Supplier ▁< ▁Map ▁< ▁Label ▁, ▁Collection ▁< ▁Artifact ▁> ▁> ▁> ▁location Map ▁, ▁boolean ▁exec Paths ▁, ▁boolean ▁legacy External Runfiles ▁, ▁ImmutableMap ▁< ▁RepositoryName ▁, ▁RepositoryName ▁> ▁repository Mapping ▁, ▁boolean ▁windows Path ▁) ▁{ ▁this ▁. ▁delegate ▁= ▁delegate ▁; ▁this ▁. ▁functions ▁= ▁Location Expander ▁. ▁all Location Functions ▁( ▁root ▁, ▁location Map ▁, ▁exec Paths ▁, ▁legacy External Runfiles ▁) ▁; ▁this ▁. ▁repository Mapping ▁= ▁repository Mapping ▁; ▁this ▁. ▁windows Path ▁= ▁windows Path ▁; ▁} ▁public ▁Location Template Context ▁( ▁Template Context ▁delegate ▁, ▁RuleContext ▁ruleContext ▁, ▁@ ▁Nullable ▁ImmutableMap ▁< ▁Label ▁, ▁Immutable Collection ▁< ▁Artifact ▁> ▁> ▁label Map ▁, ▁boolean ▁exec Paths ▁, ▁boolean ▁allow Data ▁, ▁boolean ▁windows Path ▁) ▁{ ▁this ▁( ▁delegate ▁, ▁ruleContext ▁. ▁getLabel ▁( ▁) ▁, ▁Sup pl iers ▁. ▁mem o ize ▁( ▁( ▁) ▁-> ▁Location Expander ▁. ▁build Location Map ▁( ▁ruleContext ▁, ▁label Map ▁, ▁allow Data ▁) ▁) ▁, ▁exec Paths ▁, ▁ruleContext ▁. ▁get Configuration ▁( ▁) ▁. ▁legacy External Runfiles ▁( ▁) ▁, ▁ruleContext ▁. ▁getRule ▁( ▁) ▁. ▁getPackage ▁( ▁) ▁. ▁getRepository Mapping ▁( ▁) ▁, ▁windows Path ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁lookup Variable ▁( ▁String ▁name ▁) ▁throws ▁Exp ansion Exception ▁{ ▁String ▁val ▁= ▁delegate ▁. ▁lookup Variable ▁( ▁name ▁) ▁; ▁if ▁( ▁windows Path ▁) ▁{ ▁val ▁= ▁val ▁. ▁replace ▁( ▁CHAR ▁, ▁CHAR ▁) ▁; ▁} ▁return ▁val ▁; ▁} ▁@ ▁Override ▁public ▁String ▁lookup Function ▁( ▁String ▁name ▁, ▁String ▁param ▁) ▁throws ▁Exp ansion Exception ▁{ ▁String ▁val ▁= ▁lookup Function Impl ▁( ▁name ▁, ▁param ▁) ▁; ▁if ▁( ▁windows Path ▁) ▁{ ▁val ▁= ▁val ▁. ▁replace ▁( ▁CHAR ▁, ▁CHAR ▁) ▁; ▁} ▁return ▁val ▁; ▁} ▁private ▁String ▁lookup Function Impl ▁( ▁String ▁name ▁, ▁String ▁param ▁) ▁throws ▁Exp ansion Exception ▁{ ▁try ▁{ ▁Location Function ▁f ▁= ▁functions ▁. ▁get ▁( ▁name ▁) ▁; ▁if ▁( ▁f ▁!= ▁null ▁) ▁{ ▁return ▁f ▁. ▁apply ▁( ▁param ▁, ▁repository Mapping ▁) ▁; ▁} ▁} ▁catch ▁( ▁Illegal StateException ▁e ▁) ▁{ ▁throw ▁new ▁Exp ansion Exception ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁e ▁) ▁; ▁} ▁return ▁delegate ▁. ▁lookup Function ▁( ▁name ▁, ▁param ▁) ▁; ▁} ▁}
▁public ▁Sw ap ▁( ▁long ▁total ▁, ▁long ▁free ▁) ▁{ ▁assert ▁total ▁>= ▁0 ▁: ▁STR ▁+ ▁total ▁; ▁assert ▁free ▁>= ▁0 ▁: ▁STR ▁+ ▁total ▁; ▁this ▁. ▁total ▁= ▁total ▁; ▁this ▁. ▁free ▁= ▁free ▁; ▁} ▁public ▁Sw ap ▁( ▁StreamInput ▁in ▁) ▁throws ▁IOException ▁{ ▁this ▁. ▁total ▁= ▁in ▁. ▁readLong ▁( ▁) ▁; ▁assert ▁this ▁. ▁total ▁>= ▁0 ▁: ▁STR ▁+ ▁total ▁; ▁this ▁. ▁free ▁= ▁in ▁. ▁readLong ▁( ▁) ▁; ▁assert ▁this ▁. ▁free ▁>= ▁0 ▁: ▁STR ▁+ ▁total ▁; ▁} ▁@ ▁Override ▁public ▁void ▁writeTo ▁( ▁StreamOutput ▁out ▁) ▁throws ▁IOException ▁{ ▁out ▁. ▁writeLong ▁( ▁total ▁) ▁; ▁out ▁. ▁writeLong ▁( ▁free ▁) ▁; ▁} ▁public ▁ByteSizeValue ▁getF ree ▁( ▁) ▁{ ▁return ▁new ▁ByteSizeValue ▁( ▁free ▁) ▁; ▁} ▁public ▁ByteSizeValue ▁getUsed ▁( ▁) ▁{ ▁if ▁( ▁total ▁== ▁0 ▁) ▁{ ▁if ▁( ▁free ▁> ▁0 ▁) ▁{ ▁logger ▁. ▁debug ▁( ▁STR ▁+ ▁free ▁) ▁; ▁} ▁return ▁new ▁ByteSizeValue ▁( ▁0 ▁) ▁; ▁} ▁return ▁new ▁ByteSizeValue ▁( ▁total ▁- ▁free ▁) ▁; ▁} ▁public ▁ByteSizeValue ▁getTotal ▁( ▁) ▁{ ▁return ▁new ▁ByteSizeValue ▁( ▁total ▁) ▁; ▁} ▁@ ▁Override ▁public ▁XContentBuilder ▁toXContent ▁( ▁XContentBuilder ▁builder ▁, ▁Params ▁params ▁) ▁throws ▁IOException ▁{ ▁builder ▁. ▁startObject ▁( ▁Fields ▁. ▁SW AP ▁) ▁; ▁builder ▁. ▁h umanReadable Field ▁( ▁Fields ▁. ▁TOTAL _ IN _ BYTES ▁, ▁Fields ▁. ▁TOTAL ▁, ▁getTotal ▁( ▁) ▁) ▁; ▁builder ▁. ▁h umanReadable Field ▁( ▁Fields ▁. ▁F REE _ IN _ BYTES ▁, ▁Fields ▁. ▁F REE ▁, ▁getF ree ▁( ▁) ▁) ▁; ▁builder ▁. ▁h umanReadable Field ▁( ▁Fields ▁. ▁U SED _ IN _ BYTES ▁, ▁Fields ▁. ▁U SED ▁, ▁getUsed ▁( ▁) ▁) ▁; ▁builder ▁. ▁endObject ▁( ▁) ▁; ▁return ▁builder ▁; ▁} ▁} ▁public ▁static ▁class ▁Mem ▁implements ▁Writeable ▁, ▁ToXContent Fragment ▁{ ▁private ▁static ▁final ▁Logger ▁logger ▁= ▁LogManager ▁. ▁getLogger ▁( ▁Mem ▁. ▁class ▁) ▁; ▁private ▁final ▁long ▁total ▁; ▁private ▁final ▁long ▁free ▁; ▁public ▁Mem ▁( ▁long ▁total ▁, ▁long ▁free ▁) ▁{ ▁assert ▁total ▁>= ▁0 ▁: ▁STR ▁+ ▁total ▁; ▁assert ▁free ▁>= ▁0 ▁: ▁STR ▁+ ▁total ▁; ▁this ▁. ▁total ▁= ▁total ▁; ▁this ▁. ▁free ▁= ▁free ▁; ▁} ▁public ▁Mem ▁( ▁StreamInput ▁in ▁) ▁throws ▁IOException ▁{ ▁this ▁. ▁total ▁= ▁in ▁. ▁readLong ▁( ▁) ▁; ▁assert ▁total ▁>= ▁0 ▁: ▁STR ▁+ ▁total ▁; ▁this ▁. ▁free ▁= ▁in ▁. ▁readLong ▁( ▁) ▁; ▁assert ▁free ▁>= ▁0 ▁: ▁STR ▁+ ▁total ▁; ▁} ▁@ ▁Override ▁public ▁void ▁writeTo ▁( ▁StreamOutput ▁out ▁) ▁throws ▁IOException ▁{ ▁out ▁. ▁writeLong ▁( ▁total ▁) ▁; ▁out ▁. ▁writeLong ▁( ▁free ▁) ▁; ▁} ▁public ▁ByteSizeValue ▁getTotal ▁( ▁) ▁{ ▁return ▁new ▁ByteSizeValue ▁( ▁total ▁) ▁; ▁} ▁public ▁ByteSizeValue ▁getUsed ▁( ▁) ▁{ ▁if ▁( ▁total ▁== ▁0 ▁) ▁{ ▁if ▁( ▁free ▁> ▁0 ▁) ▁{ ▁logger ▁. ▁debug ▁( ▁STR ▁+ ▁free ▁) ▁; ▁}
▁++ ▁i ▁) ▁{ ▁max To ▁[ ▁i ▁] ▁= ▁Math ▁. ▁max ▁( ▁ranges ▁[ ▁i ▁] ▁. ▁getTo ▁( ▁) ▁, ▁max To ▁[ ▁i ▁- ▁1 ▁] ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁int ▁collect ▁( ▁Leaf BucketCollector ▁sub ▁, ▁int ▁doc ▁, ▁double ▁value ▁, ▁long ▁owning Bucket Ordinal ▁, ▁int ▁low Bound ▁, ▁int ▁count ▁) ▁throws ▁IOException ▁{ ▁int ▁lo ▁= ▁low Bound ▁, ▁hi ▁= ▁ranges ▁. ▁length ▁- ▁1 ▁; ▁int ▁mid ▁= ▁( ▁lo ▁+ ▁hi ▁) ▁>>> ▁1 ▁; ▁while ▁( ▁lo ▁<= ▁hi ▁) ▁{ ▁if ▁( ▁value ▁< ▁ranges ▁[ ▁mid ▁] ▁. ▁getFrom ▁( ▁) ▁) ▁{ ▁hi ▁= ▁mid ▁- ▁1 ▁; ▁} ▁else ▁if ▁( ▁value ▁>= ▁max To ▁[ ▁mid ▁] ▁) ▁{ ▁lo ▁= ▁mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁mid ▁= ▁( ▁lo ▁+ ▁hi ▁) ▁>>> ▁1 ▁; ▁} ▁if ▁( ▁lo ▁> ▁hi ▁) ▁return ▁lo ▁; ▁int ▁start Lo ▁= ▁lo ▁, ▁start H i ▁= ▁mid ▁; ▁while ▁( ▁start Lo ▁<= ▁start H i ▁) ▁{ ▁final ▁int ▁start Mid ▁= ▁( ▁start Lo ▁+ ▁start H i ▁) ▁>>> ▁1 ▁; ▁if ▁( ▁value ▁>= ▁max To ▁[ ▁start Mid ▁] ▁) ▁{ ▁start Lo ▁= ▁start Mid ▁+ ▁1 ▁; ▁} ▁else ▁{ ▁start H i ▁= ▁start Mid ▁- ▁1 ▁; ▁} ▁} ▁int ▁end Lo ▁= ▁mid ▁, ▁end H i ▁= ▁hi ▁; ▁while ▁( ▁end Lo ▁<= ▁end H i ▁) ▁{ ▁final ▁int ▁end Mid ▁= ▁( ▁end Lo ▁+ ▁end H i ▁) ▁>>> ▁1 ▁; ▁if ▁( ▁value ▁< ▁ranges ▁[ ▁end Mid ▁] ▁. ▁getFrom ▁( ▁) ▁) ▁{ ▁end H i ▁= ▁end Mid ▁- ▁1 ▁; ▁} ▁else ▁{ ▁end Lo ▁= ▁end Mid ▁+ ▁1 ▁; ▁} ▁} ▁assert ▁start Lo ▁== ▁low Bound ▁|| ▁value ▁>= ▁max To ▁[ ▁start Lo ▁- ▁1 ▁] ▁; ▁assert ▁end H i ▁== ▁ranges ▁. ▁length ▁- ▁1 ▁|| ▁value ▁< ▁ranges ▁[ ▁end H i ▁+ ▁1 ▁] ▁. ▁getFrom ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁start Lo ▁; ▁i ▁<= ▁end H i ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁ranges ▁[ ▁i ▁] ▁. ▁matches ▁( ▁value ▁) ▁) ▁{ ▁long ▁bucket Ord ▁= ▁sub Bucket Ordinal ▁( ▁owning Bucket Ordinal ▁, ▁i ▁) ▁; ▁collect Bucket ▁( ▁sub ▁, ▁doc ▁, ▁bucket Ord ▁) ▁; ▁increment Bucket DocCount ▁( ▁bucket Ord ▁, ▁count ▁) ▁; ▁} ▁} ▁return ▁start Lo ▁; ▁} ▁} ▁}
▁Co ord ination Metadata ▁new Coord ination Metadata ▁= ▁Co ord ination Metadata ▁. ▁builder ▁( ▁co ord ination Metadata ▁) ▁. ▁clear V oting Config Exclusions ▁( ▁) ▁. ▁last Accepted Configuration ▁( ▁new ▁Co ord ination Metadata ▁. ▁V oting Configuration ▁( ▁Collections ▁. ▁singleton ▁( ▁persisted ClusterState Service ▁. ▁getNodeId ▁( ▁) ▁) ▁) ▁) ▁. ▁last Committed Configuration ▁( ▁new ▁Co ord ination Metadata ▁. ▁V oting Configuration ▁( ▁Collections ▁. ▁singleton ▁( ▁persisted ClusterState Service ▁. ▁getNodeId ▁( ▁) ▁) ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁Settings ▁persistent Settings ▁= ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁metadata ▁. ▁persistent Settings ▁( ▁) ▁) ▁. ▁put ▁( ▁UNSAFE _ BO OTSTRAP ▁. ▁getKey ▁( ▁) ▁, ▁true ▁) ▁. ▁build ▁( ▁) ▁; ▁Metadata ▁. ▁Builder ▁new Metadata ▁= ▁Metadata ▁. ▁builder ▁( ▁metadata ▁) ▁. ▁cluster UUID ▁( ▁Metadata ▁. ▁UNKNOWN _ CLUSTER _ UUID ▁) ▁. ▁generate Cluster Uuid IfNeeded ▁( ▁) ▁. ▁cluster UUID Committed ▁( ▁true ▁) ▁. ▁persistent Settings ▁( ▁persistent Settings ▁) ▁. ▁co ord ination Metadata ▁( ▁new Coord ination Metadata ▁) ▁; ▁for ▁( ▁Object Cursor ▁< ▁IndexMetadata ▁> ▁idx ▁: ▁metadata ▁. ▁indices ▁( ▁) ▁. ▁values ▁( ▁) ▁) ▁{ ▁IndexMetadata ▁indexMetadata ▁= ▁idx ▁. ▁value ▁; ▁new Metadata ▁. ▁put ▁( ▁IndexMetadata ▁. ▁builder ▁( ▁indexMetadata ▁) ▁. ▁settings ▁( ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁indexMetadata ▁. ▁getSettings ▁( ▁) ▁) ▁. ▁put ▁( ▁IndexMetadata ▁. ▁SETTING _ H ISTORY _ UUID ▁, ▁UUID s ▁. ▁random Base 64 UUID ▁( ▁) ▁) ▁) ▁) ▁; ▁} ▁final ▁ClusterState ▁new ClusterState ▁= ▁ClusterState ▁. ▁builder ▁( ▁old ClusterState ▁) ▁. ▁metadata ▁( ▁new Metadata ▁) ▁. ▁build ▁( ▁) ▁; ▁terminal ▁. ▁println ▁( ▁Terminal ▁. ▁Ver bosity ▁. ▁VER BO SE ▁, ▁STR ▁+ ▁old ClusterState ▁+ ▁STR ▁+ ▁new ClusterState ▁+ ▁STR ▁) ▁; ▁confirm ▁( ▁terminal ▁, ▁CON FI RM ATION _ MSG ▁) ▁; ▁try ▁( ▁Persist ed ClusterState Service ▁. ▁Writer ▁writer ▁= ▁persisted ClusterState Service ▁. ▁create Writer ▁( ▁) ▁) ▁{ ▁writer ▁. ▁write Full State And Commit ▁( ▁state ▁. ▁v 1 ▁( ▁) ▁, ▁new ClusterState ▁) ▁; ▁} ▁terminal ▁. ▁println ▁( ▁MASTER _ NODE _ BO OTSTRAP PED _ MSG ▁) ▁; ▁} ▁}
▁public ▁class ▁D en y Test ▁extends ▁TestCase ▁{ ▁public ▁void ▁test _0 ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁text ▁= ▁STR ▁; ▁ParserConfig ▁config ▁= ▁new ▁ParserConfig ▁( ▁) ▁; ▁config ▁. ▁add Den y ▁( ▁null ▁) ▁; ▁config ▁. ▁add Den y ▁( ▁STR ▁) ▁; ▁Exception ▁error ▁= ▁null ▁; ▁try ▁{ ▁JSON ▁. ▁parseObject ▁( ▁STR ▁, ▁Object ▁. ▁class ▁, ▁config ▁, ▁JSON ▁. ▁DEFAULT _ PARSER _ FEATURE ▁) ▁; ▁} ▁catch ▁( ▁JSONException ▁ex ▁) ▁{ ▁error ▁= ▁ex ▁; ▁} ▁Assert ▁. ▁assertNotNull ▁( ▁error ▁) ▁; ▁JSON ▁. ▁parseObject ▁( ▁text ▁, ▁B ▁. ▁class ▁, ▁config ▁, ▁JSON ▁. ▁DEFAULT _ PARSER _ FEATURE ▁) ▁; ▁} ▁public ▁void ▁test _1 ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁text ▁= ▁STR ▁; ▁ParserConfig ▁config ▁= ▁new ▁ParserConfig ▁( ▁) ▁; ▁config ▁. ▁add Den y ▁( ▁null ▁) ▁; ▁config ▁. ▁add Den y ▁( ▁STR ▁) ▁; ▁Exception ▁error ▁= ▁null ▁; ▁try ▁{ ▁JSON ▁. ▁parseObject ▁( ▁STR ▁, ▁Object ▁. ▁class ▁, ▁config ▁, ▁JSON ▁. ▁DEFAULT _ PARSER _ FEATURE ▁) ▁; ▁} ▁catch ▁( ▁JSONException ▁ex ▁) ▁{ ▁error ▁= ▁ex ▁; ▁} ▁Assert ▁. ▁assertNotNull ▁( ▁error ▁) ▁; ▁JSON ▁. ▁parseObject ▁( ▁text ▁, ▁B ▁. ▁class ▁, ▁config ▁, ▁JSON ▁. ▁DEFAULT _ PARSER _ FEATURE ▁) ▁; ▁} ▁public ▁static ▁class ▁B ▁{ ▁} ▁}
▁public ▁class ▁Blocking Flowable Most Recent Test ▁extends ▁RxJavaTest ▁{ ▁@ ▁Test ▁public ▁void ▁m ost Recent ▁( ▁) ▁{ ▁Flowable Processor ▁< ▁String ▁> ▁s ▁= ▁Publish Processor ▁. ▁create ▁( ▁) ▁; ▁Iterator ▁< ▁String ▁> ▁it ▁= ▁s ▁. ▁blocking Most Recent ▁( ▁STR ▁) ▁. ▁iterator ▁( ▁) ▁; ▁assertTrue ▁( ▁it ▁. ▁hasNext ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁it ▁. ▁next ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁it ▁. ▁next ▁( ▁) ▁) ▁; ▁s ▁. ▁onNext ▁( ▁STR ▁) ▁; ▁assertTrue ▁( ▁it ▁. ▁hasNext ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁it ▁. ▁next ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁it ▁. ▁next ▁( ▁) ▁) ▁; ▁s ▁. ▁onNext ▁( ▁STR ▁) ▁; ▁assertTrue ▁( ▁it ▁. ▁hasNext ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁it ▁. ▁next ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁it ▁. ▁next ▁( ▁) ▁) ▁; ▁s ▁. ▁onComplete ▁( ▁) ▁; ▁assertFalse ▁( ▁it ▁. ▁hasNext ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁( ▁expected ▁= ▁TestException ▁. ▁class ▁) ▁public ▁void ▁m ost Recent WithException ▁( ▁) ▁{ ▁Flowable Processor ▁< ▁String ▁> ▁s ▁= ▁Publish Processor ▁. ▁create ▁( ▁) ▁; ▁Iterator ▁< ▁String ▁> ▁it ▁= ▁s ▁. ▁blocking Most Recent ▁( ▁STR ▁) ▁. ▁iterator ▁( ▁) ▁; ▁assertTrue ▁( ▁it ▁. ▁hasNext ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁it ▁. ▁next ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁it ▁. ▁next ▁( ▁) ▁) ▁; ▁s ▁. ▁onError ▁( ▁new ▁TestException ▁( ▁) ▁) ▁; ▁assertTrue ▁( ▁it ▁. ▁hasNext ▁( ▁) ▁) ▁; ▁it ▁. ▁next ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁single Source Many Iterator s ▁( ▁) ▁{ ▁TestScheduler ▁scheduler ▁= ▁new ▁TestScheduler ▁( ▁) ▁; ▁Flowable ▁< ▁Long ▁> ▁source ▁= ▁Flowable ▁. ▁interval ▁( ▁1 ▁, ▁TimeUnit ▁. ▁SECONDS ▁, ▁scheduler ▁) ▁. ▁take ▁( ▁10 ▁) ▁; ▁Iterable ▁< ▁Long ▁> ▁iter ▁= ▁source ▁. ▁blocking Most Recent ▁( ▁- ▁1 L ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁3 ▁; ▁j ▁++ ▁) ▁{ ▁Iterator ▁< ▁Long ▁> ▁it ▁= ▁iter ▁. ▁iterator ▁( ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁Long ▁. ▁valueOf ▁( ▁- ▁1 ▁) ▁, ▁it ▁. ▁next ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁9 ▁; ▁i ▁++ ▁) ▁{ ▁scheduler ▁. ▁advanceTime By ▁( ▁1 ▁, ▁TimeUnit ▁. ▁SECONDS ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁it ▁. ▁hasNext ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁Long ▁. ▁valueOf ▁( ▁i ▁) ▁, ▁it ▁. ▁next ▁( ▁) ▁) ▁; ▁} ▁scheduler ▁. ▁advanceTime By ▁( ▁1 ▁, ▁TimeUnit ▁. ▁SECONDS ▁) ▁; ▁Assert ▁. ▁assertFalse ▁( ▁it ▁. ▁hasNext ▁( ▁) ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁empty ▁( ▁) ▁{ ▁Iterator ▁< ▁Integer ▁> ▁it ▁= ▁Flowable ▁. ▁< ▁Integer ▁> ▁empty ▁( ▁) ▁. ▁blocking Most Recent ▁( ▁1 ▁) ▁. ▁iterator ▁( ▁) ▁;
▁@ ▁Test ▁public ▁void ▁testInvalid Over w riting For Constraints ▁( ▁) ▁throws ▁Exception ▁{ ▁Extended Sql Node ▁extended Sql Node ▁= ▁( ▁Extended Sql Node ▁) ▁create Flink Parser ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁. ▁parse Stmt ▁( ▁) ▁; ▁thrown ▁. ▁expect ▁( ▁Sql Validate Exception ▁. ▁class ▁) ▁; ▁thrown ▁. ▁expectMessage ▁( ▁STR ▁) ▁; ▁extended Sql Node ▁. ▁validate ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testInvalid No Options ▁( ▁) ▁throws ▁Sql ParseException ▁{ ▁thrown ▁. ▁expect ▁( ▁Sql ParseException ▁. ▁class ▁) ▁; ▁thrown ▁. ▁expectMessage ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁; ▁create Flink Parser ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁. ▁parse Stmt ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testInvalid No Source Table ▁( ▁) ▁throws ▁Sql ParseException ▁{ ▁thrown ▁. ▁expect ▁( ▁Sql ParseException ▁. ▁class ▁) ▁; ▁thrown ▁. ▁expectMessage ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁; ▁create Flink Parser ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁. ▁parse Stmt ▁( ▁) ▁; ▁} ▁public ▁static ▁Sql Table Like Option ▁option ▁( ▁Mer ging Strategy ▁m er ging Strategy ▁, ▁Feature Option ▁feature Option ▁) ▁{ ▁return ▁new ▁Sql Table Like Option ▁( ▁m er ging Strategy ▁, ▁feature Option ▁) ▁; ▁} ▁private ▁static ▁Matcher ▁< ▁Sql Table Like ▁> ▁has Options ▁( ▁Sql Table Like Option ▁... ▁option Matchers ▁) ▁{ ▁return ▁new ▁Feature Matcher ▁< ▁Sql Table Like ▁, ▁List ▁< ▁Sql Table Like Option ▁> ▁> ▁( ▁equalTo ▁( ▁Arrays ▁. ▁asList ▁( ▁option Matchers ▁) ▁) ▁, ▁STR ▁, ▁STR ▁) ▁{ ▁@ ▁Override ▁protected ▁List ▁< ▁Sql Table Like Option ▁> ▁feature Value Of ▁( ▁Sql Table Like ▁actual ▁) ▁{ ▁return ▁actual ▁. ▁getOptions ▁( ▁) ▁; ▁} ▁} ▁; ▁} ▁private ▁static ▁Matcher ▁< ▁Sql Table Like ▁> ▁hasNo Options ▁( ▁) ▁{ ▁return ▁new ▁Feature Matcher ▁< ▁Sql Table Like ▁, ▁List ▁< ▁Sql Table Like Option ▁> ▁> ▁( ▁empty ▁( ▁) ▁, ▁STR ▁, ▁STR ▁) ▁{ ▁@ ▁Override ▁protected ▁List ▁< ▁Sql Table Like Option ▁> ▁feature Value Of ▁( ▁Sql Table Like ▁actual ▁) ▁{ ▁return ▁actual ▁. ▁getOptions ▁( ▁) ▁; ▁} ▁} ▁; ▁} ▁private ▁static ▁Matcher ▁< ▁Sql Table Like ▁> ▁point sTo ▁( ▁String ▁... ▁table ▁) ▁{ ▁return ▁new ▁Feature Matcher ▁< ▁Sql Table Like ▁, ▁String ▁[ ▁] ▁> ▁( ▁equalTo ▁( ▁table ▁) ▁, ▁STR ▁, ▁STR ▁) ▁{ ▁@ ▁Override ▁protected ▁String ▁[ ▁] ▁feature Value Of ▁( ▁Sql Table Like ▁actual ▁) ▁{ ▁return ▁actual ▁. ▁getSource Table ▁( ▁) ▁. ▁names ▁. ▁toArray ▁( ▁new ▁String ▁[ ▁0 ▁] ▁) ▁; ▁} ▁} ▁; ▁}
▁if ▁( ▁dataSpec ▁. ▁length ▁!= ▁C ▁. ▁LENGTH _ UNSET ▁|| ▁current Request Ignore s Cache ▁) ▁{ ▁bytes Remaining ▁= ▁dataSpec ▁. ▁length ▁; ▁} ▁else ▁{ ▁bytes Remaining ▁= ▁Content Metadata ▁. ▁getContent Length ▁( ▁cache ▁. ▁getContent Metadata ▁( ▁key ▁) ▁) ▁; ▁if ▁( ▁bytes Remaining ▁!= ▁C ▁. ▁LENGTH _ UNSET ▁) ▁{ ▁bytes Remaining ▁-= ▁dataSpec ▁. ▁position ▁; ▁if ▁( ▁bytes Remaining ▁<= ▁0 ▁) ▁{ ▁throw ▁new ▁DataSource Exception ▁( ▁DataSource Exception ▁. ▁POSITION _ OUT _ OF _ RANGE ▁) ▁; ▁} ▁} ▁} ▁open Next Source ▁( ▁false ▁) ▁; ▁return ▁bytes Remaining ▁; ▁} ▁catch ▁( ▁Throwable ▁e ▁) ▁{ ▁handle Before Throw ▁( ▁e ▁) ▁; ▁throw ▁e ▁; ▁} ▁} ▁@ ▁Override ▁public ▁int ▁read ▁( ▁byte ▁[ ▁] ▁buffer ▁, ▁int ▁offset ▁, ▁int ▁read Length ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁read Length ▁== ▁0 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁if ▁( ▁bytes Remaining ▁== ▁0 ▁) ▁{ ▁return ▁C ▁. ▁RESULT _ END _ OF _ INPUT ▁; ▁} ▁try ▁{ ▁if ▁( ▁read Position ▁>= ▁check Cache Position ▁) ▁{ ▁open Next Source ▁( ▁true ▁) ▁; ▁} ▁int ▁bytesRead ▁= ▁current DataSource ▁. ▁read ▁( ▁buffer ▁, ▁offset ▁, ▁read Length ▁) ▁; ▁if ▁( ▁bytesRead ▁!= ▁C ▁. ▁RESULT _ END _ OF _ INPUT ▁) ▁{ ▁if ▁( ▁is Reading From Cache ▁( ▁) ▁) ▁{ ▁total Cached BytesRead ▁+= ▁bytesRead ▁; ▁} ▁read Position ▁+= ▁bytesRead ▁; ▁if ▁( ▁bytes Remaining ▁!= ▁C ▁. ▁LENGTH _ UNSET ▁) ▁{ ▁bytes Remaining ▁-= ▁bytesRead ▁; ▁} ▁} ▁else ▁if ▁( ▁current Data Spec Length Un set ▁) ▁{ ▁set No Bytes Remaining And Maybe Store Length ▁( ▁) ▁; ▁} ▁else ▁if ▁( ▁bytes Remaining ▁> ▁0 ▁|| ▁bytes Remaining ▁== ▁C ▁. ▁LENGTH _ UNSET ▁) ▁{ ▁close Current Source ▁( ▁) ▁; ▁open Next Source ▁( ▁false ▁) ▁; ▁return ▁read ▁( ▁buffer ▁, ▁offset ▁, ▁read Length ▁) ▁; ▁} ▁return ▁bytesRead ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁if ▁( ▁current Data Spec Length Un set ▁&& ▁Cache Util ▁. ▁isC ause d By Position OutOf Range ▁( ▁e ▁) ▁) ▁{ ▁set No Bytes Remaining And Maybe Store Length ▁( ▁) ▁; ▁return ▁C ▁. ▁RESULT _ END _ OF _ INPUT ▁; ▁} ▁handle Before Throw ▁( ▁e ▁) ▁; ▁throw ▁e ▁; ▁} ▁catch ▁( ▁Throwable ▁e ▁) ▁{ ▁handle Before Throw ▁( ▁e ▁) ▁; ▁throw ▁e ▁; ▁} ▁} ▁@ ▁Override ▁@ ▁Nullable ▁public ▁Uri ▁getUri ▁( ▁) ▁{ ▁return ▁actual Uri ▁; ▁} ▁@ ▁Override ▁public ▁Map ▁< ▁String ▁, ▁List ▁< ▁String ▁> ▁> ▁getResponse Headers ▁( ▁) ▁{ ▁return ▁is Reading From Upstream ▁( ▁) ▁? ▁upstream DataSource ▁. ▁getResponse Headers ▁( ▁) ▁: ▁Collections ▁. ▁emptyMap ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁close ▁( ▁) ▁throws ▁IOException ▁{ ▁uri ▁= ▁null ▁; ▁actual Uri ▁= ▁null ▁; ▁httpMethod ▁= ▁DataSpec ▁. ▁HTTP _ METHOD _ GET ▁; ▁http Body ▁= ▁null ▁;
▁public ▁class ▁Span Test ▁{ ▁Span ▁base ▁= ▁Span ▁. ▁newBuilder ▁( ▁) ▁. ▁traceId ▁( ▁STR ▁) ▁. ▁id ▁( ▁STR ▁) ▁. ▁local Endpoint ▁( ▁FR ONT END ▁) ▁. ▁build ▁( ▁) ▁; ▁Span ▁one Of Each ▁= ▁Span ▁. ▁newBuilder ▁( ▁) ▁. ▁traceId ▁( ▁STR ▁) ▁. ▁parentId ▁( ▁STR ▁) ▁. ▁id ▁( ▁STR ▁) ▁. ▁name ▁( ▁STR ▁) ▁. ▁kind ▁( ▁Span ▁. ▁Kind ▁. ▁SERVER ▁) ▁. ▁local Endpoint ▁( ▁BACK END ▁) ▁. ▁remote Endpoint ▁( ▁FR ONT END ▁) ▁. ▁timestamp ▁( ▁1 ▁) ▁. ▁duration ▁( ▁3 ▁) ▁. ▁addAnnotation ▁( ▁2 ▁, ▁STR ▁) ▁. ▁put Tag ▁( ▁STR ▁, ▁STR ▁) ▁. ▁shared ▁( ▁true ▁) ▁. ▁debug ▁( ▁true ▁) ▁. ▁build ▁( ▁) ▁; ▁@ ▁Test ▁public ▁void ▁traceId String ▁( ▁) ▁{ ▁Span ▁with 128 Bit Id ▁= ▁base ▁. ▁toBuilder ▁( ▁) ▁. ▁traceId ▁( ▁STR ▁) ▁. ▁name ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁; ▁assertThat ▁( ▁with 128 Bit Id ▁. ▁traceId ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁local Endpoint _ empty To Null ▁( ▁) ▁{ ▁assertThat ▁( ▁base ▁. ▁toBuilder ▁( ▁) ▁. ▁local Endpoint ▁( ▁Endpoint ▁. ▁newBuilder ▁( ▁) ▁. ▁build ▁( ▁) ▁) ▁. ▁local Endpoint ▁) ▁. ▁isNull ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁remote Endpoint _ empty To Null ▁( ▁) ▁{ ▁assertThat ▁( ▁base ▁. ▁toBuilder ▁( ▁) ▁. ▁remote Endpoint ▁( ▁Endpoint ▁. ▁newBuilder ▁( ▁) ▁. ▁build ▁( ▁) ▁) ▁. ▁remote Endpoint ▁) ▁. ▁isNull ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁local ServiceName ▁( ▁) ▁{ ▁assertThat ▁( ▁base ▁. ▁toBuilder ▁( ▁) ▁. ▁local Endpoint ▁( ▁null ▁) ▁. ▁build ▁( ▁) ▁. ▁local ServiceName ▁( ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁base ▁. ▁toBuilder ▁( ▁) ▁. ▁local Endpoint ▁( ▁FR ONT END ▁) ▁. ▁build ▁( ▁) ▁. ▁local ServiceName ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁FR ONT END ▁. ▁serviceName ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁remote ServiceName ▁( ▁) ▁{ ▁assertThat ▁( ▁base ▁. ▁toBuilder ▁( ▁) ▁. ▁remote Endpoint ▁( ▁null ▁) ▁. ▁build ▁( ▁) ▁. ▁remote ServiceName ▁( ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁base ▁. ▁toBuilder ▁( ▁) ▁. ▁remote Endpoint ▁( ▁BACK END ▁) ▁. ▁build ▁( ▁) ▁. ▁remote ServiceName ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁BACK END ▁. ▁serviceName ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁span Names Lower case ▁( ▁) ▁{ ▁assertThat ▁( ▁base ▁. ▁toBuilder ▁( ▁) ▁. ▁name ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁. ▁name ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁annotations Sort By Timestamp ▁( ▁) ▁{ ▁Span ▁span ▁= ▁base ▁. ▁toBuilder ▁( ▁) ▁. ▁addAnnotation ▁( ▁2 L ▁, ▁STR ▁) ▁. ▁addAnnotation ▁( ▁1 L ▁, ▁STR ▁) ▁. ▁build ▁( ▁) ▁;
▁public ▁class ▁Kubernetes Task ManagerFactory ▁{ ▁public ▁static ▁Kubernetes Pod ▁build TaskManager K ubernetes Pod ▁( ▁Flink Pod ▁pod Template ▁, ▁Kubernetes TaskManager Parameters ▁k ubernetes TaskManager Parameters ▁) ▁{ ▁Flink Pod ▁flink Pod ▁= ▁Preconditions ▁. ▁checkNotNull ▁( ▁pod Template ▁) ▁. ▁copy ▁( ▁) ▁; ▁final ▁Kubernetes Step Decorator ▁[ ▁] ▁step Decorator s ▁= ▁new ▁Kubernetes Step Decorator ▁[ ▁] ▁{ ▁new ▁Init TaskManager Decorator ▁( ▁k ubernetes TaskManager Parameters ▁) ▁, ▁new ▁Env Secrets Decorator ▁( ▁k ubernetes TaskManager Parameters ▁) ▁, ▁new ▁Mount Secrets Decorator ▁( ▁k ubernetes TaskManager Parameters ▁) ▁, ▁new ▁Cmd TaskManager Decorator ▁( ▁k ubernetes TaskManager Parameters ▁) ▁, ▁new ▁Hadoop Conf Mount Decorator ▁( ▁k ubernetes TaskManager Parameters ▁) ▁, ▁new ▁Kerberos Mount Decorator ▁( ▁k ubernetes TaskManager Parameters ▁) ▁, ▁new ▁Flink Conf Mount Decorator ▁( ▁k ubernetes TaskManager Parameters ▁) ▁} ▁; ▁for ▁( ▁Kubernetes Step Decorator ▁step Decorator ▁: ▁step Decorator s ▁) ▁{ ▁flink Pod ▁= ▁step Decorator ▁. ▁decorate Flink Pod ▁( ▁flink Pod ▁) ▁; ▁} ▁final ▁P od ▁resolved Pod ▁= ▁new ▁P od Builder ▁( ▁flink Pod ▁. ▁getP od Without Main Container ▁( ▁) ▁) ▁. ▁edit Or New Spec ▁( ▁) ▁. ▁addTo Containers ▁( ▁flink Pod ▁. ▁getMain Container ▁( ▁) ▁) ▁. ▁end Spec ▁( ▁) ▁. ▁build ▁( ▁) ▁; ▁return ▁new ▁Kubernetes Pod ▁( ▁resolved Pod ▁) ▁; ▁} ▁}
▁private ▁void ▁transition Sql Id ▁( ▁final ▁List ▁< ▁Align ▁> ▁spans ▁) ▁{ ▁this ▁. ▁transition Annotation ▁( ▁spans ▁, ▁new ▁Annotation Replacement Callback ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁replacement ▁( ▁Align ▁align ▁, ▁List ▁< ▁Annotation Bo ▁> ▁annotation BoList ▁) ▁{ ▁Annotation Bo ▁sql Id Annotation ▁= ▁find Annotation ▁( ▁annotation BoList ▁, ▁AnnotationKey ▁. ▁SQL _ ID ▁. ▁getCode ▁( ▁) ▁) ▁; ▁if ▁( ▁sql Id Annotation ▁== ▁null ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁metaData Filter ▁!= ▁null ▁&& ▁metaData Filter ▁. ▁filter ▁( ▁align ▁, ▁MetaData ▁. ▁SQL ▁) ▁) ▁{ ▁Annotation Bo ▁annotation Bo ▁= ▁metaData Filter ▁. ▁create Annotation Bo ▁( ▁align ▁, ▁MetaData ▁. ▁SQL ▁) ▁; ▁annotation BoList ▁. ▁add ▁( ▁annotation Bo ▁) ▁; ▁return ▁; ▁} ▁final ▁Int String StringValue ▁sql Value ▁= ▁( ▁Int String StringValue ▁) ▁sql Id Annotation ▁. ▁getValue ▁( ▁) ▁; ▁final ▁int ▁sql Id ▁= ▁sql Value ▁. ▁getIntValue ▁( ▁) ▁; ▁final ▁String ▁sql Param ▁= ▁sql Value ▁. ▁getString Value 1 ▁( ▁) ▁; ▁final ▁List ▁< ▁Sql MetaData Bo ▁> ▁sql MetaData List ▁= ▁sql MetaData Dao ▁. ▁getSql MetaData ▁( ▁align ▁. ▁getAgentId ▁( ▁) ▁, ▁align ▁. ▁getAgent StartTime ▁( ▁) ▁, ▁sql Id ▁) ▁; ▁final ▁int ▁size ▁= ▁sql MetaData List ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁size ▁== ▁0 ▁) ▁{ ▁String ▁errorMessage ▁= ▁STR ▁+ ▁sql Id ▁; ▁Annotation Bo ▁api ▁= ▁new ▁Annotation Bo ▁( ▁AnnotationKey ▁. ▁SQL ▁. ▁getCode ▁( ▁) ▁, ▁errorMessage ▁) ▁; ▁annotation BoList ▁. ▁add ▁( ▁api ▁) ▁; ▁} ▁else ▁if ▁( ▁size ▁== ▁1 ▁) ▁{ ▁final ▁Sql MetaData Bo ▁sql MetaData Bo ▁= ▁sql MetaData List ▁. ▁get ▁( ▁0 ▁) ▁; ▁if ▁( ▁StringUtils ▁. ▁isEmpty ▁( ▁sql Param ▁) ▁) ▁{ ▁Annotation Bo ▁sql Meta ▁= ▁new ▁Annotation Bo ▁( ▁AnnotationKey ▁. ▁SQL _ METADATA ▁. ▁getCode ▁( ▁) ▁, ▁sql MetaData Bo ▁. ▁getSql ▁( ▁) ▁) ▁; ▁annotation BoList ▁. ▁add ▁( ▁sql Meta ▁) ▁; ▁Annotation Bo ▁sql ▁= ▁new ▁Annotation Bo ▁( ▁AnnotationKey ▁. ▁SQL ▁. ▁getCode ▁( ▁) ▁, ▁StringUtils ▁. ▁trim ▁( ▁sql MetaData Bo ▁. ▁getSql ▁( ▁) ▁) ▁) ▁; ▁annotation BoList ▁. ▁add ▁( ▁sql ▁) ▁; ▁} ▁else ▁{ ▁logger ▁. ▁debug ▁( ▁STR ▁, ▁sql MetaData Bo ▁) ▁; ▁final ▁String ▁output Params ▁= ▁sql Param ▁; ▁List ▁< ▁String ▁> ▁parsed Output Params ▁= ▁output Parameter Parser ▁. ▁parse Output Parameter ▁( ▁output Params ▁) ▁; ▁logger ▁. ▁debug ▁( ▁STR ▁, ▁output Params ▁, ▁parsed Output Params ▁) ▁; ▁String ▁original Sql ▁= ▁sqlParser ▁. ▁combine Output Params ▁( ▁sql MetaData Bo ▁. ▁getSql ▁( ▁) ▁, ▁parsed Output Params ▁) ▁; ▁logger ▁. ▁debug ▁( ▁STR ▁, ▁output Params ▁, ▁original Sql ▁) ▁; ▁Annotation Bo ▁sql Meta ▁= ▁new ▁Annotation Bo ▁( ▁AnnotationKey ▁. ▁SQL _ METADATA ▁. ▁getCode ▁( ▁) ▁, ▁sql MetaData Bo ▁. ▁getSql ▁( ▁) ▁) ▁; ▁annotation BoList ▁. ▁add ▁( ▁sql Meta ▁) ▁;
▁public ▁class ▁JobVertex Thread Info Tracker Test ▁extends ▁TestLogger ▁{ ▁private ▁static ▁final ▁int ▁REQUEST _ ID ▁= ▁0 ▁; ▁private ▁static ▁final ▁Execution JobVertex ▁EXEC UTION _ JOB _ VER TE X ▁= ▁create Execution JobVertex ▁( ▁) ▁; ▁private ▁static ▁final ▁ExecutionVertex ▁[ ▁] ▁TASK _ VER TI CES ▁= ▁EXEC UTION _ JOB _ VER TE X ▁. ▁getTask Vertices ▁( ▁) ▁; ▁private ▁static ▁final ▁JobID ▁JOB _ ID ▁= ▁new ▁JobID ▁( ▁) ▁; ▁private ▁static ▁ThreadInfo Sample ▁threadInfo Sample ▁; ▁private ▁static ▁JobVertex Thread Info Stats ▁threadInfo Stats Default Sample ▁; ▁private ▁static ▁final ▁Duration ▁C LEAN _ UP _ INTERVAL ▁= ▁Duration ▁. ▁ofSeconds ▁( ▁60 ▁) ▁; ▁private ▁static ▁final ▁Duration ▁STAT S _ REF RESH _ INTERVAL ▁= ▁Duration ▁. ▁ofSeconds ▁( ▁60 ▁) ▁; ▁private ▁static ▁final ▁Duration ▁TIME _ G AP ▁= ▁Duration ▁. ▁ofSeconds ▁( ▁60 ▁) ▁; ▁private ▁static ▁final ▁Duration ▁SMALL _ TIME _ G AP ▁= ▁Duration ▁. ▁ofMillis ▁( ▁1 ▁) ▁; ▁private ▁static ▁final ▁Duration ▁REQUEST _ TIMEOUT ▁= ▁Duration ▁. ▁ofSeconds ▁( ▁10 ▁) ▁; ▁private ▁static ▁final ▁int ▁NUMBER _ OF _ S AMP LES ▁= ▁1 ▁; ▁private ▁static ▁final ▁int ▁MAX _ STACK _ TRACE _ DE PTH ▁= ▁100 ▁; ▁private ▁static ▁final ▁Duration ▁DE LAY _ B ET WE EN _ S AMP LES ▁= ▁Duration ▁. ▁ofMillis ▁( ▁50 ▁) ▁; ▁@ ▁Rule ▁public ▁Timeout ▁case Timeout ▁= ▁new ▁Timeout ▁( ▁10 ▁, ▁TimeUnit ▁. ▁SECONDS ▁) ▁; ▁private ▁static ▁Scheduled ExecutorService ▁executor ▁; ▁@ ▁BeforeClass ▁public ▁static ▁void ▁setUp ▁( ▁) ▁{ ▁threadInfo Sample ▁= ▁Jvm Utils ▁. ▁create Thread Info Sample ▁( ▁Thread ▁. ▁currentThread ▁( ▁) ▁. ▁getId ▁( ▁) ▁, ▁MAX _ STACK _ TRACE _ DE PTH ▁) ▁. ▁get ▁( ▁) ▁; ▁threadInfo Stats Default Sample ▁= ▁create Thread Info Stats ▁( ▁REQUEST _ ID ▁, ▁SMALL _ TIME _ G AP ▁, ▁Collections ▁. ▁singletonList ▁( ▁threadInfo Sample ▁) ▁) ▁; ▁executor ▁= ▁Executors ▁. ▁new Scheduled ThreadPool ▁( ▁1 ▁) ▁; ▁} ▁@ ▁AfterClass ▁public ▁static ▁void ▁tearDown ▁( ▁) ▁{ ▁if ▁( ▁executor ▁!= ▁null ▁) ▁{ ▁executor ▁. ▁shutdownNow ▁( ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁testGet Thread Info Stats ▁( ▁) ▁throws ▁Exception ▁{ ▁do Initial Request AndVerify Result ▁( ▁create Thread Info Tracker ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Cached Stats Not Updated Within Refresh Interval ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁int ▁requestId 2 ▁= ▁1 ▁; ▁final ▁JobVertex Thread Info Stats ▁threadInfo Stats 2 ▁= ▁create Thread Info Stats ▁( ▁requestId 2 ▁, ▁TIME _ G AP ▁, ▁null ▁) ▁; ▁final ▁JobVertex Thread Info Tracker ▁< ▁JobVertex Thread Info Stats ▁> ▁tracker ▁= ▁create Thread Info Tracker ▁( ▁C LEAN _ UP _ INTERVAL ▁, ▁STAT S _ REF RESH _ INTERVAL ▁, ▁threadInfo Stats Default Sample ▁, ▁threadInfo Stats 2 ▁) ▁; ▁do Initial Request AndVerify Result ▁( ▁tracker ▁) ▁;
▁for ▁( ▁Split ▁split ▁: ▁splits ▁) ▁{ ▁if ▁( ▁pending Splits ▁. ▁put ▁( ▁source Id ▁, ▁new ▁Scheduled Split ▁( ▁next Split Id ▁. ▁getAndIncrement ▁( ▁) ▁, ▁source Id ▁, ▁split ▁) ▁) ▁) ▁{ ▁added ▁++ ▁; ▁} ▁} ▁if ▁( ▁table Scan PlanNode Ids ▁. ▁contains ▁( ▁source Id ▁) ▁) ▁{ ▁pending SourceSplit Count ▁+= ▁added ▁; ▁update Task Stats ▁( ▁) ▁; ▁} ▁needs Update ▁= ▁true ▁; ▁} ▁update Split Queue Space ▁( ▁) ▁; ▁if ▁( ▁needs Update ▁) ▁{ ▁this ▁. ▁needs Update ▁. ▁set ▁( ▁true ▁) ▁; ▁schedule Update ▁( ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁synchronized ▁void ▁no More Splits ▁( ▁PlanNodeId ▁source Id ▁) ▁{ ▁if ▁( ▁no More Splits ▁. ▁containsKey ▁( ▁source Id ▁) ▁) ▁{ ▁return ▁; ▁} ▁no More Splits ▁. ▁put ▁( ▁source Id ▁, ▁true ▁) ▁; ▁needs Update ▁. ▁set ▁( ▁true ▁) ▁; ▁schedule Update ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁synchronized ▁void ▁no More Splits ▁( ▁PlanNodeId ▁source Id ▁, ▁L ifespan ▁lifespan ▁) ▁{ ▁if ▁( ▁pending No More Splits For L ifespan ▁. ▁put ▁( ▁source Id ▁, ▁lifespan ▁) ▁) ▁{ ▁needs Update ▁. ▁set ▁( ▁true ▁) ▁; ▁schedule Update ▁( ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁synchronized ▁void ▁setOutput Buffers ▁( ▁Output Buffers ▁new Output Buffers ▁) ▁{ ▁if ▁( ▁getTask Status ▁( ▁) ▁. ▁getState ▁( ▁) ▁. ▁isDone ▁( ▁) ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁new Output Buffers ▁. ▁getVersion ▁( ▁) ▁> ▁output Buffers ▁. ▁get ▁( ▁) ▁. ▁getVersion ▁( ▁) ▁) ▁{ ▁output Buffers ▁. ▁set ▁( ▁new Output Buffers ▁) ▁; ▁needs Update ▁. ▁set ▁( ▁true ▁) ▁; ▁schedule Update ▁( ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁List enableFuture ▁< ▁? ▁> ▁remove Remote Source ▁( ▁TaskId ▁remote Source TaskId ▁) ▁{ ▁URI ▁remote Source Uri ▁= ▁uri Builder From ▁( ▁task Location ▁) ▁. ▁append Path ▁( ▁STR ▁) ▁. ▁append Path ▁( ▁remote Source TaskId ▁. ▁toString ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁Request ▁request ▁= ▁prepare Delete ▁( ▁) ▁. ▁setUri ▁( ▁remote Source Uri ▁) ▁. ▁build ▁( ▁) ▁; ▁Request Error Tracker ▁error Tracker ▁= ▁task Request Error Tracker ▁( ▁taskId ▁, ▁remote Source Uri ▁, ▁max Error Duration ▁, ▁error Scheduled Executor ▁, ▁STR ▁) ▁; ▁SettableFuture ▁< ▁? ▁> ▁future ▁= ▁SettableFuture ▁. ▁create ▁( ▁) ▁; ▁do Remove Remote Source ▁( ▁error Tracker ▁, ▁request ▁, ▁future ▁) ▁; ▁return ▁future ▁; ▁} ▁private ▁void ▁do Remove Remote Source ▁( ▁Request Error Tracker ▁error Tracker ▁, ▁Request ▁request ▁, ▁SettableFuture ▁< ▁? ▁> ▁future ▁) ▁{ ▁error Tracker ▁. ▁start Request ▁( ▁) ▁; ▁Future Callback ▁< ▁Status Response ▁> ▁callback ▁= ▁new ▁Future Callback ▁< ▁Status Response ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁onSuccess ▁( ▁@ ▁Nullable ▁Status Response ▁response ▁) ▁{ ▁if ▁( ▁response ▁== ▁null ▁) ▁{ ▁throw ▁new ▁PrestoException ▁( ▁GENERIC _ INTERNAL _ ERROR ▁, ▁STR ▁) ▁; ▁}
▁public ▁class ▁ByteBuffer Codec ▁implements ▁Object Serializer ▁, ▁Object Deserializer ▁{ ▁public ▁final ▁static ▁ByteBuffer Codec ▁instance ▁= ▁new ▁ByteBuffer Codec ▁( ▁) ▁; ▁@ ▁Override ▁public ▁< ▁T ▁> ▁T ▁deser ial ze ▁( ▁Default JSONParser ▁parser ▁, ▁Type ▁type ▁, ▁Object ▁fieldName ▁) ▁{ ▁ByteBuffer Bean ▁bean ▁= ▁parser ▁. ▁parseObject ▁( ▁ByteBuffer Bean ▁. ▁class ▁) ▁; ▁return ▁( ▁T ▁) ▁bean ▁. ▁byteBuffer ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getFast Match Token ▁( ▁) ▁{ ▁return ▁JSONToken ▁. ▁L BR ACKET ▁; ▁} ▁@ ▁Override ▁public ▁void ▁write ▁( ▁JSONSerializer ▁serializer ▁, ▁Object ▁object ▁, ▁Object ▁fieldName ▁, ▁Type ▁fieldType ▁, ▁int ▁features ▁) ▁throws ▁IOException ▁{ ▁ByteBuffer ▁byteBuf ▁= ▁( ▁ByteBuffer ▁) ▁object ▁; ▁byte ▁[ ▁] ▁array ▁= ▁byteBuf ▁. ▁array ▁( ▁) ▁; ▁SerializeWriter ▁out ▁= ▁serializer ▁. ▁out ▁; ▁out ▁. ▁write ▁( ▁CHAR ▁) ▁; ▁out ▁. ▁write FieldName ▁( ▁STR ▁) ▁; ▁out ▁. ▁write ByteArray ▁( ▁array ▁) ▁; ▁out ▁. ▁write FieldValue ▁( ▁CHAR ▁, ▁STR ▁, ▁byteBuf ▁. ▁limit ▁( ▁) ▁) ▁; ▁out ▁. ▁write FieldValue ▁( ▁CHAR ▁, ▁STR ▁, ▁byteBuf ▁. ▁position ▁( ▁) ▁) ▁; ▁out ▁. ▁write ▁( ▁CHAR ▁) ▁; ▁} ▁public ▁static ▁class ▁ByteBuffer Bean ▁{ ▁public ▁byte ▁[ ▁] ▁array ▁; ▁public ▁int ▁limit ▁; ▁public ▁int ▁position ▁; ▁public ▁ByteBuffer ▁byteBuffer ▁( ▁) ▁{ ▁ByteBuffer ▁buf ▁= ▁ByteBuffer ▁. ▁wrap ▁( ▁array ▁) ▁; ▁buf ▁. ▁limit ▁( ▁limit ▁) ▁; ▁buf ▁. ▁position ▁( ▁position ▁) ▁; ▁return ▁buf ▁; ▁} ▁} ▁}
▁@ ▁MapFeature ▁. ▁Require ▁( ▁value ▁= ▁SUPPORTS _ PUT ▁, ▁absent ▁= ▁ALLOWS _ NULL _ VALUES ▁) ▁@ ▁CollectionSize ▁. ▁Require ▁( ▁absent ▁= ▁ Z ERO ▁) ▁public ▁void ▁testPut IfAbsent _ put WithNull Value Unsupported ▁( ▁) ▁{ ▁try ▁{ ▁getMap ▁( ▁) ▁. ▁putIfAbsent ▁( ▁k 0 ▁( ▁) ▁, ▁null ▁) ▁; ▁} ▁catch ▁( ▁NullPointer Exception ▁toler ated ▁) ▁{ ▁} ▁expectUnchanged ▁( ▁) ▁; ▁expect NullValue Missing When NullValues Unsupported ▁( ▁STR ▁) ▁; ▁} ▁}
▁public ▁class ▁Tar Arch iver Test ▁{ ▁@ ▁Rule ▁public ▁TemporaryFolder ▁tmp ▁= ▁new ▁TemporaryFolder ▁( ▁) ▁; ▁@ ▁Issue ▁( ▁STR ▁) ▁@ ▁Test ▁public ▁void ▁permission ▁( ▁) ▁throws ▁Exception ▁{ ▁assumeTrue ▁( ▁! ▁Functions ▁. ▁isWindows ▁( ▁) ▁) ▁; ▁File ▁tar ▁= ▁File ▁. ▁createTempFile ▁( ▁STR ▁, ▁STR ▁) ▁; ▁File ▁zip ▁= ▁File ▁. ▁createTempFile ▁( ▁STR ▁, ▁STR ▁) ▁; ▁FilePath ▁dir ▁= ▁new ▁FilePath ▁( ▁File ▁. ▁createTempFile ▁( ▁STR ▁, ▁STR ▁) ▁) ▁; ▁try ▁{ ▁dir ▁. ▁delete ▁( ▁) ▁; ▁dir ▁. ▁child ▁( ▁STR ▁) ▁. ▁mkdirs ▁( ▁) ▁; ▁FilePath ▁f ▁= ▁dir ▁. ▁child ▁( ▁STR ▁) ▁; ▁f ▁. ▁touch ▁( ▁0 ▁) ▁; ▁f ▁. ▁ch mod ▁( ▁0 7 55 ▁) ▁; ▁f ▁= ▁dir ▁. ▁child ▁( ▁STR ▁) ▁; ▁f ▁. ▁touch ▁( ▁0 ▁) ▁; ▁f ▁. ▁ch mod ▁( ▁0 64 4 ▁) ▁; ▁int ▁dir Mode ▁= ▁dir ▁. ▁child ▁( ▁STR ▁) ▁. ▁mode ▁( ▁) ▁; ▁dir ▁. ▁tar ▁( ▁Files ▁. ▁new OutputStream ▁( ▁tar ▁. ▁toPath ▁( ▁) ▁) ▁, ▁STR ▁) ▁; ▁dir ▁. ▁zip ▁( ▁Files ▁. ▁new OutputStream ▁( ▁zip ▁. ▁toPath ▁( ▁) ▁) ▁) ▁; ▁FilePath ▁e ▁= ▁dir ▁. ▁child ▁( ▁STR ▁) ▁; ▁e ▁. ▁mkdirs ▁( ▁) ▁; ▁run ▁( ▁e ▁, ▁STR ▁, ▁STR ▁, ▁tar ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁0 7 55 ▁, ▁e ▁. ▁child ▁( ▁STR ▁) ▁. ▁mode ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁dir Mode ▁, ▁e ▁. ▁child ▁( ▁STR ▁) ▁. ▁mode ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁0 64 4 ▁, ▁e ▁. ▁child ▁( ▁STR ▁) ▁. ▁mode ▁( ▁) ▁) ▁; ▁e ▁. ▁delete Contents ▁( ▁) ▁; ▁run ▁( ▁e ▁, ▁STR ▁, ▁zip ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁; ▁e ▁= ▁e ▁. ▁list Directories ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁; ▁assertEquals ▁( ▁0 7 55 ▁, ▁e ▁. ▁child ▁( ▁STR ▁) ▁. ▁mode ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁dir Mode ▁, ▁e ▁. ▁child ▁( ▁STR ▁) ▁. ▁mode ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁0 64 4 ▁, ▁e ▁. ▁child ▁( ▁STR ▁) ▁. ▁mode ▁( ▁) ▁) ▁; ▁} ▁finally ▁{ ▁tar ▁. ▁delete ▁( ▁) ▁; ▁zip ▁. ▁delete ▁( ▁) ▁; ▁dir ▁. ▁delete Recursive ▁( ▁) ▁; ▁} ▁} ▁private ▁static ▁void ▁run ▁( ▁FilePath ▁dir ▁, ▁String ▁... ▁cmd s ▁) ▁throws ▁Interrupted Exception ▁{ ▁try ▁{ ▁assertEquals ▁( ▁0 ▁, ▁new ▁Local Launcher ▁( ▁StreamTask Listener ▁. ▁from St dout ▁( ▁) ▁) ▁. ▁launch ▁( ▁) ▁. ▁cmd s ▁( ▁cmd s ▁) ▁. ▁pw d ▁( ▁dir ▁) ▁. ▁join ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁x ▁) ▁{ ▁Assume ▁. ▁assume No Exception ▁( ▁STR ▁+ ▁Arrays ▁. ▁toString ▁( ▁cmd s ▁) ▁, ▁x ▁) ▁; ▁} ▁}
▁@ ▁ThreadSafe ▁public ▁class ▁Local Spawn Runner ▁implements ▁Spawn Runner ▁{ ▁private ▁static ▁final ▁Joiner ▁SPACE _ JO INER ▁= ▁Joiner ▁. ▁on ▁( ▁CHAR ▁) ▁; ▁private ▁static ▁final ▁String ▁UN HAND LED _ EXCEPTION _ MSG ▁= ▁STR ▁; ▁private ▁static ▁final ▁int ▁LOCAL _ EXEC _ ERROR ▁= ▁- ▁1 ▁; ▁private ▁static ▁final ▁Google Logger ▁logger ▁= ▁Google Logger ▁. ▁for Enclosing Class ▁( ▁) ▁; ▁private ▁final ▁Path ▁execRoot ▁; ▁private ▁final ▁ResourceManager ▁resourceManager ▁; ▁private ▁final ▁String ▁hostName ▁; ▁private ▁final ▁Local Execution Options ▁local Execution Options ▁; ▁@ ▁Nullable ▁private ▁final ▁Process Wrapper ▁process Wrapper ▁; ▁private ▁final ▁Local Env Provider ▁local Env Provider ▁; ▁private ▁final ▁B in Tools ▁bin Tools ▁; ▁private ▁final ▁Runfiles Tree Updater ▁runfiles Tree Updater ▁; ▁public ▁Local Spawn Runner ▁( ▁Path ▁execRoot ▁, ▁Local Execution Options ▁local Execution Options ▁, ▁ResourceManager ▁resourceManager ▁, ▁Local Env Provider ▁local Env Provider ▁, ▁B in Tools ▁bin Tools ▁, ▁Process Wrapper ▁process Wrapper ▁, ▁Runfiles Tree Updater ▁runfiles Tree Updater ▁) ▁{ ▁this ▁. ▁execRoot ▁= ▁execRoot ▁; ▁this ▁. ▁process Wrapper ▁= ▁process Wrapper ▁; ▁this ▁. ▁local Execution Options ▁= ▁Preconditions ▁. ▁checkNotNull ▁( ▁local Execution Options ▁) ▁; ▁this ▁. ▁hostName ▁= ▁NetUtil ▁. ▁getCached Short Host Name ▁( ▁) ▁; ▁this ▁. ▁resourceManager ▁= ▁resourceManager ▁; ▁this ▁. ▁local Env Provider ▁= ▁local Env Provider ▁; ▁this ▁. ▁bin Tools ▁= ▁bin Tools ▁; ▁this ▁. ▁runfiles Tree Updater ▁= ▁runfiles Tree Updater ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁Spawn Result ▁exec ▁( ▁Spawn ▁spawn ▁, ▁Spawn ExecutionContext ▁context ▁) ▁throws ▁IOException ▁, ▁Interrupted Exception ▁, ▁Exec Exception ▁, ▁For bidden Action InputException ▁{ ▁runfiles Tree Updater ▁. ▁update Runfiles Directory ▁( ▁execRoot ▁, ▁spawn ▁. ▁getR un files Supplier ▁( ▁) ▁, ▁bin Tools ▁, ▁spawn ▁. ▁getEnvironment ▁( ▁) ▁, ▁context ▁. ▁getFile Out Err ▁( ▁) ▁) ▁; ▁try ▁( ▁S ilent Closeable ▁c ▁= ▁Profiler ▁. ▁instance ▁( ▁) ▁. ▁profile ▁( ▁Profiler Task ▁. ▁LOCAL _ EXECUT ION ▁, ▁spawn ▁. ▁getResource Owner ▁( ▁) ▁. ▁getMnemonic ▁( ▁) ▁) ▁) ▁{ ▁Action Execution Metadata ▁owner ▁= ▁spawn ▁. ▁getResource Owner ▁( ▁) ▁; ▁context ▁. ▁report ▁( ▁Spawn Scheduling Event ▁. ▁create ▁( ▁getName ▁( ▁) ▁) ▁) ▁; ▁try ▁( ▁Resource Handle ▁handle ▁= ▁resourceManager ▁. ▁acquire Resources ▁( ▁owner ▁, ▁spawn ▁. ▁getLocal Resources ▁( ▁) ▁) ▁) ▁{ ▁context ▁. ▁report ▁( ▁Spawn Execut ing Event ▁. ▁create ▁( ▁getName ▁( ▁) ▁) ▁) ▁; ▁if ▁( ▁! ▁local Execution Options ▁. ▁local Lock free Output ▁) ▁{ ▁context ▁. ▁lock Output Files ▁( ▁) ▁; ▁} ▁return ▁new ▁Sub process Handler ▁( ▁spawn ▁, ▁context ▁) ▁. ▁run ▁( ▁) ▁; ▁} ▁} ▁} ▁@ ▁Override ▁public ▁boolean ▁can Exec ▁( ▁Spawn ▁spawn ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁handles Caching ▁( ▁) ▁{ ▁return ▁false ▁; ▁}
▁class ▁Single Row ▁extends ▁Row ▁{ ▁private ▁final ▁String ▁displayName ▁; ▁private ▁final ▁String ▁description ▁; ▁private ▁final ▁String ▁defaultValue ▁; ▁Single Row ▁( ▁Snippet ▁snippet ▁, ▁Configuration Property ▁property ▁) ▁{ ▁super ▁( ▁snippet ▁, ▁property ▁. ▁getName ▁( ▁) ▁) ▁; ▁this ▁. ▁displayName ▁= ▁property ▁. ▁getDisplayName ▁( ▁) ▁; ▁this ▁. ▁description ▁= ▁property ▁. ▁getDescription ▁( ▁) ▁; ▁this ▁. ▁defaultValue ▁= ▁getDefaultValue ▁( ▁property ▁. ▁getDefaultValue ▁( ▁) ▁) ▁; ▁} ▁private ▁String ▁getDefaultValue ▁( ▁Object ▁defaultValue ▁) ▁{ ▁if ▁( ▁defaultValue ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁if ▁( ▁defaultValue ▁. ▁getClass ▁( ▁) ▁. ▁isArray ▁( ▁) ▁) ▁{ ▁return ▁Arrays ▁. ▁stream ▁( ▁( ▁Object ▁[ ▁] ▁) ▁defaultValue ▁) ▁. ▁map ▁( ▁Object ▁:: ▁toString ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁joining ▁( ▁STR ▁+ ▁System ▁. ▁lineSeparator ▁( ▁) ▁) ▁) ▁; ▁} ▁return ▁defaultValue ▁. ▁toString ▁( ▁) ▁; ▁} ▁@ ▁Override ▁void ▁write ▁( ▁Asci id oc ▁as ci id oc ▁) ▁{ ▁as ci id oc ▁. ▁append ▁( ▁STR ▁) ▁; ▁as ci id oc ▁. ▁append ▁( ▁STR ▁+ ▁get Anchor ▁( ▁) ▁+ ▁STR ▁) ▁; ▁as ci id oc ▁. ▁append ln ▁( ▁STR ▁+ ▁get Anchor ▁( ▁) ▁+ ▁STR ▁, ▁this ▁. ▁displayName ▁, ▁STR ▁) ▁; ▁write Description ▁( ▁as ci id oc ▁) ▁; ▁write DefaultValue ▁( ▁as ci id oc ▁) ▁; ▁} ▁private ▁void ▁write Description ▁( ▁Asci id oc ▁builder ▁) ▁{ ▁if ▁( ▁this ▁. ▁description ▁== ▁null ▁|| ▁this ▁. ▁description ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁builder ▁. ▁append ln ▁( ▁STR ▁) ▁; ▁} ▁else ▁{ ▁String ▁clean ed Description ▁= ▁this ▁. ▁description ▁. ▁replace ▁( ▁STR ▁, ▁STR ▁) ▁. ▁replace ▁( ▁STR ▁, ▁STR ▁) ▁. ▁replace ▁( ▁STR ▁, ▁STR ▁) ▁; ▁builder ▁. ▁append ln ▁( ▁STR ▁, ▁clean ed Description ▁, ▁STR ▁) ▁; ▁} ▁} ▁private ▁void ▁write DefaultValue ▁( ▁Asci id oc ▁builder ▁) ▁{ ▁String ▁defaultValue ▁= ▁( ▁this ▁. ▁defaultValue ▁!= ▁null ▁) ▁? ▁this ▁. ▁defaultValue ▁: ▁STR ▁; ▁if ▁( ▁defaultValue ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁builder ▁. ▁append ln ▁( ▁STR ▁) ▁; ▁} ▁else ▁{ ▁defaultValue ▁= ▁defaultValue ▁. ▁replace ▁( ▁STR ▁, ▁STR ▁) ▁. ▁replace ▁( ▁STR ▁, ▁STR ▁) ▁; ▁builder ▁. ▁append ln ▁( ▁STR ▁, ▁defaultValue ▁, ▁STR ▁) ▁; ▁} ▁} ▁}
▁@ ▁Internal ▁public ▁class ▁Group Combine OperatorBase ▁< ▁IN ▁, ▁OUT ▁, ▁F T ▁extends ▁Group Combine Function ▁< ▁IN ▁, ▁OUT ▁> ▁> ▁extends ▁SingleInput Operator ▁< ▁IN ▁, ▁OUT ▁, ▁F T ▁> ▁{ ▁private ▁Ordering ▁group Order ▁; ▁public ▁Group Combine OperatorBase ▁( ▁F T ▁udf ▁, ▁Unary Operator Information ▁< ▁IN ▁, ▁OUT ▁> ▁operator Info ▁, ▁int ▁[ ▁] ▁key Positions ▁, ▁String ▁name ▁) ▁{ ▁super ▁( ▁new ▁User Code ObjectWrapper ▁< ▁F T ▁> ▁( ▁udf ▁) ▁, ▁operator Info ▁, ▁key Positions ▁, ▁name ▁) ▁; ▁} ▁public ▁void ▁setGroup Order ▁( ▁Ordering ▁order ▁) ▁{ ▁this ▁. ▁group Order ▁= ▁order ▁; ▁} ▁public ▁Ordering ▁getGroup Order ▁( ▁) ▁{ ▁return ▁this ▁. ▁group Order ▁; ▁} ▁private ▁TypeComparator ▁< ▁IN ▁> ▁getType Comparator ▁( ▁TypeInformation ▁< ▁IN ▁> ▁typeInfo ▁, ▁int ▁[ ▁] ▁sort Columns ▁, ▁boolean ▁[ ▁] ▁sortOrder ings ▁, ▁ExecutionConfig ▁executionConfig ▁) ▁{ ▁if ▁( ▁typeInfo ▁instanceof ▁Composite Type ▁) ▁{ ▁return ▁( ▁( ▁Composite Type ▁< ▁IN ▁> ▁) ▁typeInfo ▁) ▁. ▁create Comparator ▁( ▁sort Columns ▁, ▁sortOrder ings ▁, ▁0 ▁, ▁executionConfig ▁) ▁; ▁} ▁else ▁if ▁( ▁typeInfo ▁instanceof ▁Atomic Type ▁) ▁{ ▁return ▁( ▁( ▁Atomic Type ▁< ▁IN ▁> ▁) ▁typeInfo ▁) ▁. ▁create Comparator ▁( ▁sortOrder ings ▁[ ▁0 ▁] ▁, ▁executionConfig ▁) ▁; ▁} ▁throw ▁new ▁Invalid Program Exception ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁List ▁< ▁OUT ▁> ▁execute On Collections ▁( ▁List ▁< ▁IN ▁> ▁input Data ▁, ▁RuntimeContext ▁ctx ▁, ▁ExecutionConfig ▁executionConfig ▁) ▁throws ▁Exception ▁{ ▁Group Combine Function ▁< ▁IN ▁, ▁OUT ▁> ▁function ▁= ▁this ▁. ▁user Function ▁. ▁getUser Code Object ▁( ▁) ▁; ▁Unary Operator Information ▁< ▁IN ▁, ▁OUT ▁> ▁operator Info ▁= ▁getOperator Info ▁( ▁) ▁; ▁TypeInformation ▁< ▁IN ▁> ▁inputType ▁= ▁operator Info ▁. ▁getInput Type ▁( ▁) ▁; ▁int ▁[ ▁] ▁key Columns ▁= ▁getKey Columns ▁( ▁0 ▁) ▁; ▁int ▁[ ▁] ▁sort Columns ▁= ▁key Columns ▁; ▁boolean ▁[ ▁] ▁sortOrder ings ▁= ▁new ▁boolean ▁[ ▁sort Columns ▁. ▁length ▁] ▁; ▁if ▁( ▁group Order ▁!= ▁null ▁) ▁{ ▁sort Columns ▁= ▁ArrayUtils ▁. ▁addAll ▁( ▁sort Columns ▁, ▁group Order ▁. ▁getField Positions ▁( ▁) ▁) ▁; ▁sortOrder ings ▁= ▁ArrayUtils ▁. ▁addAll ▁( ▁sortOrder ings ▁, ▁group Order ▁. ▁getField Sort Direction s ▁( ▁) ▁) ▁; ▁} ▁if ▁( ▁sort Columns ▁. ▁length ▁== ▁0 ▁) ▁{ ▁checkArgument ▁( ▁sortOrder ings ▁. ▁length ▁== ▁0 ▁) ▁; ▁} ▁else ▁{ ▁final ▁TypeComparator ▁< ▁IN ▁> ▁sort Comparator ▁= ▁getType Comparator ▁( ▁inputType ▁, ▁sort Columns ▁, ▁sortOrder ings ▁, ▁executionConfig ▁) ▁; ▁Collections ▁. ▁sort ▁( ▁input Data ▁, ▁new ▁Comparator ▁< ▁IN ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁int ▁compare ▁( ▁IN ▁o 1 ▁, ▁IN ▁o 2 ▁) ▁{ ▁return ▁sort Comparator ▁. ▁compare ▁( ▁o 1 ▁, ▁o 2 ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁Function Utils ▁. ▁set Function RuntimeContext ▁( ▁function ▁, ▁ctx ▁) ▁;
▁@ ▁Override ▁public ▁synchronized ▁Advice ▁get Advice ▁( ▁) ▁{ ▁if ▁( ▁this ▁. ▁instant iated Advice ▁== ▁null ▁) ▁{ ▁this ▁. ▁instant iated Advice ▁= ▁instantiate Advice ▁( ▁this ▁. ▁declared Pointcut ▁) ▁; ▁} ▁return ▁this ▁. ▁instant iated Advice ▁; ▁} ▁private ▁Advice ▁instantiate Advice ▁( ▁AspectJ Expression Pointcut ▁point cut ▁) ▁{ ▁Advice ▁advice ▁= ▁this ▁. ▁aspect J Advisor Factory ▁. ▁get Advice ▁( ▁this ▁. ▁aspect J Advice Method ▁, ▁point cut ▁, ▁this ▁. ▁aspect Instance Factory ▁, ▁this ▁. ▁decl aration Order ▁, ▁this ▁. ▁aspect Name ▁) ▁; ▁return ▁( ▁advice ▁!= ▁null ▁? ▁advice ▁: ▁EMPTY _ AD VICE ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is Per Instance ▁( ▁) ▁{ ▁return ▁( ▁get Aspect Metadata ▁( ▁) ▁. ▁getA j Type ▁( ▁) ▁. ▁getPer Clause ▁( ▁) ▁. ▁getKind ▁( ▁) ▁!= ▁Per Clause Kind ▁. ▁SINGLETON ▁) ▁; ▁} ▁public ▁Aspect Metadata ▁get Aspect Metadata ▁( ▁) ▁{ ▁return ▁this ▁. ▁aspect Instance Factory ▁. ▁get Aspect Metadata ▁( ▁) ▁; ▁} ▁public ▁Metadata Aware Aspect Instance Factory ▁get Aspect Instance Factory ▁( ▁) ▁{ ▁return ▁this ▁. ▁aspect Instance Factory ▁; ▁} ▁public ▁AspectJ Expression Pointcut ▁getDeclared Pointcut ▁( ▁) ▁{ ▁return ▁this ▁. ▁declared Pointcut ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getOrder ▁( ▁) ▁{ ▁return ▁this ▁. ▁aspect Instance Factory ▁. ▁getOrder ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁get Aspect Name ▁( ▁) ▁{ ▁return ▁this ▁. ▁aspect Name ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getDecl aration Order ▁( ▁) ▁{ ▁return ▁this ▁. ▁decl aration Order ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is Before Advice ▁( ▁) ▁{ ▁if ▁( ▁this ▁. ▁is Before Advice ▁== ▁null ▁) ▁{ ▁determine Advice Type ▁( ▁) ▁; ▁} ▁return ▁this ▁. ▁is Before Advice ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is After Advice ▁( ▁) ▁{ ▁if ▁( ▁this ▁. ▁is After Advice ▁== ▁null ▁) ▁{ ▁determine Advice Type ▁( ▁) ▁; ▁} ▁return ▁this ▁. ▁is After Advice ▁; ▁} ▁private ▁void ▁determine Advice Type ▁( ▁) ▁{ ▁AspectJ Annotation ▁< ▁? ▁> ▁aspect J Annotation ▁= ▁Abstract Aspect J Advisor Factory ▁. ▁find Aspect J Annotation On Method ▁( ▁this ▁. ▁aspect J Advice Method ▁) ▁; ▁if ▁( ▁aspect J Annotation ▁== ▁null ▁) ▁{ ▁this ▁. ▁is Before Advice ▁= ▁false ▁; ▁this ▁. ▁is After Advice ▁= ▁false ▁; ▁} ▁else ▁{ ▁switch ▁( ▁aspect J Annotation ▁. ▁getAnnotation Type ▁( ▁) ▁) ▁{ ▁case ▁At Pointcut ▁: ▁case ▁At Around ▁: ▁this ▁. ▁is Before Advice ▁= ▁false ▁; ▁this ▁. ▁is After Advice ▁= ▁false ▁; ▁break ▁; ▁case ▁At Before ▁: ▁this ▁. ▁is Before Advice ▁= ▁true ▁; ▁this ▁. ▁is After Advice ▁= ▁false ▁; ▁break ▁; ▁case ▁At After ▁: ▁case ▁At After Returning ▁: ▁case ▁At After Throwing ▁: ▁this ▁. ▁is Before Advice ▁= ▁false ▁; ▁this ▁. ▁is After Advice ▁= ▁true ▁; ▁break ▁; ▁} ▁} ▁}
▁} ▁else ▁if ▁( ▁command ▁<= ▁GROUP _ G 0_ END ▁) ▁{ ▁handle G 0 Character ▁( ▁command ▁) ▁; ▁cue s Need Update ▁= ▁true ▁; ▁} ▁else ▁if ▁( ▁command ▁<= ▁GROUP _ C 1_ END ▁) ▁{ ▁handle C 1 Command ▁( ▁command ▁) ▁; ▁cue s Need Update ▁= ▁true ▁; ▁} ▁else ▁if ▁( ▁command ▁<= ▁GROUP _ G 1_ END ▁) ▁{ ▁handle G 1 Character ▁( ▁command ▁) ▁; ▁cue s Need Update ▁= ▁true ▁; ▁} ▁else ▁{ ▁Log ▁. ▁w ▁( ▁TAG ▁, ▁STR ▁+ ▁command ▁) ▁; ▁} ▁} ▁else ▁{ ▁command ▁= ▁service Block Packet ▁. ▁read Bits ▁( ▁8 ▁) ▁; ▁if ▁( ▁command ▁<= ▁GROUP _ C 2_ END ▁) ▁{ ▁handle C 2 Command ▁( ▁command ▁) ▁; ▁} ▁else ▁if ▁( ▁command ▁<= ▁GROUP _ G 2_ END ▁) ▁{ ▁handle G 2 Character ▁( ▁command ▁) ▁; ▁cue s Need Update ▁= ▁true ▁; ▁} ▁else ▁if ▁( ▁command ▁<= ▁GROUP _ C 3_ END ▁) ▁{ ▁handle C 3 Command ▁( ▁command ▁) ▁; ▁} ▁else ▁if ▁( ▁command ▁<= ▁GROUP _ G 3_ END ▁) ▁{ ▁handle G 3 Character ▁( ▁command ▁) ▁; ▁cue s Need Update ▁= ▁true ▁; ▁} ▁else ▁{ ▁Log ▁. ▁w ▁( ▁TAG ▁, ▁STR ▁+ ▁command ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁cue s Need Update ▁) ▁{ ▁cue s ▁= ▁getDisplay C ue s ▁( ▁) ▁; ▁} ▁} ▁private ▁void ▁handle C 0 Command ▁( ▁int ▁command ▁) ▁{ ▁switch ▁( ▁command ▁) ▁{ ▁case ▁COM MAND _ N UL ▁: ▁break ▁; ▁case ▁COM MAND _ ET X ▁: ▁cue s ▁= ▁getDisplay C ue s ▁( ▁) ▁; ▁break ▁; ▁case ▁COM MAND _ B S ▁: ▁current C ue Info Builder ▁. ▁back space ▁( ▁) ▁; ▁break ▁; ▁case ▁COM MAND _ FF ▁: ▁reset C ue Builders ▁( ▁) ▁; ▁break ▁; ▁case ▁COM MAND _ CR ▁: ▁current C ue Info Builder ▁. ▁append ▁( ▁CHAR ▁) ▁; ▁break ▁; ▁case ▁COM MAND _ H CR ▁: ▁break ▁; ▁default ▁: ▁if ▁( ▁command ▁>= ▁COM MAND _ EXT 1_ START ▁&& ▁command ▁<= ▁COM MAND _ EXT 1_ END ▁) ▁{ ▁Log ▁. ▁w ▁( ▁TAG ▁, ▁STR ▁+ ▁command ▁) ▁; ▁service Block Packet ▁. ▁skip Bits ▁( ▁8 ▁) ▁; ▁} ▁else ▁if ▁( ▁command ▁>= ▁COM MAND _ P 16_ START ▁&& ▁command ▁<= ▁COM MAND _ P 16_ END ▁) ▁{ ▁Log ▁. ▁w ▁( ▁TAG ▁, ▁STR ▁+ ▁command ▁) ▁; ▁service Block Packet ▁. ▁skip Bits ▁( ▁16 ▁) ▁; ▁} ▁else ▁{ ▁Log ▁. ▁w ▁( ▁TAG ▁, ▁STR ▁+ ▁command ▁) ▁; ▁} ▁} ▁} ▁private ▁void ▁handle C 1 Command ▁( ▁int ▁command ▁) ▁{ ▁int ▁window ▁;
▁public ▁class ▁Api Id Aware Interceptor ▁implements ▁Api Id Aware A roundInterceptor ▁{ ▁public ▁static ▁boolean ▁before ▁; ▁public ▁static ▁boolean ▁after ▁; ▁public ▁static ▁Object ▁before Target ▁; ▁public ▁static ▁int ▁before Api Id ▁= ▁- ▁1 ▁; ▁public ▁static ▁Object ▁[ ▁] ▁before Args ▁; ▁public ▁static ▁Object ▁after Target ▁; ▁public ▁static ▁int ▁after Api Id ▁= ▁- ▁1 ▁; ▁public ▁static ▁Object ▁[ ▁] ▁after Args ▁; ▁public ▁static ▁Object ▁result ▁; ▁public ▁static ▁Throwable ▁throwable ▁; ▁public ▁static ▁void ▁clear ▁( ▁) ▁{ ▁before ▁= ▁false ▁; ▁after ▁= ▁false ▁; ▁before Target ▁= ▁null ▁; ▁before Api Id ▁= ▁- ▁1 ▁; ▁before Args ▁= ▁null ▁; ▁after Target ▁= ▁null ▁; ▁after Api Id ▁= ▁- ▁1 ▁; ▁after Args ▁= ▁null ▁; ▁result ▁= ▁null ▁; ▁throwable ▁= ▁null ▁; ▁} ▁@ ▁Override ▁public ▁void ▁before ▁( ▁Object ▁target ▁, ▁int ▁api Id ▁, ▁Object ▁[ ▁] ▁args ▁) ▁{ ▁this ▁. ▁before ▁= ▁true ▁; ▁this ▁. ▁before Target ▁= ▁target ▁; ▁this ▁. ▁before Api Id ▁= ▁api Id ▁; ▁this ▁. ▁before Args ▁= ▁args ▁; ▁} ▁@ ▁Override ▁public ▁void ▁after ▁( ▁Object ▁target ▁, ▁int ▁api Id ▁, ▁Object ▁[ ▁] ▁args ▁, ▁Object ▁result ▁, ▁Throwable ▁throwable ▁) ▁{ ▁this ▁. ▁after ▁= ▁true ▁; ▁this ▁. ▁after Target ▁= ▁target ▁; ▁this ▁. ▁after Api Id ▁= ▁api Id ▁; ▁this ▁. ▁after Args ▁= ▁args ▁; ▁this ▁. ▁result ▁= ▁result ▁; ▁this ▁. ▁throwable ▁= ▁throwable ▁; ▁} ▁private ▁String ▁to Args ▁( ▁Object ▁[ ▁] ▁args ▁) ▁{ ▁if ▁( ▁args ▁== ▁null ▁) ▁{ ▁return ▁STR ▁; ▁} ▁return ▁Arrays ▁. ▁asList ▁( ▁args ▁) ▁. ▁toString ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁Union Editor Actions 2 Test ▁extends ▁Abstract Union Editor Test ▁{ ▁@ ▁Test ▁public ▁void ▁test Cycle Group On Component ▁( ▁) ▁throws ▁Exception ▁{ ▁init ▁( ▁simple Union ▁, ▁pg m B b C at ▁, ▁false ▁) ▁; ▁get Actions ▁( ▁) ▁; ▁Number Input Dialog ▁dialog ▁; ▁DataType ▁dt 1 ▁= ▁getDataType ▁( ▁1 ▁) ▁; ▁DataType ▁dt 3 ▁= ▁getDataType ▁( ▁3 ▁) ▁; ▁int ▁num ▁= ▁model ▁. ▁getNum Components ▁( ▁) ▁; ▁setSelection ▁( ▁new ▁int ▁[ ▁] ▁{ ▁2 ▁} ▁) ▁; ▁Cycle Group Action ▁action ▁= ▁getC ycle Group ▁( ▁new ▁Char DataType ▁( ▁) ▁) ▁; ▁invoke ▁( ▁action ▁) ▁; ▁assertEquals ▁( ▁num ▁, ▁model ▁. ▁getNum Components ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁getLength ▁( ▁2 ▁) ▁) ▁; ▁check Selection ▁( ▁new ▁int ▁[ ▁] ▁{ ▁2 ▁} ▁) ▁; ▁assertEquals ▁( ▁getDataType ▁( ▁1 ▁) ▁, ▁dt 1 ▁) ▁; ▁assertTrue ▁( ▁getDataType ▁( ▁2 ▁) ▁. ▁isE quivalent ▁( ▁new ▁Char DataType ▁( ▁) ▁) ▁) ▁; ▁assertEquals ▁( ▁getDataType ▁( ▁3 ▁) ▁, ▁dt 3 ▁) ▁; ▁invoke ▁( ▁action ▁, ▁false ▁) ▁; ▁dialog ▁= ▁waitFor Dialog Component ▁( ▁Number Input Dialog ▁. ▁class ▁) ▁; ▁assertNotNull ▁( ▁dialog ▁) ▁; ▁ok Input ▁( ▁dialog ▁, ▁7 ▁) ▁; ▁dialog ▁= ▁null ▁; ▁waitUntil Dialog Provider G one ▁( ▁Number Input Dialog ▁. ▁class ▁, ▁2000 ▁) ▁; ▁assertEquals ▁( ▁num ▁, ▁model ▁. ▁getNum Components ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁7 ▁, ▁getLength ▁( ▁2 ▁) ▁) ▁; ▁check Selection ▁( ▁new ▁int ▁[ ▁] ▁{ ▁2 ▁} ▁) ▁; ▁assertEquals ▁( ▁getDataType ▁( ▁1 ▁) ▁, ▁dt 1 ▁) ▁; ▁assertTrue ▁( ▁getDataType ▁( ▁2 ▁) ▁. ▁isE quivalent ▁( ▁new ▁String DataType ▁( ▁) ▁) ▁) ▁; ▁assertEquals ▁( ▁getDataType ▁( ▁3 ▁) ▁, ▁dt 3 ▁) ▁; ▁invoke ▁( ▁action ▁, ▁false ▁) ▁; ▁dialog ▁= ▁waitFor Dialog Component ▁( ▁Number Input Dialog ▁. ▁class ▁) ▁; ▁assertNotNull ▁( ▁dialog ▁) ▁; ▁ok Input ▁( ▁dialog ▁, ▁10 ▁) ▁; ▁dialog ▁= ▁null ▁; ▁waitUntil Dialog Provider G one ▁( ▁Number Input Dialog ▁. ▁class ▁, ▁2000 ▁) ▁; ▁assertEquals ▁( ▁num ▁, ▁model ▁. ▁getNum Components ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁10 ▁, ▁getLength ▁( ▁2 ▁) ▁) ▁; ▁check Selection ▁( ▁new ▁int ▁[ ▁] ▁{ ▁2 ▁} ▁) ▁; ▁assertEquals ▁( ▁getDataType ▁( ▁1 ▁) ▁, ▁dt 1 ▁) ▁; ▁assertTrue ▁( ▁getDataType ▁( ▁2 ▁) ▁. ▁isE quivalent ▁( ▁new ▁Unicode DataType ▁( ▁) ▁) ▁) ▁; ▁assertEquals ▁( ▁getDataType ▁( ▁3 ▁) ▁, ▁dt 3 ▁) ▁; ▁invoke ▁( ▁action ▁) ▁; ▁assertEquals ▁( ▁num ▁, ▁model ▁. ▁getNum Components ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁getLength ▁( ▁2 ▁) ▁) ▁; ▁check Selection ▁( ▁new ▁int ▁[ ▁] ▁{ ▁2 ▁} ▁) ▁; ▁assertEquals ▁( ▁getDataType ▁( ▁1 ▁) ▁, ▁dt 1 ▁) ▁; ▁assertTrue ▁( ▁getDataType ▁( ▁2 ▁) ▁. ▁isE quivalent ▁( ▁new ▁Char DataType ▁( ▁) ▁) ▁) ▁;
▁while ▁( ▁it ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁result ▁. ▁add ▁( ▁it ▁. ▁next ▁( ▁) ▁) ▁; ▁} ▁return ▁result ▁; ▁} ▁protected ▁< ▁T ▁> ▁List ▁< ▁T ▁> ▁list ▁( ▁Iterable ▁< ▁T ▁> ▁col ▁) ▁{ ▁List ▁< ▁T ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁T ▁t ▁: ▁col ▁) ▁{ ▁result ▁. ▁add ▁( ▁t ▁) ▁; ▁} ▁return ▁result ▁; ▁} ▁@ ▁Safe Varargs ▁protected ▁static ▁< ▁T ▁> ▁List ▁< ▁T ▁> ▁list ▁( ▁T ▁... ▁args ▁) ▁{ ▁return ▁Arrays ▁. ▁asList ▁( ▁args ▁) ▁; ▁} ▁protected ▁List ▁< ▁Address ▁> ▁addrs ▁( ▁long ▁... ▁offsets ▁) ▁{ ▁List ▁< ▁Address ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁offsets ▁. ▁length ▁) ▁; ▁for ▁( ▁long ▁off ▁: ▁offsets ▁) ▁{ ▁result ▁. ▁add ▁( ▁addr ▁( ▁off ▁) ▁) ▁; ▁} ▁return ▁result ▁; ▁} ▁protected ▁DBTrace AddressSnapRange PropertyMap O c clusion Into P ast Iterable ▁< ▁String ▁> ▁make O c clusion Iterable ▁( ▁Trace AddressSnapRange ▁t as r ▁) ▁{ ▁return ▁new ▁DBTrace AddressSnapRange PropertyMap O c clusion Into P ast Iterable ▁< ▁> ▁( ▁space ▁, ▁t as r ▁) ▁; ▁} ▁@ ▁Before ▁public ▁void ▁setUp ▁( ▁) ▁throws ▁IOException ▁, ▁Version Exception ▁{ ▁to y ▁= ▁Default Language Service ▁. ▁getLanguage Service ▁( ▁) ▁. ▁getLanguage ▁( ▁new ▁Language ID ▁( ▁STR ▁) ▁) ▁; ▁obj ▁= ▁new ▁My Object ▁( ▁this ▁) ▁; ▁factory ▁= ▁new ▁DBC ached Object Store Factory ▁( ▁obj ▁) ▁; ▁try ▁( ▁Undo able Transaction ▁tid ▁= ▁Undo able Transaction ▁. ▁start ▁( ▁obj ▁, ▁STR ▁, ▁true ▁) ▁) ▁{ ▁space ▁= ▁new ▁DBTrace AddressSnapRange PropertyMap Space ▁< ▁> ▁( ▁STR ▁, ▁factory ▁, ▁obj ▁. ▁getRead WriteLock ▁( ▁) ▁, ▁to y ▁. ▁getDefault Space ▁( ▁) ▁, ▁My Entry ▁. ▁class ▁, ▁My Entry ▁:: ▁new ▁) ▁; ▁} ▁} ▁@ ▁After ▁public ▁void ▁tearDown ▁( ▁) ▁{ ▁obj ▁. ▁release ▁( ▁this ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testEmpty ▁( ▁) ▁{ ▁DBTrace AddressSnapRange PropertyMap O c clusion Into P ast Iterable ▁< ▁String ▁> ▁it ▁= ▁make O c clusion Iterable ▁( ▁t as r ▁( ▁0 x 0000 ▁, ▁0 xffff ▁, ▁0 ▁, ▁100 ▁) ▁) ▁; ▁assertFalse ▁( ▁it ▁. ▁iterator ▁( ▁) ▁. ▁hasNext ▁( ▁) ▁) ▁; ▁try ▁{ ▁it ▁. ▁iterator ▁( ▁) ▁. ▁peek ▁( ▁) ▁; ▁fail ▁( ▁) ▁; ▁} ▁catch ▁( ▁NoSuch ElementException ▁e ▁) ▁{ ▁} ▁assertNull ▁( ▁it ▁. ▁iterator ▁( ▁) ▁. ▁next ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test OutOf Window ▁( ▁) ▁{ ▁DBTrace AddressSnapRange PropertyMap O c clusion Into P ast Iterable ▁< ▁String ▁> ▁it ▁; ▁try ▁( ▁Undo able Transaction ▁tid ▁= ▁Undo able Transaction ▁. ▁start ▁( ▁obj ▁, ▁STR ▁, ▁true ▁) ▁) ▁{ ▁space ▁. ▁put ▁( ▁t as r ▁( ▁0 x 1000 ▁, ▁0 x 1 fff ▁, ▁5 ▁, ▁10 ▁) ▁, ▁STR ▁) ▁; ▁}
▁public ▁class ▁MySqlSelectTest _13 ▁extends ▁MysqlTest ▁{ ▁public ▁void ▁test _0 ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁MySql StatementParser ▁parser ▁= ▁new ▁MySql StatementParser ▁( ▁sql ▁) ▁; ▁List ▁< ▁SQLStatement ▁> ▁statementList ▁= ▁parser ▁. ▁parseStatement List ▁( ▁) ▁; ▁SQLStatement ▁stmt ▁= ▁statementList ▁. ▁get ▁( ▁0 ▁) ▁; ▁SQLSelect Statement ▁select Stmt ▁= ▁( ▁SQLSelect Statement ▁) ▁stmt ▁; ▁SQLSelect ▁select ▁= ▁select Stmt ▁. ▁getSelect ▁( ▁) ▁; ▁Assert ▁. ▁assertNotNull ▁( ▁select ▁. ▁getQuery ▁( ▁) ▁) ▁; ▁MySql Select QueryBlock ▁queryBlock ▁= ▁( ▁MySql Select QueryBlock ▁) ▁select ▁. ▁getQuery ▁( ▁) ▁; ▁Assert ▁. ▁assertNull ▁( ▁queryBlock ▁. ▁getOrderBy ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁1 ▁, ▁statementList ▁. ▁size ▁( ▁) ▁) ▁; ▁MySqlSchema StatVisitor ▁visitor ▁= ▁new ▁MySqlSchema StatVisitor ▁( ▁) ▁; ▁stmt ▁. ▁accept ▁( ▁visitor ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁1 ▁, ▁visitor ▁. ▁getTables ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁1 ▁, ▁visitor ▁. ▁getColumns ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁0 ▁, ▁visitor ▁. ▁getConditions ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁0 ▁, ▁visitor ▁. ▁getOrderBy Columns ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁visitor ▁. ▁getTables ▁( ▁) ▁. ▁containsKey ▁( ▁new ▁TableStat ▁. ▁Name ▁( ▁STR ▁) ▁) ▁) ▁; ▁String ▁output ▁= ▁SQLUtils ▁. ▁toMySqlString ▁( ▁stmt ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁+ ▁STR ▁, ▁output ▁) ▁; ▁} ▁}
▁public ▁class ▁Annotation ▁{ ▁private ▁static ▁final ▁Pattern ▁ QU OT ATION _ PATTERN ▁= ▁Pattern ▁. ▁compile ▁( ▁STR ▁) ▁; ▁private ▁static ▁Map ▁< ▁String ▁, ▁Annotated String Handler ▁> ▁AN NOT ATED _ STRING _ MAP ▁; ▁private ▁String ▁annotation Text ▁; ▁private ▁String ▁[ ▁] ▁annotation Parts ▁; ▁private ▁Annotated String Handler ▁annotated String Handler ▁; ▁private ▁Attributed String ▁display String ▁; ▁private ▁static ▁Map ▁< ▁String ▁, ▁Annotated String Handler ▁> ▁get Annotated String Handler Map ▁( ▁) ▁{ ▁if ▁( ▁AN NOT ATED _ STRING _ MAP ▁== ▁null ▁) ▁{ ▁AN NOT ATED _ STRING _ MAP ▁= ▁create Annotated String Handler Map ▁( ▁) ▁; ▁} ▁return ▁AN NOT ATED _ STRING _ MAP ▁; ▁} ▁private ▁static ▁Map ▁< ▁String ▁, ▁Annotated String Handler ▁> ▁create Annotated String Handler Map ▁( ▁) ▁{ ▁Map ▁< ▁String ▁, ▁Annotated String Handler ▁> ▁map ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁List ▁< ▁Annotated String Handler ▁> ▁instances ▁= ▁Class Searcher ▁. ▁getInstances ▁( ▁Annotated String Handler ▁. ▁class ▁) ▁; ▁for ▁( ▁Annotated String Handler ▁instance ▁: ▁instances ▁) ▁{ ▁String ▁[ ▁] ▁supported Annotations ▁= ▁instance ▁. ▁getSupported Annotations ▁( ▁) ▁; ▁for ▁( ▁String ▁supported Annotation ▁: ▁supported Annotations ▁) ▁{ ▁map ▁. ▁put ▁( ▁supported Annotation ▁, ▁instance ▁) ▁; ▁} ▁} ▁return ▁Collections ▁. ▁unmodifiableMap ▁( ▁map ▁) ▁; ▁} ▁public ▁Annotation ▁( ▁String ▁annotation Text ▁, ▁Attributed String ▁prototype String ▁, ▁Program ▁program ▁) ▁{ ▁this ▁. ▁annotation Text ▁= ▁annotation Text ▁; ▁annotation Parts ▁= ▁parse Annotation Text ▁( ▁annotation Text ▁) ▁; ▁annotated String Handler ▁= ▁getHandler ▁( ▁annotation Parts ▁) ▁; ▁try ▁{ ▁display String ▁= ▁annotated String Handler ▁. ▁create Annotated String ▁( ▁prototype String ▁, ▁annotation Parts ▁, ▁program ▁) ▁; ▁} ▁catch ▁( ▁Annotation Exception ▁a e ▁) ▁{ ▁annotated String Handler ▁= ▁new ▁Invalid Annotated String Handler ▁( ▁STR ▁+ ▁a e ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁display String ▁= ▁annotated String Handler ▁. ▁create Annotated String ▁( ▁prototype String ▁, ▁annotation Parts ▁, ▁program ▁) ▁; ▁} ▁} ▁private ▁Annotated String Handler ▁getHandler ▁( ▁String ▁[ ▁] ▁annotation P iece s ▁) ▁{ ▁if ▁( ▁annotation P iece s ▁. ▁length ▁<= ▁1 ▁) ▁{ ▁return ▁new ▁Invalid Annotated String Handler ▁( ▁STR ▁+ ▁STR ▁) ▁; ▁} ▁String ▁keyword ▁= ▁annotation P iece s ▁[ ▁0 ▁] ▁; ▁Annotated String Handler ▁handler ▁= ▁get Annotated String Handler Map ▁( ▁) ▁. ▁get ▁( ▁keyword ▁) ▁; ▁if ▁( ▁handler ▁== ▁null ▁) ▁{ ▁return ▁new ▁Invalid Annotated String Handler ▁( ▁STR ▁+ ▁keyword ▁) ▁; ▁} ▁return ▁handler ▁; ▁} ▁String ▁[ ▁] ▁getAnnotation Parts ▁( ▁) ▁{ ▁return ▁annotation Parts ▁; ▁} ▁Annotated String Handler ▁getHandler ▁( ▁) ▁{ ▁return ▁annotated String Handler ▁; ▁} ▁public ▁Attributed String ▁getDisplay String ▁( ▁) ▁{ ▁return ▁display String ▁; ▁}
▁public ▁static ▁_ Fields ▁findBy Thrift Id OrThrow ▁( ▁int ▁field Id ▁) ▁{ ▁_ Fields ▁fields ▁= ▁findBy Thrift Id ▁( ▁field Id ▁) ▁; ▁if ▁( ▁fields ▁== ▁null ▁) ▁throw ▁new ▁java ▁. ▁lang ▁. ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁field Id ▁+ ▁STR ▁) ▁; ▁return ▁fields ▁; ▁} ▁public ▁static ▁_ Fields ▁findByName ▁( ▁java ▁. ▁lang ▁. ▁String ▁name ▁) ▁{ ▁return ▁byName ▁. ▁get ▁( ▁name ▁) ▁; ▁} ▁private ▁final ▁short ▁_ th rift Id ▁; ▁private ▁final ▁java ▁. ▁lang ▁. ▁String ▁_ field Name ▁; ▁_ Fields ▁( ▁short ▁thrift Id ▁, ▁java ▁. ▁lang ▁. ▁String ▁fieldName ▁) ▁{ ▁_ th rift Id ▁= ▁thrift Id ▁; ▁_ field Name ▁= ▁fieldName ▁; ▁} ▁public ▁short ▁get Thrift Field Id ▁( ▁) ▁{ ▁return ▁_ th rift Id ▁; ▁} ▁public ▁java ▁. ▁lang ▁. ▁String ▁getFieldName ▁( ▁) ▁{ ▁return ▁_ field Name ▁; ▁} ▁} ▁private ▁static ▁final ▁int ▁__ DE AD LOCK ED THREAD COUNT _ IS SET _ ID ▁= ▁0 ▁; ▁private ▁byte ▁__ iss et _ bit field ▁= ▁0 ▁; ▁private ▁static ▁final ▁_ Fields ▁optional s ▁[ ▁] ▁= ▁{ ▁_ Fields ▁. ▁DE AD LOCK ED _ THREAD _ COUNT ▁, ▁_ Fields ▁. ▁DE AD LOCK ED _ THREAD _ LIST ▁} ▁; ▁public ▁static ▁final ▁java ▁. ▁util ▁. ▁Map ▁< ▁_ Fields ▁, ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁meta _ data ▁. ▁Field MetaData ▁> ▁metaData Map ▁; ▁static ▁{ ▁java ▁. ▁util ▁. ▁Map ▁< ▁_ Fields ▁, ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁meta _ data ▁. ▁Field MetaData ▁> ▁tmp Map ▁= ▁new ▁java ▁. ▁util ▁. ▁EnumMap ▁< ▁_ Fields ▁, ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁meta _ data ▁. ▁Field MetaData ▁> ▁( ▁_ Fields ▁. ▁class ▁) ▁; ▁tmp Map ▁. ▁put ▁( ▁_ Fields ▁. ▁DE AD LOCK ED _ THREAD _ COUNT ▁, ▁new ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁meta _ data ▁. ▁Field MetaData ▁( ▁STR ▁, ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁T Field Requirement Type ▁. ▁OPTION AL ▁, ▁new ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁meta _ data ▁. ▁FieldValue MetaData ▁( ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁protocol ▁. ▁T Type ▁. ▁I 32 ▁) ▁) ▁) ▁;
▁final ▁InputStream ▁target Stream ▁= ▁new ▁ByteArray InputStream ▁( ▁Char Streams ▁. ▁toString ▁( ▁initial Reader ▁) ▁. ▁getBytes ▁( ▁Char sets ▁. ▁UTF _8 ▁) ▁) ▁; ▁initial Reader ▁. ▁close ▁( ▁) ▁; ▁target Stream ▁. ▁close ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁given Using Commons IO _ when Conver ting Reader Into InputStream With Encoding ▁( ▁) ▁throws ▁IOException ▁{ ▁final ▁Reader ▁initial Reader ▁= ▁new ▁StringReader ▁( ▁STR ▁) ▁; ▁final ▁InputStream ▁target Stream ▁= ▁IOUtils ▁. ▁to InputStream ▁( ▁IOUtils ▁. ▁toString ▁( ▁initial Reader ▁) ▁, ▁Char sets ▁. ▁UTF _8 ▁) ▁; ▁initial Reader ▁. ▁close ▁( ▁) ▁; ▁target Stream ▁. ▁close ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁given Using Commons IO _ when Conver ting Reader Into InputStream With Encoding _ thenCorrect ▁( ▁) ▁throws ▁IOException ▁{ ▁String ▁initial String ▁= ▁STR ▁; ▁final ▁Reader ▁initial Reader ▁= ▁new ▁StringReader ▁( ▁initial String ▁) ▁; ▁final ▁InputStream ▁target Stream ▁= ▁IOUtils ▁. ▁to InputStream ▁( ▁IOUtils ▁. ▁toString ▁( ▁initial Reader ▁) ▁, ▁Char sets ▁. ▁UTF _8 ▁) ▁; ▁String ▁final String ▁= ▁IOUtils ▁. ▁toString ▁( ▁target Stream ▁, ▁Char sets ▁. ▁UTF _8 ▁) ▁; ▁assertThat ▁( ▁final String ▁, ▁equalTo ▁( ▁initial String ▁) ▁) ▁; ▁initial Reader ▁. ▁close ▁( ▁) ▁; ▁target Stream ▁. ▁close ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁Exception Translator ▁extends ▁Default Execute Listener ▁{ ▁@ ▁Override ▁public ▁void ▁exception ▁( ▁Execute Context ▁context ▁) ▁{ ▁SQL Dialect ▁dialect ▁= ▁context ▁. ▁configuration ▁( ▁) ▁. ▁dialect ▁( ▁) ▁; ▁SQLException Translator ▁translator ▁= ▁new ▁SQL ErrorCode SQL Exception Translator ▁( ▁dialect ▁. ▁third Part y ▁( ▁) ▁. ▁spring Db Name ▁( ▁) ▁) ▁; ▁context ▁. ▁exception ▁( ▁translator ▁. ▁translate ▁( ▁STR ▁, ▁context ▁. ▁sql ▁( ▁) ▁, ▁context ▁. ▁sql Exception ▁( ▁) ▁) ▁) ▁; ▁} ▁}
▁@ ▁Public ▁public ▁class ▁Tuple 24 ▁< ▁T 0 ▁, ▁T 1 ▁, ▁T 2 ▁, ▁T 3 ▁, ▁T 4 ▁, ▁T 5 ▁, ▁T 6 ▁, ▁T 7 ▁, ▁T 8 ▁, ▁T 9 ▁, ▁T 10 ▁, ▁T 11 ▁, ▁T 12 ▁, ▁T 13 ▁, ▁T 14 ▁, ▁T 15 ▁, ▁T 16 ▁, ▁T 17 ▁, ▁T 18 ▁, ▁T 19 ▁, ▁T 20 ▁, ▁T 21 ▁, ▁T 22 ▁, ▁T 23 ▁> ▁extends ▁Tuple ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁public ▁T 0 ▁f 0 ▁; ▁public ▁T 1 ▁f 1 ▁; ▁public ▁T 2 ▁f 2 ▁; ▁public ▁T 3 ▁f 3 ▁; ▁public ▁T 4 ▁f 4 ▁; ▁public ▁T 5 ▁f 5 ▁; ▁public ▁T 6 ▁f 6 ▁; ▁public ▁T 7 ▁f 7 ▁; ▁public ▁T 8 ▁f 8 ▁; ▁public ▁T 9 ▁f 9 ▁; ▁public ▁T 10 ▁f 10 ▁; ▁public ▁T 11 ▁f 11 ▁; ▁public ▁T 12 ▁f 12 ▁; ▁public ▁T 13 ▁f 13 ▁; ▁public ▁T 14 ▁f 14 ▁; ▁public ▁T 15 ▁f 15 ▁; ▁public ▁T 16 ▁f 16 ▁; ▁public ▁T 17 ▁f 17 ▁; ▁public ▁T 18 ▁f 18 ▁; ▁public ▁T 19 ▁f 19 ▁; ▁public ▁T 20 ▁f 20 ▁; ▁public ▁T 21 ▁f 21 ▁; ▁public ▁T 22 ▁f 22 ▁; ▁public ▁T 23 ▁f 23 ▁; ▁public ▁Tuple 24 ▁( ▁) ▁{ ▁} ▁public ▁Tuple 24 ▁( ▁T 0 ▁f 0 ▁, ▁T 1 ▁f 1 ▁, ▁T 2 ▁f 2 ▁, ▁T 3 ▁f 3 ▁, ▁T 4 ▁f 4 ▁, ▁T 5 ▁f 5 ▁, ▁T 6 ▁f 6 ▁, ▁T 7 ▁f 7 ▁, ▁T 8 ▁f 8 ▁, ▁T 9 ▁f 9 ▁, ▁T 10 ▁f 10 ▁, ▁T 11 ▁f 11 ▁, ▁T 12 ▁f 12 ▁, ▁T 13 ▁f 13 ▁, ▁T 14 ▁f 14 ▁, ▁T 15 ▁f 15 ▁, ▁T 16 ▁f 16 ▁, ▁T 17 ▁f 17 ▁, ▁T 18 ▁f 18 ▁, ▁T 19 ▁f 19 ▁, ▁T 20 ▁f 20 ▁, ▁T 21 ▁f 21 ▁, ▁T 22 ▁f 22 ▁, ▁T 23 ▁f 23 ▁) ▁{ ▁this ▁. ▁f 0 ▁= ▁f 0 ▁; ▁this ▁. ▁f 1 ▁= ▁f 1 ▁; ▁this ▁. ▁f 2 ▁= ▁f 2 ▁; ▁this ▁. ▁f 3 ▁= ▁f 3 ▁; ▁this ▁. ▁f 4 ▁= ▁f 4 ▁; ▁this ▁. ▁f 5 ▁= ▁f 5 ▁; ▁this ▁. ▁f 6 ▁= ▁f 6 ▁; ▁this ▁. ▁f 7 ▁= ▁f 7 ▁; ▁this ▁. ▁f 8 ▁= ▁f 8 ▁; ▁this ▁. ▁f 9 ▁= ▁f 9 ▁; ▁this ▁. ▁f 10 ▁= ▁f 10 ▁; ▁this ▁. ▁f 11 ▁= ▁f 11 ▁; ▁this ▁. ▁f 12 ▁= ▁f 12 ▁; ▁this ▁. ▁f 13 ▁= ▁f 13 ▁; ▁this ▁. ▁f 14 ▁= ▁f 14 ▁; ▁this ▁. ▁f 15 ▁= ▁f 15 ▁; ▁this ▁. ▁f 16 ▁= ▁f 16 ▁;
▁private ▁boolean ▁ignore Action While Menu Show ing ▁( ▁) ▁{ ▁if ▁( ▁getKey Binding Pre ced ence ▁( ▁) ▁== ▁Key Binding Pre ced ence ▁. ▁Reser ved Actions Level ▁) ▁{ ▁return ▁false ▁; ▁} ▁Menu Selection Manager ▁menu Manager ▁= ▁Menu Selection Manager ▁. ▁default Manager ▁( ▁) ▁; ▁return ▁menu Manager ▁. ▁getSelected Path ▁( ▁) ▁. ▁length ▁!= ▁0 ▁; ▁} ▁private ▁List ▁< ▁Executable Action ▁> ▁get Valid Context Actions ▁( ▁ActionContext ▁local Context ▁, ▁ActionContext ▁global Context ▁) ▁{ ▁List ▁< ▁Executable Action ▁> ▁list ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁boolean ▁has Local Actions For Key Binding ▁= ▁false ▁; ▁for ▁( ▁Action Data ▁action Data ▁: ▁actions ▁) ▁{ ▁if ▁( ▁action Data ▁. ▁is My Provider ▁( ▁local Context ▁) ▁) ▁{ ▁has Local Actions For Key Binding ▁= ▁true ▁; ▁if ▁( ▁isValid And Enabled ▁( ▁action Data ▁, ▁local Context ▁) ▁) ▁{ ▁list ▁. ▁add ▁( ▁new ▁Executable Action ▁( ▁action Data ▁. ▁action ▁, ▁local Context ▁) ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁has Local Actions For Key Binding ▁) ▁{ ▁return ▁list ▁; ▁} ▁for ▁( ▁Action Data ▁action Data ▁: ▁actions ▁) ▁{ ▁if ▁( ▁! ▁( ▁action Data ▁. ▁action ▁instanceof ▁Component Based D ock ingAction ▁) ▁) ▁{ ▁continue ▁; ▁} ▁Component Based D ock ingAction ▁component Action ▁= ▁( ▁Component Based D ock ingAction ▁) ▁action Data ▁. ▁action ▁; ▁if ▁( ▁component Action ▁. ▁isValid Component Context ▁( ▁local Context ▁) ▁) ▁{ ▁has Local Actions For Key Binding ▁= ▁true ▁; ▁if ▁( ▁isValid And Enabled ▁( ▁action Data ▁, ▁local Context ▁) ▁) ▁{ ▁list ▁. ▁add ▁( ▁new ▁Executable Action ▁( ▁action Data ▁. ▁action ▁, ▁local Context ▁) ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁has Local Actions For Key Binding ▁) ▁{ ▁return ▁list ▁; ▁} ▁for ▁( ▁Action Data ▁action Data ▁: ▁actions ▁) ▁{ ▁if ▁( ▁action Data ▁. ▁is Global Action ▁( ▁) ▁) ▁{ ▁if ▁( ▁isValid And Enabled ▁( ▁action Data ▁, ▁local Context ▁) ▁) ▁{ ▁list ▁. ▁add ▁( ▁new ▁Executable Action ▁( ▁action Data ▁. ▁action ▁, ▁local Context ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁isValid And Enabled Glob ally ▁( ▁action Data ▁, ▁global Context ▁) ▁) ▁{ ▁list ▁. ▁add ▁( ▁new ▁Executable Action ▁( ▁action Data ▁. ▁action ▁, ▁global Context ▁) ▁) ▁; ▁} ▁} ▁} ▁return ▁list ▁; ▁} ▁private ▁boolean ▁isValid And Enabled ▁( ▁Action Data ▁action Data ▁, ▁ActionContext ▁context ▁) ▁{ ▁DockingActionIf ▁a ▁= ▁action Data ▁. ▁action ▁; ▁return ▁a ▁. ▁isValid Context ▁( ▁context ▁) ▁&& ▁a ▁. ▁isEnabledFor Context ▁( ▁context ▁) ▁; ▁} ▁private ▁boolean ▁isValid And Enabled Glob ally ▁( ▁Action Data ▁action Data ▁, ▁ActionContext ▁context ▁) ▁{ ▁if ▁( ▁context ▁== ▁null ▁) ▁{ ▁return ▁false ▁; ▁} ▁return ▁action Data ▁. ▁supports Default Tool Context ▁( ▁) ▁&& ▁isValid And Enabled ▁( ▁action Data ▁, ▁context ▁) ▁; ▁}
▁} ▁private ▁void ▁en l arge By ▁( ▁Consumer ▁< ▁WebDriver ▁. ▁Window ▁> ▁operation ▁) ▁{ ▁WebDriver ▁. ▁Window ▁window ▁= ▁driver ▁. ▁man age ▁( ▁) ▁. ▁window ▁( ▁) ▁; ▁Dimension ▁size ▁= ▁window ▁. ▁getSize ▁( ▁) ▁; ▁operation ▁. ▁accept ▁( ▁window ▁) ▁; ▁wait ▁. ▁until ▁( ▁ $ ▁-> ▁window ▁. ▁getSize ▁( ▁) ▁. ▁width ▁> ▁size ▁. ▁width ▁) ▁; ▁wait ▁. ▁until ▁( ▁ $ ▁-> ▁window ▁. ▁getSize ▁( ▁) ▁. ▁height ▁> ▁size ▁. ▁height ▁) ▁; ▁} ▁private ▁Expected Condition ▁< ▁Boolean ▁> ▁windowSize Equal ▁( ▁final ▁Dimension ▁size ▁) ▁{ ▁return ▁driver ▁-> ▁{ ▁Dimension ▁new Size ▁= ▁driver ▁. ▁man age ▁( ▁) ▁. ▁window ▁( ▁) ▁. ▁getSize ▁( ▁) ▁; ▁return ▁new Size ▁. ▁height ▁== ▁size ▁. ▁height ▁&& ▁new Size ▁. ▁width ▁== ▁size ▁. ▁width ▁; ▁} ▁; ▁} ▁}
▁public ▁class ▁Fi x up No Return Functions No Rep air Script ▁extends ▁Fi x up No Return Functions Script ▁{ ▁@ ▁Override ▁void ▁rep air D am age ▁( ▁Program ▁cp ▁, ▁Function ▁func ▁, ▁Address ▁entry ▁) ▁{ ▁func ▁. ▁set No Return ▁( ▁true ▁) ▁; ▁try ▁{ ▁String ▁name ▁= ▁func ▁. ▁getName ▁( ▁) ▁; ▁entry List ▁. ▁setMessage ▁( ▁STR ▁+ ▁name ▁) ▁; ▁set No F all Th ru ▁( ▁cp ▁, ▁entry ▁) ▁; ▁entry List ▁. ▁setMessage ▁( ▁STR ▁+ ▁name ▁) ▁; ▁fix Calling Function Body ▁( ▁cp ▁, ▁entry ▁) ▁; ▁} ▁catch ▁( ▁Cancelled Exception ▁e ▁) ▁{ ▁} ▁} ▁}
▁@ ▁Internal ▁public ▁final ▁class ▁Tuple Un wr apping Joiner ▁< ▁I 1 ▁, ▁I 2 ▁, ▁OUT ▁, ▁K ▁> ▁extends ▁Wrapping Function ▁< ▁Flat Join Function ▁< ▁I 1 ▁, ▁I 2 ▁, ▁OUT ▁> ▁> ▁implements ▁Flat Join Function ▁< ▁Tuple 2 ▁< ▁K ▁, ▁I 1 ▁> ▁, ▁Tuple 2 ▁< ▁K ▁, ▁I 2 ▁> ▁, ▁OUT ▁> ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁public ▁Tuple Un wr apping Joiner ▁( ▁Flat Join Function ▁< ▁I 1 ▁, ▁I 2 ▁, ▁OUT ▁> ▁wrapped ▁) ▁{ ▁super ▁( ▁wrapped ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁join ▁( ▁Tuple 2 ▁< ▁K ▁, ▁I 1 ▁> ▁value 1 ▁, ▁Tuple 2 ▁< ▁K ▁, ▁I 2 ▁> ▁value 2 ▁, ▁Collector ▁< ▁OUT ▁> ▁collector ▁) ▁throws ▁Exception ▁{ ▁wrapped Function ▁. ▁join ▁( ▁unwrap ▁( ▁value 1 ▁) ▁, ▁unwrap ▁( ▁value 2 ▁) ▁, ▁collector ▁) ▁; ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁private ▁< ▁V ▁> ▁V ▁unwrap ▁( ▁Tuple 2 ▁< ▁K ▁, ▁V ▁> ▁t ▁) ▁{ ▁return ▁t ▁== ▁null ▁? ▁null ▁: ▁( ▁V ▁) ▁( ▁t ▁. ▁getField ▁( ▁1 ▁) ▁) ▁; ▁} ▁}
▁@ ▁RunWith ▁( ▁Parameterized ▁. ▁class ▁) ▁public ▁class ▁Statement Test ▁{ ▁private ▁static ▁final ▁TestUtil ▁. ▁Collect ing Matcher ▁< ▁Test Run ▁> ▁TEST _ RESULT _ MATCH ER ▁= ▁TestUtil ▁. ▁create Too Many Failures Matcher ▁( ▁) ▁; ▁private ▁static ▁TestContext ▁context ▁; ▁private ▁final ▁Test Run ▁testRun ▁; ▁@ ▁Parameterized ▁. ▁Parameters ▁( ▁name ▁= ▁STR ▁) ▁public ▁static ▁Collection ▁< ▁? ▁extends ▁Test Run ▁> ▁createControl Flow Tests ▁( ▁) ▁{ ▁context ▁= ▁new ▁TestContext ▁( ▁Statement Test ▁. ▁class ▁) ▁; ▁final ▁Collection ▁< ▁? ▁extends ▁Test Run ▁> ▁test Runs ▁= ▁TestUtil ▁. ▁createTest Runs ▁( ▁TestUtil ▁. ▁getRequired L anguages ▁( ▁context ▁) ▁, ▁TestUtil ▁. ▁getRequired Value L anguages ▁( ▁context ▁) ▁, ▁new ▁Function ▁< ▁String ▁, ▁Collection ▁< ▁? ▁extends ▁Snippet ▁> ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Collection ▁< ▁? ▁extends ▁Snippet ▁> ▁apply ▁( ▁String ▁lang ▁) ▁{ ▁return ▁context ▁. ▁getStatement s ▁( ▁null ▁, ▁null ▁, ▁lang ▁) ▁; ▁} ▁} ▁, ▁new ▁Function ▁< ▁String ▁, ▁Collection ▁< ▁? ▁extends ▁Snippet ▁> ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Collection ▁< ▁? ▁extends ▁Snippet ▁> ▁apply ▁( ▁String ▁lang ▁) ▁{ ▁return ▁context ▁. ▁getValue Constructors ▁( ▁null ▁, ▁lang ▁) ▁; ▁} ▁} ▁) ▁; ▁return ▁test Runs ▁; ▁} ▁@ ▁BeforeClass ▁public ▁static ▁void ▁setUp Class ▁( ▁) ▁{ ▁TestUtil ▁. ▁assertNo Current Context ▁( ▁) ▁; ▁} ▁@ ▁AfterClass ▁public ▁static ▁void ▁after Class ▁( ▁) ▁throws ▁IOException ▁{ ▁context ▁. ▁close ▁( ▁) ▁; ▁context ▁= ▁null ▁; ▁} ▁public ▁Statement Test ▁( ▁final ▁Test Run ▁testRun ▁) ▁{ ▁Objects ▁. ▁requireNonNull ▁( ▁testRun ▁) ▁; ▁this ▁. ▁testRun ▁= ▁testRun ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Statement ▁( ▁) ▁{ ▁Assume ▁. ▁assume That ▁( ▁testRun ▁, ▁TEST _ RESULT _ MATCH ER ▁) ▁; ▁boolean ▁success ▁= ▁false ▁; ▁try ▁{ ▁try ▁{ ▁final ▁Value ▁result ▁= ▁testRun ▁. ▁getS nippet ▁( ▁) ▁. ▁getExecutable Value ▁( ▁) ▁. ▁execute ▁( ▁testRun ▁. ▁getActual Parameters ▁( ▁) ▁. ▁toArray ▁( ▁) ▁) ▁; ▁TestUtil ▁. ▁validate Result ▁( ▁testRun ▁, ▁result ▁, ▁null ▁, ▁true ▁) ▁; ▁success ▁= ▁true ▁; ▁} ▁catch ▁( ▁Polyglot Exception ▁pe ▁) ▁{ ▁TestUtil ▁. ▁validate Result ▁( ▁testRun ▁, ▁null ▁, ▁pe ▁, ▁true ▁) ▁; ▁success ▁= ▁true ▁; ▁} ▁} ▁catch ▁( ▁Polyglot Exception ▁| ▁AssertionError ▁e ▁) ▁{ ▁throw ▁new ▁AssertionError ▁( ▁TestUtil ▁. ▁format ErrorMessage ▁( ▁STR ▁+ ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁testRun ▁, ▁context ▁) ▁, ▁e ▁) ▁; ▁} ▁finally ▁{ ▁TEST _ RESULT _ MATCH ER ▁. ▁accept ▁( ▁new ▁AbstractMap ▁. ▁Simple Immutable Entry ▁< ▁> ▁( ▁testRun ▁, ▁success ▁) ▁) ▁; ▁} ▁} ▁}
▁public ▁class ▁E TC 1 Compressor ▁{ ▁static ▁class ▁E TC 1 File Processor ▁extends ▁File Processor ▁{ ▁E TC 1 File Processor ▁( ▁) ▁{ ▁addInput Suffix ▁( ▁STR ▁) ▁; ▁addInput Suffix ▁( ▁STR ▁) ▁; ▁addInput Suffix ▁( ▁STR ▁) ▁; ▁addInput Suffix ▁( ▁STR ▁) ▁; ▁setOutput Suffix ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁process File ▁( ▁Entry ▁entry ▁) ▁throws ▁Exception ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁entry ▁. ▁inputFile ▁) ▁; ▁Pixmap ▁pixmap ▁= ▁new ▁Pixmap ▁( ▁new ▁FileHandle ▁( ▁entry ▁. ▁inputFile ▁) ▁) ▁; ▁if ▁( ▁pixmap ▁. ▁getFormat ▁( ▁) ▁!= ▁Format ▁. ▁RGB 88 8 ▁&& ▁pixmap ▁. ▁getFormat ▁( ▁) ▁!= ▁Format ▁. ▁RGB 56 5 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁pixmap ▁. ▁getFormat ▁( ▁) ▁+ ▁STR ▁) ▁; ▁Pixmap ▁tmp ▁= ▁new ▁Pixmap ▁( ▁pixmap ▁. ▁getWidth ▁( ▁) ▁, ▁pixmap ▁. ▁getHeight ▁( ▁) ▁, ▁Format ▁. ▁RGB 88 8 ▁) ▁; ▁tmp ▁. ▁setB l ending ▁( ▁Bl ending ▁. ▁None ▁) ▁; ▁tmp ▁. ▁draw P ixmap ▁( ▁pixmap ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁pixmap ▁. ▁getWidth ▁( ▁) ▁, ▁pixmap ▁. ▁getHeight ▁( ▁) ▁) ▁; ▁pixmap ▁. ▁dispose ▁( ▁) ▁; ▁pixmap ▁= ▁tmp ▁; ▁} ▁E TC 1 ▁. ▁encode Image PK M ▁( ▁pixmap ▁) ▁. ▁write ▁( ▁new ▁FileHandle ▁( ▁entry ▁. ▁outputFile ▁) ▁) ▁; ▁pixmap ▁. ▁dispose ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁process Dir ▁( ▁Entry ▁entry Dir ▁, ▁ArrayList ▁< ▁Entry ▁> ▁value ▁) ▁throws ▁Exception ▁{ ▁if ▁( ▁! ▁entry Dir ▁. ▁outputDir ▁. ▁exists ▁( ▁) ▁) ▁{ ▁if ▁( ▁! ▁entry Dir ▁. ▁outputDir ▁. ▁mkdirs ▁( ▁) ▁) ▁throw ▁new ▁Exception ▁( ▁STR ▁+ ▁entry Dir ▁. ▁outputDir ▁+ ▁STR ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁process ▁( ▁String ▁input Directory ▁, ▁String ▁output Directory ▁, ▁boolean ▁recursive ▁, ▁boolean ▁flatten ▁) ▁throws ▁Exception ▁{ ▁Gdx N atives Loader ▁. ▁load ▁( ▁) ▁; ▁E TC 1 File Processor ▁processor ▁= ▁new ▁E TC 1 File Processor ▁( ▁) ▁; ▁processor ▁. ▁set Recursive ▁( ▁recursive ▁) ▁; ▁processor ▁. ▁setF lat ten Output ▁( ▁flatten ▁) ▁; ▁processor ▁. ▁process ▁( ▁new ▁File ▁( ▁input Directory ▁) ▁, ▁new ▁File ▁( ▁output Directory ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁throws ▁Exception ▁{ ▁if ▁( ▁args ▁. ▁length ▁!= ▁2 ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁) ▁; ▁System ▁. ▁exit ▁( ▁- ▁1 ▁) ▁; ▁} ▁E TC 1 Compressor ▁. ▁process ▁( ▁args ▁[ ▁0 ▁] ▁, ▁args ▁[ ▁1 ▁] ▁, ▁true ▁, ▁false ▁) ▁; ▁} ▁}
▁public ▁abstract ▁class ▁Base Meta Op ▁extends ▁Base Grid Op ▁implements ▁Meta Op ▁{ ▁public ▁Base Meta Op ▁( ▁) ▁{ ▁} ▁public ▁Base Meta Op ▁( ▁INDArray ▁x ▁, ▁INDArray ▁y ▁) ▁{ ▁super ▁( ▁x ▁, ▁y ▁) ▁; ▁} ▁protected ▁Base Meta Op ▁( ▁Op ▁op A ▁, ▁Op ▁op B ▁) ▁{ ▁super ▁( ▁op A ▁, ▁op B ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Op Descriptor ▁getFirst Op Descriptor ▁( ▁) ▁{ ▁return ▁queue d Ops ▁. ▁get ▁( ▁0 ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Op Descriptor ▁getSecond Op Descriptor ▁( ▁) ▁{ ▁return ▁queue d Ops ▁. ▁get ▁( ▁1 ▁) ▁; ▁} ▁protected ▁Base Meta Op ▁( ▁Op Descriptor ▁op A ▁, ▁Op Descriptor ▁op B ▁) ▁{ ▁super ▁( ▁op A ▁, ▁op B ▁) ▁; ▁} ▁protected ▁Base Meta Op ▁( ▁Grid Pointer s ▁op A ▁, ▁Grid Pointer s ▁op B ▁) ▁{ ▁super ▁( ▁op A ▁, ▁op B ▁) ▁; ▁} ▁public ▁Op ▁getFirst Op ▁( ▁) ▁{ ▁return ▁getFirst Op Descriptor ▁( ▁) ▁. ▁getOp ▁( ▁) ▁; ▁} ▁public ▁Op ▁getSecond Op ▁( ▁) ▁{ ▁return ▁getSecond Op Descriptor ▁( ▁) ▁. ▁getOp ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setFirst Pointer s ▁( ▁Grid Pointer s ▁pointer s ▁) ▁{ ▁grid ▁. ▁set ▁( ▁0 ▁, ▁pointer s ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Second Pointer s ▁( ▁Grid Pointer s ▁pointer s ▁) ▁{ ▁grid ▁. ▁set ▁( ▁1 ▁, ▁pointer s ▁) ▁; ▁} ▁}
▁assert List Functions ▁( ▁Optional ▁. ▁of ▁( ▁format ▁( ▁STR ▁, ▁TEST _ C ATALOG ▁) ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁, ▁function 1 ▁. ▁with Version ▁( ▁STR ▁) ▁, ▁function 2 ▁. ▁with Version ▁( ▁STR ▁) ▁) ▁; ▁assert List Functions ▁( ▁Optional ▁. ▁of ▁( ▁format ▁( ▁STR ▁, ▁TEST _ C ATALOG ▁, ▁STR ▁) ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁, ▁function 1 ▁. ▁with Version ▁( ▁STR ▁) ▁) ▁; ▁assert List Functions ▁( ▁Optional ▁. ▁of ▁( ▁STR ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁, ▁function 1 ▁. ▁with Version ▁( ▁STR ▁) ▁, ▁function 2 ▁. ▁with Version ▁( ▁STR ▁) ▁) ▁; ▁assert List Functions ▁( ▁Optional ▁. ▁of ▁( ▁STR ▁) ▁, ▁Optional ▁. ▁of ▁( ▁STR ▁) ▁, ▁function 1 ▁. ▁with Version ▁( ▁STR ▁) ▁, ▁function 2 ▁. ▁with Version ▁( ▁STR ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testCreate Function ▁( ▁) ▁{ ▁assert List Functions ▁( ▁) ▁; ▁createFunction ▁( ▁FUNCTION _ POWER _ TO WER _ D OUBLE ▁, ▁false ▁) ▁; ▁assert List Functions ▁( ▁FUNCTION _ POWER _ TO WER _ D OUBLE ▁. ▁with Version ▁( ▁STR ▁) ▁) ▁; ▁createFunction ▁( ▁FUNCTION _ POWER _ TO WER _ D OUBLE _ UP D ATED ▁, ▁true ▁) ▁; ▁assert List Functions ▁( ▁FUNCTION _ POWER _ TO WER _ D OUBLE _ UP D ATED ▁. ▁with Version ▁( ▁STR ▁) ▁) ▁; ▁assertGet Functions ▁( ▁PO WER _ TO WER ▁, ▁FUNCTION _ POWER _ TO WER _ D OUBLE _ UP D ATED ▁. ▁with Version ▁( ▁STR ▁) ▁) ▁; ▁createFunction ▁( ▁FUNCTION _ POWER _ TO WER _ INT ▁, ▁true ▁) ▁; ▁assert List Functions ▁( ▁FUNCTION _ POWER _ TO WER _ D OUBLE _ UP D ATED ▁. ▁with Version ▁( ▁STR ▁) ▁, ▁FUNCTION _ POWER _ TO WER _ INT ▁. ▁with Version ▁( ▁STR ▁) ▁) ▁; ▁assertGet Functions ▁( ▁PO WER _ TO WER ▁, ▁FUNCTION _ POWER _ TO WER _ D OUBLE _ UP D ATED ▁. ▁with Version ▁( ▁STR ▁) ▁, ▁FUNCTION _ POWER _ TO WER _ INT ▁. ▁with Version ▁( ▁STR ▁) ▁) ▁; ▁createFunction ▁( ▁FUNCTION _ T ANG ENT ▁, ▁true ▁) ▁; ▁assert List Functions ▁( ▁FUNCTION _ POWER _ TO WER _ D OUBLE _ UP D ATED ▁. ▁with Version ▁( ▁STR ▁) ▁, ▁FUNCTION _ POWER _ TO WER _ INT ▁. ▁with Version ▁( ▁STR ▁) ▁, ▁FUNCTION _ T ANG ENT ▁. ▁with Version ▁( ▁STR ▁) ▁) ▁; ▁assertGet Functions ▁( ▁PO WER _ TO WER ▁, ▁FUNCTION _ POWER _ TO WER _ D OUBLE _ UP D ATED ▁. ▁with Version ▁( ▁STR ▁) ▁, ▁FUNCTION _ POWER _ TO WER _ INT ▁. ▁with Version ▁( ▁STR ▁) ▁) ▁; ▁assertGet Functions ▁( ▁T ANG ENT ▁, ▁FUNCTION _ T ANG ENT ▁. ▁with Version ▁( ▁STR ▁) ▁) ▁; ▁}
▁public ▁class ▁J axb Date Unm arshalling ▁{ ▁public ▁static ▁final ▁String ▁DEFAULT _ DATE _ UN MAR SH ALL ING _ FILE ▁= ▁STR ▁; ▁public ▁static ▁final ▁String ▁CUSTOM _ DATE _ UN MAR SH ALL ING _ FILE ▁= ▁STR ▁; ▁public ▁static ▁Book ▁unmarshal Dates ▁( ▁InputStream ▁inputFile ▁) ▁throws ▁JAXB Exception ▁{ ▁JAXB Context ▁j axb Context ▁= ▁JAXB Context ▁. ▁newInstance ▁( ▁Book ▁. ▁class ▁) ▁; ▁Unm arshaller ▁j axb Unm arshaller ▁= ▁j axb Context ▁. ▁createUn m arshaller ▁( ▁) ▁; ▁return ▁( ▁Book ▁) ▁j axb Unm arshaller ▁. ▁unmarshal ▁( ▁inputFile ▁) ▁; ▁} ▁public ▁static ▁Book Date Adapter ▁unmarshal Dates Using Custom Xml Adapter ▁( ▁InputStream ▁inputFile ▁) ▁throws ▁JAXB Exception ▁{ ▁JAXB Context ▁j axb Context ▁= ▁JAXB Context ▁. ▁newInstance ▁( ▁Book Date Adapter ▁. ▁class ▁) ▁; ▁Unm arshaller ▁j axb Unm arshaller ▁= ▁j axb Context ▁. ▁createUn m arshaller ▁( ▁) ▁; ▁return ▁( ▁Book Date Adapter ▁) ▁j axb Unm arshaller ▁. ▁unmarshal ▁( ▁inputFile ▁) ▁; ▁} ▁public ▁static ▁Book LocalDateTime Adapter ▁unmarshal Dates Using Java 8 ▁( ▁InputStream ▁inputFile ▁) ▁throws ▁JAXB Exception ▁{ ▁JAXB Context ▁j axb Context ▁= ▁JAXB Context ▁. ▁newInstance ▁( ▁Book LocalDateTime Adapter ▁. ▁class ▁) ▁; ▁Unm arshaller ▁j axb Unm arshaller ▁= ▁j axb Context ▁. ▁createUn m arshaller ▁( ▁) ▁; ▁return ▁( ▁Book LocalDateTime Adapter ▁) ▁j axb Unm arshaller ▁. ▁unmarshal ▁( ▁inputFile ▁) ▁; ▁} ▁public ▁static ▁InputStream ▁getInputStream ▁( ▁String ▁file ▁) ▁{ ▁ClassLoader ▁classLoader ▁= ▁J axb Date Unm arshalling ▁. ▁class ▁. ▁getClassLoader ▁( ▁) ▁; ▁return ▁classLoader ▁. ▁getResourceAs Stream ▁( ▁file ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁throws ▁JAXB Exception ▁{ ▁Book ▁book ▁= ▁unmarshal Dates ▁( ▁getInputStream ▁( ▁DEFAULT _ DATE _ UN MAR SH ALL ING _ FILE ▁) ▁) ▁; ▁Book Date Adapter ▁book Date Adapter ▁= ▁unmarshal Dates Using Custom Xml Adapter ▁( ▁getInputStream ▁( ▁CUSTOM _ DATE _ UN MAR SH ALL ING _ FILE ▁) ▁) ▁; ▁Book LocalDateTime Adapter ▁book LocalDateTime Adapter ▁= ▁unmarshal Dates Using Java 8 ▁( ▁getInputStream ▁( ▁CUSTOM _ DATE _ UN MAR SH ALL ING _ FILE ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁book ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁book Date Adapter ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁book LocalDateTime Adapter ▁) ▁; ▁} ▁}
▁public ▁class ▁X Node ▁{ ▁private ▁final ▁Node ▁node ▁; ▁private ▁final ▁String ▁name ▁; ▁private ▁final ▁String ▁body ▁; ▁private ▁final ▁Properties ▁attributes ▁; ▁private ▁final ▁Properties ▁variables ▁; ▁private ▁final ▁X Path Parser ▁x path Parser ▁; ▁public ▁X Node ▁( ▁X Path Parser ▁x path Parser ▁, ▁Node ▁node ▁, ▁Properties ▁variables ▁) ▁{ ▁this ▁. ▁x path Parser ▁= ▁x path Parser ▁; ▁this ▁. ▁node ▁= ▁node ▁; ▁this ▁. ▁name ▁= ▁node ▁. ▁getNode Name ▁( ▁) ▁; ▁this ▁. ▁variables ▁= ▁variables ▁; ▁this ▁. ▁attributes ▁= ▁parse Attributes ▁( ▁node ▁) ▁; ▁this ▁. ▁body ▁= ▁parse Body ▁( ▁node ▁) ▁; ▁} ▁public ▁X Node ▁new X Node ▁( ▁Node ▁node ▁) ▁{ ▁return ▁new ▁X Node ▁( ▁x path Parser ▁, ▁node ▁, ▁variables ▁) ▁; ▁} ▁public ▁X Node ▁getParent ▁( ▁) ▁{ ▁Node ▁parent ▁= ▁node ▁. ▁getParent Node ▁( ▁) ▁; ▁if ▁( ▁! ▁( ▁parent ▁instanceof ▁Element ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁else ▁{ ▁return ▁new ▁X Node ▁( ▁x path Parser ▁, ▁parent ▁, ▁variables ▁) ▁; ▁} ▁} ▁public ▁String ▁getPath ▁( ▁) ▁{ ▁StringBuilder ▁builder ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁Node ▁current ▁= ▁node ▁; ▁while ▁( ▁current ▁instanceof ▁Element ▁) ▁{ ▁if ▁( ▁current ▁!= ▁node ▁) ▁{ ▁builder ▁. ▁insert ▁( ▁0 ▁, ▁STR ▁) ▁; ▁} ▁builder ▁. ▁insert ▁( ▁0 ▁, ▁current ▁. ▁getNode Name ▁( ▁) ▁) ▁; ▁current ▁= ▁current ▁. ▁getParent Node ▁( ▁) ▁; ▁} ▁return ▁builder ▁. ▁toString ▁( ▁) ▁; ▁} ▁public ▁String ▁getValue Based Identifier ▁( ▁) ▁{ ▁StringBuilder ▁builder ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁X Node ▁current ▁= ▁this ▁; ▁while ▁( ▁current ▁!= ▁null ▁) ▁{ ▁if ▁( ▁current ▁!= ▁this ▁) ▁{ ▁builder ▁. ▁insert ▁( ▁0 ▁, ▁STR ▁) ▁; ▁} ▁String ▁value ▁= ▁current ▁. ▁getString Attribute ▁( ▁STR ▁, ▁current ▁. ▁getString Attribute ▁( ▁STR ▁, ▁current ▁. ▁getString Attribute ▁( ▁STR ▁, ▁( ▁String ▁) ▁null ▁) ▁) ▁) ▁; ▁if ▁( ▁value ▁!= ▁null ▁) ▁{ ▁value ▁= ▁value ▁. ▁replace ▁( ▁CHAR ▁, ▁CHAR ▁) ▁; ▁builder ▁. ▁insert ▁( ▁0 ▁, ▁STR ▁) ▁; ▁builder ▁. ▁insert ▁( ▁0 ▁, ▁value ▁) ▁; ▁builder ▁. ▁insert ▁( ▁0 ▁, ▁STR ▁) ▁; ▁} ▁builder ▁. ▁insert ▁( ▁0 ▁, ▁current ▁. ▁getName ▁( ▁) ▁) ▁; ▁current ▁= ▁current ▁. ▁getParent ▁( ▁) ▁; ▁} ▁return ▁builder ▁. ▁toString ▁( ▁) ▁; ▁} ▁public ▁String ▁eval String ▁( ▁String ▁expression ▁) ▁{ ▁return ▁x path Parser ▁. ▁eval String ▁( ▁node ▁, ▁expression ▁) ▁; ▁} ▁public ▁Boolean ▁eval Boolean ▁( ▁String ▁expression ▁) ▁{ ▁return ▁x path Parser ▁. ▁eval Boolean ▁( ▁node ▁, ▁expression ▁) ▁; ▁} ▁public ▁Double ▁eval Double ▁( ▁String ▁expression ▁) ▁{ ▁return ▁x path Parser ▁. ▁eval Double ▁( ▁node ▁, ▁expression ▁) ▁; ▁} ▁public ▁List ▁< ▁X Node ▁> ▁eval Nodes ▁( ▁String ▁expression ▁) ▁{ ▁return ▁x path Parser ▁. ▁eval Nodes ▁( ▁node ▁, ▁expression ▁) ▁;
▁public ▁class ▁Client AM Security Info ▁extends ▁Security Info ▁{ ▁@ ▁Override ▁public ▁Kerberos Info ▁getK erberos Info ▁( ▁Class ▁< ▁? ▁> ▁protocol ▁, ▁Configuration ▁conf ▁) ▁{ ▁if ▁( ▁! ▁protocol ▁. ▁equals ▁( ▁Client AM ProtocolPB ▁. ▁class ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁return ▁new ▁Kerberos Info ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Class ▁< ▁? ▁extends ▁Annotation ▁> ▁annotationType ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁String ▁server Principal ▁( ▁) ▁{ ▁return ▁Yarn Service Constants ▁. ▁PR INC IP AL ▁; ▁} ▁@ ▁Override ▁public ▁String ▁client Principal ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁} ▁; ▁} ▁@ ▁Override ▁public ▁Token Info ▁getToken Info ▁( ▁Class ▁< ▁? ▁> ▁protocol ▁, ▁Configuration ▁conf ▁) ▁{ ▁return ▁null ▁; ▁} ▁}
▁@ ▁Override ▁public ▁boolean ▁matches Safely ▁( ▁Value ▁item ▁) ▁{ ▁return ▁item ▁. ▁is Number ▁( ▁) ▁&& ▁item ▁. ▁f its In Int ▁( ▁) ▁&& ▁item ▁. ▁asInt ▁( ▁) ▁== ▁expected ▁; ▁} ▁@ ▁Override ▁public ▁void ▁describe To ▁( ▁Description ▁description ▁) ▁{ ▁description ▁. ▁appendValue ▁( ▁expected ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁describe Mismatch Safely ▁( ▁Value ▁item ▁, ▁Description ▁description ▁) ▁{ ▁super ▁. ▁describe Mismatch Safely ▁( ▁item ▁, ▁description ▁) ▁; ▁if ▁( ▁! ▁item ▁. ▁is Number ▁( ▁) ▁) ▁{ ▁description ▁. ▁appendText ▁( ▁STR ▁) ▁; ▁} ▁else ▁if ▁( ▁! ▁item ▁. ▁f its In Int ▁( ▁) ▁) ▁{ ▁description ▁. ▁appendText ▁( ▁STR ▁) ▁; ▁} ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Implicit Type ▁( ▁) ▁{ ▁Value ▁obj ▁= ▁getP y Object Implicit Type ▁. ▁execute ▁( ▁) ▁; ▁Assert ▁. ▁assertThat ▁( ▁obj ▁, ▁new ▁Member Matcher ▁( ▁STR ▁, ▁new ▁Int Matcher ▁( ▁1 ▁) ▁) ▁) ▁; ▁Assert ▁. ▁assertThat ▁( ▁obj ▁, ▁new ▁Not Existing Matcher ▁( ▁STR ▁) ▁) ▁; ▁Assert ▁. ▁assertThat ▁( ▁obj ▁, ▁new ▁Not Existing Matcher ▁( ▁STR ▁) ▁) ▁; ▁free P y Object ▁. ▁execute ▁( ▁obj ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Explicit Type ▁( ▁) ▁{ ▁Value ▁obj ▁= ▁getP y Object Explicit Type ▁. ▁execute ▁( ▁) ▁; ▁Assert ▁. ▁assertThat ▁( ▁obj ▁, ▁new ▁Not Existing Matcher ▁( ▁STR ▁) ▁) ▁; ▁Assert ▁. ▁assertThat ▁( ▁obj ▁, ▁new ▁Member Matcher ▁( ▁STR ▁, ▁new ▁Member Matcher ▁( ▁STR ▁, ▁new ▁Int Matcher ▁( ▁1 ▁) ▁) ▁) ▁) ▁; ▁Assert ▁. ▁assertThat ▁( ▁obj ▁, ▁new ▁Member Matcher ▁( ▁STR ▁, ▁new ▁Int Matcher ▁( ▁42 ▁) ▁) ▁) ▁; ▁free P y Object ▁. ▁execute ▁( ▁obj ▁) ▁; ▁} ▁}
▁static ▁CodeBlock ▁generate Cast ing Super Call ▁( ▁Type Name ▁toReturn ▁, ▁Method Spec ▁method ▁) ▁{ ▁return ▁CodeBlock ▁. ▁builder ▁( ▁) ▁. ▁add ▁( ▁STR ▁, ▁toReturn ▁, ▁method ▁. ▁name ▁) ▁. ▁add ▁( ▁Fluent Iterable ▁. ▁from ▁( ▁method ▁. ▁parameters ▁) ▁. ▁transform ▁( ▁new ▁Function ▁< ▁Parameter Spec ▁, ▁String ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁String ▁apply ▁( ▁Parameter Spec ▁input ▁) ▁{ ▁return ▁input ▁. ▁name ▁; ▁} ▁} ▁) ▁. ▁join ▁( ▁Joiner ▁. ▁on ▁( ▁STR ▁) ▁) ▁) ▁. ▁add ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁Method Spec ▁. ▁Builder ▁over rid ing ▁( ▁Executable Element ▁method ▁) ▁{ ▁String ▁methodName ▁= ▁method ▁. ▁getSimpleName ▁( ▁) ▁. ▁toString ▁( ▁) ▁; ▁Method Spec ▁. ▁Builder ▁builder ▁= ▁Method Spec ▁. ▁method Builder ▁( ▁methodName ▁) ▁. ▁addAnnotation ▁( ▁Override ▁. ▁class ▁) ▁; ▁Set ▁< ▁Modifier ▁> ▁modifiers ▁= ▁method ▁. ▁getModifiers ▁( ▁) ▁; ▁modifiers ▁= ▁new ▁LinkedHashSet ▁< ▁> ▁( ▁modifiers ▁) ▁; ▁modifiers ▁. ▁remove ▁( ▁Modifier ▁. ▁AB STR ACT ▁) ▁; ▁Modifier ▁default Modifier ▁= ▁null ▁; ▁try ▁{ ▁default Modifier ▁= ▁Modifier ▁. ▁valueOf ▁( ▁STR ▁) ▁; ▁} ▁catch ▁( ▁IllegalArgument Exception ▁e ▁) ▁{ ▁} ▁modifiers ▁. ▁remove ▁( ▁default Modifier ▁) ▁; ▁builder ▁= ▁builder ▁. ▁add Modifiers ▁( ▁modifiers ▁) ▁; ▁for ▁( ▁TypeParameter Element ▁type Parameter Element ▁: ▁method ▁. ▁getType Parameters ▁( ▁) ▁) ▁{ ▁Type Variable ▁var ▁= ▁( ▁Type Variable ▁) ▁type Parameter Element ▁. ▁asType ▁( ▁) ▁; ▁builder ▁= ▁builder ▁. ▁add Type Variable ▁( ▁Type Variable Name ▁. ▁get ▁( ▁var ▁) ▁) ▁; ▁} ▁builder ▁= ▁builder ▁. ▁return s ▁( ▁Type Name ▁. ▁get ▁( ▁method ▁. ▁getReturnType ▁( ▁) ▁) ▁) ▁. ▁add Parameters ▁( ▁getParameters ▁( ▁method ▁) ▁) ▁. ▁var args ▁( ▁method ▁. ▁is Var Args ▁( ▁) ▁) ▁; ▁for ▁( ▁TypeMirror ▁thrown Type ▁: ▁method ▁. ▁get Thrown Types ▁( ▁) ▁) ▁{ ▁builder ▁= ▁builder ▁. ▁add Exception ▁( ▁Type Name ▁. ▁get ▁( ▁thrown Type ▁) ▁) ▁; ▁} ▁return ▁builder ▁; ▁} ▁List ▁< ▁Parameter Spec ▁> ▁getParameters ▁( ▁Executable Element ▁method ▁) ▁{ ▁return ▁getParameters ▁( ▁method ▁. ▁getParameters ▁( ▁) ▁) ▁; ▁} ▁List ▁< ▁Parameter Spec ▁> ▁getParameters ▁( ▁List ▁< ▁? ▁extends ▁VariableElement ▁> ▁parameters ▁) ▁{ ▁List ▁< ▁Parameter Spec ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁VariableElement ▁parameter ▁: ▁parameters ▁) ▁{ ▁result ▁. ▁add ▁( ▁getParameter ▁( ▁parameter ▁) ▁) ▁; ▁} ▁return ▁de d up ed Parameters ▁( ▁result ▁) ▁; ▁} ▁private ▁static ▁List ▁< ▁Parameter Spec ▁> ▁de d up ed Parameters ▁( ▁List ▁< ▁Parameter Spec ▁> ▁parameters ▁) ▁{ ▁boolean ▁has D u pe s ▁= ▁false ▁; ▁Set ▁< ▁String ▁> ▁names ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁Parameter Spec ▁parameter ▁: ▁parameters ▁) ▁{ ▁String ▁name ▁= ▁parameter ▁. ▁name ▁;
▁public ▁class ▁Async Search Security IT ▁extends ▁ES RestTestCase ▁{ ▁@ ▁Override ▁protected ▁Settings ▁restClient Settings ▁( ▁) ▁{ ▁String ▁token ▁= ▁basicAuth HeaderValue ▁( ▁STR ▁, ▁new ▁SecureString ▁( ▁STR ▁. ▁toCharArray ▁( ▁) ▁) ▁) ▁; ▁return ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁ThreadContext ▁. ▁PREFIX ▁+ ▁STR ▁, ▁token ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁@ ▁Before ▁public ▁void ▁index Document s ▁( ▁) ▁throws ▁IOException ▁{ ▁createIndex ▁( ▁STR ▁, ▁Settings ▁. ▁EMPTY ▁) ▁; ▁index ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁index ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁index ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁refresh ▁( ▁STR ▁) ▁; ▁createIndex ▁( ▁STR ▁, ▁Settings ▁. ▁EMPTY ▁) ▁; ▁index ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁refresh ▁( ▁STR ▁) ▁; ▁createIndex ▁( ▁STR ▁, ▁Settings ▁. ▁EMPTY ▁) ▁; ▁index ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁index ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁refresh ▁( ▁STR ▁) ▁; ▁} ▁public ▁void ▁testWith D ls And Fl s ▁( ▁) ▁throws ▁Exception ▁{ ▁Response ▁submit Res p ▁= ▁submit Async Search ▁( ▁STR ▁, ▁STR ▁, ▁TimeValue ▁. ▁timeValue Seconds ▁( ▁10 ▁) ▁, ▁STR ▁) ▁; ▁assert OK ▁( ▁submit Res p ▁) ▁; ▁SearchHit ▁[ ▁] ▁h its ▁= ▁getSearch Hits ▁( ▁extract Response Id ▁( ▁submit Res p ▁) ▁, ▁STR ▁) ▁; ▁assertThat ▁( ▁h its ▁, ▁array Containing InAnyOrder ▁( ▁new ▁Custom Matcher ▁< ▁SearchHit ▁> ▁( ▁STR ▁) ▁{ ▁@ ▁Override ▁public ▁boolean ▁matches ▁( ▁Object ▁actual ▁) ▁{ ▁SearchHit ▁hit ▁= ▁( ▁SearchHit ▁) ▁actual ▁; ▁return ▁STR ▁. ▁equals ▁( ▁hit ▁. ▁getIndex ▁( ▁) ▁) ▁&& ▁STR ▁. ▁equals ▁( ▁hit ▁. ▁getId ▁( ▁) ▁) ▁&& ▁hit ▁. ▁getSource AsMap ▁( ▁) ▁. ▁isEmpty ▁( ▁) ▁; ▁} ▁} ▁, ▁new ▁Custom Matcher ▁< ▁SearchHit ▁> ▁( ▁STR ▁) ▁{ ▁@ ▁Override ▁public ▁boolean ▁matches ▁( ▁Object ▁actual ▁) ▁{ ▁SearchHit ▁hit ▁= ▁( ▁SearchHit ▁) ▁actual ▁; ▁return ▁STR ▁. ▁equals ▁( ▁hit ▁. ▁getIndex ▁( ▁) ▁) ▁&& ▁STR ▁. ▁equals ▁( ▁hit ▁. ▁getId ▁( ▁) ▁) ▁&& ▁STR ▁. ▁equals ▁( ▁hit ▁. ▁getSource AsMap ▁( ▁) ▁. ▁get ▁( ▁STR ▁) ▁) ▁; ▁} ▁} ▁, ▁new ▁Custom Matcher ▁< ▁SearchHit ▁> ▁( ▁STR ▁) ▁{ ▁@ ▁Override ▁public ▁boolean ▁matches ▁( ▁Object ▁actual ▁) ▁{ ▁SearchHit ▁hit ▁= ▁( ▁SearchHit ▁) ▁actual ▁; ▁return ▁STR ▁. ▁equals ▁( ▁hit ▁. ▁getIndex ▁( ▁) ▁) ▁&& ▁STR ▁. ▁equals ▁( ▁hit ▁. ▁getId ▁( ▁) ▁) ▁&& ▁hit ▁. ▁getSource AsMap ▁( ▁) ▁. ▁isEmpty ▁( ▁) ▁; ▁} ▁} ▁) ▁) ▁; ▁} ▁public ▁void ▁testWith Users ▁( ▁) ▁throws ▁Exception ▁{ ▁testCase ▁( ▁STR ▁, ▁STR ▁) ▁; ▁testCase ▁( ▁STR ▁, ▁STR ▁) ▁; ▁}
▁maybe Set Header ▁( ▁headers ▁, ▁XA _ CONTENT _ ENCODING ▁, ▁md ▁. ▁getContent Encoding ▁( ▁) ▁) ▁; ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ CONTENT _ LANG UAGE ▁, ▁md ▁. ▁getContent Language ▁( ▁) ▁) ▁; ▁if ▁( ▁md ▁. ▁getUser MetaData Of ▁( ▁Headers ▁. ▁C R Y PT O _ CE K _ ALG ORITHM ▁) ▁!= ▁null ▁&& ▁md ▁. ▁getUser MetaData Of ▁( ▁Headers ▁. ▁UN EN CRY P TED _ CONTENT _ LENGTH ▁) ▁!= ▁null ▁) ▁{ ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ CONTENT _ LENGTH ▁, ▁md ▁. ▁getUser MetaData Of ▁( ▁Headers ▁. ▁UN EN CRY P TED _ CONTENT _ LENGTH ▁) ▁) ▁; ▁} ▁else ▁{ ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ CONTENT _ LENGTH ▁, ▁md ▁. ▁getContent Length ▁( ▁) ▁) ▁; ▁} ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ CONTENT _ MD 5 ▁, ▁md ▁. ▁getContent MD 5 ▁( ▁) ▁) ▁; ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ CONTENT _ RANGE ▁, ▁md ▁. ▁getContent Range ▁( ▁) ▁) ▁; ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ CONTENT _ TYPE ▁, ▁md ▁. ▁getContentType ▁( ▁) ▁) ▁; ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ ET AG ▁, ▁md ▁. ▁getE Tag ▁( ▁) ▁) ▁; ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ LAST _ MODIFI ED ▁, ▁md ▁. ▁getLast Modified ▁( ▁) ▁) ▁; ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ ARCHIVE _ STATUS ▁, ▁md ▁. ▁get Archive Status ▁( ▁) ▁) ▁; ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ OBJECT _ LOCK _ LEG AL _ H OLD _ STATUS ▁, ▁md ▁. ▁getObject Lock Le gal Hold Status ▁( ▁) ▁) ▁; ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ OBJECT _ LOCK _ MODE ▁, ▁md ▁. ▁getObject Lock Mode ▁( ▁) ▁) ▁; ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ OBJECT _ LOCK _ RE TA IN _ UNT IL _ DATE ▁, ▁md ▁. ▁getObject Lock Retain Until Date ▁( ▁) ▁) ▁; ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ OBJECT _ REP LICATION _ STATUS ▁, ▁md ▁. ▁getRe plication Status ▁( ▁) ▁) ▁; ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ S 3_ VERSION _ ID ▁, ▁md ▁. ▁getVersion Id ▁( ▁) ▁) ▁; ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ SERVER _ S IDE _ EN CRY PTION ▁, ▁md ▁. ▁getS SE Algorithm ▁( ▁) ▁) ▁; ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ STORAGE _ CLASS ▁, ▁md ▁. ▁getStorage Class ▁( ▁) ▁) ▁; ▁maybe Set Header ▁( ▁headers ▁, ▁XA _ STORAGE _ CLASS ▁, ▁md ▁. ▁getRe plication Status ▁( ▁) ▁) ▁; ▁return ▁headers ▁; ▁}
▁public ▁class ▁Function Th unk FieldLocation ▁extends ▁Function Signature FieldLocation ▁{ ▁public ▁Function Th unk FieldLocation ▁( ▁Program ▁program ▁, ▁Address ▁location Addr ▁, ▁Address ▁function Addr ▁, ▁int ▁char Offset ▁, ▁String ▁signature ▁) ▁{ ▁super ▁( ▁program ▁, ▁location Addr ▁, ▁function Addr ▁, ▁char Offset ▁, ▁signature ▁) ▁; ▁} ▁public ▁Function Th unk FieldLocation ▁( ▁) ▁{ ▁} ▁}
▁for ▁( ▁List ▁< ▁Drm Init Data ▁. ▁S cheme Data ▁> ▁scheme Data ▁: ▁scheme Data s ▁) ▁{ ▁scheme Data s Builder ▁. ▁add ▁( ▁ImmutableList ▁. ▁copyOf ▁( ▁scheme Data ▁) ▁) ▁; ▁} ▁return ▁new ▁License Server ▁( ▁scheme Data s Builder ▁. ▁build ▁( ▁) ▁) ▁; ▁} ▁private ▁License Server ▁( ▁ImmutableSet ▁< ▁ImmutableList ▁< ▁Drm Init Data ▁. ▁S cheme Data ▁> ▁> ▁allowed Scheme Data s ▁) ▁{ ▁received Scheme Data s ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁this ▁. ▁allowed Scheme Data s ▁= ▁allowed Scheme Data s ▁; ▁} ▁public ▁ImmutableList ▁< ▁ImmutableList ▁< ▁Drm Init Data ▁. ▁S cheme Data ▁> ▁> ▁getRe ce ived Scheme Data s ▁( ▁) ▁{ ▁return ▁ImmutableList ▁. ▁copyOf ▁( ▁received Scheme Data s ▁) ▁; ▁} ▁@ ▁Override ▁public ▁byte ▁[ ▁] ▁execute Pro vision Request ▁( ▁UUID ▁uuid ▁, ▁Pro vision Request ▁request ▁) ▁throws ▁Media D rm Callback Exception ▁{ ▁if ▁( ▁Arrays ▁. ▁equals ▁( ▁request ▁. ▁getData ▁( ▁) ▁, ▁FA KE _ PRO VI SION _ REQUEST ▁. ▁getData ▁( ▁) ▁) ▁) ▁{ ▁return ▁Bytes ▁. ▁toArray ▁( ▁VALID _ PRO VI SION _ RESPONSE ▁) ▁; ▁} ▁else ▁{ ▁return ▁Util ▁. ▁EMPTY _ BYTE _ ARRAY ▁; ▁} ▁} ▁@ ▁Override ▁public ▁byte ▁[ ▁] ▁execute Key Request ▁( ▁UUID ▁uuid ▁, ▁Key Request ▁request ▁) ▁throws ▁Media D rm Callback Exception ▁{ ▁ImmutableList ▁< ▁Drm Init Data ▁. ▁S cheme Data ▁> ▁scheme Data s ▁= ▁Key RequestData ▁. ▁from ByteArray ▁( ▁request ▁. ▁getData ▁( ▁) ▁) ▁. ▁scheme Data s ▁; ▁received Scheme Data s ▁. ▁add ▁( ▁scheme Data s ▁) ▁; ▁return ▁Bytes ▁. ▁toArray ▁( ▁allowed Scheme Data s ▁. ▁contains ▁( ▁scheme Data s ▁) ▁? ▁VALID _ KEY _ RESPONSE ▁: ▁KEY _ DEN I ED _ RESPONSE ▁) ▁; ▁} ▁} ▁private ▁static ▁class ▁Key RequestData ▁implements ▁Parcelable ▁{ ▁public ▁final ▁ImmutableList ▁< ▁Drm Init Data ▁. ▁S cheme Data ▁> ▁scheme Data s ▁; ▁public ▁final ▁int ▁type ▁; ▁public ▁final ▁ImmutableMap ▁< ▁String ▁, ▁String ▁> ▁optional Parameters ▁; ▁public ▁Key RequestData ▁( ▁List ▁< ▁Drm Init Data ▁. ▁S cheme Data ▁> ▁scheme Data s ▁, ▁int ▁type ▁, ▁Map ▁< ▁String ▁, ▁String ▁> ▁optional Parameters ▁) ▁{ ▁this ▁. ▁scheme Data s ▁= ▁ImmutableList ▁. ▁copyOf ▁( ▁scheme Data s ▁) ▁; ▁this ▁. ▁type ▁= ▁type ▁; ▁this ▁. ▁optional Parameters ▁= ▁ImmutableMap ▁. ▁copyOf ▁( ▁optional Parameters ▁) ▁; ▁} ▁public ▁Key RequestData ▁( ▁Parcel ▁in ▁) ▁{ ▁this ▁. ▁scheme Data s ▁= ▁ImmutableList ▁. ▁copyOf ▁( ▁in ▁. ▁read Parcelable List ▁( ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁, ▁Drm Init Data ▁. ▁S cheme Data ▁. ▁class ▁. ▁getClassLoader ▁( ▁) ▁) ▁) ▁; ▁this ▁. ▁type ▁= ▁in ▁. ▁readInt ▁( ▁) ▁; ▁ImmutableMap ▁. ▁Builder ▁< ▁String ▁, ▁String ▁> ▁optional Parameters ▁= ▁new ▁ImmutableMap ▁. ▁Builder ▁< ▁> ▁( ▁) ▁;
▁public ▁class ▁Action Wrapper Tests ▁extends ▁ESTestCase ▁{ ▁private ▁ Z onedDateTime ▁now ▁= ▁ Z onedDateTime ▁. ▁now ▁( ▁ Z oneOffset ▁. ▁UTC ▁) ▁; ▁private ▁Watch ▁watch ▁= ▁mock ▁( ▁Watch ▁. ▁class ▁) ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁private ▁Executable Action ▁< ▁Action ▁> ▁executable Action ▁= ▁mock ▁( ▁Executable Action ▁. ▁class ▁) ▁; ▁private ▁Action Wrapper ▁action Wrapper ▁= ▁new ▁Action Wrapper ▁( ▁STR ▁, ▁null ▁, ▁Ne ver Condition ▁. ▁INSTANCE ▁, ▁null ▁, ▁executable Action ▁, ▁null ▁, ▁null ▁) ▁; ▁public ▁void ▁test That Unm et Action Condition Res ets Ack Status ▁( ▁) ▁throws ▁Exception ▁{ ▁Watch Status ▁watch Status ▁= ▁new ▁Watch Status ▁( ▁now ▁, ▁Collections ▁. ▁singletonMap ▁( ▁STR ▁, ▁create Action Status ▁( ▁State ▁. ▁A CK ED ▁) ▁) ▁) ▁; ▁when ▁( ▁watch ▁. ▁status ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁watch Status ▁) ▁; ▁Action Wrapper Result ▁result ▁= ▁action Wrapper ▁. ▁execute ▁( ▁mock Execution Content ▁( ▁watch ▁) ▁) ▁; ▁assertThat ▁( ▁result ▁. ▁condition ▁( ▁) ▁. ▁met ▁( ▁) ▁, ▁is ▁( ▁false ▁) ▁) ▁; ▁assertThat ▁( ▁result ▁. ▁action ▁( ▁) ▁. ▁status ▁( ▁) ▁, ▁is ▁( ▁Action ▁. ▁Result ▁. ▁Status ▁. ▁CON D ITION _ FAILED ▁) ▁) ▁; ▁assertThat ▁( ▁watch ▁. ▁status ▁( ▁) ▁. ▁action Status ▁( ▁STR ▁) ▁. ▁ack Status ▁( ▁) ▁. ▁state ▁( ▁) ▁, ▁is ▁( ▁State ▁. ▁AW A ITS _ SUCCESS F UL _ EXECUT ION ▁) ▁) ▁; ▁} ▁public ▁void ▁test Other Actions Are Not A ffected On Action Condition Reset ▁( ▁) ▁throws ▁Exception ▁{ ▁Map ▁< ▁String ▁, ▁Action Status ▁> ▁status Map ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁status Map ▁. ▁put ▁( ▁STR ▁, ▁create Action Status ▁( ▁State ▁. ▁A CK ED ▁) ▁) ▁; ▁State ▁other State ▁= ▁randomFrom ▁( ▁State ▁. ▁A CK ABLE ▁, ▁State ▁. ▁AW A ITS _ SUCCESS F UL _ EXECUT ION ▁) ▁; ▁status Map ▁. ▁put ▁( ▁STR ▁, ▁create Action Status ▁( ▁other State ▁) ▁) ▁; ▁Watch Status ▁watch Status ▁= ▁new ▁Watch Status ▁( ▁now ▁, ▁status Map ▁) ▁; ▁when ▁( ▁watch ▁. ▁status ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁watch Status ▁) ▁; ▁action Wrapper ▁. ▁execute ▁( ▁mock Execution Content ▁( ▁watch ▁) ▁) ▁; ▁assertThat ▁( ▁watch ▁. ▁status ▁( ▁) ▁. ▁action Status ▁( ▁STR ▁) ▁. ▁ack Status ▁( ▁) ▁. ▁state ▁( ▁) ▁, ▁is ▁( ▁other State ▁) ▁) ▁; ▁} ▁public ▁void ▁test That Multiple Results CanBe Returned ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁Logging Action ▁logging Action ▁= ▁new ▁Logging Action ▁( ▁new ▁Text Template ▁( ▁STR ▁) ▁, ▁null ▁, ▁null ▁) ▁; ▁final ▁Executable Action ▁< ▁Logging Action ▁> ▁executable Action ▁= ▁new ▁Executable Logging Action ▁( ▁logging Action ▁, ▁logger ▁, ▁new ▁Mock Text Template Engine ▁( ▁) ▁) ▁;
▁@ ▁Deprecated ▁@ ▁Override ▁public ▁final ▁boolean ▁isIn complete Source ▁( ▁) ▁{ ▁try ▁{ ▁return ▁InteropLibrary ▁. ▁getUncached ▁( ▁) ▁. ▁is Exception In complete Source ▁( ▁this ▁) ▁; ▁} ▁catch ▁( ▁Unsupported MessageException ▁um ▁) ▁{ ▁throw ▁Compiler Directives ▁. ▁shouldNot ReachHere ▁( ▁um ▁) ▁; ▁} ▁} ▁@ ▁Deprecated ▁@ ▁Override ▁public ▁final ▁boolean ▁isInternal Error ▁( ▁) ▁{ ▁return ▁false ▁; ▁} ▁@ ▁Deprecated ▁@ ▁Override ▁public ▁final ▁boolean ▁isCancelled ▁( ▁) ▁{ ▁return ▁false ▁; ▁} ▁@ ▁Deprecated ▁@ ▁Override ▁public ▁final ▁boolean ▁is Exit ▁( ▁) ▁{ ▁return ▁getException Type ▁( ▁) ▁== ▁Exception Type ▁. ▁EX IT ▁; ▁} ▁@ ▁Deprecated ▁@ ▁Override ▁public ▁final ▁int ▁get Exit Status ▁( ▁) ▁{ ▁try ▁{ ▁return ▁InteropLibrary ▁. ▁getUncached ▁( ▁) ▁. ▁getException Exit Status ▁( ▁this ▁) ▁; ▁} ▁catch ▁( ▁Unsupported MessageException ▁um ▁) ▁{ ▁throw ▁Compiler Directives ▁. ▁shouldNot ReachHere ▁( ▁um ▁) ▁; ▁} ▁} ▁@ ▁Deprecated ▁@ ▁TruffleBoundary ▁@ ▁Override ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁final ▁Throwable ▁init Cause ▁( ▁Throwable ▁throwable ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁final ▁Throwable ▁getCause ▁( ▁) ▁{ ▁return ▁cause ▁; ▁} ▁Throwable ▁getL azy StackTrace ▁( ▁) ▁{ ▁return ▁lazy StackTrace ▁; ▁} ▁void ▁set Lazy StackTrace ▁( ▁Throwable ▁stackTrace ▁) ▁{ ▁this ▁. ▁lazy StackTrace ▁= ▁stackTrace ▁; ▁} ▁private ▁Exception Type ▁getException Type ▁( ▁) ▁{ ▁try ▁{ ▁return ▁InteropLibrary ▁. ▁getUncached ▁( ▁) ▁. ▁getException Type ▁( ▁this ▁) ▁; ▁} ▁catch ▁( ▁Unsupported MessageException ▁um ▁) ▁{ ▁throw ▁Compiler Directives ▁. ▁shouldNot ReachHere ▁( ▁um ▁) ▁; ▁} ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁static ▁boolean ▁is Truffle Exception ▁( ▁Throwable ▁t ▁) ▁{ ▁return ▁t ▁instanceof ▁com ▁. ▁oracle ▁. ▁truffle ▁. ▁api ▁. ▁Truffle Exception ▁; ▁} ▁}
▁public ▁class ▁DB 2 Index Configurator ▁implements ▁DBE Object Configurator ▁< ▁DB 2 Index ▁> ▁{ ▁private ▁static ▁final ▁String ▁CON S _ IX _ NAME ▁= ▁STR ▁; ▁private ▁static ▁final ▁List ▁< ▁DBS Index Type ▁> ▁I X _ TYPES ▁; ▁static ▁{ ▁I X _ TYPES ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁DB 2 Index Type ▁. ▁values ▁( ▁) ▁. ▁length ▁) ▁; ▁for ▁( ▁DB 2 Index Type ▁db 2 Index Type ▁: ▁DB 2 Index Type ▁. ▁values ▁( ▁) ▁) ▁{ ▁if ▁( ▁db 2 Index Type ▁. ▁isValid For Creation ▁( ▁) ▁) ▁{ ▁I X _ TYPES ▁. ▁add ▁( ▁db 2 Index Type ▁. ▁get DB S Index Type ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁@ ▁Override ▁public ▁DB 2 Index ▁configure Object ▁( ▁DBR ProgressMonitor ▁monitor ▁, ▁Object ▁container ▁, ▁DB 2 Index ▁index ▁) ▁{ ▁return ▁UIT ask ▁. ▁run ▁( ▁( ▁) ▁-> ▁{ ▁DB 2 TableBase ▁table ▁= ▁( ▁DB 2 TableBase ▁) ▁container ▁; ▁Edit Index Page ▁edit Page ▁= ▁new ▁Edit Index Page ▁( ▁DB 2 Messages ▁. ▁edit _ db 2_ index _ man ager _ dialog _ title ▁, ▁index ▁, ▁I X _ TYPES ▁) ▁; ▁if ▁( ▁! ▁edit Page ▁. ▁edit ▁( ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁String ▁tableName ▁= ▁CommonUtils ▁. ▁escape Identifier ▁( ▁table ▁. ▁getName ▁( ▁) ▁) ▁; ▁String ▁col Name ▁= ▁CommonUtils ▁. ▁escape Identifier ▁( ▁edit Page ▁. ▁getSelected Attributes ▁( ▁) ▁. ▁iterator ▁( ▁) ▁. ▁next ▁( ▁) ▁. ▁getName ▁( ▁) ▁) ▁; ▁String ▁index Base Name ▁= ▁String ▁. ▁format ▁( ▁CON S _ IX _ NAME ▁, ▁tableName ▁, ▁col Name ▁) ▁; ▁String ▁indexName ▁= ▁DB ObjectName Case Transformer ▁. ▁transform Name ▁( ▁table ▁. ▁getDataSource ▁( ▁) ▁, ▁index Base Name ▁) ▁; ▁index ▁. ▁setName ▁( ▁indexName ▁) ▁; ▁index ▁. ▁setIndex Type ▁( ▁edit Page ▁. ▁getIndex Type ▁( ▁) ▁) ▁; ▁index ▁. ▁set Unique Rule ▁( ▁edit Page ▁. ▁is Unique ▁( ▁) ▁? ▁DB 2 Unique Rule ▁. ▁U ▁: ▁DB 2 Unique Rule ▁. ▁D ▁) ▁; ▁int ▁col Index ▁= ▁1 ▁; ▁for ▁( ▁DBSEntity Attribute ▁tableColumn ▁: ▁edit Page ▁. ▁getSelected Attributes ▁( ▁) ▁) ▁{ ▁index ▁. ▁addColumn ▁( ▁new ▁DB 2 Index Column ▁( ▁index ▁, ▁( ▁DB 2 TableColumn ▁) ▁tableColumn ▁, ▁col Index ▁++ ▁, ▁! ▁Boolean ▁. ▁TRUE ▁. ▁equals ▁( ▁edit Page ▁. ▁getAttribute Property ▁( ▁tableColumn ▁, ▁Edit Index Page ▁. ▁PROP _ DESC ▁) ▁) ▁) ▁) ▁; ▁} ▁return ▁index ▁; ▁} ▁) ▁; ▁} ▁}
▁@ ▁Override ▁public ▁void ▁post Visit ▁( ▁Operator ▁< ▁? ▁> ▁c ▁) ▁{ ▁Optimizer Node ▁n ▁= ▁this ▁. ▁con 2 node ▁. ▁get ▁( ▁c ▁) ▁; ▁n ▁. ▁setInput ▁( ▁this ▁. ▁con 2 node ▁, ▁this ▁. ▁default Data ExchangeMode ▁) ▁; ▁n ▁. ▁setB roadcast Inputs ▁( ▁this ▁. ▁con 2 node ▁, ▁this ▁. ▁default Data ExchangeMode ▁) ▁; ▁if ▁( ▁n ▁instanceof ▁Bulk Iteration Node ▁) ▁{ ▁final ▁Bulk Iteration Node ▁iter Node ▁= ▁( ▁Bulk Iteration Node ▁) ▁n ▁; ▁final ▁Bulk Iteration Base ▁< ▁? ▁> ▁iter ▁= ▁iter Node ▁. ▁get Iteration Contract ▁( ▁) ▁; ▁HashMap ▁< ▁Operator ▁< ▁? ▁> ▁, ▁Optimizer Node ▁> ▁c losure ▁= ▁new ▁HashMap ▁< ▁Operator ▁< ▁? ▁> ▁, ▁Optimizer Node ▁> ▁( ▁con 2 node ▁) ▁; ▁final ▁Graph Cre ating Visitor ▁recursive Creator ▁= ▁new ▁Graph Cre ating Visitor ▁( ▁this ▁, ▁true ▁, ▁iter Node ▁. ▁getParallelism ▁( ▁) ▁, ▁default Data ExchangeMode ▁, ▁c losure ▁) ▁; ▁Bulk Partial Sol ution Node ▁partial Sol ution ▁; ▁iter ▁. ▁getNext Partial Sol ution ▁( ▁) ▁. ▁accept ▁( ▁recursive Creator ▁) ▁; ▁partial Sol ution ▁= ▁( ▁Bulk Partial Sol ution Node ▁) ▁recursive Creator ▁. ▁con 2 node ▁. ▁get ▁( ▁iter ▁. ▁getPart ial Sol ution ▁( ▁) ▁) ▁; ▁Optimizer Node ▁root Of Step Function ▁= ▁recursive Creator ▁. ▁con 2 node ▁. ▁get ▁( ▁iter ▁. ▁getNext Partial Sol ution ▁( ▁) ▁) ▁; ▁if ▁( ▁partial Sol ution ▁== ▁null ▁) ▁{ ▁throw ▁new ▁Compiler Exception ▁( ▁STR ▁) ▁; ▁} ▁Optimizer Node ▁termination C riterion ▁= ▁null ▁; ▁if ▁( ▁iter ▁. ▁get Termination C riterion ▁( ▁) ▁!= ▁null ▁) ▁{ ▁termination C riterion ▁= ▁recursive Creator ▁. ▁con 2 node ▁. ▁get ▁( ▁iter ▁. ▁get Termination C riterion ▁( ▁) ▁) ▁; ▁if ▁( ▁termination C riterion ▁== ▁null ▁) ▁{ ▁iter ▁. ▁get Termination C riterion ▁( ▁) ▁. ▁accept ▁( ▁recursive Creator ▁) ▁; ▁termination C riterion ▁= ▁recursive Creator ▁. ▁con 2 node ▁. ▁get ▁( ▁iter ▁. ▁get Termination C riterion ▁( ▁) ▁) ▁; ▁} ▁} ▁iter Node ▁. ▁set Partial Sol ution ▁( ▁partial Sol ution ▁) ▁; ▁iter Node ▁. ▁setNext Partial Sol ution ▁( ▁root Of Step Function ▁, ▁termination C riterion ▁) ▁; ▁Static Dynamic Path Identifier ▁identifier ▁= ▁new ▁Static Dynamic Path Identifier ▁( ▁iter Node ▁. ▁get Cost Weight ▁( ▁) ▁) ▁; ▁iter Node ▁. ▁accept For Step Function ▁( ▁identifier ▁) ▁; ▁} ▁else ▁if ▁( ▁n ▁instanceof ▁Work set Iteration Node ▁) ▁{ ▁final ▁Work set Iteration Node ▁iter Node ▁= ▁( ▁Work set Iteration Node ▁) ▁n ▁; ▁final ▁Delta Iteration Base ▁< ▁? ▁, ▁? ▁> ▁iter ▁= ▁iter Node ▁. ▁get Iteration Contract ▁( ▁) ▁; ▁{ ▁Step Function Validator ▁ws f ▁= ▁new ▁Step Function Validator ▁( ▁) ▁; ▁iter ▁. ▁getNext Work set ▁( ▁) ▁. ▁accept ▁( ▁ws f ▁) ▁;
▁@ ▁Test ▁public ▁void ▁testDefault Log Aggregation File Controller Factory ▁( ▁) ▁throws ▁IOException ▁{ ▁LogAggregation File Controller Factory ▁factory ▁= ▁new ▁LogAggregation File Controller Factory ▁( ▁getConf ▁( ▁) ▁) ▁; ▁List ▁< ▁LogAggregation File Controller ▁> ▁list ▁= ▁factory ▁. ▁getConfig ured Log Aggregation File Controller List ▁( ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁1 ▁, ▁list ▁. ▁size ▁( ▁) ▁) ▁; ▁assertTrue ▁( ▁STR ▁+ ▁STR ▁, ▁list ▁. ▁get ▁( ▁0 ▁) ▁instanceof ▁LogAggregation T File Controller ▁) ▁; ▁assertTrue ▁( ▁STR ▁, ▁factory ▁. ▁getFile Controller ForWrite ▁( ▁) ▁instanceof ▁LogAggregation T File Controller ▁) ▁; ▁verify File Controller Instance ▁( ▁factory ▁, ▁LogAggregation T File Controller ▁. ▁class ▁) ▁; ▁} ▁@ ▁Test ▁( ▁expected ▁= ▁Exception ▁. ▁class ▁) ▁public ▁void ▁test Log Aggregation File Controller Factory Class Not Set ▁( ▁) ▁{ ▁Configuration ▁conf ▁= ▁getConf ▁( ▁) ▁; ▁conf ▁. ▁set ▁( ▁Yarn Configuration ▁. ▁LOG _ AG GREG ATION _ FILE _ FORMAT S ▁, ▁STR ▁) ▁; ▁new ▁LogAggregation File Controller Factory ▁( ▁conf ▁) ▁; ▁fail ▁( ▁STR ▁+ ▁STR ▁) ▁; ▁} ▁private ▁void ▁enable File Control lers ▁( ▁List ▁< ▁Class ▁< ▁? ▁extends ▁LogAggregation File Controller ▁> ▁> ▁file Control lers ▁, ▁List ▁< ▁String ▁> ▁file Controller Names ▁) ▁{ ▁Configuration ▁conf ▁= ▁getConf ▁( ▁) ▁; ▁conf ▁. ▁set ▁( ▁Yarn Configuration ▁. ▁LOG _ AG GREG ATION _ FILE _ FORMAT S ▁, ▁StringUtils ▁. ▁join ▁( ▁file Controller Names ▁, ▁STR ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁file Control lers ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁Class ▁< ▁? ▁extends ▁LogAggregation File Controller ▁> ▁file Controller ▁= ▁file Control lers ▁. ▁get ▁( ▁i ▁) ▁; ▁String ▁controller Name ▁= ▁file Controller Names ▁. ▁get ▁( ▁i ▁) ▁; ▁conf ▁. ▁setClass ▁( ▁String ▁. ▁format ▁( ▁LOG _ AG GREG ATION _ FILE _ CONTROL LER _ F MT ▁, ▁controller Name ▁) ▁, ▁file Controller ▁, ▁LogAggregation File Controller ▁. ▁class ▁) ▁; ▁conf ▁. ▁set ▁( ▁String ▁. ▁format ▁( ▁LOG _ AG GREG ATION _ RE MOTE _ APP _ LOG _ DIR _ F MT ▁, ▁controller Name ▁) ▁, ▁REMOTE _ LOG _ ROOT ▁+ ▁controller Name ▁+ ▁STR ▁) ▁; ▁conf ▁. ▁set ▁( ▁String ▁. ▁format ▁( ▁LOG _ AG GREG ATION _ RE MOTE _ APP _ LOG _ DIR _ SUFFIX _ F MT ▁, ▁controller Name ▁) ▁, ▁controller Name ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Log Aggregation File Controller Factory ▁( ▁) ▁throws ▁Exception ▁{ ▁enable File Control lers ▁( ▁ALL _ FILE _ CONTROL LER S ▁, ▁ALL _ FILE _ CONTROL LER _ NAMES ▁) ▁; ▁LogAggregation File Controller Factory ▁factory ▁= ▁new ▁LogAggregation File Controller Factory ▁( ▁getConf ▁( ▁) ▁) ▁; ▁List ▁< ▁LogAggregation File Controller ▁> ▁list ▁= ▁factory ▁. ▁getConfig ured Log Aggregation File Controller List ▁( ▁) ▁;
▁public ▁String ▁get Up Url ▁( ▁) ▁{ ▁return ▁Functions ▁. ▁getN e are st Ancestor Url ▁( ▁Stapler ▁. ▁getCurrent Request ▁( ▁) ▁, ▁getParent ▁( ▁) ▁) ▁+ ▁CHAR ▁; ▁} ▁public ▁final ▁@ ▁CheckForNull ▁FilePath ▁getWorkspace ▁( ▁) ▁{ ▁if ▁( ▁workspace ▁== ▁null ▁) ▁return ▁null ▁; ▁Node ▁n ▁= ▁getB uilt On ▁( ▁) ▁; ▁if ▁( ▁n ▁== ▁null ▁) ▁return ▁null ▁; ▁return ▁n ▁. ▁create Path ▁( ▁workspace ▁) ▁; ▁} ▁protected ▁void ▁set Workspace ▁( ▁@ ▁NonNull ▁FilePath ▁ws ▁) ▁{ ▁this ▁. ▁workspace ▁= ▁ws ▁. ▁getRemote ▁( ▁) ▁; ▁} ▁public ▁final ▁FilePath ▁getModule Root ▁( ▁) ▁{ ▁FilePath ▁ws ▁= ▁getWorkspace ▁( ▁) ▁; ▁if ▁( ▁ws ▁== ▁null ▁) ▁return ▁null ▁; ▁return ▁getParent ▁( ▁) ▁. ▁getSc m ▁( ▁) ▁. ▁getModule Root ▁( ▁ws ▁, ▁this ▁) ▁; ▁} ▁public ▁FilePath ▁[ ▁] ▁getModule Root s ▁( ▁) ▁{ ▁FilePath ▁ws ▁= ▁getWorkspace ▁( ▁) ▁; ▁if ▁( ▁ws ▁== ▁null ▁) ▁return ▁null ▁; ▁return ▁getParent ▁( ▁) ▁. ▁getSc m ▁( ▁) ▁. ▁getModule Root s ▁( ▁ws ▁, ▁this ▁) ▁; ▁} ▁@ ▁Override ▁@ ▁CheckForNull ▁public ▁Set ▁< ▁String ▁> ▁getC ul p rit Ids ▁( ▁) ▁{ ▁return ▁c ul p rit s ▁; ▁} ▁@ ▁Override ▁@ ▁Ex ported ▁@ ▁NonNull ▁public ▁Set ▁< ▁User ▁> ▁getC ul p rit s ▁( ▁) ▁{ ▁return ▁RunWith SC M ▁. ▁super ▁. ▁getC ul p rit s ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁should Calc ulate C ul p rit s ▁( ▁) ▁{ ▁return ▁getC ul p rit Ids ▁( ▁) ▁== ▁null ▁; ▁} ▁@ ▁Override ▁@ ▁NonNull ▁public ▁Set ▁< ▁User ▁> ▁calculate C ul p rit s ▁( ▁) ▁{ ▁Set ▁< ▁User ▁> ▁c ▁= ▁RunWith SC M ▁. ▁super ▁. ▁calculate C ul p rit s ▁( ▁) ▁; ▁AbstractBuild ▁< ▁P ▁, ▁R ▁> ▁p ▁= ▁getPrevious Completed Build ▁( ▁) ▁; ▁if ▁( ▁upstream C ul p rit s ▁) ▁{ ▁if ▁( ▁p ▁!= ▁null ▁&& ▁p ▁. ▁getPrevious Not Failed Build ▁( ▁) ▁!= ▁null ▁) ▁{ ▁Map ▁< ▁Abstract Project ▁, ▁AbstractBuild ▁. ▁Dependency Change ▁> ▁dep map ▁= ▁p ▁. ▁get Dependency Changes ▁( ▁p ▁. ▁getPrevious Successful Build ▁( ▁) ▁) ▁; ▁for ▁( ▁AbstractBuild ▁. ▁Dependency Change ▁dep ▁: ▁dep map ▁. ▁values ▁( ▁) ▁) ▁{ ▁for ▁( ▁AbstractBuild ▁< ▁? ▁, ▁? ▁> ▁b ▁: ▁dep ▁. ▁getBuild s ▁( ▁) ▁) ▁{ ▁for ▁( ▁Change Log Set ▁. ▁Entry ▁entry ▁: ▁b ▁. ▁get ChangeSet ▁( ▁) ▁) ▁{ ▁c ▁. ▁add ▁( ▁entry ▁. ▁getAuthor ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁} ▁} ▁return ▁c ▁; ▁} ▁public ▁String ▁getH udson Version ▁( ▁) ▁{ ▁return ▁h udson Version ▁; ▁} ▁@ ▁Deprecated ▁public ▁abstract ▁class ▁Abstract Runner ▁extends ▁AbstractBuild Execution ▁{ ▁} ▁public ▁abstract ▁class ▁AbstractBuild Execution ▁extends ▁Runner ▁{ ▁protected ▁Launcher ▁launcher ▁; ▁protected ▁Build Listener ▁listener ▁; ▁private ▁Le ase ▁le ase ▁;
▁public ▁abstract ▁class ▁Base Database Driver ▁< ▁DESC ▁> ▁{ ▁protected ▁Context ▁m Context ▁; ▁public ▁Base Database Driver ▁( ▁Context ▁context ▁) ▁{ ▁m Context ▁= ▁context ▁; ▁} ▁public ▁Context ▁getContext ▁( ▁) ▁{ ▁return ▁m Context ▁; ▁} ▁public ▁abstract ▁List ▁< ▁DESC ▁> ▁getDatabase Names ▁( ▁) ▁; ▁public ▁abstract ▁List ▁< ▁String ▁> ▁getTable Names ▁( ▁DESC ▁database ▁) ▁; ▁public ▁abstract ▁Database ▁. ▁Execute SQL Response ▁execute SQL ▁( ▁DESC ▁database ▁, ▁String ▁query ▁, ▁Execute ResultHandler ▁< ▁Database ▁. ▁Execute SQL Response ▁> ▁handler ▁) ▁throws ▁SQLite Exception ▁; ▁public ▁interface ▁Execute ResultHandler ▁< ▁RESULT ▁> ▁{ ▁RESULT ▁handle Raw Query ▁( ▁) ▁throws ▁SQLite Exception ▁; ▁RESULT ▁handle Select ▁( ▁Cursor ▁result ▁) ▁throws ▁SQLite Exception ▁; ▁RESULT ▁handle Insert ▁( ▁long ▁in ser ted Id ▁) ▁throws ▁SQLite Exception ▁; ▁RESULT ▁handle Update Delete ▁( ▁int ▁count ▁) ▁throws ▁SQLite Exception ▁; ▁} ▁}
▁public ▁class ▁Test Regex Template ▁{ ▁@ ▁Test ▁public ▁void ▁test ▁( ▁) ▁{ ▁Regex Template ▁regex Template ▁= ▁new ▁Regex Template ▁( ▁STR ▁) ▁; ▁assertEquals ▁( ▁regex Template ▁. ▁getField Names ▁( ▁) ▁, ▁ImmutableList ▁. ▁of ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁regex Template ▁. ▁parse ▁( ▁STR ▁) ▁, ▁Optional ▁. ▁of ▁( ▁ImmutableMap ▁. ▁of ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁) ▁) ▁; ▁assertEquals ▁( ▁regex Template ▁. ▁parse ▁( ▁STR ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁regex Template ▁. ▁parse ▁( ▁STR ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁regex Template ▁. ▁parse ▁( ▁STR ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁) ▁; ▁regex Template ▁= ▁new ▁Regex Template ▁( ▁STR ▁) ▁; ▁assertEquals ▁( ▁regex Template ▁. ▁parse ▁( ▁STR ▁) ▁, ▁Optional ▁. ▁of ▁( ▁ImmutableMap ▁. ▁of ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁) ▁) ▁; ▁assertEquals ▁( ▁regex Template ▁. ▁parse ▁( ▁STR ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁regex Template ▁. ▁parse ▁( ▁STR ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁) ▁; ▁} ▁}
▁public ▁static ▁Class ▁< ▁? ▁> ▁resolve ReturnType For Factory Method ▁( ▁Method ▁method ▁, ▁Object ▁[ ▁] ▁args ▁, ▁@ ▁Nullable ▁ClassLoader ▁classLoader ▁) ▁{ ▁Assert ▁. ▁notNull ▁( ▁method ▁, ▁STR ▁) ▁; ▁Assert ▁. ▁notNull ▁( ▁args ▁, ▁STR ▁) ▁; ▁Type Variable ▁< ▁Method ▁> ▁[ ▁] ▁declared Type Variables ▁= ▁method ▁. ▁getType Parameters ▁( ▁) ▁; ▁Type ▁generic ReturnType ▁= ▁method ▁. ▁getGeneric ReturnType ▁( ▁) ▁; ▁Type ▁[ ▁] ▁method ParameterTypes ▁= ▁method ▁. ▁getGeneric ParameterTypes ▁( ▁) ▁; ▁Assert ▁. ▁isTrue ▁( ▁args ▁. ▁length ▁== ▁method ParameterTypes ▁. ▁length ▁, ▁STR ▁) ▁; ▁boolean ▁loc ally Declared Type Variable Matches ReturnType ▁= ▁false ▁; ▁for ▁( ▁Type Variable ▁< ▁Method ▁> ▁current Type Variable ▁: ▁declared Type Variables ▁) ▁{ ▁if ▁( ▁current Type Variable ▁. ▁equals ▁( ▁generic ReturnType ▁) ▁) ▁{ ▁loc ally Declared Type Variable Matches ReturnType ▁= ▁true ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁loc ally Declared Type Variable Matches ReturnType ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁method ParameterTypes ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁Type ▁method Parameter Type ▁= ▁method ParameterTypes ▁[ ▁i ▁] ▁; ▁Object ▁arg ▁= ▁args ▁[ ▁i ▁] ▁; ▁if ▁( ▁method Parameter Type ▁. ▁equals ▁( ▁generic ReturnType ▁) ▁) ▁{ ▁if ▁( ▁arg ▁instanceof ▁Typed StringValue ▁) ▁{ ▁Typed StringValue ▁typed Value ▁= ▁( ▁( ▁Typed StringValue ▁) ▁arg ▁) ▁; ▁if ▁( ▁typed Value ▁. ▁has Target Type ▁( ▁) ▁) ▁{ ▁return ▁typed Value ▁. ▁getTarget Type ▁( ▁) ▁; ▁} ▁try ▁{ ▁Class ▁< ▁? ▁> ▁resolved Type ▁= ▁typed Value ▁. ▁resolve Target Type ▁( ▁classLoader ▁) ▁; ▁if ▁( ▁resolved Type ▁!= ▁null ▁) ▁{ ▁return ▁resolved Type ▁; ▁} ▁} ▁catch ▁( ▁ClassNot FoundException ▁ex ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁+ ▁typed Value ▁. ▁getTarget TypeName ▁( ▁) ▁+ ▁STR ▁, ▁ex ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁arg ▁!= ▁null ▁&& ▁! ▁( ▁arg ▁instanceof ▁Bean Metadata Element ▁) ▁) ▁{ ▁return ▁arg ▁. ▁getClass ▁( ▁) ▁; ▁} ▁return ▁method ▁. ▁getReturnType ▁( ▁) ▁; ▁} ▁else ▁if ▁( ▁method Parameter Type ▁instanceof ▁Parameterized Type ▁) ▁{ ▁Parameterized Type ▁parameter ized Type ▁= ▁( ▁Parameterized Type ▁) ▁method Parameter Type ▁; ▁Type ▁[ ▁] ▁actual TypeArguments ▁= ▁parameter ized Type ▁. ▁getActual TypeArguments ▁( ▁) ▁; ▁for ▁( ▁Type ▁type Arg ▁: ▁actual TypeArguments ▁) ▁{ ▁if ▁( ▁type Arg ▁. ▁equals ▁( ▁generic ReturnType ▁) ▁) ▁{ ▁if ▁( ▁arg ▁instanceof ▁Class ▁) ▁{ ▁return ▁( ▁Class ▁< ▁? ▁> ▁) ▁arg ▁; ▁} ▁else ▁{ ▁String ▁className ▁= ▁null ▁; ▁if ▁( ▁arg ▁instanceof ▁String ▁) ▁{ ▁className ▁= ▁( ▁String ▁) ▁arg ▁; ▁} ▁else ▁if ▁( ▁arg ▁instanceof ▁Typed StringValue ▁) ▁{ ▁Typed StringValue ▁typed Value ▁= ▁( ▁( ▁Typed StringValue ▁) ▁arg ▁) ▁; ▁String ▁target TypeName ▁= ▁typed Value ▁. ▁getTarget TypeName ▁( ▁) ▁;
▁@ ▁Configuration ▁( ▁proxyBean Methods ▁= ▁false ▁) ▁public ▁class ▁My WebSocket Configuration ▁{ ▁@ ▁Bean ▁public ▁Server Endpoint Exporter ▁server Endpoint Exporter ▁( ▁) ▁{ ▁return ▁new ▁Server Endpoint Exporter ▁( ▁) ▁; ▁} ▁}
▁else ▁if ▁( ▁msg ▁. ▁wh at ▁== ▁MS G _ C LE AR ▁) ▁{ ▁Gif Frame Loader ▁. ▁Delay Target ▁target ▁= ▁( ▁Delay Target ▁) ▁msg ▁. ▁obj ▁; ▁request Manager ▁. ▁clear ▁( ▁target ▁) ▁; ▁} ▁return ▁false ▁; ▁} ▁} ▁@ ▁Visible ForTesting ▁static ▁class ▁Delay Target ▁extends ▁Custom Target ▁< ▁Bitmap ▁> ▁{ ▁private ▁final ▁Handler ▁handler ▁; ▁@ ▁Syn thetic ▁final ▁int ▁index ▁; ▁private ▁final ▁long ▁target Time ▁; ▁private ▁Bitmap ▁resource ▁; ▁Delay Target ▁( ▁Handler ▁handler ▁, ▁int ▁index ▁, ▁long ▁target Time ▁) ▁{ ▁this ▁. ▁handler ▁= ▁handler ▁; ▁this ▁. ▁index ▁= ▁index ▁; ▁this ▁. ▁target Time ▁= ▁target Time ▁; ▁} ▁Bitmap ▁getResource ▁( ▁) ▁{ ▁return ▁resource ▁; ▁} ▁@ ▁Override ▁public ▁void ▁on Resource Ready ▁( ▁@ ▁NonNull ▁Bitmap ▁resource ▁, ▁@ ▁Nullable ▁Transition ▁< ▁? ▁super ▁Bitmap ▁> ▁transition ▁) ▁{ ▁this ▁. ▁resource ▁= ▁resource ▁; ▁Message ▁msg ▁= ▁handler ▁. ▁obtain Message ▁( ▁Frame Loader Callback ▁. ▁MS G _ DELAY ▁, ▁this ▁) ▁; ▁handler ▁. ▁sendMessage At Time ▁( ▁msg ▁, ▁target Time ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁onLoad C le ared ▁( ▁@ ▁Nullable ▁Drawable ▁placeholder ▁) ▁{ ▁this ▁. ▁resource ▁= ▁null ▁; ▁} ▁} ▁private ▁static ▁RequestBuilder ▁< ▁Bitmap ▁> ▁get RequestBuilder ▁( ▁Request Manager ▁request Manager ▁, ▁int ▁width ▁, ▁int ▁height ▁) ▁{ ▁return ▁request Manager ▁. ▁as Bitmap ▁( ▁) ▁. ▁apply ▁( ▁disk Cache Strategy Of ▁( ▁Disk Cache Strategy ▁. ▁NONE ▁) ▁. ▁use Animation Pool ▁( ▁true ▁) ▁. ▁skip MemoryCache ▁( ▁true ▁) ▁. ▁override ▁( ▁width ▁, ▁height ▁) ▁) ▁; ▁} ▁private ▁static ▁Key ▁getFrame Signature ▁( ▁) ▁{ ▁return ▁new ▁Object Key ▁( ▁Math ▁. ▁random ▁( ▁) ▁) ▁; ▁} ▁@ ▁Visible ForTesting ▁interface ▁On E very Frame Listener ▁{ ▁void ▁on Frame Ready ▁( ▁) ▁; ▁} ▁}
▁assertThat ▁( ▁terms ▁. ▁getName ▁( ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁; ▁List ▁< ▁? ▁extends ▁Terms ▁. ▁Bucket ▁> ▁buckets ▁= ▁terms ▁. ▁getBuckets ▁( ▁) ▁; ▁assertThat ▁( ▁buckets ▁. ▁size ▁( ▁) ▁, ▁equalTo ▁( ▁interval ▁) ▁) ▁; ▁List ▁< ▁String ▁> ▁min Keys ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁double ▁minValue ▁= ▁Double ▁. ▁POSITIVE _ INFINITY ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁interval ▁; ▁++ ▁i ▁) ▁{ ▁Terms ▁. ▁Bucket ▁bucket ▁= ▁buckets ▁. ▁get ▁( ▁i ▁) ▁; ▁assertThat ▁( ▁bucket ▁, ▁notNullValue ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁( ▁String ▁) ▁bucket ▁. ▁getKey ▁( ▁) ▁, ▁equalTo ▁( ▁STR ▁+ ▁( ▁i ▁ % ▁interval ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁bucket ▁. ▁get DocCount ▁( ▁) ▁, ▁greaterThan ▁( ▁0 L ▁) ▁) ▁; ▁Sum ▁sum ▁= ▁bucket ▁. ▁getAggregations ▁( ▁) ▁. ▁get ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁sum ▁, ▁notNullValue ▁( ▁) ▁) ▁; ▁if ▁( ▁sum ▁. ▁value ▁( ▁) ▁< ▁minValue ▁) ▁{ ▁minValue ▁= ▁sum ▁. ▁value ▁( ▁) ▁; ▁min Keys ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁min Keys ▁. ▁add ▁( ▁bucket ▁. ▁getKey AsString ▁( ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁sum ▁. ▁value ▁( ▁) ▁== ▁minValue ▁) ▁{ ▁min Keys ▁. ▁add ▁( ▁bucket ▁. ▁getKey AsString ▁( ▁) ▁) ▁; ▁} ▁} ▁Internal Bucket Metric Value ▁min Bucket Value ▁= ▁response ▁. ▁getAggregations ▁( ▁) ▁. ▁get ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁min Bucket Value ▁, ▁notNullValue ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁min Bucket Value ▁. ▁getName ▁( ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁min Bucket Value ▁. ▁value ▁( ▁) ▁, ▁equalTo ▁( ▁minValue ▁) ▁) ▁; ▁assertThat ▁( ▁min Bucket Value ▁. ▁keys ▁( ▁) ▁, ▁equalTo ▁( ▁min Keys ▁. ▁toArray ▁( ▁new ▁String ▁[ ▁min Keys ▁. ▁size ▁( ▁) ▁] ▁) ▁) ▁) ▁; ▁} ▁public ▁void ▁test Metric As Sub Agg ▁( ▁) ▁throws ▁Exception ▁{ ▁SearchResponse ▁response ▁= ▁client ▁( ▁) ▁. ▁prepareSearch ▁( ▁STR ▁) ▁. ▁add Aggregation ▁( ▁terms ▁( ▁STR ▁) ▁. ▁field ▁( ▁STR ▁) ▁. ▁order ▁( ▁Bucket Order ▁. ▁key ▁( ▁true ▁) ▁) ▁. ▁sub Aggregation ▁( ▁histogram ▁( ▁STR ▁) ▁. ▁field ▁( ▁SINGLE _ VALUE D _ FIELD _ NAME ▁) ▁. ▁interval ▁( ▁interval ▁) ▁. ▁extended Bounds ▁( ▁min Random Value ▁, ▁max Random Value ▁) ▁. ▁sub Aggregation ▁( ▁sum ▁( ▁STR ▁) ▁. ▁field ▁( ▁SINGLE _ VALUE D _ FIELD _ NAME ▁) ▁) ▁) ▁. ▁sub Aggregation ▁( ▁min Bucket ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁. ▁get ▁( ▁) ▁; ▁assert SearchResponse ▁( ▁response ▁) ▁; ▁Terms ▁terms ▁= ▁response ▁. ▁getAggregations ▁( ▁) ▁. ▁get ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁terms ▁, ▁notNullValue ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁terms ▁. ▁getName ▁( ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁;
▁public ▁abstract ▁class ▁VT Abstract Reference Program Correlator Factory ▁extends ▁VT Abstract Program Correlator Factory ▁{ ▁public ▁static ▁final ▁String ▁MEMORY _ MODE L ▁= ▁STR ▁; ▁public ▁static ▁final ▁L SH Memory Model ▁MEMORY _ MODE L _ DEFAULT ▁= ▁L SH Memory Model ▁. ▁L ARGE ▁; ▁public ▁static ▁final ▁String ▁MEMORY _ MODE L _ DESC ▁= ▁STR ▁; ▁public ▁static ▁final ▁String ▁CON FID ENCE _ THRESHOLD ▁= ▁STR ▁; ▁public ▁static ▁final ▁double ▁CON FID ENCE _ THRESHOLD _ DEFAULT ▁= ▁1 ▁; ▁public ▁static ▁final ▁String ▁CON FID ENCE _ THRESHOLD _ DESC ▁= ▁STR ▁; ▁public ▁static ▁final ▁String ▁S IM IL AR ITY _ THRESHOLD ▁= ▁STR ▁; ▁public ▁static ▁final ▁String ▁S IM IL AR ITY _ THRESHOLD _ DESC ▁= ▁STR ▁; ▁public ▁static ▁final ▁double ▁S IM IL AR ITY _ THRESHOLD _ DEFAULT ▁= ▁0.5 ▁; ▁public ▁static ▁final ▁String ▁REF INE _ RESULT S ▁= ▁STR ▁; ▁public ▁static ▁final ▁boolean ▁REF INE _ RESULT S _ DEFAULT ▁= ▁true ▁; ▁public ▁static ▁final ▁String ▁REF INE _ RESULT S _ DESC ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁help Location Topic ▁= ▁STR ▁; ▁public ▁String ▁corre lator Name ▁= ▁STR ▁; ▁protected ▁String ▁corre lator Description ▁= ▁STR ▁; ▁protected ▁String ▁help Location Anchor ▁= ▁STR ▁; ▁public ▁VT Abstract Reference Program Correlator Factory ▁( ▁) ▁{ ▁super ▁( ▁VT Program Correlator Address Re str iction Preference ▁. ▁RE STR I CTION _ NOT _ ALLOW ED ▁) ▁; ▁} ▁@ ▁Override ▁public ▁VT Options ▁createDefault Options ▁( ▁) ▁{ ▁VT Options ▁options ▁= ▁new ▁VT Options ▁( ▁corre lator Name ▁) ▁; ▁HelpLocation ▁help ▁= ▁new ▁HelpLocation ▁( ▁help Location Topic ▁, ▁help Location Anchor ▁) ▁; ▁options ▁. ▁setOptions HelpLocation ▁( ▁help ▁) ▁; ▁options ▁. ▁register Option ▁( ▁MEMORY _ MODE L ▁, ▁MEMORY _ MODE L _ DEFAULT ▁, ▁help ▁, ▁MEMORY _ MODE L _ DESC ▁) ▁; ▁options ▁. ▁register Option ▁( ▁CON FID ENCE _ THRESHOLD ▁, ▁CON FID ENCE _ THRESHOLD _ DEFAULT ▁, ▁help ▁, ▁CON FID ENCE _ THRESHOLD _ DESC ▁) ▁; ▁options ▁. ▁register Option ▁( ▁S IM IL AR ITY _ THRESHOLD ▁, ▁S IM IL AR ITY _ THRESHOLD _ DEFAULT ▁, ▁help ▁, ▁S IM IL AR ITY _ THRESHOLD _ DESC ▁) ▁; ▁options ▁. ▁register Option ▁( ▁REF INE _ RESULT S ▁, ▁REF INE _ RESULT S _ DEFAULT ▁, ▁help ▁, ▁REF INE _ RESULT S _ DESC ▁) ▁; ▁options ▁. ▁set Double ▁( ▁CON FID ENCE _ THRESHOLD ▁, ▁CON FID ENCE _ THRESHOLD _ DEFAULT ▁) ▁; ▁options ▁. ▁set Double ▁( ▁S IM IL AR ITY _ THRESHOLD ▁, ▁S IM IL AR ITY _ THRESHOLD _ DEFAULT ▁) ▁; ▁options ▁. ▁set Enum ▁( ▁MEMORY _ MODE L ▁, ▁MEMORY _ MODE L _ DEFAULT ▁) ▁; ▁options ▁. ▁setBoolean ▁( ▁REF INE _ RESULT S ▁, ▁REF INE _ RESULT S _ DEFAULT ▁) ▁; ▁return ▁options ▁; ▁}
▁Metadata ▁metadata ▁= ▁Metadata ▁. ▁builder ▁( ▁) ▁. ▁persistent Settings ▁( ▁settings ▁( ▁Version ▁. ▁CURRENT ▁) ▁. ▁build ▁( ▁) ▁) ▁. ▁put Custom ▁( ▁IndexLifecycle Metadata ▁. ▁TYPE ▁, ▁lifecycle Metadata ▁) ▁. ▁put ▁( ▁IndexMetadata ▁. ▁builder ▁( ▁STR ▁) ▁. ▁settings ▁( ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁. ▁put ▁( ▁STR ▁, ▁1 ▁) ▁. ▁put ▁( ▁STR ▁, ▁0 ▁) ▁. ▁put ▁( ▁STR ▁, ▁Version ▁. ▁CURRENT ▁. ▁id ▁) ▁. ▁put ▁( ▁Lifecycle Settings ▁. ▁LI F EC YCLE _ NAME ▁, ▁policy Name ▁) ▁) ▁. ▁put Custom ▁( ▁I L M _ C USTOM _ METADATA _ KEY ▁, ▁lifecycle State ▁. ▁build ▁( ▁) ▁. ▁asMap ▁( ▁) ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁try ▁( ▁XContentBuilder ▁builder ▁= ▁JsonXContent ▁. ▁contentBuilder ▁( ▁) ▁) ▁{ ▁builder ▁. ▁startObject ▁( ▁) ▁; ▁metadata ▁. ▁toXContent ▁( ▁builder ▁, ▁ToXContent ▁. ▁EMPTY _ PARAMS ▁) ▁; ▁builder ▁. ▁endObject ▁( ▁) ▁; ▁logger ▁. ▁info ▁( ▁STR ▁, ▁Strings ▁. ▁toString ▁( ▁builder ▁) ▁) ▁; ▁} ▁String ▁nodeId ▁= ▁randomAlpha OfLength ▁( ▁10 ▁) ▁; ▁DiscoveryNode ▁masterNode ▁= ▁DiscoveryNode ▁. ▁createLocal ▁( ▁Node Roles ▁. ▁masterNode ▁( ▁settings ▁( ▁Version ▁. ▁CURRENT ▁) ▁. ▁build ▁( ▁) ▁) ▁, ▁new ▁Transport Address ▁( ▁Transport Address ▁. ▁META _ ADDRESS ▁, ▁9 3 00 ▁) ▁, ▁nodeId ▁) ▁; ▁ClusterState ▁currentState ▁= ▁ClusterState ▁. ▁builder ▁( ▁ClusterName ▁. ▁DEFAULT ▁) ▁. ▁metadata ▁( ▁metadata ▁) ▁. ▁nodes ▁( ▁DiscoveryNodes ▁. ▁builder ▁( ▁) ▁. ▁local NodeId ▁( ▁nodeId ▁) ▁. ▁master NodeId ▁( ▁nodeId ▁) ▁. ▁add ▁( ▁masterNode ▁) ▁. ▁build ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁Policy Steps Registry ▁registry ▁= ▁new ▁Policy Steps Registry ▁( ▁NamedXContent Registry ▁. ▁EMPTY ▁, ▁client ▁, ▁null ▁) ▁; ▁registry ▁. ▁update ▁( ▁currentState ▁) ▁; ▁assertThat ▁( ▁registry ▁. ▁getFirst Step ▁( ▁new Policy ▁. ▁getName ▁( ▁) ▁) ▁, ▁equalTo ▁( ▁policy Steps ▁. ▁get ▁( ▁0 ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁registry ▁. ▁getL ifecycle Policy Map ▁( ▁) ▁. ▁size ▁( ▁) ▁, ▁equalTo ▁( ▁1 ▁) ▁) ▁; ▁assertNotNull ▁( ▁registry ▁. ▁getL ifecycle Policy Map ▁( ▁) ▁. ▁get ▁( ▁new Policy ▁. ▁getName ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁registry ▁. ▁getL ifecycle Policy Map ▁( ▁) ▁. ▁get ▁( ▁new Policy ▁. ▁getName ▁( ▁) ▁) ▁. ▁getHeaders ▁( ▁) ▁, ▁equalTo ▁( ▁headers ▁) ▁) ▁; ▁assertThat ▁( ▁registry ▁. ▁getFirst Step Map ▁( ▁) ▁. ▁size ▁( ▁) ▁, ▁equalTo ▁( ▁1 ▁) ▁) ▁; ▁assertThat ▁( ▁registry ▁. ▁getStep Map ▁( ▁) ▁. ▁size ▁( ▁) ▁, ▁equalTo ▁( ▁1 ▁) ▁) ▁; ▁Map ▁< ▁Step ▁. ▁StepKey ▁, ▁Step ▁> ▁registered Steps For Policy ▁= ▁registry ▁. ▁getStep Map ▁( ▁) ▁. ▁get ▁( ▁new Policy ▁. ▁getName ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁registered Steps For Policy ▁. ▁size ▁( ▁) ▁, ▁equalTo ▁( ▁policy Steps ▁. ▁size ▁( ▁) ▁) ▁) ▁;
▁public ▁class ▁AMD 64 Address Lowering Test ▁extends ▁Graal CompilerTest ▁{ ▁private ▁StructuredGraph ▁graph ▁; ▁private ▁AMD 64 Address Lowering ▁lower ing ▁; ▁@ ▁Before ▁public ▁void ▁check AMD 64 ▁( ▁) ▁{ ▁assumeTrue ▁( ▁STR ▁, ▁getTarget ▁( ▁) ▁. ▁arch ▁instanceof ▁AMD 64 ▁) ▁; ▁graph ▁= ▁new ▁StructuredGraph ▁. ▁Builder ▁( ▁getInitial Options ▁( ▁) ▁, ▁getDebug Context ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁lower ing ▁= ▁new ▁AMD 64 Address Lowering ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁convert Base And Index To Dis placement ▁( ▁) ▁{ ▁ValueNode ▁base ▁= ▁graph ▁. ▁unique ▁( ▁con st 64 ▁( ▁1000 ▁) ▁) ▁; ▁ValueNode ▁index ▁= ▁graph ▁. ▁unique ▁( ▁con st 64 ▁( ▁10 ▁) ▁) ▁; ▁Address Node ▁result ▁= ▁lower ing ▁. ▁lower ▁( ▁base ▁, ▁index ▁) ▁; ▁assert Address ▁( ▁result ▁, ▁null ▁, ▁null ▁, ▁Scale ▁. ▁T imes 1 ▁, ▁10 10 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁convert Base To Dis placement ▁( ▁) ▁{ ▁ValueNode ▁constant Address ▁= ▁graph ▁. ▁addOr Unique With Inputs ▁( ▁con st 64 ▁( ▁1000 ▁) ▁) ▁; ▁Address Node ▁result ▁= ▁lower ing ▁. ▁lower ▁( ▁constant Address ▁, ▁null ▁) ▁; ▁assert Address ▁( ▁result ▁, ▁null ▁, ▁null ▁, ▁Scale ▁. ▁T imes 1 ▁, ▁1000 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁convert Base And Sh if ted Index To Dis placement ▁( ▁) ▁{ ▁ValueNode ▁base ▁= ▁graph ▁. ▁addOr Unique With Inputs ▁( ▁con st 64 ▁( ▁1000 ▁) ▁) ▁; ▁ValueNode ▁index ▁= ▁graph ▁. ▁addOr Unique With Inputs ▁( ▁new ▁Left Shift Node ▁( ▁con st 64 ▁( ▁10 ▁) ▁, ▁con st 32 ▁( ▁1 ▁) ▁) ▁) ▁; ▁Address Node ▁result ▁= ▁lower ing ▁. ▁lower ▁( ▁base ▁, ▁index ▁) ▁; ▁assert Address ▁( ▁result ▁, ▁null ▁, ▁null ▁, ▁Scale ▁. ▁T imes 2 ▁, ▁10 20 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁convert Base And Neg ated Sh if ted Index To Dis placement ▁( ▁) ▁{ ▁ValueNode ▁base ▁= ▁graph ▁. ▁addOr Unique With Inputs ▁( ▁con st 64 ▁( ▁1000 ▁) ▁) ▁; ▁ValueNode ▁index ▁= ▁graph ▁. ▁addOr Unique With Inputs ▁( ▁new ▁Neg ate Node ▁( ▁new ▁Left Shift Node ▁( ▁con st 64 ▁( ▁10 ▁) ▁, ▁con st 32 ▁( ▁2 ▁) ▁) ▁) ▁) ▁; ▁Address Node ▁result ▁= ▁lower ing ▁. ▁lower ▁( ▁base ▁, ▁index ▁) ▁; ▁assert Address ▁( ▁result ▁, ▁null ▁, ▁null ▁, ▁Scale ▁. ▁T imes 4 ▁, ▁9 60 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁convert Neg ated Base And Neg ated Sh if ted Index To Dis placement ▁( ▁) ▁{ ▁ValueNode ▁base ▁= ▁graph ▁. ▁addOr Unique With Inputs ▁( ▁new ▁Neg ate Node ▁( ▁con st 64 ▁( ▁1000 ▁) ▁) ▁) ▁;
▁public ▁abstract ▁class ▁Binary Predicate ▁< ▁T ▁, ▁U ▁, ▁R ▁, ▁F ▁extends ▁Predicate Bi Function ▁< ▁T ▁, ▁U ▁, ▁R ▁> ▁> ▁extends ▁Binary ScalarFunction ▁{ ▁private ▁final ▁F ▁function ▁; ▁protected ▁Binary Predicate ▁( ▁Source ▁source ▁, ▁Expression ▁left ▁, ▁Expression ▁right ▁, ▁F ▁function ▁) ▁{ ▁super ▁( ▁source ▁, ▁left ▁, ▁right ▁) ▁; ▁this ▁. ▁function ▁= ▁function ▁; ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁@ ▁Override ▁public ▁R ▁fold ▁( ▁) ▁{ ▁return ▁function ▁( ▁) ▁. ▁apply ▁( ▁( ▁T ▁) ▁left ▁( ▁) ▁. ▁fold ▁( ▁) ▁, ▁( ▁U ▁) ▁right ▁( ▁) ▁. ▁fold ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁String ▁script MethodName ▁( ▁) ▁{ ▁return ▁function ▁. ▁script MethodName ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁Objects ▁. ▁hash ▁( ▁left ▁( ▁) ▁, ▁right ▁( ▁) ▁, ▁function ▁. ▁symbol ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁obj ▁) ▁{ ▁if ▁( ▁this ▁== ▁obj ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁obj ▁== ▁null ▁|| ▁getClass ▁( ▁) ▁!= ▁obj ▁. ▁getClass ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁Binary Predicate ▁< ▁? ▁, ▁? ▁, ▁? ▁, ▁? ▁> ▁other ▁= ▁( ▁Binary Predicate ▁< ▁? ▁, ▁? ▁, ▁? ▁, ▁? ▁> ▁) ▁obj ▁; ▁return ▁Objects ▁. ▁equals ▁( ▁symbol ▁( ▁) ▁, ▁other ▁. ▁symbol ▁( ▁) ▁) ▁&& ▁Objects ▁. ▁equals ▁( ▁left ▁( ▁) ▁, ▁other ▁. ▁left ▁( ▁) ▁) ▁&& ▁Objects ▁. ▁equals ▁( ▁right ▁( ▁) ▁, ▁other ▁. ▁right ▁( ▁) ▁) ▁; ▁} ▁public ▁String ▁symbol ▁( ▁) ▁{ ▁return ▁function ▁. ▁symbol ▁( ▁) ▁; ▁} ▁public ▁F ▁function ▁( ▁) ▁{ ▁return ▁function ▁; ▁} ▁@ ▁Override ▁public ▁String ▁node String ▁( ▁) ▁{ ▁return ▁left ▁( ▁) ▁. ▁node String ▁( ▁) ▁+ ▁STR ▁+ ▁symbol ▁( ▁) ▁+ ▁STR ▁+ ▁right ▁( ▁) ▁. ▁node String ▁( ▁) ▁; ▁} ▁}
▁@ ▁Override ▁public ▁L uminanceSource ▁crop ▁( ▁int ▁left ▁, ▁int ▁top ▁, ▁int ▁width ▁, ▁int ▁height ▁) ▁{ ▁return ▁new ▁Plan ar Y UV L uminanceSource ▁( ▁y uv Data ▁, ▁data Width ▁, ▁data Height ▁, ▁this ▁. ▁left ▁+ ▁left ▁, ▁this ▁. ▁top ▁+ ▁top ▁, ▁width ▁, ▁height ▁, ▁false ▁) ▁; ▁} ▁public ▁int ▁[ ▁] ▁render Thumbnail ▁( ▁) ▁{ ▁int ▁width ▁= ▁getWidth ▁( ▁) ▁ / ▁TH UM B N AIL _ SCALE _ FACTOR ▁; ▁int ▁height ▁= ▁getHeight ▁( ▁) ▁ / ▁TH UM B N AIL _ SCALE _ FACTOR ▁; ▁int ▁[ ▁] ▁pixel s ▁= ▁new ▁int ▁[ ▁width ▁ * ▁height ▁] ▁; ▁byte ▁[ ▁] ▁y uv ▁= ▁y uv Data ▁; ▁int ▁input Offset ▁= ▁top ▁ * ▁data Width ▁+ ▁left ▁; ▁for ▁( ▁int ▁y ▁= ▁0 ▁; ▁y ▁< ▁height ▁; ▁y ▁++ ▁) ▁{ ▁int ▁output Offset ▁= ▁y ▁ * ▁width ▁; ▁for ▁( ▁int ▁x ▁= ▁0 ▁; ▁x ▁< ▁width ▁; ▁x ▁++ ▁) ▁{ ▁int ▁g re y ▁= ▁y uv ▁[ ▁input Offset ▁+ ▁x ▁ * ▁TH UM B N AIL _ SCALE _ FACTOR ▁] ▁& ▁0 xff ▁; ▁pixel s ▁[ ▁output Offset ▁+ ▁x ▁] ▁= ▁0 xFF 000000 ▁| ▁( ▁g re y ▁ * ▁0 x 000 10 10 1 ▁) ▁; ▁} ▁input Offset ▁+= ▁data Width ▁ * ▁TH UM B N AIL _ SCALE _ FACTOR ▁; ▁} ▁return ▁pixel s ▁; ▁} ▁public ▁int ▁get Thumbnail Width ▁( ▁) ▁{ ▁return ▁getWidth ▁( ▁) ▁ / ▁TH UM B N AIL _ SCALE _ FACTOR ▁; ▁} ▁public ▁int ▁get Thumbnail Height ▁( ▁) ▁{ ▁return ▁getHeight ▁( ▁) ▁ / ▁TH UM B N AIL _ SCALE _ FACTOR ▁; ▁} ▁private ▁void ▁reverse H orizontal ▁( ▁int ▁width ▁, ▁int ▁height ▁) ▁{ ▁byte ▁[ ▁] ▁y uv Data ▁= ▁this ▁. ▁y uv Data ▁; ▁for ▁( ▁int ▁y ▁= ▁0 ▁, ▁row Start ▁= ▁top ▁ * ▁data Width ▁+ ▁left ▁; ▁y ▁< ▁height ▁; ▁y ▁++ ▁, ▁row Start ▁+= ▁data Width ▁) ▁{ ▁int ▁middle ▁= ▁row Start ▁+ ▁width ▁ / ▁2 ▁; ▁for ▁( ▁int ▁x 1 ▁= ▁row Start ▁, ▁x 2 ▁= ▁row Start ▁+ ▁width ▁- ▁1 ▁; ▁x 1 ▁< ▁middle ▁; ▁x 1 ▁++ ▁, ▁x 2 ▁-- ▁) ▁{ ▁byte ▁temp ▁= ▁y uv Data ▁[ ▁x 1 ▁] ▁; ▁y uv Data ▁[ ▁x 1 ▁] ▁= ▁y uv Data ▁[ ▁x 2 ▁] ▁; ▁y uv Data ▁[ ▁x 2 ▁] ▁= ▁temp ▁; ▁} ▁} ▁} ▁}
▁@ ▁Override ▁public ▁void ▁dispose ▁( ▁) ▁{ ▁if ▁( ▁e ager ▁) ▁{ ▁dispose Resource ▁( ▁) ▁; ▁upstream ▁. ▁dispose ▁( ▁) ▁; ▁upstream ▁= ▁Disposable Helper ▁. ▁DISPOSED ▁; ▁} ▁else ▁{ ▁upstream ▁. ▁dispose ▁( ▁) ▁; ▁upstream ▁= ▁Disposable Helper ▁. ▁DISPOSED ▁; ▁dispose Resource ▁( ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁boolean ▁isDisposed ▁( ▁) ▁{ ▁return ▁upstream ▁. ▁isDisposed ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁onSubscribe ▁( ▁Disposable ▁d ▁) ▁{ ▁if ▁( ▁Disposable Helper ▁. ▁validate ▁( ▁this ▁. ▁upstream ▁, ▁d ▁) ▁) ▁{ ▁this ▁. ▁upstream ▁= ▁d ▁; ▁downstream ▁. ▁onSubscribe ▁( ▁this ▁) ▁; ▁} ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁@ ▁Override ▁public ▁void ▁onSuccess ▁( ▁T ▁value ▁) ▁{ ▁upstream ▁= ▁Disposable Helper ▁. ▁DISPOSED ▁; ▁if ▁( ▁e ager ▁) ▁{ ▁Object ▁u ▁= ▁getAndSet ▁( ▁this ▁) ▁; ▁if ▁( ▁u ▁!= ▁this ▁) ▁{ ▁try ▁{ ▁dis po ser ▁. ▁accept ▁( ▁( ▁U ▁) ▁u ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁ex ▁) ▁{ ▁Exceptions ▁. ▁throwIfFatal ▁( ▁ex ▁) ▁; ▁downstream ▁. ▁onError ▁( ▁ex ▁) ▁; ▁return ▁; ▁} ▁} ▁else ▁{ ▁return ▁; ▁} ▁} ▁downstream ▁. ▁onSuccess ▁( ▁value ▁) ▁; ▁if ▁( ▁! ▁e ager ▁) ▁{ ▁dispose Resource ▁( ▁) ▁; ▁} ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁@ ▁Override ▁public ▁void ▁onError ▁( ▁Throwable ▁e ▁) ▁{ ▁upstream ▁= ▁Disposable Helper ▁. ▁DISPOSED ▁; ▁if ▁( ▁e ager ▁) ▁{ ▁Object ▁u ▁= ▁getAndSet ▁( ▁this ▁) ▁; ▁if ▁( ▁u ▁!= ▁this ▁) ▁{ ▁try ▁{ ▁dis po ser ▁. ▁accept ▁( ▁( ▁U ▁) ▁u ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁ex ▁) ▁{ ▁Exceptions ▁. ▁throwIfFatal ▁( ▁ex ▁) ▁; ▁e ▁= ▁new ▁Composite Exception ▁( ▁e ▁, ▁ex ▁) ▁; ▁} ▁} ▁else ▁{ ▁return ▁; ▁} ▁} ▁downstream ▁. ▁onError ▁( ▁e ▁) ▁; ▁if ▁( ▁! ▁e ager ▁) ▁{ ▁dispose Resource ▁( ▁) ▁; ▁} ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁void ▁dispose Resource ▁( ▁) ▁{ ▁Object ▁u ▁= ▁getAndSet ▁( ▁this ▁) ▁; ▁if ▁( ▁u ▁!= ▁this ▁) ▁{ ▁try ▁{ ▁dis po ser ▁. ▁accept ▁( ▁( ▁U ▁) ▁u ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁ex ▁) ▁{ ▁Exceptions ▁. ▁throwIfFatal ▁( ▁ex ▁) ▁; ▁RxJavaPlugins ▁. ▁onError ▁( ▁ex ▁) ▁; ▁} ▁} ▁} ▁} ▁}
▁@ ▁Gener ates ▁Currency ▁generate C urrency ▁( ▁) ▁{ ▁try ▁{ ▁Method ▁method ▁= ▁Currency ▁. ▁class ▁. ▁getMethod ▁( ▁STR ▁) ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁Set ▁< ▁Currency ▁> ▁curr encies ▁= ▁( ▁Set ▁< ▁Currency ▁> ▁) ▁method ▁. ▁invoke ▁( ▁null ▁) ▁; ▁return ▁pick Instance ▁( ▁curr encies ▁, ▁Currency ▁. ▁getInstance ▁( ▁Locale ▁. ▁US ▁) ▁) ▁; ▁} ▁catch ▁( ▁NoSuch MethodException ▁not Java 7 ▁) ▁{ ▁return ▁pre Java 7 F resh C urrency ▁( ▁) ▁; ▁} ▁catch ▁( ▁Invocation TargetException ▁not Java 7 ▁) ▁{ ▁return ▁pre Java 7 F resh C urrency ▁( ▁) ▁; ▁} ▁catch ▁( ▁Illegal AccessException ▁imp ossible ▁) ▁{ ▁throw ▁new ▁AssertionError ▁( ▁imp ossible ▁) ▁; ▁} ▁} ▁private ▁Currency ▁pre Java 7 F resh C urrency ▁( ▁) ▁{ ▁for ▁( ▁Set ▁< ▁Locale ▁> ▁use less Local es ▁= ▁Sets ▁. ▁newHashSet ▁( ▁) ▁; ▁; ▁) ▁{ ▁Locale ▁locale ▁= ▁generate Locale ▁( ▁) ▁; ▁if ▁( ▁use less Local es ▁. ▁contains ▁( ▁locale ▁) ▁) ▁{ ▁return ▁Currency ▁. ▁getInstance ▁( ▁Locale ▁. ▁US ▁) ▁; ▁} ▁try ▁{ ▁return ▁Currency ▁. ▁getInstance ▁( ▁locale ▁) ▁; ▁} ▁catch ▁( ▁IllegalArgument Exception ▁e ▁) ▁{ ▁use less Local es ▁. ▁add ▁( ▁locale ▁) ▁; ▁} ▁} ▁} ▁@ ▁Empty ▁< ▁T ▁> ▁com ▁. ▁google ▁. ▁common ▁. ▁base ▁. ▁Optional ▁< ▁T ▁> ▁generate G oogle Optional ▁( ▁) ▁{ ▁return ▁com ▁. ▁google ▁. ▁common ▁. ▁base ▁. ▁Optional ▁. ▁absent ▁( ▁) ▁; ▁} ▁@ ▁Gener ates ▁< ▁T ▁> ▁com ▁. ▁google ▁. ▁common ▁. ▁base ▁. ▁Optional ▁< ▁T ▁> ▁generate G oogle Optional ▁( ▁T ▁value ▁) ▁{ ▁return ▁com ▁. ▁google ▁. ▁common ▁. ▁base ▁. ▁Optional ▁. ▁of ▁( ▁value ▁) ▁; ▁} ▁@ ▁Gener ates ▁Joiner ▁generate Joiner ▁( ▁) ▁{ ▁return ▁Joiner ▁. ▁on ▁( ▁generate String ▁( ▁) ▁) ▁; ▁} ▁@ ▁Gener ates ▁Splitter ▁generate Splitter ▁( ▁) ▁{ ▁return ▁Splitter ▁. ▁on ▁( ▁generate String ▁( ▁) ▁) ▁; ▁} ▁@ ▁Gener ates ▁< ▁T ▁> ▁Equivalence ▁< ▁T ▁> ▁generate Equivalence ▁( ▁) ▁{ ▁return ▁new ▁Equivalence ▁< ▁T ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁protected ▁boolean ▁do Equivalent ▁( ▁T ▁a ▁, ▁T ▁b ▁) ▁{ ▁return ▁false ▁; ▁} ▁@ ▁Override ▁protected ▁int ▁do Hash ▁( ▁T ▁t ▁) ▁{ ▁return ▁0 ▁; ▁} ▁final ▁String ▁string ▁= ▁param String ▁( ▁Equivalence ▁. ▁class ▁, ▁generate Int ▁( ▁) ▁) ▁; ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁string ▁; ▁} ▁} ▁; ▁} ▁@ ▁Gener ates ▁CharMatcher ▁generate Char Matcher ▁( ▁) ▁{ ▁return ▁new ▁CharMatcher ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁boolean ▁matches ▁( ▁char ▁c ▁) ▁{ ▁return ▁false ▁; ▁} ▁final ▁String ▁string ▁= ▁param String ▁( ▁CharMatcher ▁. ▁class ▁, ▁generate Int ▁( ▁) ▁) ▁; ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁string ▁; ▁} ▁} ▁; ▁}
▁abstract ▁class ▁Aut owire Utils ▁{ ▁public ▁static ▁final ▁Comparator ▁< ▁Executable ▁> ▁EXEC UT ABLE _ COMP ARATOR ▁= ▁( ▁e 1 ▁, ▁e 2 ▁) ▁-> ▁{ ▁int ▁result ▁= ▁Boolean ▁. ▁compare ▁( ▁Modifier ▁. ▁isPublic ▁( ▁e 2 ▁. ▁getModifiers ▁( ▁) ▁) ▁, ▁Modifier ▁. ▁isPublic ▁( ▁e 1 ▁. ▁getModifiers ▁( ▁) ▁) ▁) ▁; ▁return ▁result ▁!= ▁0 ▁? ▁result ▁: ▁Integer ▁. ▁compare ▁( ▁e 2 ▁. ▁getParameter Count ▁( ▁) ▁, ▁e 1 ▁. ▁getParameter Count ▁( ▁) ▁) ▁; ▁} ▁; ▁public ▁static ▁void ▁sort Constructors ▁( ▁Constructor ▁< ▁? ▁> ▁[ ▁] ▁construct ors ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁construct ors ▁, ▁EXEC UT ABLE _ COMP ARATOR ▁) ▁; ▁} ▁public ▁static ▁void ▁sort Factory Methods ▁( ▁Method ▁[ ▁] ▁factory Methods ▁) ▁{ ▁Arrays ▁. ▁sort ▁( ▁factory Methods ▁, ▁EXEC UT ABLE _ COMP ARATOR ▁) ▁; ▁} ▁public ▁static ▁boolean ▁is Excluded From Dependency Check ▁( ▁Property Descriptor ▁pd ▁) ▁{ ▁Method ▁w m ▁= ▁pd ▁. ▁getWrite Method ▁( ▁) ▁; ▁if ▁( ▁w m ▁== ▁null ▁) ▁{ ▁return ▁false ▁; ▁} ▁if ▁( ▁! ▁w m ▁. ▁getDecl aringClass ▁( ▁) ▁. ▁getName ▁( ▁) ▁. ▁contains ▁( ▁STR ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁Class ▁< ▁? ▁> ▁super class ▁= ▁w m ▁. ▁getDecl aringClass ▁( ▁) ▁. ▁getSuperclass ▁( ▁) ▁; ▁return ▁! ▁ClassUtils ▁. ▁has Method ▁( ▁super class ▁, ▁w m ▁) ▁; ▁} ▁public ▁static ▁boolean ▁is Setter Defined In Interface ▁( ▁Property Descriptor ▁pd ▁, ▁Set ▁< ▁Class ▁< ▁? ▁> ▁> ▁interfaces ▁) ▁{ ▁Method ▁setter ▁= ▁pd ▁. ▁getWrite Method ▁( ▁) ▁; ▁if ▁( ▁setter ▁!= ▁null ▁) ▁{ ▁Class ▁< ▁? ▁> ▁targetClass ▁= ▁setter ▁. ▁getDecl aringClass ▁( ▁) ▁; ▁for ▁( ▁Class ▁< ▁? ▁> ▁if c ▁: ▁interfaces ▁) ▁{ ▁if ▁( ▁if c ▁. ▁isAssignable From ▁( ▁targetClass ▁) ▁&& ▁ClassUtils ▁. ▁has Method ▁( ▁if c ▁, ▁setter ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁Object ▁resolve Aut ow iring Value ▁( ▁Object ▁aut ow iring Value ▁, ▁Class ▁< ▁? ▁> ▁required Type ▁) ▁{ ▁if ▁( ▁aut ow iring Value ▁instanceof ▁Object Factory ▁&& ▁! ▁required Type ▁. ▁isInstance ▁( ▁aut ow iring Value ▁) ▁) ▁{ ▁Object Factory ▁< ▁? ▁> ▁factory ▁= ▁( ▁Object Factory ▁< ▁? ▁> ▁) ▁aut ow iring Value ▁; ▁if ▁( ▁aut ow iring Value ▁instanceof ▁Serializable ▁&& ▁required Type ▁. ▁isInterface ▁( ▁) ▁) ▁{ ▁aut ow iring Value ▁= ▁Proxy ▁. ▁new Proxy Instance ▁( ▁required Type ▁. ▁getClassLoader ▁( ▁) ▁, ▁new ▁Class ▁< ▁? ▁> ▁[ ▁] ▁{ ▁required Type ▁} ▁, ▁new ▁Object Factory De legating Invocation Handler ▁( ▁factory ▁) ▁) ▁; ▁} ▁else ▁{ ▁return ▁factory ▁. ▁getObject ▁( ▁) ▁; ▁} ▁} ▁return ▁aut ow iring Value ▁; ▁}
▁private ▁static ▁Pair ▁< ▁Long ▁, ▁Long ▁> ▁line arly Inter p olate ▁( ▁long ▁x ▁, ▁long ▁[ ▁] ▁x References ▁, ▁long ▁[ ▁] ▁y References ▁) ▁{ ▁int ▁previous Reference Index ▁= ▁Util ▁. ▁binarySearch Floor ▁( ▁x References ▁, ▁x ▁, ▁true ▁, ▁true ▁) ▁; ▁long ▁x Previous Reference ▁= ▁x References ▁[ ▁previous Reference Index ▁] ▁; ▁long ▁y Previous Reference ▁= ▁y References ▁[ ▁previous Reference Index ▁] ▁; ▁int ▁next Reference Index ▁= ▁previous Reference Index ▁+ ▁1 ▁; ▁if ▁( ▁next Reference Index ▁== ▁x References ▁. ▁length ▁) ▁{ ▁return ▁Pair ▁. ▁create ▁( ▁x Previous Reference ▁, ▁y Previous Reference ▁) ▁; ▁} ▁else ▁{ ▁long ▁x Next Reference ▁= ▁x References ▁[ ▁next Reference Index ▁] ▁; ▁long ▁y Next Reference ▁= ▁y References ▁[ ▁next Reference Index ▁] ▁; ▁double ▁pro port ion ▁= ▁x Next Reference ▁== ▁x Previous Reference ▁? ▁0.0 ▁: ▁( ▁( ▁double ▁) ▁x ▁- ▁x Previous Reference ▁) ▁ / ▁( ▁x Next Reference ▁- ▁x Previous Reference ▁) ▁; ▁long ▁y ▁= ▁( ▁long ▁) ▁( ▁pro port ion ▁ * ▁( ▁y Next Reference ▁- ▁y Previous Reference ▁) ▁) ▁+ ▁y Previous Reference ▁; ▁return ▁Pair ▁. ▁create ▁( ▁x ▁, ▁y ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁long ▁getData End Position ▁( ▁) ▁{ ▁return ▁C ▁. ▁POSITION _ UNSET ▁; ▁} ▁}
▁public ▁class ▁P eer Recovery Target Service Tests ▁extends ▁IndexShard TestCase ▁{ ▁public ▁void ▁testWrite File Chunks Concurrent ly ▁( ▁) ▁throws ▁Exception ▁{ ▁IndexShard ▁source Shard ▁= ▁new Started Shard ▁( ▁true ▁) ▁; ▁int ▁num Docs ▁= ▁between ▁( ▁20 ▁, ▁100 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁num Docs ▁; ▁i ▁++ ▁) ▁{ ▁index Doc ▁( ▁source Shard ▁, ▁STR ▁, ▁Integer ▁. ▁toString ▁( ▁i ▁) ▁) ▁; ▁} ▁source Shard ▁. ▁flush ▁( ▁new ▁Flush Request ▁( ▁) ▁) ▁; ▁Store ▁. ▁Metadata Snapshot ▁source Snapshot ▁= ▁source Shard ▁. ▁store ▁( ▁) ▁. ▁getMetadata ▁( ▁null ▁) ▁; ▁List ▁< ▁Store File Metadata ▁> ▁md Files ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁Store File Metadata ▁md ▁: ▁source Snapshot ▁) ▁{ ▁md Files ▁. ▁add ▁( ▁md ▁) ▁; ▁} ▁final ▁IndexShard ▁target Shard ▁= ▁new Shard ▁( ▁false ▁) ▁; ▁final ▁DiscoveryNode ▁p Node ▁= ▁getF ake Dis co Node ▁( ▁source Shard ▁. ▁routing Entry ▁( ▁) ▁. ▁current NodeId ▁( ▁) ▁) ▁; ▁final ▁DiscoveryNode ▁r Node ▁= ▁getF ake Dis co Node ▁( ▁target Shard ▁. ▁routing Entry ▁( ▁) ▁. ▁current NodeId ▁( ▁) ▁) ▁; ▁target Shard ▁. ▁mark As Recover ing ▁( ▁STR ▁, ▁new ▁Recovery State ▁( ▁target Shard ▁. ▁routing Entry ▁( ▁) ▁, ▁r Node ▁, ▁p Node ▁) ▁) ▁; ▁final ▁Recovery Target ▁recovery Target ▁= ▁new ▁Recovery Target ▁( ▁target Shard ▁, ▁null ▁, ▁null ▁) ▁; ▁final ▁Plain ActionFuture ▁< ▁Void ▁> ▁receive FileInfo Future ▁= ▁new ▁Plain ActionFuture ▁< ▁> ▁( ▁) ▁; ▁recovery Target ▁. ▁receive FileInfo ▁( ▁md Files ▁. ▁stream ▁( ▁) ▁. ▁map ▁( ▁Store File Metadata ▁:: ▁name ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toList ▁( ▁) ▁) ▁, ▁md Files ▁. ▁stream ▁( ▁) ▁. ▁map ▁( ▁Store File Metadata ▁:: ▁length ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toList ▁( ▁) ▁) ▁, ▁Collections ▁. ▁emptyList ▁( ▁) ▁, ▁Collections ▁. ▁emptyList ▁( ▁) ▁, ▁0 ▁, ▁receive FileInfo Future ▁) ▁; ▁receive FileInfo Future ▁. ▁actionGet ▁( ▁) ▁; ▁List ▁< ▁Recovery File Chunk Request ▁> ▁requests ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁long ▁seqNo ▁= ▁0 ▁; ▁for ▁( ▁Store File Metadata ▁md ▁: ▁md Files ▁) ▁{ ▁try ▁( ▁Index Input ▁in ▁= ▁source Shard ▁. ▁store ▁( ▁) ▁. ▁directory ▁( ▁) ▁. ▁open Input ▁( ▁md ▁. ▁name ▁( ▁) ▁, ▁IO Context ▁. ▁READ ON CE ▁) ▁) ▁{ ▁int ▁pos ▁= ▁0 ▁; ▁while ▁( ▁pos ▁< ▁md ▁. ▁length ▁( ▁) ▁) ▁{ ▁int ▁length ▁= ▁between ▁( ▁1 ▁, ▁Math ▁. ▁toIntExact ▁( ▁md ▁. ▁length ▁( ▁) ▁- ▁pos ▁) ▁) ▁; ▁byte ▁[ ▁] ▁buffer ▁= ▁new ▁byte ▁[ ▁length ▁] ▁; ▁in ▁. ▁readBytes ▁( ▁buffer ▁, ▁0 ▁, ▁length ▁) ▁;
▁body ▁. ▁append ▁( ▁blockBuilder ▁. ▁invoke ▁( ▁STR ▁, ▁Block ▁. ▁class ▁) ▁) ▁; ▁one Line Description ▁= ▁STR ▁+ ▁array ▁+ ▁STR ▁+ ▁mapper Description ▁+ ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁BytecodeNode ▁getByte code ▁( ▁Method Generation Context ▁generation Context ▁) ▁{ ▁return ▁body ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁BytecodeNode ▁> ▁getChild Nodes ▁( ▁) ▁{ ▁return ▁ImmutableList ▁. ▁of ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁String ▁format One Line ▁( ▁) ▁{ ▁return ▁one Line Description ▁; ▁} ▁}
▁check Signature s ▁( ▁STR ▁, ▁STR ▁) ▁; ▁function Signature Markup Items ▁= ▁getSpec ific Type Of Markup ▁( ▁Function Signature Markup Type ▁. ▁class ▁, ▁test Match ▁, ▁true ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁function Signature Markup Items ▁. ▁size ▁( ▁) ▁) ▁; ▁check Markup Status ▁( ▁function Signature Markup Items ▁, ▁VTMarkupItem Status ▁. ▁UN APP LI ED ▁) ▁; ▁check Inline Flags ▁( ▁true ▁, ▁false ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Same Param Count _ Not Inline Not Inline ▁( ▁) ▁{ ▁use Match ▁( ▁STR ▁, ▁STR ▁) ▁; ▁set Inline ▁( ▁source Function ▁, ▁false ▁) ▁; ▁set Inline ▁( ▁destination Function ▁, ▁false ▁) ▁; ▁check Signature s ▁( ▁STR ▁, ▁STR ▁) ▁; ▁ToolOptions ▁apply Options ▁= ▁vt Test Env ▁. ▁getV T Controller ▁( ▁) ▁. ▁getOptions ▁( ▁) ▁; ▁set Apply Markup Options To Defaults ▁( ▁apply Options ▁) ▁; ▁List ▁< ▁VTMarkupItem ▁> ▁function Signature Markup Items ▁= ▁getSpec ific Type Of Markup ▁( ▁Function Signature Markup Type ▁. ▁class ▁, ▁test Match ▁, ▁true ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁function Signature Markup Items ▁. ▁size ▁( ▁) ▁) ▁; ▁check Markup Status ▁( ▁function Signature Markup Items ▁, ▁VTMarkupItem Status ▁. ▁UN APP LI ED ▁) ▁; ▁check Inline Flags ▁( ▁false ▁, ▁false ▁) ▁; ▁apply Function Signature Markup ▁( ▁function Signature Markup Items ▁) ▁; ▁check Signature s ▁( ▁STR ▁, ▁STR ▁) ▁; ▁function Signature Markup Items ▁= ▁getSpec ific Type Of Markup ▁( ▁Function Signature Markup Type ▁. ▁class ▁, ▁test Match ▁, ▁false ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁function Signature Markup Items ▁. ▁size ▁( ▁) ▁) ▁; ▁check Markup Status ▁( ▁function Signature Markup Items ▁, ▁VTMarkupItem Status ▁. ▁REPLACE D ▁) ▁; ▁check Inline Flags ▁( ▁false ▁, ▁false ▁) ▁; ▁un app ly Function Signature Markup ▁( ▁function Signature Markup Items ▁) ▁; ▁check Signature s ▁( ▁STR ▁, ▁STR ▁) ▁; ▁function Signature Markup Items ▁= ▁getSpec ific Type Of Markup ▁( ▁Function Signature Markup Type ▁. ▁class ▁, ▁test Match ▁, ▁true ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁function Signature Markup Items ▁. ▁size ▁( ▁) ▁) ▁; ▁check Markup Status ▁( ▁function Signature Markup Items ▁, ▁VTMarkupItem Status ▁. ▁UN APP LI ED ▁) ▁; ▁check Inline Flags ▁( ▁false ▁, ▁false ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Same Param Count _ Inline Inline ▁( ▁) ▁{ ▁use Match ▁( ▁STR ▁, ▁STR ▁) ▁; ▁set Inline ▁( ▁source Function ▁, ▁true ▁) ▁; ▁set Inline ▁( ▁destination Function ▁, ▁true ▁) ▁; ▁check Signature s ▁( ▁STR ▁, ▁STR ▁) ▁; ▁ToolOptions ▁apply Options ▁= ▁vt Test Env ▁. ▁getV T Controller ▁( ▁) ▁. ▁getOptions ▁( ▁) ▁; ▁set Apply Markup Options To Defaults ▁( ▁apply Options ▁) ▁; ▁List ▁< ▁VTMarkupItem ▁> ▁function Signature Markup Items ▁= ▁getSpec ific Type Of Markup ▁( ▁Function Signature Markup Type ▁. ▁class ▁, ▁test Match ▁, ▁true ▁) ▁;
▁assertEquals ▁( ▁STR ▁, ▁relative To Work ing ▁( ▁sub dir ▁. ▁toUri ▁( ▁) ▁. ▁getPath ▁( ▁) ▁) ▁) ▁; ▁Path ▁sub sub dir ▁= ▁new ▁Path ▁( ▁sub dir ▁, ▁STR ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁relative To Work ing ▁( ▁sub sub dir ▁. ▁toUri ▁( ▁) ▁. ▁getPath ▁( ▁) ▁) ▁) ▁; ▁Path ▁parent ▁= ▁new ▁Path ▁( ▁c wd Path ▁, ▁STR ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁relative To Work ing ▁( ▁parent ▁. ▁toUri ▁( ▁) ▁. ▁getPath ▁( ▁) ▁) ▁) ▁; ▁Path ▁side ways ▁= ▁new ▁Path ▁( ▁parent ▁, ▁STR ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁relative To Work ing ▁( ▁side ways ▁. ▁toUri ▁( ▁) ▁. ▁getPath ▁( ▁) ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Volume Normalization ▁( ▁) ▁throws ▁Throwable ▁{ ▁LOG ▁. ▁info ▁( ▁STR ▁+ ▁TEST _ ROOT _ DIR ▁) ▁; ▁String ▁relative Test Root ▁= ▁relative To Work ing ▁( ▁TEST _ ROOT _ DIR ▁) ▁; ▁FileSystem ▁local FileSystem ▁= ▁FileSystem ▁. ▁getLocal ▁( ▁new ▁Configuration ▁( ▁) ▁) ▁; ▁String ▁[ ▁] ▁vol s ▁= ▁new ▁String ▁[ ▁] ▁{ ▁relative Test Root ▁+ ▁STR ▁, ▁relative Test Root ▁+ ▁STR ▁} ▁; ▁Path ▁del Dir ▁= ▁new ▁Path ▁( ▁vol s ▁[ ▁0 ▁] ▁, ▁MR Async Disk Service ▁. ▁T OB E DE LETED ▁) ▁; ▁local FileSystem ▁. ▁mkdirs ▁( ▁del Dir ▁) ▁; ▁local FileSystem ▁. ▁create ▁( ▁new ▁Path ▁( ▁del Dir ▁, ▁STR ▁) ▁) ▁. ▁close ▁( ▁) ▁; ▁MR Async Disk Service ▁service ▁= ▁new ▁MR Async Disk Service ▁( ▁local FileSystem ▁, ▁vol s ▁) ▁; ▁make S ure Clean ed Up ▁( ▁vol s ▁, ▁service ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test MR Async Disk Service ▁( ▁) ▁throws ▁Throwable ▁{ ▁FileSystem ▁local FileSystem ▁= ▁FileSystem ▁. ▁getLocal ▁( ▁new ▁Configuration ▁( ▁) ▁) ▁; ▁String ▁[ ▁] ▁vol s ▁= ▁new ▁String ▁[ ▁] ▁{ ▁TEST _ ROOT _ DIR ▁+ ▁STR ▁, ▁TEST _ ROOT _ DIR ▁+ ▁STR ▁} ▁; ▁MR Async Disk Service ▁service ▁= ▁new ▁MR Async Disk Service ▁( ▁local FileSystem ▁, ▁vol s ▁) ▁; ▁String ▁a ▁= ▁STR ▁; ▁String ▁b ▁= ▁STR ▁; ▁String ▁c ▁= ▁STR ▁; ▁String ▁d ▁= ▁STR ▁; ▁File ▁f a ▁= ▁new ▁File ▁( ▁vol s ▁[ ▁0 ▁] ▁, ▁a ▁) ▁; ▁File ▁fb ▁= ▁new ▁File ▁( ▁vol s ▁[ ▁1 ▁] ▁, ▁b ▁) ▁; ▁File ▁fc ▁= ▁new ▁File ▁( ▁vol s ▁[ ▁1 ▁] ▁, ▁c ▁) ▁; ▁File ▁fd ▁= ▁new ▁File ▁( ▁vol s ▁[ ▁1 ▁] ▁, ▁d ▁) ▁; ▁f a ▁. ▁mkdirs ▁( ▁) ▁; ▁fb ▁. ▁mkdirs ▁( ▁) ▁; ▁fc ▁. ▁mkdirs ▁( ▁) ▁; ▁fd ▁. ▁mkdirs ▁( ▁) ▁; ▁assertTrue ▁( ▁f a ▁. ▁exists ▁( ▁) ▁) ▁; ▁assertTrue ▁( ▁fb ▁. ▁exists ▁( ▁) ▁) ▁; ▁assertTrue ▁( ▁fc ▁. ▁exists ▁( ▁) ▁) ▁;
▁public ▁class ▁Distance Between Points Service UnitTest ▁{ ▁private ▁Distance Between Points Service ▁service ▁= ▁new ▁Distance Between Points Service ▁( ▁) ▁; ▁@ ▁Test ▁public ▁void ▁givenTwo Points _ when Calc ulate Distance By Form ul a _ thenCorrect ▁( ▁) ▁{ ▁double ▁x 1 ▁= ▁3 ▁; ▁double ▁y 1 ▁= ▁4 ▁; ▁double ▁x 2 ▁= ▁7 ▁; ▁double ▁y 2 ▁= ▁1 ▁; ▁double ▁distance ▁= ▁service ▁. ▁calculate Distance Between Points ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁) ▁; ▁assertEquals ▁( ▁distance ▁, ▁5 ▁, ▁0.001 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁givenTwo Points _ when Calc ulate Distance With H y p ot _ thenCorrect ▁( ▁) ▁{ ▁double ▁x 1 ▁= ▁3 ▁; ▁double ▁y 1 ▁= ▁4 ▁; ▁double ▁x 2 ▁= ▁7 ▁; ▁double ▁y 2 ▁= ▁1 ▁; ▁double ▁distance ▁= ▁service ▁. ▁calculate Distance Between Point sWith H y p ot ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁) ▁; ▁assertEquals ▁( ▁distance ▁, ▁5 ▁, ▁0.001 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁givenTwo Points _ when Calc ulate Distance With Point 2 D _ thenCorrect ▁( ▁) ▁{ ▁double ▁x 1 ▁= ▁3 ▁; ▁double ▁y 1 ▁= ▁4 ▁; ▁double ▁x 2 ▁= ▁7 ▁; ▁double ▁y 2 ▁= ▁1 ▁; ▁double ▁distance ▁= ▁service ▁. ▁calculate Distance Between Point sWith Point 2 D ▁( ▁x 1 ▁, ▁y 1 ▁, ▁x 2 ▁, ▁y 2 ▁) ▁; ▁assertEquals ▁( ▁distance ▁, ▁5 ▁, ▁0.001 ▁) ▁; ▁} ▁}
▁@ ▁GwtIncompatible ▁public ▁static ▁< ▁E ▁> ▁Linked BlockingQueue ▁< ▁E ▁> ▁new Linked BlockingQueue ▁( ▁Iterable ▁< ▁? ▁extends ▁E ▁> ▁elements ▁) ▁{ ▁if ▁( ▁elements ▁instanceof ▁Collection ▁) ▁{ ▁return ▁new ▁Linked BlockingQueue ▁< ▁E ▁> ▁( ▁( ▁Collection ▁< ▁? ▁extends ▁E ▁> ▁) ▁elements ▁) ▁; ▁} ▁Linked BlockingQueue ▁< ▁E ▁> ▁queue ▁= ▁new ▁Linked BlockingQueue ▁< ▁E ▁> ▁( ▁) ▁; ▁Iterables ▁. ▁addAll ▁( ▁queue ▁, ▁elements ▁) ▁; ▁return ▁queue ▁; ▁} ▁@ ▁GwtIncompatible ▁public ▁static ▁< ▁E ▁extends ▁Comparable ▁> ▁Priority BlockingQueue ▁< ▁E ▁> ▁new Priority BlockingQueue ▁( ▁) ▁{ ▁return ▁new ▁Priority BlockingQueue ▁< ▁E ▁> ▁( ▁) ▁; ▁} ▁@ ▁GwtIncompatible ▁public ▁static ▁< ▁E ▁extends ▁Comparable ▁> ▁Priority BlockingQueue ▁< ▁E ▁> ▁new Priority BlockingQueue ▁( ▁Iterable ▁< ▁? ▁extends ▁E ▁> ▁elements ▁) ▁{ ▁if ▁( ▁elements ▁instanceof ▁Collection ▁) ▁{ ▁return ▁new ▁Priority BlockingQueue ▁< ▁E ▁> ▁( ▁( ▁Collection ▁< ▁? ▁extends ▁E ▁> ▁) ▁elements ▁) ▁; ▁} ▁Priority BlockingQueue ▁< ▁E ▁> ▁queue ▁= ▁new ▁Priority BlockingQueue ▁< ▁E ▁> ▁( ▁) ▁; ▁Iterables ▁. ▁addAll ▁( ▁queue ▁, ▁elements ▁) ▁; ▁return ▁queue ▁; ▁} ▁public ▁static ▁< ▁E ▁extends ▁Comparable ▁> ▁PriorityQueue ▁< ▁E ▁> ▁new PriorityQueue ▁( ▁) ▁{ ▁return ▁new ▁PriorityQueue ▁< ▁E ▁> ▁( ▁) ▁; ▁} ▁public ▁static ▁< ▁E ▁extends ▁Comparable ▁> ▁PriorityQueue ▁< ▁E ▁> ▁new PriorityQueue ▁( ▁Iterable ▁< ▁? ▁extends ▁E ▁> ▁elements ▁) ▁{ ▁if ▁( ▁elements ▁instanceof ▁Collection ▁) ▁{ ▁return ▁new ▁PriorityQueue ▁< ▁E ▁> ▁( ▁( ▁Collection ▁< ▁? ▁extends ▁E ▁> ▁) ▁elements ▁) ▁; ▁} ▁PriorityQueue ▁< ▁E ▁> ▁queue ▁= ▁new ▁PriorityQueue ▁< ▁E ▁> ▁( ▁) ▁; ▁Iterables ▁. ▁addAll ▁( ▁queue ▁, ▁elements ▁) ▁; ▁return ▁queue ▁; ▁} ▁@ ▁GwtIncompatible ▁public ▁static ▁< ▁E ▁> ▁S ynchronous Queue ▁< ▁E ▁> ▁new Synchron ous Queue ▁( ▁) ▁{ ▁return ▁new ▁S ynchronous Queue ▁< ▁E ▁> ▁( ▁) ▁; ▁} ▁@ ▁Beta ▁@ ▁CanIgnore ReturnValue ▁@ ▁GwtIncompatible ▁public ▁static ▁< ▁E ▁> ▁int ▁drain ▁( ▁BlockingQueue ▁< ▁E ▁> ▁q ▁, ▁Collection ▁< ▁? ▁super ▁E ▁> ▁buffer ▁, ▁int ▁numElements ▁, ▁java ▁. ▁time ▁. ▁Duration ▁timeout ▁) ▁throws ▁Interrupted Exception ▁{ ▁return ▁drain ▁( ▁q ▁, ▁buffer ▁, ▁numElements ▁, ▁timeout ▁. ▁toNanos ▁( ▁) ▁, ▁TimeUnit ▁. ▁NANOSECONDS ▁) ▁; ▁} ▁@ ▁Beta ▁@ ▁CanIgnore ReturnValue ▁@ ▁GwtIncompatible ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁static ▁< ▁E ▁> ▁int ▁drain ▁( ▁BlockingQueue ▁< ▁E ▁> ▁q ▁, ▁Collection ▁< ▁? ▁super ▁E ▁> ▁buffer ▁, ▁int ▁numElements ▁, ▁long ▁timeout ▁, ▁TimeUnit ▁unit ▁) ▁throws ▁Interrupted Exception ▁{ ▁Preconditions ▁. ▁checkNotNull ▁( ▁buffer ▁) ▁; ▁long ▁deadline ▁= ▁System ▁. ▁nanoTime ▁( ▁) ▁+ ▁unit ▁. ▁toNanos ▁( ▁timeout ▁) ▁; ▁int ▁added ▁= ▁0 ▁; ▁while ▁( ▁added ▁< ▁numElements ▁) ▁{ ▁added ▁+= ▁q ▁. ▁drain To ▁( ▁buffer ▁, ▁numElements ▁- ▁added ▁) ▁;
▁public ▁class ▁Update Global White Addr Sub Command ▁implements ▁Sub Command ▁{ ▁@ ▁Override ▁public ▁String ▁commandName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁String ▁command Desc ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁Options ▁build Command line Options ▁( ▁Options ▁options ▁) ▁{ ▁Option Group ▁option Group ▁= ▁new ▁Option Group ▁( ▁) ▁; ▁Option ▁opt ▁= ▁new ▁Option ▁( ▁STR ▁, ▁STR ▁, ▁true ▁, ▁STR ▁) ▁; ▁option Group ▁. ▁addOption ▁( ▁opt ▁) ▁; ▁opt ▁= ▁new ▁Option ▁( ▁STR ▁, ▁STR ▁, ▁true ▁, ▁STR ▁) ▁; ▁option Group ▁. ▁addOption ▁( ▁opt ▁) ▁; ▁option Group ▁. ▁setRequired ▁( ▁true ▁) ▁; ▁options ▁. ▁addOption Group ▁( ▁option Group ▁) ▁; ▁opt ▁= ▁new ▁Option ▁( ▁STR ▁, ▁STR ▁, ▁true ▁, ▁STR ▁) ▁; ▁opt ▁. ▁setRequired ▁( ▁true ▁) ▁; ▁options ▁. ▁addOption ▁( ▁opt ▁) ▁; ▁return ▁options ▁; ▁} ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁CommandLine ▁commandLine ▁, ▁Options ▁options ▁, ▁R P CH ook ▁rpc Hook ▁) ▁throws ▁Sub CommandException ▁{ ▁Default MQAdminExt ▁default MQAdminExt ▁= ▁new ▁Default MQAdminExt ▁( ▁rpc Hook ▁) ▁; ▁default MQAdminExt ▁. ▁setInstance Name ▁( ▁Long ▁. ▁toString ▁( ▁System ▁. ▁current TimeMillis ▁( ▁) ▁) ▁) ▁; ▁try ▁{ ▁String ▁global White Remote Addresses ▁= ▁commandLine ▁. ▁getOptionValue ▁( ▁CHAR ▁) ▁. ▁trim ▁( ▁) ▁; ▁if ▁( ▁commandLine ▁. ▁hasOption ▁( ▁CHAR ▁) ▁) ▁{ ▁String ▁addr ▁= ▁commandLine ▁. ▁getOptionValue ▁( ▁CHAR ▁) ▁. ▁trim ▁( ▁) ▁; ▁default MQAdminExt ▁. ▁start ▁( ▁) ▁; ▁default MQAdminExt ▁. ▁update Global White Addr Config ▁( ▁addr ▁, ▁global White Remote Addresses ▁) ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁STR ▁, ▁addr ▁) ▁; ▁return ▁; ▁} ▁else ▁if ▁( ▁commandLine ▁. ▁hasOption ▁( ▁CHAR ▁) ▁) ▁{ ▁String ▁clusterName ▁= ▁commandLine ▁. ▁getOptionValue ▁( ▁CHAR ▁) ▁. ▁trim ▁( ▁) ▁; ▁default MQAdminExt ▁. ▁start ▁( ▁) ▁; ▁Set ▁< ▁String ▁> ▁master Set ▁= ▁Command Util ▁. ▁fetch Master Addr By Cluster Name ▁( ▁default MQAdminExt ▁, ▁clusterName ▁) ▁; ▁for ▁( ▁String ▁addr ▁: ▁master Set ▁) ▁{ ▁default MQAdminExt ▁. ▁update Global White Addr Config ▁( ▁addr ▁, ▁global White Remote Addresses ▁) ▁; ▁System ▁. ▁out ▁. ▁printf ▁( ▁STR ▁, ▁addr ▁) ▁; ▁} ▁return ▁; ▁} ▁Server Util ▁. ▁print CommandLine Help ▁( ▁STR ▁+ ▁this ▁. ▁commandName ▁( ▁) ▁, ▁options ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁throw ▁new ▁Sub CommandException ▁( ▁this ▁. ▁getClass ▁( ▁) ▁. ▁getSimpleName ▁( ▁) ▁+ ▁STR ▁, ▁e ▁) ▁; ▁} ▁finally ▁{ ▁default MQAdminExt ▁. ▁shutdown ▁( ▁) ▁; ▁} ▁} ▁}
▁protected ▁abstract ▁void ▁reload ▁( ▁) ▁; ▁@ ▁Override ▁protected ▁void ▁submit ▁( ▁StaplerRequest ▁req ▁, ▁Stapler Response ▁rsp ▁) ▁throws ▁IOException ▁, ▁Servlet Exception ▁, ▁Form Exception ▁{ ▁super ▁. ▁submit ▁( ▁req ▁, ▁rsp ▁) ▁; ▁next Update ▁= ▁0 ▁; ▁} ▁private ▁static ▁final ▁class ▁Reload Thread ▁extends ▁Thread ▁{ ▁final ▁Set ▁< ▁View Job ▁> ▁reload Queue ▁= ▁new ▁LinkedHashSet ▁< ▁> ▁( ▁) ▁; ▁private ▁Reload Thread ▁( ▁) ▁{ ▁setName ▁( ▁STR ▁) ▁; ▁} ▁private ▁View Job ▁getNext ▁( ▁) ▁throws ▁Interrupted Exception ▁{ ▁synchronized ▁( ▁reload Queue ▁) ▁{ ▁while ▁( ▁reload Queue ▁. ▁isEmpty ▁( ▁) ▁&& ▁! ▁term in ating ▁( ▁) ▁) ▁reload Queue ▁. ▁wait ▁( ▁TimeUnit ▁. ▁MINUTES ▁. ▁toMillis ▁( ▁1 ▁) ▁) ▁; ▁if ▁( ▁term in ating ▁( ▁) ▁) ▁throw ▁new ▁Interrupted Exception ▁( ▁) ▁; ▁View Job ▁job ▁= ▁reload Queue ▁. ▁iterator ▁( ▁) ▁. ▁next ▁( ▁) ▁; ▁reload Queue ▁. ▁remove ▁( ▁job ▁) ▁; ▁return ▁job ▁; ▁} ▁} ▁private ▁boolean ▁term in ating ▁( ▁) ▁{ ▁return ▁Jenkins ▁. ▁get ▁( ▁) ▁. ▁is Term in ating ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁run ▁( ▁) ▁{ ▁while ▁( ▁! ▁term in ating ▁( ▁) ▁) ▁{ ▁try ▁{ ▁getNext ▁( ▁) ▁. ▁_ re load ▁( ▁) ▁; ▁} ▁catch ▁( ▁Interrupted Exception ▁e ▁) ▁{ ▁return ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁t ▁. ▁printStackTrace ▁( ▁) ▁; ▁} ▁} ▁} ▁} ▁public ▁static ▁boolean ▁reload Periodic ally ▁= ▁System Properties ▁. ▁getBoolean ▁( ▁View Job ▁. ▁class ▁. ▁getName ▁( ▁) ▁+ ▁STR ▁) ▁; ▁}
▁class ▁Testing Dispatcher Gateway Service ▁implements ▁Abstract Dispatcher Leader Process ▁. ▁Dispatcher Gateway Service ▁{ ▁private ▁final ▁Function ▁< ▁JobID ▁, ▁Completable Future ▁< ▁Void ▁> ▁> ▁on Removed JobGraph Function ▁; ▁private ▁final ▁Dispatcher Gateway ▁dispatcher Gateway ▁; ▁private ▁final ▁Completable Future ▁< ▁Application Status ▁> ▁shut Down Future ▁; ▁private ▁final ▁Completable Future ▁< ▁Void ▁> ▁termination Future ▁; ▁private ▁final ▁boolean ▁complete Termination Future On Close ▁; ▁private ▁Testing Dispatcher Gateway Service ▁( ▁Completable Future ▁< ▁Void ▁> ▁termination Future ▁, ▁Function ▁< ▁JobID ▁, ▁Completable Future ▁< ▁Void ▁> ▁> ▁on Removed JobGraph Function ▁, ▁Dispatcher Gateway ▁dispatcher Gateway ▁, ▁Completable Future ▁< ▁Application Status ▁> ▁shut Down Future ▁, ▁boolean ▁complete Termination Future On Close ▁) ▁{ ▁this ▁. ▁termination Future ▁= ▁termination Future ▁; ▁this ▁. ▁on Removed JobGraph Function ▁= ▁on Removed JobGraph Function ▁; ▁this ▁. ▁dispatcher Gateway ▁= ▁dispatcher Gateway ▁; ▁this ▁. ▁shut Down Future ▁= ▁shut Down Future ▁; ▁this ▁. ▁complete Termination Future On Close ▁= ▁complete Termination Future On Close ▁; ▁} ▁@ ▁Override ▁public ▁Dispatcher Gateway ▁get Gateway ▁( ▁) ▁{ ▁return ▁dispatcher Gateway ▁; ▁} ▁@ ▁Override ▁public ▁Completable Future ▁< ▁Void ▁> ▁on Removed JobGraph ▁( ▁JobID ▁jobId ▁) ▁{ ▁return ▁on Removed JobGraph Function ▁. ▁apply ▁( ▁jobId ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Completable Future ▁< ▁Application Status ▁> ▁getSh ut Down Future ▁( ▁) ▁{ ▁return ▁shut Down Future ▁; ▁} ▁public ▁Completable Future ▁< ▁Void ▁> ▁get Termination Future ▁( ▁) ▁{ ▁return ▁termination Future ▁; ▁} ▁@ ▁Override ▁public ▁Completable Future ▁< ▁Void ▁> ▁close Async ▁( ▁) ▁{ ▁if ▁( ▁complete Termination Future On Close ▁) ▁{ ▁termination Future ▁. ▁complete ▁( ▁null ▁) ▁; ▁} ▁return ▁termination Future ▁; ▁} ▁public ▁static ▁Builder ▁newBuilder ▁( ▁) ▁{ ▁return ▁new ▁Builder ▁( ▁) ▁; ▁} ▁public ▁static ▁class ▁Builder ▁{ ▁private ▁Completable Future ▁< ▁Void ▁> ▁termination Future ▁= ▁new ▁Completable Future ▁< ▁> ▁( ▁) ▁; ▁private ▁Function ▁< ▁JobID ▁, ▁Completable Future ▁< ▁Void ▁> ▁> ▁on Removed JobGraph Function ▁= ▁ignored ▁-> ▁Future Utils ▁. ▁completed Void Future ▁( ▁) ▁; ▁private ▁Dispatcher Gateway ▁dispatcher Gateway ▁= ▁new ▁Testing Dispatcher Gateway ▁. ▁Builder ▁( ▁) ▁. ▁build ▁( ▁) ▁; ▁private ▁Completable Future ▁< ▁Application Status ▁> ▁shut Down Future ▁= ▁new ▁Completable Future ▁< ▁> ▁( ▁) ▁; ▁private ▁boolean ▁complete Termination Future On Close ▁= ▁true ▁; ▁private ▁Builder ▁( ▁) ▁{ ▁} ▁public ▁Builder ▁set Termination Future ▁( ▁Completable Future ▁< ▁Void ▁> ▁termination Future ▁) ▁{ ▁this ▁. ▁termination Future ▁= ▁termination Future ▁; ▁return ▁this ▁; ▁} ▁public ▁Builder ▁set Dispatcher Gateway ▁( ▁Dispatcher Gateway ▁dispatcher Gateway ▁) ▁{ ▁this ▁. ▁dispatcher Gateway ▁= ▁dispatcher Gateway ▁; ▁return ▁this ▁; ▁} ▁public ▁Builder ▁setOn Removed JobGraph Function ▁( ▁Function ▁< ▁JobID ▁, ▁Completable Future ▁< ▁Void ▁> ▁> ▁on Removed JobGraph Function ▁) ▁{ ▁this ▁. ▁on Removed JobGraph Function ▁= ▁on Removed JobGraph Function ▁; ▁return ▁this ▁; ▁}
▁Fluent Iterable ▁< ▁Timestamp edValue ▁< ▁IN ▁> ▁> ▁record sWith Timestamp ▁= ▁Fluent Iterable ▁. ▁from ▁( ▁contents ▁) ▁. ▁transform ▁( ▁new ▁Function ▁< ▁StreamRecord ▁< ▁IN ▁> ▁, ▁Timestamp edValue ▁< ▁IN ▁> ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Timestamp edValue ▁< ▁IN ▁> ▁apply ▁( ▁StreamRecord ▁< ▁IN ▁> ▁input ▁) ▁{ ▁return ▁Timestamp edValue ▁. ▁from ▁( ▁input ▁) ▁; ▁} ▁} ▁) ▁; ▁evict or Context ▁. ▁evict Before ▁( ▁record sWith Timestamp ▁, ▁Iterables ▁. ▁size ▁( ▁record sWith Timestamp ▁) ▁) ▁; ▁Fluent Iterable ▁< ▁IN ▁> ▁project ed Contents ▁= ▁record sWith Timestamp ▁. ▁transform ▁( ▁new ▁Function ▁< ▁Timestamp edValue ▁< ▁IN ▁> ▁, ▁IN ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁IN ▁apply ▁( ▁Timestamp edValue ▁< ▁IN ▁> ▁input ▁) ▁{ ▁return ▁input ▁. ▁getValue ▁( ▁) ▁; ▁} ▁} ▁) ▁; ▁process Context ▁. ▁window ▁= ▁trigger Context ▁. ▁window ▁; ▁user Function ▁. ▁process ▁( ▁trigger Context ▁. ▁key ▁, ▁trigger Context ▁. ▁window ▁, ▁process Context ▁, ▁project ed Contents ▁, ▁timestamp ed Collector ▁) ▁; ▁evict or Context ▁. ▁evict After ▁( ▁record sWith Timestamp ▁, ▁Iterables ▁. ▁size ▁( ▁record sWith Timestamp ▁) ▁) ▁; ▁window State ▁. ▁clear ▁( ▁) ▁; ▁for ▁( ▁Timestamp edValue ▁< ▁IN ▁> ▁record ▁: ▁record sWith Timestamp ▁) ▁{ ▁window State ▁. ▁add ▁( ▁record ▁. ▁getStream Record ▁( ▁) ▁) ▁; ▁} ▁} ▁private ▁void ▁clear All State ▁( ▁W ▁window ▁, ▁List State ▁< ▁StreamRecord ▁< ▁IN ▁> ▁> ▁window State ▁, ▁Mer ging Window Set ▁< ▁W ▁> ▁m er ging Windows ▁) ▁throws ▁Exception ▁{ ▁window State ▁. ▁clear ▁( ▁) ▁; ▁trigger Context ▁. ▁clear ▁( ▁) ▁; ▁process Context ▁. ▁window ▁= ▁window ▁; ▁process Context ▁. ▁clear ▁( ▁) ▁; ▁if ▁( ▁m er ging Windows ▁!= ▁null ▁) ▁{ ▁m er ging Windows ▁. ▁ret ire Window ▁( ▁window ▁) ▁; ▁m er ging Windows ▁. ▁persist ▁( ▁) ▁; ▁} ▁} ▁class ▁Ev ict or Context ▁implements ▁Ev ict or ▁. ▁Ev ict or Context ▁{ ▁protected ▁K ▁key ▁; ▁protected ▁W ▁window ▁; ▁public ▁Ev ict or Context ▁( ▁K ▁key ▁, ▁W ▁window ▁) ▁{ ▁this ▁. ▁key ▁= ▁key ▁; ▁this ▁. ▁window ▁= ▁window ▁; ▁} ▁@ ▁Override ▁public ▁long ▁getCurrent ProcessingTime ▁( ▁) ▁{ ▁return ▁internal Timer Service ▁. ▁current ProcessingTime ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁long ▁getCurrent Watermark ▁( ▁) ▁{ ▁return ▁internal Timer Service ▁. ▁current Watermark ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁MetricGroup ▁get MetricGroup ▁( ▁) ▁{ ▁return ▁Ev icting Window Operator ▁. ▁this ▁. ▁get MetricGroup ▁( ▁) ▁; ▁} ▁public ▁K ▁getKey ▁( ▁) ▁{ ▁return ▁key ▁; ▁} ▁void ▁evict Before ▁( ▁Iterable ▁< ▁Timestamp edValue ▁< ▁IN ▁> ▁> ▁elements ▁, ▁int ▁size ▁) ▁{ ▁evict or ▁. ▁evict Before ▁( ▁( ▁Iterable ▁) ▁elements ▁, ▁size ▁, ▁window ▁, ▁this ▁) ▁; ▁}
▁@ ▁Option ▁( ▁help ▁= ▁STR ▁, ▁category ▁= ▁Option Category ▁. ▁USER ▁, ▁st ability ▁= ▁Option Stability ▁. ▁STABLE ▁) ▁public ▁static ▁final ▁OptionKey ▁< ▁List ▁< ▁Path ▁> ▁> ▁Java Library Path ▁= ▁new ▁OptionKey ▁< ▁> ▁( ▁Collections ▁. ▁emptyList ▁( ▁) ▁, ▁PATH S _ OPTION _ TYPE ▁) ▁; ▁@ ▁Option ▁( ▁help ▁= ▁STR ▁, ▁category ▁= ▁Option Category ▁. ▁EX PERT ▁, ▁st ability ▁= ▁Option Stability ▁. ▁STABLE ▁) ▁public ▁static ▁final ▁OptionKey ▁< ▁List ▁< ▁Path ▁> ▁> ▁Boot Library Path ▁= ▁new ▁OptionKey ▁< ▁> ▁( ▁Collections ▁. ▁emptyList ▁( ▁) ▁, ▁PATH S _ OPTION _ TYPE ▁) ▁; ▁@ ▁Option ▁( ▁help ▁= ▁STR ▁, ▁category ▁= ▁Option Category ▁. ▁EX PERT ▁, ▁st ability ▁= ▁Option Stability ▁. ▁STABLE ▁) ▁public ▁static ▁final ▁OptionKey ▁< ▁List ▁< ▁Path ▁> ▁> ▁Ext Dirs ▁= ▁new ▁OptionKey ▁< ▁> ▁( ▁Collections ▁. ▁emptyList ▁( ▁) ▁, ▁PATH S _ OPTION _ TYPE ▁) ▁; ▁@ ▁Option ▁( ▁help ▁= ▁STR ▁, ▁category ▁= ▁Option Category ▁. ▁USER ▁, ▁st ability ▁= ▁Option Stability ▁. ▁STABLE ▁) ▁public ▁static ▁final ▁OptionKey ▁< ▁Boolean ▁> ▁Enable Assertions ▁= ▁new ▁OptionKey ▁< ▁> ▁( ▁false ▁) ▁; ▁@ ▁Option ▁( ▁help ▁= ▁STR ▁, ▁category ▁= ▁Option Category ▁. ▁USER ▁, ▁st ability ▁= ▁Option Stability ▁. ▁STABLE ▁) ▁public ▁static ▁final ▁OptionKey ▁< ▁Boolean ▁> ▁Enable System Assertions ▁= ▁new ▁OptionKey ▁< ▁> ▁( ▁false ▁) ▁; ▁public ▁static ▁List ▁< ▁Path ▁> ▁parse Paths ▁( ▁String ▁paths ▁) ▁{ ▁List ▁< ▁Path ▁> ▁list ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁String ▁path ▁: ▁split By File Separator ▁( ▁paths ▁) ▁) ▁{ ▁list ▁. ▁add ▁( ▁Paths ▁. ▁get ▁( ▁path ▁) ▁) ▁; ▁} ▁return ▁list ▁; ▁} ▁private ▁static ▁List ▁< ▁String ▁> ▁split By File Separator ▁( ▁String ▁strings ▁) ▁{ ▁return ▁new ▁ArrayList ▁< ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁strings ▁. ▁split ▁( ▁File ▁. ▁path Separator ▁) ▁) ▁) ▁; ▁} ▁public ▁enum ▁Spec Comp li an cy Mode ▁{ ▁STRICT ▁, ▁H OT SP OT ▁} ▁private ▁static ▁final ▁OptionType ▁< ▁Spec Comp li an cy Mode ▁> ▁SPE C _ COMP LI AN C Y _ OPTION _ TYPE ▁= ▁new ▁OptionType ▁< ▁> ▁( ▁STR ▁, ▁new ▁Function ▁< ▁String ▁, ▁Spec Comp li an cy Mode ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Spec Comp li an cy Mode ▁apply ▁( ▁String ▁s ▁) ▁{ ▁try ▁{ ▁return ▁Spec Comp li an cy Mode ▁. ▁valueOf ▁( ▁s ▁. ▁toUpperCase ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁IllegalArgument Exception ▁e ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁} ▁} ▁) ▁;
▁@ ▁RestController ▁public ▁class ▁Config Properties Controller ▁{ ▁@ ▁Value ▁( ▁STR ▁) ▁private ▁String ▁property One WithValue ▁; ▁@ ▁Value ▁( ▁STR ▁) ▁private ▁String ▁property Two WithValue ▁; ▁@ ▁Value ▁( ▁STR ▁) ▁private ▁String ▁property Three WithValue ▁; ▁private ▁Dynamic String Property ▁property One With Dynamic ▁= ▁Dynamic Property Factory ▁. ▁getInstance ▁( ▁) ▁. ▁getString Property ▁( ▁STR ▁, ▁STR ▁) ▁; ▁private ▁Dynamic String Property ▁property Two With Dynamic ▁= ▁Dynamic Property Factory ▁. ▁getInstance ▁( ▁) ▁. ▁getString Property ▁( ▁STR ▁, ▁STR ▁) ▁; ▁private ▁Dynamic String Property ▁property Three With Dynamic ▁= ▁Dynamic Property Factory ▁. ▁getInstance ▁( ▁) ▁. ▁getString Property ▁( ▁STR ▁, ▁STR ▁) ▁; ▁@ ▁GetMapping ▁( ▁STR ▁) ▁public ▁Map ▁< ▁String ▁, ▁String ▁> ▁getProperties From Dynamic ▁( ▁) ▁{ ▁Map ▁< ▁String ▁, ▁String ▁> ▁properties ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁properties ▁. ▁put ▁( ▁property One With Dynamic ▁. ▁getName ▁( ▁) ▁, ▁property One With Dynamic ▁. ▁get ▁( ▁) ▁) ▁; ▁properties ▁. ▁put ▁( ▁property Two With Dynamic ▁. ▁getName ▁( ▁) ▁, ▁property Two With Dynamic ▁. ▁get ▁( ▁) ▁) ▁; ▁properties ▁. ▁put ▁( ▁property Three With Dynamic ▁. ▁getName ▁( ▁) ▁, ▁property Three With Dynamic ▁. ▁get ▁( ▁) ▁) ▁; ▁return ▁properties ▁; ▁} ▁@ ▁GetMapping ▁( ▁STR ▁) ▁public ▁Map ▁< ▁String ▁, ▁String ▁> ▁getProperties From Value ▁( ▁) ▁{ ▁Map ▁< ▁String ▁, ▁String ▁> ▁properties ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁properties ▁. ▁put ▁( ▁STR ▁, ▁property One WithValue ▁) ▁; ▁properties ▁. ▁put ▁( ▁STR ▁, ▁property Two WithValue ▁) ▁; ▁properties ▁. ▁put ▁( ▁STR ▁, ▁property Three WithValue ▁) ▁; ▁return ▁properties ▁; ▁} ▁}
▁@ ▁Test ▁public ▁void ▁test A mb iguous Channels ▁( ▁) ▁throws ▁IOException ▁{ ▁Dem ult iple x ing Record Deserializer ▁< ▁Long ▁> ▁deserializer ▁= ▁Dem ult iple x ing Record Deserializer ▁. ▁create ▁( ▁new ▁InputChannel Info ▁( ▁1 ▁, ▁0 ▁) ▁, ▁res caling Descriptor ▁( ▁to ▁( ▁41 ▁, ▁42 ▁) ▁, ▁array ▁( ▁mappings ▁( ▁) ▁, ▁mappings ▁( ▁to ▁( ▁2 ▁, ▁3 ▁) ▁, ▁to ▁( ▁4 ▁, ▁5 ▁) ▁) ▁) ▁, ▁set ▁( ▁42 ▁) ▁) ▁, ▁unused ▁-> ▁new ▁Spill ing Adapt ive Sp anning Record Deserializer ▁< ▁> ▁( ▁io Manager ▁. ▁getSp ill ing Directories Paths ▁( ▁) ▁) ▁, ▁unused ▁-> ▁new ▁Record Filter ▁( ▁new ▁Mod Selector ▁( ▁2 ▁) ▁, ▁Long Serializer ▁. ▁INSTANCE ▁, ▁1 ▁) ▁) ▁; ▁assertEquals ▁( ▁Sets ▁. ▁new Set ▁( ▁new ▁Subtask Connection Descriptor ▁( ▁41 ▁, ▁2 ▁) ▁, ▁new ▁Subtask Connection Descriptor ▁( ▁41 ▁, ▁3 ▁) ▁, ▁new ▁Subtask Connection Descriptor ▁( ▁42 ▁, ▁2 ▁) ▁, ▁new ▁Subtask Connection Descriptor ▁( ▁42 ▁, ▁3 ▁) ▁) ▁, ▁deserializer ▁. ▁getVirtual Channel Select ors ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁100 ▁; ▁i ▁++ ▁) ▁{ ▁MemorySegment ▁memory Segment ▁= ▁allocate Un pooled Segment ▁( ▁128 ▁) ▁; ▁try ▁( ▁Buffer Builder ▁buffer Builder ▁= ▁create BufferBuilder ▁( ▁memory Segment ▁) ▁) ▁{ ▁Buffer ▁buffer ▁= ▁writeLong s ▁( ▁buffer Builder ▁, ▁i ▁, ▁i ▁+ ▁1 L ▁) ▁; ▁Subtask Connection Descriptor ▁selector ▁= ▁Iterables ▁. ▁get ▁( ▁deserializer ▁. ▁getVirtual Channel Select ors ▁( ▁) ▁, ▁i ▁ / ▁10 ▁ % ▁2 ▁) ▁; ▁deserializer ▁. ▁select ▁( ▁selector ▁) ▁; ▁deserializer ▁. ▁setNext Buffer ▁( ▁buffer ▁) ▁; ▁if ▁( ▁selector ▁. ▁getInput Subtask Index ▁( ▁) ▁== ▁41 ▁) ▁{ ▁assertEquals ▁( ▁Arrays ▁. ▁asList ▁( ▁( ▁long ▁) ▁i ▁, ▁i ▁+ ▁1 L ▁) ▁, ▁readLong s ▁( ▁deserializer ▁) ▁) ▁; ▁} ▁else ▁{ ▁assertEquals ▁( ▁Arrays ▁. ▁asList ▁( ▁i ▁ / ▁2 ▁ * ▁2 ▁+ ▁1 L ▁) ▁, ▁readLong s ▁( ▁deserializer ▁) ▁) ▁; ▁} ▁} ▁assertTrue ▁( ▁memory Segment ▁. ▁isF reed ▁( ▁) ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Watermarks ▁( ▁) ▁throws ▁IOException ▁{ ▁Dem ult iple x ing Record Deserializer ▁< ▁Long ▁> ▁deserializer ▁= ▁Dem ult iple x ing Record Deserializer ▁. ▁create ▁( ▁new ▁InputChannel Info ▁( ▁0 ▁, ▁0 ▁) ▁, ▁res caling Descriptor ▁( ▁to ▁( ▁0 ▁, ▁1 ▁) ▁, ▁array ▁( ▁mappings ▁( ▁to ▁( ▁0 ▁, ▁1 ▁) ▁, ▁to ▁( ▁4 ▁, ▁5 ▁) ▁) ▁) ▁, ▁emptySet ▁( ▁) ▁) ▁, ▁unused ▁-> ▁new ▁Spill ing Adapt ive Sp anning Record Deserializer ▁< ▁> ▁( ▁io Manager ▁. ▁getSp ill ing Directories Paths ▁( ▁) ▁) ▁, ▁unused ▁-> ▁Record Filter ▁. ▁all ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁4 ▁, ▁deserializer ▁. ▁getVirtual Channel Select ors ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁;
▁@ ▁Interface Audience ▁. ▁Private ▁public ▁class ▁DFS St riped OutputStream ▁extends ▁DFS OutputStream ▁implements ▁Stream Capabilities ▁{ ▁private ▁static ▁final ▁ByteBuffer Pool ▁BUFFER _ POOL ▁= ▁new ▁Elastic ByteBuffer Pool ▁( ▁) ▁; ▁private ▁final ▁Exception Last Seen ▁exception Last Seen ▁= ▁new ▁Exception Last Seen ▁( ▁) ▁; ▁static ▁class ▁Multiple BlockingQueue ▁< ▁T ▁> ▁{ ▁private ▁final ▁List ▁< ▁BlockingQueue ▁< ▁T ▁> ▁> ▁queues ▁; ▁Multiple BlockingQueue ▁( ▁int ▁num Queue ▁, ▁int ▁queue Size ▁) ▁{ ▁queues ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁num Queue ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁num Queue ▁; ▁i ▁++ ▁) ▁{ ▁queues ▁. ▁add ▁( ▁new ▁Linked BlockingQueue ▁< ▁T ▁> ▁( ▁queue Size ▁) ▁) ▁; ▁} ▁} ▁void ▁offer ▁( ▁int ▁i ▁, ▁T ▁object ▁) ▁{ ▁final ▁boolean ▁b ▁= ▁queues ▁. ▁get ▁( ▁i ▁) ▁. ▁offer ▁( ▁object ▁) ▁; ▁Preconditions ▁. ▁checkState ▁( ▁b ▁, ▁STR ▁+ ▁object ▁+ ▁STR ▁+ ▁i ▁) ▁; ▁} ▁T ▁take ▁( ▁int ▁i ▁) ▁throws ▁Interrupted IOException ▁{ ▁try ▁{ ▁return ▁queues ▁. ▁get ▁( ▁i ▁) ▁. ▁take ▁( ▁) ▁; ▁} ▁catch ▁( ▁Interrupted Exception ▁ie ▁) ▁{ ▁throw ▁DFS Util Client ▁. ▁to Interrupted IOException ▁( ▁STR ▁+ ▁i ▁, ▁ie ▁) ▁; ▁} ▁} ▁T ▁take With Timeout ▁( ▁int ▁i ▁) ▁throws ▁Interrupted IOException ▁{ ▁try ▁{ ▁return ▁queues ▁. ▁get ▁( ▁i ▁) ▁. ▁poll ▁( ▁100 ▁, ▁TimeUnit ▁. ▁MILLISECONDS ▁) ▁; ▁} ▁catch ▁( ▁Interrupted Exception ▁e ▁) ▁{ ▁throw ▁DFS Util Client ▁. ▁to Interrupted IOException ▁( ▁STR ▁+ ▁i ▁, ▁e ▁) ▁; ▁} ▁} ▁T ▁poll ▁( ▁int ▁i ▁) ▁{ ▁return ▁queues ▁. ▁get ▁( ▁i ▁) ▁. ▁poll ▁( ▁) ▁; ▁} ▁T ▁peek ▁( ▁int ▁i ▁) ▁{ ▁return ▁queues ▁. ▁get ▁( ▁i ▁) ▁. ▁peek ▁( ▁) ▁; ▁} ▁void ▁clear ▁( ▁) ▁{ ▁for ▁( ▁BlockingQueue ▁< ▁T ▁> ▁q ▁: ▁queues ▁) ▁{ ▁q ▁. ▁clear ▁( ▁) ▁; ▁} ▁} ▁} ▁static ▁class ▁Coordinator ▁{ ▁private ▁final ▁Multiple BlockingQueue ▁< ▁Located Block ▁> ▁follow ing Blocks ▁; ▁private ▁final ▁Multiple BlockingQueue ▁< ▁ExtendedBlock ▁> ▁end Blocks ▁; ▁private ▁final ▁Multiple BlockingQueue ▁< ▁Located Block ▁> ▁new Blocks ▁; ▁private ▁final ▁Map ▁< ▁Striped DataStream er ▁, ▁Boolean ▁> ▁update Stream er Map ▁; ▁private ▁final ▁Multiple BlockingQueue ▁< ▁Boolean ▁> ▁stream er Update Result ▁; ▁Coordinator ▁( ▁final ▁int ▁num All Blocks ▁) ▁{ ▁follow ing Blocks ▁= ▁new ▁Multiple BlockingQueue ▁< ▁> ▁( ▁num All Blocks ▁, ▁1 ▁) ▁; ▁end Blocks ▁= ▁new ▁Multiple BlockingQueue ▁< ▁> ▁( ▁num All Blocks ▁, ▁1 ▁) ▁; ▁new Blocks ▁= ▁new ▁Multiple BlockingQueue ▁< ▁> ▁( ▁num All Blocks ▁, ▁1 ▁) ▁; ▁update Stream er Map ▁= ▁new ▁Concurrent HashMap ▁< ▁> ▁( ▁num All Blocks ▁) ▁; ▁stream er Update Result ▁= ▁new ▁Multiple BlockingQueue ▁< ▁> ▁( ▁num All Blocks ▁, ▁1 ▁) ▁; ▁}
▁public ▁class ▁Text Sim ilarity ▁{ ▁public ▁static ▁double ▁sim il ar ▁( ▁String ▁str A ▁, ▁String ▁str B ▁) ▁{ ▁String ▁new Str A ▁, ▁new Str B ▁; ▁if ▁( ▁str A ▁. ▁length ▁( ▁) ▁< ▁str B ▁. ▁length ▁( ▁) ▁) ▁{ ▁new Str A ▁= ▁remove Sign ▁( ▁str B ▁) ▁; ▁new Str B ▁= ▁remove Sign ▁( ▁str A ▁) ▁; ▁} ▁else ▁{ ▁new Str A ▁= ▁remove Sign ▁( ▁str A ▁) ▁; ▁new Str B ▁= ▁remove Sign ▁( ▁str B ▁) ▁; ▁} ▁int ▁temp ▁= ▁Math ▁. ▁max ▁( ▁new Str A ▁. ▁length ▁( ▁) ▁, ▁new Str B ▁. ▁length ▁( ▁) ▁) ▁; ▁if ▁( ▁0 ▁== ▁temp ▁) ▁{ ▁return ▁1 ▁; ▁} ▁int ▁temp 2 ▁= ▁long est Common Substring ▁( ▁new Str A ▁, ▁new Str B ▁) ▁. ▁length ▁( ▁) ▁; ▁return ▁Number Util ▁. ▁div ▁( ▁temp 2 ▁, ▁temp ▁) ▁; ▁} ▁public ▁static ▁String ▁sim il ar ▁( ▁String ▁str A ▁, ▁String ▁str B ▁, ▁int ▁scale ▁) ▁{ ▁return ▁Number Util ▁. ▁format Percent ▁( ▁sim il ar ▁( ▁str A ▁, ▁str B ▁) ▁, ▁scale ▁) ▁; ▁} ▁private ▁static ▁String ▁remove Sign ▁( ▁String ▁str ▁) ▁{ ▁int ▁length ▁= ▁str ▁. ▁length ▁( ▁) ▁; ▁StringBuilder ▁sb ▁= ▁StrUtil ▁. ▁builder ▁( ▁length ▁) ▁; ▁char ▁c ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁length ▁; ▁i ▁++ ▁) ▁{ ▁c ▁= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁if ▁( ▁isValid Char ▁( ▁c ▁) ▁) ▁{ ▁sb ▁. ▁append ▁( ▁c ▁) ▁; ▁} ▁} ▁return ▁sb ▁. ▁toString ▁( ▁) ▁; ▁} ▁private ▁static ▁boolean ▁isValid Char ▁( ▁char ▁char Value ▁) ▁{ ▁return ▁( ▁char Value ▁>= ▁0 x 4 E 00 ▁&& ▁char Value ▁<= ▁0 X 9 FF F ▁) ▁|| ▁( ▁char Value ▁>= ▁CHAR ▁&& ▁char Value ▁<= ▁CHAR ▁) ▁|| ▁( ▁char Value ▁>= ▁CHAR ▁&& ▁char Value ▁<= ▁CHAR ▁) ▁|| ▁( ▁char Value ▁>= ▁CHAR ▁&& ▁char Value ▁<= ▁CHAR ▁) ▁; ▁} ▁private ▁static ▁String ▁long est Common Substring ▁( ▁String ▁str A ▁, ▁String ▁str B ▁) ▁{ ▁int ▁m ▁= ▁str A ▁. ▁length ▁( ▁) ▁; ▁int ▁n ▁= ▁str B ▁. ▁length ▁( ▁) ▁; ▁final ▁int ▁[ ▁] ▁[ ▁] ▁matrix ▁= ▁new ▁int ▁[ ▁m ▁+ ▁1 ▁] ▁[ ▁n ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁<= ▁m ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁int ▁j ▁= ▁1 ▁; ▁j ▁<= ▁n ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁str A ▁. ▁charAt ▁( ▁i ▁- ▁1 ▁) ▁== ▁str B ▁. ▁charAt ▁( ▁j ▁- ▁1 ▁) ▁) ▁{ ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁matrix ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁- ▁1 ▁] ▁+ ▁1 ▁; ▁}
▁public ▁class ▁Completable Do On Test ▁extends ▁RxJavaTest ▁{ ▁@ ▁Test ▁public ▁void ▁success Accept Throws ▁( ▁) ▁{ ▁Completable ▁. ▁complete ▁( ▁) ▁. ▁doOn Event ▁( ▁new ▁Consumer ▁< ▁Throwable ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁accept ▁( ▁Throwable ▁e ▁) ▁throws ▁Exception ▁{ ▁throw ▁new ▁TestException ▁( ▁) ▁; ▁} ▁} ▁) ▁. ▁test ▁( ▁) ▁. ▁assertFailure ▁( ▁TestException ▁. ▁class ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁error Accept Throws ▁( ▁) ▁{ ▁TestObserver Ex ▁< ▁Void ▁> ▁to ▁= ▁Completable ▁. ▁error ▁( ▁new ▁TestException ▁( ▁STR ▁) ▁) ▁. ▁doOn Event ▁( ▁new ▁Consumer ▁< ▁Throwable ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁accept ▁( ▁Throwable ▁e ▁) ▁throws ▁Exception ▁{ ▁throw ▁new ▁TestException ▁( ▁STR ▁) ▁; ▁} ▁} ▁) ▁. ▁to ▁( ▁TestHelper ▁. ▁< ▁Void ▁> ▁test Consumer ▁( ▁) ▁) ▁. ▁assertFailure ▁( ▁Composite Exception ▁. ▁class ▁) ▁; ▁List ▁< ▁Throwable ▁> ▁errors ▁= ▁TestHelper ▁. ▁composite List ▁( ▁to ▁. ▁errors ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁) ▁; ▁TestHelper ▁. ▁assertError ▁( ▁errors ▁, ▁0 ▁, ▁TestException ▁. ▁class ▁, ▁STR ▁) ▁; ▁TestHelper ▁. ▁assertError ▁( ▁errors ▁, ▁1 ▁, ▁TestException ▁. ▁class ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁doOn Dispose Called ▁( ▁) ▁{ ▁final ▁AtomicBoolean ▁atomic Boolean ▁= ▁new ▁AtomicBoolean ▁( ▁) ▁; ▁assertFalse ▁( ▁atomic Boolean ▁. ▁get ▁( ▁) ▁) ▁; ▁Completable ▁. ▁complete ▁( ▁) ▁. ▁doOn Dispose ▁( ▁new ▁Action ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁run ▁( ▁) ▁throws ▁Exception ▁{ ▁atomic Boolean ▁. ▁set ▁( ▁true ▁) ▁; ▁} ▁} ▁) ▁. ▁test ▁( ▁) ▁. ▁assertResult ▁( ▁) ▁. ▁dispose ▁( ▁) ▁; ▁assertTrue ▁( ▁atomic Boolean ▁. ▁get ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁onSubscribe Crash ▁( ▁) ▁{ ▁List ▁< ▁Throwable ▁> ▁errors ▁= ▁TestHelper ▁. ▁track Plugin Errors ▁( ▁) ▁; ▁try ▁{ ▁final ▁Disposable ▁bs ▁= ▁Disposable ▁. ▁empty ▁( ▁) ▁; ▁new ▁Completable ▁( ▁) ▁{ ▁@ ▁Override ▁protected ▁void ▁subscribeActual ▁( ▁Completable Observer ▁observer ▁) ▁{ ▁observer ▁. ▁onSubscribe ▁( ▁bs ▁) ▁; ▁observer ▁. ▁onError ▁( ▁new ▁TestException ▁( ▁STR ▁) ▁) ▁; ▁observer ▁. ▁onComplete ▁( ▁) ▁; ▁} ▁} ▁. ▁doOn Subscribe ▁( ▁new ▁Consumer ▁< ▁Disposable ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁accept ▁( ▁Disposable ▁d ▁) ▁throws ▁Exception ▁{ ▁throw ▁new ▁TestException ▁( ▁STR ▁) ▁; ▁} ▁} ▁) ▁. ▁to ▁( ▁TestHelper ▁. ▁< ▁Void ▁> ▁test Consumer ▁( ▁) ▁) ▁. ▁assertFailure And Message ▁( ▁TestException ▁. ▁class ▁, ▁STR ▁) ▁; ▁assertTrue ▁( ▁bs ▁. ▁isDisposed ▁( ▁) ▁) ▁; ▁TestHelper ▁. ▁assertUn deliver able ▁( ▁errors ▁, ▁0 ▁, ▁TestException ▁. ▁class ▁, ▁STR ▁) ▁; ▁} ▁finally ▁{ ▁RxJavaPlugins ▁. ▁reset ▁( ▁) ▁; ▁} ▁} ▁}
▁public ▁class ▁Json Row Decoder Factory ▁implements ▁Row Decoder Factory ▁{ ▁private ▁final ▁ObjectMapper ▁objectMapper ▁; ▁@ ▁Inject ▁public ▁Json Row Decoder Factory ▁( ▁ObjectMapper ▁objectMapper ▁) ▁{ ▁this ▁. ▁objectMapper ▁= ▁requireNonNull ▁( ▁objectMapper ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Row Decoder ▁create ▁( ▁Map ▁< ▁String ▁, ▁String ▁> ▁decoder Params ▁, ▁Set ▁< ▁Decoder ColumnHandle ▁> ▁columns ▁) ▁{ ▁requireNonNull ▁( ▁columns ▁, ▁STR ▁) ▁; ▁return ▁new ▁Json Row Decoder ▁( ▁objectMapper ▁, ▁choose Field Decoder s ▁( ▁columns ▁) ▁) ▁; ▁} ▁private ▁Map ▁< ▁Decoder ColumnHandle ▁, ▁Json Field Decoder ▁> ▁choose Field Decoder s ▁( ▁Set ▁< ▁Decoder ColumnHandle ▁> ▁columns ▁) ▁{ ▁return ▁columns ▁. ▁stream ▁( ▁) ▁. ▁collect ▁( ▁toImmutable Map ▁( ▁identity ▁( ▁) ▁, ▁this ▁:: ▁choose Field Decoder ▁) ▁) ▁; ▁} ▁private ▁Json Field Decoder ▁choose Field Decoder ▁( ▁Decoder ColumnHandle ▁column ▁) ▁{ ▁try ▁{ ▁requireNonNull ▁( ▁column ▁) ▁; ▁checkArgument ▁( ▁! ▁column ▁. ▁isInternal ▁( ▁) ▁, ▁STR ▁, ▁column ▁. ▁getName ▁( ▁) ▁) ▁; ▁String ▁dataFormat ▁= ▁Optional ▁. ▁ofNullable ▁( ▁column ▁. ▁getData Format ▁( ▁) ▁) ▁. ▁orElse ▁( ▁STR ▁) ▁; ▁switch ▁( ▁dataFormat ▁) ▁{ ▁case ▁STR ▁: ▁return ▁new ▁Custom DateTime Json Field Decoder ▁( ▁column ▁) ▁; ▁case ▁STR ▁: ▁return ▁new ▁ISO 8601 Json Field Decoder ▁( ▁column ▁) ▁; ▁case ▁STR ▁: ▁return ▁new ▁Second s Since Epoch Json Field Decoder ▁( ▁column ▁) ▁; ▁case ▁STR ▁: ▁return ▁new ▁M illi seconds Since Epoch Json Field Decoder ▁( ▁column ▁) ▁; ▁case ▁STR ▁: ▁return ▁new ▁RF C 28 22 Json Field Decoder ▁( ▁column ▁) ▁; ▁case ▁STR ▁: ▁return ▁new ▁Default Json Field Decoder ▁( ▁column ▁) ▁; ▁default ▁: ▁throw ▁new ▁IllegalArgument Exception ▁( ▁format ▁( ▁STR ▁, ▁column ▁. ▁getData Format ▁( ▁) ▁, ▁column ▁. ▁getName ▁( ▁) ▁) ▁) ▁; ▁} ▁} ▁catch ▁( ▁IllegalArgument Exception ▁e ▁) ▁{ ▁throw ▁new ▁PrestoException ▁( ▁GENERIC _ USER _ ERROR ▁, ▁e ▁) ▁; ▁} ▁} ▁public ▁static ▁Json Field Decoder ▁throw Unsupported ColumnType ▁( ▁Decoder ColumnHandle ▁column ▁) ▁{ ▁if ▁( ▁column ▁. ▁getData Format ▁( ▁) ▁== ▁null ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁format ▁( ▁STR ▁, ▁column ▁. ▁getType ▁( ▁) ▁. ▁getDisplayName ▁( ▁) ▁, ▁column ▁. ▁getName ▁( ▁) ▁) ▁) ▁; ▁} ▁throw ▁new ▁IllegalArgument Exception ▁( ▁format ▁( ▁STR ▁, ▁column ▁. ▁getType ▁( ▁) ▁, ▁column ▁. ▁getName ▁( ▁) ▁, ▁column ▁. ▁getData Format ▁( ▁) ▁) ▁) ▁; ▁} ▁}
▁class ▁Random Amount InputStream ▁extends ▁Filter InputStream ▁{ ▁private ▁final ▁Random ▁random ▁; ▁public ▁Random Amount InputStream ▁( ▁InputStream ▁in ▁, ▁Random ▁random ▁) ▁{ ▁super ▁( ▁checkNotNull ▁( ▁in ▁) ▁) ▁; ▁this ▁. ▁random ▁= ▁checkNotNull ▁( ▁random ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁read ▁( ▁byte ▁[ ▁] ▁b ▁, ▁int ▁off ▁, ▁int ▁len ▁) ▁throws ▁IOException ▁{ ▁return ▁super ▁. ▁read ▁( ▁b ▁, ▁off ▁, ▁random ▁. ▁nextInt ▁( ▁len ▁) ▁+ ▁1 ▁) ▁; ▁} ▁}
▁public ▁final ▁class ▁SQLUtils ▁{ ▁private ▁static ▁final ▁Log ▁log ▁= ▁Log ▁. ▁getLog ▁( ▁SQLUtils ▁. ▁class ▁) ▁; ▁public ▁static ▁final ▁Pattern ▁PATTERN _ OUT _ PARAM ▁= ▁Pattern ▁. ▁compile ▁( ▁STR ▁) ▁; ▁public ▁static ▁final ▁Pattern ▁PATTERN _ SI MPLE _ NAME ▁= ▁Pattern ▁. ▁compile ▁( ▁STR ▁, ▁Pattern ▁. ▁CASE _ INSENSITIVE ▁) ▁; ▁private ▁static ▁final ▁Pattern ▁CREATE _ PREFIX _ PATTERN ▁= ▁Pattern ▁. ▁compile ▁( ▁STR ▁, ▁Pattern ▁. ▁CASE _ INSENSITIVE ▁| ▁Pattern ▁. ▁MULT IL INE ▁) ▁; ▁private ▁static ▁final ▁int ▁MIN _ SQL _ DESCRIPTION _ LENGTH ▁= ▁512 ▁; ▁private ▁static ▁final ▁int ▁MAX _ SQL _ DESCRIPTION _ LENGTH ▁= ▁500 ▁; ▁private ▁static ▁final ▁String ▁DBE A VER _ DDL _ COMMENT ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁DBE A VER _ DDL _ W ARNING ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁DBE A VER _ SCRIPT _ DELIMITER ▁= ▁STR ▁; ▁public ▁static ▁String ▁strip Transformation s ▁( ▁String ▁query ▁) ▁{ ▁return ▁query ▁; ▁} ▁public ▁static ▁String ▁strip Comments ▁( ▁@ ▁NotNull ▁SQL Dialect ▁dialect ▁, ▁@ ▁NotNull ▁String ▁query ▁) ▁{ ▁Pair ▁< ▁String ▁, ▁String ▁> ▁multi Line Comments ▁= ▁dialect ▁. ▁getM ulti Line Comments ▁( ▁) ▁; ▁return ▁strip Comments ▁( ▁query ▁, ▁multi Line Comments ▁== ▁null ▁? ▁null ▁: ▁multi Line Comments ▁. ▁getFirst ▁( ▁) ▁, ▁multi Line Comments ▁== ▁null ▁? ▁null ▁: ▁multi Line Comments ▁. ▁getSecond ▁( ▁) ▁, ▁dialect ▁. ▁getSingle Line Comments ▁( ▁) ▁) ▁; ▁} ▁public ▁static ▁boolean ▁is Comment Line ▁( ▁SQL Dialect ▁dialect ▁, ▁String ▁line ▁) ▁{ ▁for ▁( ▁String ▁sl c ▁: ▁dialect ▁. ▁getSingle Line Comments ▁( ▁) ▁) ▁{ ▁if ▁( ▁line ▁. ▁startsWith ▁( ▁sl c ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁return ▁false ▁; ▁} ▁public ▁static ▁String ▁strip Comments ▁( ▁@ ▁NotNull ▁String ▁query ▁, ▁@ ▁Nullable ▁String ▁ml Comment Start ▁, ▁@ ▁Nullable ▁String ▁ml Comment End ▁, ▁String ▁[ ▁] ▁sl Comments ▁) ▁{ ▁String ▁le ading ▁= ▁STR ▁, ▁tra iling ▁= ▁STR ▁; ▁{ ▁int ▁startPos ▁, ▁endPos ▁; ▁for ▁( ▁startPos ▁= ▁0 ▁; ▁startPos ▁< ▁query ▁. ▁length ▁( ▁) ▁; ▁startPos ▁++ ▁) ▁{ ▁if ▁( ▁! ▁Character ▁. ▁is Whitespace ▁( ▁query ▁. ▁charAt ▁( ▁startPos ▁) ▁) ▁) ▁{ ▁break ▁; ▁} ▁} ▁for ▁( ▁endPos ▁= ▁query ▁. ▁length ▁( ▁) ▁- ▁1 ▁; ▁endPos ▁> ▁startPos ▁; ▁endPos ▁-- ▁) ▁{ ▁if ▁( ▁! ▁Character ▁. ▁is Whitespace ▁( ▁query ▁. ▁charAt ▁( ▁endPos ▁) ▁) ▁) ▁{ ▁break ▁; ▁} ▁} ▁if ▁( ▁startPos ▁> ▁0 ▁) ▁{ ▁le ading ▁= ▁query ▁. ▁substring ▁( ▁0 ▁, ▁startPos ▁) ▁; ▁} ▁if ▁( ▁endPos ▁< ▁query ▁. ▁length ▁( ▁) ▁- ▁1 ▁) ▁{ ▁tra iling ▁= ▁query ▁. ▁substring ▁( ▁endPos ▁+ ▁1 ▁) ▁; ▁} ▁} ▁query ▁= ▁query ▁. ▁trim ▁( ▁) ▁;
▁assert OK ▁( ▁del Res p ▁) ▁; ▁} ▁Response Exception ▁exc ▁= ▁expectThrows ▁( ▁Response Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁submit Async Sql Search ▁( ▁STR ▁+ ▁other User ▁+ ▁STR ▁, ▁TimeValue ▁. ▁timeValue Seconds ▁( ▁10 ▁) ▁, ▁user ▁) ▁) ▁; ▁assertThat ▁( ▁exc ▁. ▁getResponse ▁( ▁) ▁. ▁getStatusLine ▁( ▁) ▁. ▁getStatusCode ▁( ▁) ▁, ▁equalTo ▁( ▁400 ▁) ▁) ▁; ▁} ▁public ▁void ▁testWith Manager ▁( ▁) ▁throws ▁IOException ▁{ ▁Response ▁submit Res p ▁= ▁submit Async Sql Search ▁( ▁STR ▁, ▁TimeValue ▁. ▁timeValue Seconds ▁( ▁10 ▁) ▁, ▁STR ▁) ▁; ▁assert OK ▁( ▁submit Res p ▁) ▁; ▁String ▁id ▁= ▁extract Response Id ▁( ▁submit Res p ▁) ▁; ▁Response ▁get Res p ▁= ▁getAsync Sql Search ▁( ▁id ▁, ▁STR ▁) ▁; ▁assert OK ▁( ▁get Res p ▁) ▁; ▁Response ▁getStatus ▁= ▁getAsync Sql Status ▁( ▁id ▁, ▁STR ▁) ▁; ▁assert OK ▁( ▁getStatus ▁) ▁; ▁Map ▁< ▁String ▁, ▁Object ▁> ▁status ▁= ▁Base Rest Sql TestCase ▁. ▁toMap ▁( ▁getStatus ▁, ▁null ▁) ▁; ▁assertEquals ▁( ▁200 ▁, ▁status ▁. ▁get ▁( ▁STR ▁) ▁) ▁; ▁Response ▁delete Res p ▁= ▁delete Async Sql Search ▁( ▁id ▁, ▁STR ▁) ▁; ▁assert OK ▁( ▁delete Res p ▁) ▁; ▁} ▁static ▁String ▁extract Response Id ▁( ▁Response ▁response ▁) ▁throws ▁IOException ▁{ ▁Map ▁< ▁String ▁, ▁Object ▁> ▁map ▁= ▁toMap ▁( ▁response ▁) ▁; ▁return ▁( ▁String ▁) ▁map ▁. ▁get ▁( ▁STR ▁) ▁; ▁} ▁static ▁void ▁index ▁( ▁String ▁index ▁, ▁String ▁id ▁, ▁Object ▁... ▁fields ▁) ▁throws ▁IOException ▁{ ▁XContentBuilder ▁document ▁= ▁jsonBuilder ▁( ▁) ▁. ▁startObject ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁fields ▁. ▁length ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁document ▁. ▁field ▁( ▁( ▁String ▁) ▁fields ▁[ ▁i ▁] ▁, ▁fields ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁} ▁document ▁. ▁endObject ▁( ▁) ▁; ▁final ▁Request ▁request ▁= ▁new ▁Request ▁( ▁STR ▁, ▁STR ▁+ ▁index ▁+ ▁STR ▁+ ▁id ▁) ▁; ▁request ▁. ▁setJsonEntity ▁( ▁Strings ▁. ▁toString ▁( ▁document ▁) ▁) ▁; ▁assert OK ▁( ▁client ▁( ▁) ▁. ▁performRequest ▁( ▁request ▁) ▁) ▁; ▁} ▁static ▁void ▁refresh ▁( ▁String ▁index ▁) ▁throws ▁IOException ▁{ ▁assert OK ▁( ▁adminClient ▁( ▁) ▁. ▁performRequest ▁( ▁new ▁Request ▁( ▁STR ▁, ▁STR ▁+ ▁index ▁+ ▁STR ▁) ▁) ▁) ▁; ▁} ▁static ▁Response ▁get ▁( ▁String ▁index ▁, ▁String ▁id ▁, ▁String ▁user ▁) ▁throws ▁IOException ▁{ ▁final ▁Request ▁request ▁= ▁new ▁Request ▁( ▁STR ▁, ▁STR ▁+ ▁index ▁+ ▁STR ▁+ ▁id ▁) ▁; ▁set Run As Header ▁( ▁request ▁, ▁user ▁) ▁; ▁return ▁client ▁( ▁) ▁. ▁performRequest ▁( ▁request ▁) ▁; ▁} ▁static ▁Response ▁submit Async Sql Search ▁( ▁String ▁query ▁, ▁TimeValue ▁waitFor Completion ▁, ▁String ▁user ▁) ▁throws ▁IOException ▁{ ▁final ▁Request ▁request ▁= ▁new ▁Request ▁( ▁STR ▁, ▁STR ▁) ▁; ▁set Run As Header ▁( ▁request ▁, ▁user ▁) ▁;
▁public ▁class ▁Function Utils ▁{ ▁public ▁static ▁Field String Info ▁getFunction ReturnType String Info ▁( ▁Function ▁function ▁, ▁String ▁function Signature String ▁) ▁{ ▁DataType ▁returnType ▁= ▁function ▁. ▁getReturnType ▁( ▁) ▁; ▁return ▁new ▁Field String Info ▁( ▁function Signature String ▁, ▁returnType ▁. ▁getName ▁( ▁) ▁, ▁0 ▁) ▁; ▁} ▁public ▁static ▁Field String Info ▁getFunction Name String Info ▁( ▁Function ▁function ▁, ▁String ▁function Signature String ▁) ▁{ ▁String ▁functionName ▁= ▁function ▁. ▁getName ▁( ▁true ▁) ▁; ▁int ▁offset ▁= ▁function Signature String ▁. ▁indexOf ▁( ▁functionName ▁) ▁; ▁if ▁( ▁offset ▁== ▁- ▁1 ▁) ▁{ ▁functionName ▁= ▁function ▁. ▁getName ▁( ▁) ▁; ▁offset ▁= ▁function Signature String ▁. ▁indexOf ▁( ▁functionName ▁) ▁; ▁} ▁return ▁new ▁Field String Info ▁( ▁function Signature String ▁, ▁functionName ▁, ▁offset ▁) ▁; ▁} ▁public ▁static ▁int ▁get Calling Convention Signature Offset ▁( ▁Function ▁function ▁) ▁{ ▁Pro totype Model ▁call ingConvention ▁= ▁function ▁. ▁get Calling Convention ▁( ▁) ▁; ▁if ▁( ▁call ingConvention ▁== ▁null ▁) ▁{ ▁return ▁0 ▁; ▁} ▁String ▁call ingConvention Name ▁= ▁call ingConvention ▁. ▁getName ▁( ▁) ▁; ▁if ▁( ▁call ingConvention Name ▁== ▁null ▁) ▁{ ▁return ▁0 ▁; ▁} ▁if ▁( ▁call ingConvention Name ▁. ▁equals ▁( ▁Function ▁. ▁UNKNOWN _ CALL ING _ CON VENT ION _ STRING ▁) ▁) ▁{ ▁return ▁0 ▁; ▁} ▁return ▁call ingConvention Name ▁. ▁length ▁( ▁) ▁+ ▁1 ▁; ▁} ▁public ▁static ▁Field String Info ▁[ ▁] ▁getFunction Parameter String Infos ▁( ▁Function ▁function ▁, ▁String ▁function Signature String ▁) ▁{ ▁Parameter ▁[ ▁] ▁arguments ▁= ▁function ▁. ▁getParameters ▁( ▁) ▁; ▁int ▁startIndex ▁= ▁function Signature String ▁. ▁indexOf ▁( ▁CHAR ▁) ▁+ ▁1 ▁; ▁List ▁< ▁Field String Info ▁> ▁list ▁= ▁new ▁ArrayList ▁< ▁Field String Info ▁> ▁( ▁) ▁; ▁for ▁( ▁Parameter ▁parameter ▁: ▁arguments ▁) ▁{ ▁String ▁dataType Name ▁= ▁parameter ▁. ▁getDataType ▁( ▁) ▁. ▁getDisplayName ▁( ▁) ▁; ▁String ▁parameter Name ▁= ▁parameter ▁. ▁getName ▁( ▁) ▁; ▁startIndex ▁= ▁function Signature String ▁. ▁indexOf ▁( ▁dataType Name ▁, ▁startIndex ▁) ▁; ▁list ▁. ▁add ▁( ▁new ▁Field String Info ▁( ▁function Signature String ▁, ▁dataType Name ▁+ ▁STR ▁+ ▁parameter Name ▁, ▁startIndex ▁) ▁) ▁; ▁startIndex ▁= ▁function Signature String ▁. ▁indexOf ▁( ▁parameter Name ▁, ▁startIndex ▁) ▁+ ▁parameter Name ▁. ▁length ▁( ▁) ▁; ▁} ▁return ▁list ▁. ▁toArray ▁( ▁new ▁Field String Info ▁[ ▁list ▁. ▁size ▁( ▁) ▁] ▁) ▁; ▁} ▁}
▁public ▁class ▁T im ers Savepoint ITCase ▁{ ▁private ▁static ▁final ▁int ▁PAR ALLELISM ▁= ▁4 ▁; ▁private ▁static ▁final ▁OneShot Latch ▁result Latch ▁= ▁new ▁OneShot Latch ▁( ▁) ▁; ▁@ ▁ClassRule ▁public ▁static ▁final ▁TemporaryFolder ▁T MP _ FOLDER ▁= ▁new ▁TemporaryFolder ▁( ▁) ▁; ▁public ▁static ▁final ▁String ▁SA VE POINT _ FILE _ NAME ▁= ▁STR ▁; ▁public ▁enum ▁ExecutionMode ▁{ ▁PER FORM _ SA VE POINT ▁, ▁VER IFY _ SA VE POINT ▁} ▁private ▁final ▁ExecutionMode ▁execution Mode ▁= ▁ExecutionMode ▁. ▁VER IFY _ SA VE POINT ▁; ▁@ ▁Rule ▁public ▁final ▁MiniCluster With Client Resource ▁miniCluster Resource ▁= ▁new ▁MiniCluster With Client Resource ▁( ▁new ▁MiniCluster Resource Configuration ▁. ▁Builder ▁( ▁) ▁. ▁setNumber Task Managers ▁( ▁1 ▁) ▁. ▁setNumber Slots Per TaskManager ▁( ▁PAR ALLELISM ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁@ ▁Test ▁( ▁timeout ▁= ▁60 _000 ▁) ▁public ▁void ▁test Savepoint With T im ers ▁( ▁) ▁throws ▁Exception ▁{ ▁try ▁( ▁Cluster Client ▁< ▁? ▁> ▁client ▁= ▁miniCluster Resource ▁. ▁getCluster Client ▁( ▁) ▁) ▁{ ▁if ▁( ▁execution Mode ▁== ▁ExecutionMode ▁. ▁PER FORM _ SA VE POINT ▁) ▁{ ▁take Savepoint ▁( ▁STR ▁+ ▁SA VE POINT _ FILE _ NAME ▁, ▁client ▁) ▁; ▁} ▁else ▁if ▁( ▁execution Mode ▁== ▁ExecutionMode ▁. ▁VER IFY _ SA VE POINT ▁) ▁{ ▁verify Savepoint ▁( ▁getResource Filename ▁( ▁SA VE POINT _ FILE _ NAME ▁) ▁, ▁client ▁) ▁; ▁} ▁else ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁+ ▁execution Mode ▁) ▁; ▁} ▁} ▁} ▁private ▁void ▁verify Savepoint ▁( ▁String ▁savepoint Path ▁, ▁Cluster Client ▁< ▁? ▁> ▁client ▁) ▁throws ▁IOException ▁, ▁Interrupted Exception ▁, ▁java ▁. ▁util ▁. ▁concurrent ▁. ▁Execution Exception ▁{ ▁JobGraph ▁jobGraph ▁; ▁jobGraph ▁= ▁getJob Graph ▁( ▁Embedded R ocksDB StateBackend ▁. ▁PriorityQueue State Type ▁. ▁HE AP ▁) ▁; ▁jobGraph ▁. ▁setS ave point Restore Settings ▁( ▁Savepoint Restore Settings ▁. ▁for Path ▁( ▁savepoint Path ▁) ▁) ▁; ▁client ▁. ▁submit Job ▁( ▁jobGraph ▁) ▁. ▁get ▁( ▁) ▁; ▁result Latch ▁. ▁await ▁( ▁) ▁; ▁} ▁private ▁void ▁take Savepoint ▁( ▁String ▁savepoint Path ▁, ▁Cluster Client ▁< ▁? ▁> ▁client ▁) ▁throws ▁Exception ▁{ ▁JobGraph ▁jobGraph ▁= ▁getJob Graph ▁( ▁Embedded R ocksDB StateBackend ▁. ▁PriorityQueue State Type ▁. ▁RO CK S DB ▁) ▁; ▁client ▁. ▁submit Job ▁( ▁jobGraph ▁) ▁. ▁get ▁( ▁) ▁; ▁waitFor All Task Running ▁( ▁miniCluster Resource ▁. ▁getMin i Cluster ▁( ▁) ▁, ▁jobGraph ▁. ▁getJobID ▁( ▁) ▁) ▁; ▁Completable Future ▁< ▁String ▁> ▁savepoint Path Future ▁= ▁client ▁. ▁trigger Savepoint ▁( ▁jobGraph ▁. ▁getJobID ▁( ▁) ▁, ▁null ▁) ▁; ▁String ▁job man ager Savepoint Path ▁= ▁savepoint Path Future ▁. ▁get ▁( ▁2 ▁, ▁TimeUnit ▁. ▁SECONDS ▁) ▁; ▁File ▁jobManager Savepoint ▁= ▁new ▁File ▁( ▁new ▁URI ▁( ▁job man ager Savepoint Path ▁) ▁. ▁getPath ▁( ▁) ▁) ▁; ▁FileUtils ▁. ▁move Directory ▁( ▁jobManager Savepoint ▁, ▁new ▁File ▁( ▁savepoint Path ▁) ▁) ▁; ▁}
▁public ▁class ▁RowExpression Tree Translator ▁< ▁T ▁, ▁C ▁> ▁{ ▁private ▁final ▁RowExpression Translator ▁< ▁T ▁, ▁C ▁> ▁row Expression Translator ▁; ▁private ▁final ▁RowExpression Visitor ▁< ▁Translated Expression ▁< ▁T ▁> ▁, ▁C ▁> ▁visitor ▁; ▁private ▁RowExpression Tree Translator ▁( ▁RowExpression Translator ▁< ▁T ▁, ▁C ▁> ▁row Expression Translator ▁) ▁{ ▁this ▁. ▁row Expression Translator ▁= ▁requireNonNull ▁( ▁row Expression Translator ▁, ▁STR ▁) ▁; ▁this ▁. ▁visitor ▁= ▁new ▁Trans lat ing Visitor ▁( ▁) ▁; ▁} ▁public ▁Translated Expression ▁< ▁T ▁> ▁rewrite ▁( ▁RowExpression ▁node ▁, ▁C ▁context ▁) ▁{ ▁return ▁node ▁. ▁accept ▁( ▁this ▁. ▁visitor ▁, ▁context ▁) ▁; ▁} ▁public ▁static ▁< ▁T ▁, ▁C ▁> ▁Translated Expression ▁< ▁T ▁> ▁translate With ▁( ▁RowExpression ▁expression ▁, ▁RowExpression Translator ▁< ▁T ▁, ▁C ▁> ▁translator ▁, ▁C ▁context ▁) ▁{ ▁return ▁expression ▁. ▁accept ▁( ▁new ▁RowExpression Tree Translator ▁< ▁> ▁( ▁translator ▁) ▁. ▁visitor ▁, ▁context ▁) ▁; ▁} ▁private ▁class ▁Trans lat ing Visitor ▁implements ▁RowExpression Visitor ▁< ▁Translated Expression ▁< ▁T ▁> ▁, ▁C ▁> ▁{ ▁@ ▁Override ▁public ▁Translated Expression ▁< ▁T ▁> ▁visit Call ▁( ▁CallExpression ▁call ▁, ▁C ▁context ▁) ▁{ ▁return ▁row Expression Translator ▁. ▁translate Call ▁( ▁call ▁, ▁context ▁, ▁RowExpression Tree Translator ▁. ▁this ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Translated Expression ▁< ▁T ▁> ▁visit Input Reference ▁( ▁Input Reference Expression ▁reference ▁, ▁C ▁context ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Translated Expression ▁< ▁T ▁> ▁visit Constant ▁( ▁Constant Expression ▁literal ▁, ▁C ▁context ▁) ▁{ ▁return ▁row Expression Translator ▁. ▁translate Constant ▁( ▁literal ▁, ▁context ▁, ▁RowExpression Tree Translator ▁. ▁this ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Translated Expression ▁< ▁T ▁> ▁visit Lambda ▁( ▁Lambda Definition Expression ▁lambda ▁, ▁C ▁context ▁) ▁{ ▁return ▁row Expression Translator ▁. ▁translate Lambda ▁( ▁lambda ▁, ▁context ▁, ▁RowExpression Tree Translator ▁. ▁this ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Translated Expression ▁< ▁T ▁> ▁visit Variable Reference ▁( ▁Variable Reference Expression ▁reference ▁, ▁C ▁context ▁) ▁{ ▁return ▁row Expression Translator ▁. ▁translate Variable ▁( ▁reference ▁, ▁context ▁, ▁RowExpression Tree Translator ▁. ▁this ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Translated Expression ▁< ▁T ▁> ▁visit Special Form ▁( ▁Special Form Expression ▁special Form ▁, ▁C ▁context ▁) ▁{ ▁return ▁row Expression Translator ▁. ▁translate Special Form ▁( ▁special Form ▁, ▁context ▁, ▁RowExpression Tree Translator ▁. ▁this ▁) ▁; ▁} ▁} ▁}
▁public ▁class ▁Deployment Manager ▁{ ▁private ▁static ▁final ▁Logger ▁log ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Deployment Manager ▁. ▁class ▁) ▁; ▁private ▁final ▁Vertx Internal ▁vertx ▁; ▁private ▁final ▁Map ▁< ▁String ▁, ▁Deployment ▁> ▁de ploy ments ▁= ▁new ▁Concurrent HashMap ▁< ▁> ▁( ▁) ▁; ▁public ▁Deployment Manager ▁( ▁Vertx Internal ▁vertx ▁) ▁{ ▁this ▁. ▁vertx ▁= ▁vertx ▁; ▁} ▁private ▁String ▁generate Deployment ID ▁( ▁) ▁{ ▁return ▁UUID ▁. ▁randomUUID ▁( ▁) ▁. ▁toString ▁( ▁) ▁; ▁} ▁public ▁Future ▁< ▁String ▁> ▁de ploy Vert icle ▁( ▁Callable ▁< ▁V ert icle ▁> ▁v ert icle Supplier ▁, ▁Deployment Options ▁options ▁) ▁{ ▁if ▁( ▁options ▁. ▁getInstances ▁( ▁) ▁< ▁1 ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁options ▁. ▁check Isolation Not Defined ▁( ▁) ▁; ▁Context Internal ▁current Context ▁= ▁vertx ▁. ▁getOrCreate Context ▁( ▁) ▁; ▁ClassLoader ▁cl ▁= ▁options ▁. ▁getClassLoader ▁( ▁) ▁; ▁if ▁( ▁cl ▁== ▁null ▁) ▁{ ▁cl ▁= ▁Thread ▁. ▁currentThread ▁( ▁) ▁. ▁getContext ClassLoader ▁( ▁) ▁; ▁if ▁( ▁cl ▁== ▁null ▁) ▁{ ▁cl ▁= ▁getClass ▁( ▁) ▁. ▁getClassLoader ▁( ▁) ▁; ▁} ▁} ▁return ▁do De ploy ▁( ▁options ▁, ▁v ▁-> ▁STR ▁+ ▁v ▁. ▁getClass ▁( ▁) ▁. ▁getName ▁( ▁) ▁, ▁current Context ▁, ▁current Context ▁, ▁cl ▁, ▁v ert icle Supplier ▁) ▁. ▁map ▁( ▁Deployment ▁:: ▁de ployment ID ▁) ▁; ▁} ▁public ▁Future ▁< ▁Void ▁> ▁un de ploy Vert icle ▁( ▁String ▁de ployment ID ▁) ▁{ ▁Deployment ▁de ployment ▁= ▁de ploy ments ▁. ▁get ▁( ▁de ployment ID ▁) ▁; ▁Context ▁current Context ▁= ▁vertx ▁. ▁getOrCreate Context ▁( ▁) ▁; ▁if ▁( ▁de ployment ▁== ▁null ▁) ▁{ ▁return ▁( ▁( ▁Context Internal ▁) ▁current Context ▁) ▁. ▁failed Future ▁( ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁) ▁; ▁} ▁else ▁{ ▁return ▁de ployment ▁. ▁do Un de ploy ▁( ▁vertx ▁. ▁getOrCreate Context ▁( ▁) ▁) ▁; ▁} ▁} ▁public ▁Set ▁< ▁String ▁> ▁de ploy ments ▁( ▁) ▁{ ▁return ▁Collections ▁. ▁unmodifiableSet ▁( ▁de ploy ments ▁. ▁keySet ▁( ▁) ▁) ▁; ▁} ▁public ▁Deployment ▁get Deployment ▁( ▁String ▁de ployment ID ▁) ▁{ ▁return ▁de ploy ments ▁. ▁get ▁( ▁de ployment ID ▁) ▁; ▁} ▁public ▁Future ▁< ▁Void ▁> ▁un de ploy All ▁( ▁) ▁{ ▁Set ▁< ▁String ▁> ▁de ployment IDs ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁Deployment ▁> ▁entry ▁: ▁de ploy ments ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁if ▁( ▁! ▁entry ▁. ▁getValue ▁( ▁) ▁. ▁is Child ▁( ▁) ▁) ▁{ ▁de ployment IDs ▁. ▁add ▁( ▁entry ▁. ▁getKey ▁( ▁) ▁) ▁; ▁} ▁} ▁List ▁< ▁Future ▁> ▁completion List ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁;
▁int ▁balance ▁= ▁tree ▁. ▁getB alance ▁( ▁node ▁) ▁; ▁return ▁( ▁balance ▁<= ▁1 ▁&& ▁balance ▁>= ▁- ▁1 ▁) ▁&& ▁is AV L ▁( ▁tree ▁, ▁node ▁. ▁left ▁) ▁&& ▁is AV L ▁( ▁tree ▁, ▁node ▁. ▁right ▁) ▁; ▁} ▁private ▁AV L Tree ▁getSample AV L Tree ▁( ▁) ▁{ ▁AV L Tree ▁a vl Tree ▁= ▁new ▁AV L Tree ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁10 ▁; ▁i ▁++ ▁) ▁a vl Tree ▁. ▁insert ▁( ▁i ▁) ▁; ▁return ▁a vl Tree ▁; ▁} ▁}
▁assertThat ▁( ▁post Processor ▁. ▁getPack ages To Scan ▁( ▁) ▁) ▁. ▁contains ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁void ▁with No Base Packages Sc anning Uses Base Package Of AnnotatedClass ▁( ▁) ▁{ ▁this ▁. ▁context ▁= ▁new ▁Annotation Config Application Context ▁( ▁No Base Packages ▁. ▁class ▁) ▁; ▁Servlet Component Register ing PostProcessor ▁post Processor ▁= ▁this ▁. ▁context ▁. ▁getBean ▁( ▁Servlet Component Register ing PostProcessor ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁post Processor ▁. ▁getPack ages To Scan ▁( ▁) ▁) ▁. ▁containsExactly ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁void ▁no Base Package And Base Package Are Combined Correct ly ▁( ▁) ▁{ ▁this ▁. ▁context ▁= ▁new ▁Annotation Config Application Context ▁( ▁No Base Packages ▁. ▁class ▁, ▁Base Packages ▁. ▁class ▁) ▁; ▁Servlet Component Register ing PostProcessor ▁post Processor ▁= ▁this ▁. ▁context ▁. ▁getBean ▁( ▁Servlet Component Register ing PostProcessor ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁post Processor ▁. ▁getPack ages To Scan ▁( ▁) ▁) ▁. ▁containsExactly InAnyOrder ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁void ▁basePackage And No Base Package Are Combined Correct ly ▁( ▁) ▁{ ▁this ▁. ▁context ▁= ▁new ▁Annotation Config Application Context ▁( ▁Base Packages ▁. ▁class ▁, ▁No Base Packages ▁. ▁class ▁) ▁; ▁Servlet Component Register ing PostProcessor ▁post Processor ▁= ▁this ▁. ▁context ▁. ▁getBean ▁( ▁Servlet Component Register ing PostProcessor ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁post Processor ▁. ▁getPack ages To Scan ▁( ▁) ▁) ▁. ▁containsExactly InAnyOrder ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Configuration ▁( ▁proxyBean Methods ▁= ▁false ▁) ▁@ ▁Servlet Component Scan ▁( ▁{ ▁STR ▁, ▁STR ▁} ▁) ▁static ▁class ▁Value Packages ▁{ ▁} ▁@ ▁Configuration ▁( ▁proxyBean Methods ▁= ▁false ▁) ▁@ ▁Servlet Component Scan ▁( ▁basePackages ▁= ▁{ ▁STR ▁, ▁STR ▁} ▁) ▁static ▁class ▁Base Packages ▁{ ▁} ▁@ ▁Configuration ▁( ▁proxyBean Methods ▁= ▁false ▁) ▁@ ▁Servlet Component Scan ▁( ▁basePackages ▁= ▁STR ▁) ▁static ▁class ▁Ad ditional Packages ▁{ ▁} ▁@ ▁Configuration ▁( ▁proxyBean Methods ▁= ▁false ▁) ▁@ ▁Servlet Component Scan ▁( ▁basePackage Classes ▁= ▁Servlet Component Scan Registrar Tests ▁. ▁class ▁) ▁static ▁class ▁Base Package Classes ▁{ ▁} ▁@ ▁Configuration ▁( ▁proxyBean Methods ▁= ▁false ▁) ▁@ ▁Servlet Component Scan ▁( ▁value ▁= ▁STR ▁, ▁basePackages ▁= ▁STR ▁) ▁static ▁class ▁Value And Base Packages ▁{ ▁} ▁@ ▁Configuration ▁( ▁proxyBean Methods ▁= ▁false ▁) ▁@ ▁Servlet Component Scan ▁static ▁class ▁No Base Packages ▁{ ▁} ▁}
▁register ForeignCall ▁( ▁bb ▁, ▁bb ▁. ▁get Providers ▁( ▁) ▁. ▁getF oreign Calls ▁( ▁) ▁. ▁getDescriptor ▁( ▁node ▁. ▁getOperation ▁( ▁) ▁. ▁foreign Call Signature ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁n ▁instanceof ▁Binary Math Intrinsic Node ▁) ▁{ ▁Binary Math Intrinsic Node ▁node ▁= ▁( ▁Binary Math Intrinsic Node ▁) ▁n ▁; ▁register ForeignCall ▁( ▁bb ▁, ▁bb ▁. ▁get Providers ▁( ▁) ▁. ▁getF oreign Calls ▁( ▁) ▁. ▁getDescriptor ▁( ▁node ▁. ▁getOperation ▁( ▁) ▁. ▁foreign Call Signature ▁) ▁) ▁; ▁} ▁} ▁} ▁private ▁void ▁register Embedded Root ▁( ▁ConstantNode ▁cn ▁) ▁{ ▁if ▁( ▁bb ▁. ▁sc anning Policy ▁( ▁) ▁. ▁track Constant ▁( ▁bb ▁, ▁cn ▁. ▁asJava Constant ▁( ▁) ▁) ▁) ▁{ ▁Bytecode Position ▁position ▁= ▁cn ▁. ▁getNode SourcePosition ▁( ▁) ▁; ▁if ▁( ▁position ▁== ▁null ▁) ▁{ ▁position ▁= ▁new ▁Bytecode Position ▁( ▁null ▁, ▁method ▁, ▁0 ▁) ▁; ▁} ▁bb ▁. ▁getUn iverse ▁( ▁) ▁. ▁register Embedded Root ▁( ▁cn ▁. ▁asJava Constant ▁( ▁) ▁, ▁position ▁) ▁; ▁} ▁} ▁private ▁static ▁void ▁register ForeignCall ▁( ▁BigBang ▁bb ▁, ▁Foreign Call Descriptor ▁foreign Call Descriptor ▁) ▁{ ▁Optional ▁< ▁AnalysisMethod ▁> ▁targetMethod ▁= ▁bb ▁. ▁getHost VM ▁( ▁) ▁. ▁handle ForeignCall ▁( ▁foreign Call Descriptor ▁, ▁bb ▁. ▁get Providers ▁( ▁) ▁. ▁getF oreign Calls ▁( ▁) ▁) ▁; ▁targetMethod ▁. ▁ifPresent ▁( ▁analysis Method ▁-> ▁{ ▁bb ▁. ▁add Root Method ▁( ▁analysis Method ▁) ▁; ▁} ▁) ▁; ▁} ▁protected ▁void ▁apply ▁( ▁) ▁{ ▁if ▁( ▁Guarded Annotation Access ▁. ▁isAnnotation Present ▁( ▁method ▁, ▁NodeIntrinsic ▁. ▁class ▁) ▁) ▁{ ▁graph ▁. ▁getDebug ▁( ▁) ▁. ▁log ▁( ▁STR ▁, ▁method ▁) ▁; ▁Analysis Type ▁returnType ▁= ▁( ▁Analysis Type ▁) ▁method ▁. ▁getSignature ▁( ▁) ▁. ▁getReturnType ▁( ▁method ▁. ▁getDecl aringClass ▁( ▁) ▁) ▁; ▁if ▁( ▁returnType ▁. ▁getJava Kind ▁( ▁) ▁== ▁JavaKind ▁. ▁Object ▁) ▁{ ▁Type Flow ▁< ▁? ▁> ▁returnType Flow ▁= ▁method Flow ▁. ▁getResult Flow ▁( ▁) ▁. ▁getDeclared Type ▁( ▁) ▁. ▁getType Flow ▁( ▁this ▁. ▁bb ▁, ▁true ▁) ▁; ▁Bytecode Position ▁source ▁= ▁new ▁Bytecode Position ▁( ▁null ▁, ▁method ▁, ▁0 ▁) ▁; ▁returnType Flow ▁= ▁new ▁Proxy TypeFlow ▁( ▁source ▁, ▁returnType Flow ▁) ▁; ▁F ormal ReturnType Flow ▁result Flow ▁= ▁new ▁F ormal ReturnType Flow ▁( ▁source ▁, ▁returnType ▁, ▁method ▁) ▁; ▁returnType Flow ▁. ▁add Original Use ▁( ▁this ▁. ▁bb ▁, ▁result Flow ▁) ▁; ▁method Flow ▁. ▁add M isc Entry ▁( ▁returnType Flow ▁) ▁; ▁method Flow ▁. ▁setResult ▁( ▁result Flow ▁) ▁; ▁} ▁return ▁; ▁} ▁if ▁( ▁! ▁parse ▁( ▁) ▁) ▁{ ▁return ▁; ▁} ▁bb ▁. ▁getHost VM ▁( ▁) ▁. ▁method Before TypeFlow Creation Hook ▁( ▁bb ▁, ▁method ▁, ▁graph ▁) ▁; ▁processed Nodes ▁= ▁new ▁Node Bit Map ▁( ▁graph ▁) ▁; ▁Type Flow sOf Nodes ▁type Flows ▁= ▁new ▁Type Flow sOf Nodes ▁( ▁) ▁;
▁public ▁class ▁V 9 1 Network ▁extends ▁Network ▁< ▁Auth Required ▁, ▁Request Pause d ▁> ▁{ ▁public ▁V 9 1 Network ▁( ▁Dev Tools ▁dev Tools ▁) ▁{ ▁super ▁( ▁dev Tools ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Command ▁< ▁Void ▁> ▁setUser Agent Override ▁( ▁User Agent ▁userAgent ▁) ▁{ ▁return ▁org ▁. ▁openqa ▁. ▁selenium ▁. ▁devtools ▁. ▁v 9 1 ▁. ▁network ▁. ▁Network ▁. ▁setUser Agent Override ▁( ▁userAgent ▁. ▁userAgent ▁( ▁) ▁, ▁userAgent ▁. ▁accept Language ▁( ▁) ▁, ▁userAgent ▁. ▁platform ▁( ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Command ▁< ▁Void ▁> ▁enable Network Caching ▁( ▁) ▁{ ▁return ▁org ▁. ▁openqa ▁. ▁selenium ▁. ▁devtools ▁. ▁v 9 1 ▁. ▁network ▁. ▁Network ▁. ▁setCache Disabled ▁( ▁false ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Command ▁< ▁Void ▁> ▁disable Network Caching ▁( ▁) ▁{ ▁return ▁org ▁. ▁openqa ▁. ▁selenium ▁. ▁devtools ▁. ▁v 9 1 ▁. ▁network ▁. ▁Network ▁. ▁setCache Disabled ▁( ▁true ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Command ▁< ▁Void ▁> ▁enable Fetch For All Patterns ▁( ▁) ▁{ ▁return ▁Fetch ▁. ▁enable ▁( ▁Optional ▁. ▁of ▁( ▁ImmutableList ▁. ▁of ▁( ▁new ▁Request Pattern ▁( ▁Optional ▁. ▁of ▁( ▁STR ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁) ▁) ▁) ▁, ▁Optional ▁. ▁of ▁( ▁true ▁) ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Command ▁< ▁Void ▁> ▁disable Fetch ▁( ▁) ▁{ ▁return ▁Fetch ▁. ▁disable ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Event ▁< ▁Auth Required ▁> ▁auth Required Event ▁( ▁) ▁{ ▁return ▁Fetch ▁. ▁auth Required ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁String ▁getUri From ▁( ▁Auth Required ▁auth Required ▁) ▁{ ▁return ▁auth Required ▁. ▁getAuth Ch all eng e ▁( ▁) ▁. ▁getOrigin ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Command ▁< ▁Void ▁> ▁continue With Auth ▁( ▁Auth Required ▁auth Required ▁, ▁Username And Password ▁credentials ▁) ▁{ ▁return ▁Fetch ▁. ▁continue With Auth ▁( ▁auth Required ▁. ▁getRequest Id ▁( ▁) ▁, ▁new ▁Auth Ch all eng e Response ▁( ▁Auth Ch all eng e Response ▁. ▁Response ▁. ▁PRO VID EC RED ENTIAL S ▁, ▁Optional ▁. ▁of ▁( ▁credentials ▁. ▁username ▁( ▁) ▁) ▁, ▁Optional ▁. ▁ofNullable ▁( ▁credentials ▁. ▁password ▁( ▁) ▁) ▁) ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Command ▁< ▁Void ▁> ▁cancel Auth ▁( ▁Auth Required ▁auth Required ▁) ▁{ ▁return ▁Fetch ▁. ▁continue With Auth ▁( ▁auth Required ▁. ▁getRequest Id ▁( ▁) ▁, ▁new ▁Auth Ch all eng e Response ▁( ▁Auth Ch all eng e Response ▁. ▁Response ▁. ▁CANCE LA UTH ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁) ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Event ▁< ▁Request Pause d ▁> ▁request Pause d Event ▁( ▁) ▁{ ▁return ▁Fetch ▁. ▁request Pause d ▁( ▁) ▁; ▁}
▁public ▁class ▁Batch Execution Key edStateBackend ▁< ▁K ▁> ▁implements ▁Checkpoint able Key edStateBackend ▁< ▁K ▁> ▁{ ▁private ▁static ▁final ▁Logger ▁LOG ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Batch Execution Key edStateBackend ▁. ▁class ▁) ▁; ▁private ▁static ▁final ▁Map ▁< ▁State Descriptor ▁. ▁Type ▁, ▁State Factory ▁> ▁STATE _ FACTOR IES ▁= ▁Stream ▁. ▁of ▁( ▁Tuple 2 ▁. ▁of ▁( ▁State Descriptor ▁. ▁Type ▁. ▁VALUE ▁, ▁( ▁State Factory ▁) ▁Batch Execution KeyValue State ▁:: ▁create ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁State Descriptor ▁. ▁Type ▁. ▁LIST ▁, ▁( ▁State Factory ▁) ▁Batch Execution Key List State ▁:: ▁create ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁State Descriptor ▁. ▁Type ▁. ▁MAP ▁, ▁( ▁State Factory ▁) ▁Batch Execution Key Map State ▁:: ▁create ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁State Descriptor ▁. ▁Type ▁. ▁AG GREG AT ING ▁, ▁( ▁State Factory ▁) ▁Batch Execution Key Aggreg ating State ▁:: ▁create ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁State Descriptor ▁. ▁Type ▁. ▁RED U C ING ▁, ▁( ▁State Factory ▁) ▁Batch Execution Key Re ducing State ▁:: ▁create ▁) ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toMap ▁( ▁t ▁-> ▁t ▁. ▁f 0 ▁, ▁t ▁-> ▁t ▁. ▁f 1 ▁) ▁) ▁; ▁private ▁K ▁current Key ▁= ▁null ▁; ▁private ▁final ▁TypeSerializer ▁< ▁K ▁> ▁keySerializer ▁; ▁private ▁final ▁List ▁< ▁Key Selection Listener ▁< ▁K ▁> ▁> ▁key Selection Listeners ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁private ▁final ▁Map ▁< ▁String ▁, ▁State ▁> ▁states ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁private ▁final ▁Map ▁< ▁String ▁, ▁Key Grouped Internal PriorityQueue ▁< ▁? ▁> ▁> ▁priority Queues ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁private ▁final ▁KeyGroupRange ▁keyGroupRange ▁; ▁public ▁Batch Execution Key edStateBackend ▁( ▁TypeSerializer ▁< ▁K ▁> ▁keySerializer ▁, ▁KeyGroupRange ▁keyGroupRange ▁) ▁{ ▁this ▁. ▁keySerializer ▁= ▁keySerializer ▁; ▁this ▁. ▁keyGroupRange ▁= ▁keyGroupRange ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setCurrent Key ▁( ▁K ▁newKey ▁) ▁{ ▁if ▁( ▁! ▁Objects ▁. ▁equals ▁( ▁newKey ▁, ▁current Key ▁) ▁) ▁{ ▁notify Key Selected ▁( ▁newKey ▁) ▁; ▁for ▁( ▁State ▁value ▁: ▁states ▁. ▁values ▁( ▁) ▁) ▁{ ▁( ▁( ▁Abstract Batch Execution Key State ▁< ▁? ▁, ▁? ▁, ▁? ▁> ▁) ▁value ▁) ▁. ▁clear All Namespaces ▁( ▁) ▁; ▁} ▁for ▁( ▁Key Grouped Internal PriorityQueue ▁< ▁? ▁> ▁value ▁: ▁priority Queues ▁. ▁values ▁( ▁) ▁) ▁{ ▁while ▁( ▁value ▁. ▁poll ▁( ▁) ▁!= ▁null ▁) ▁{ ▁} ▁} ▁this ▁. ▁current Key ▁= ▁newKey ▁; ▁} ▁} ▁@ ▁Override ▁public ▁K ▁getCurrent Key ▁( ▁) ▁{ ▁return ▁current Key ▁; ▁} ▁@ ▁Override ▁public ▁TypeSerializer ▁< ▁K ▁> ▁getKey Serializer ▁( ▁) ▁{ ▁return ▁keySerializer ▁; ▁}
▁public ▁final ▁class ▁Lambda Utils ▁{ ▁private ▁static ▁final ▁Pattern ▁L AM B DA _ PATTERN ▁= ▁Pattern ▁. ▁compile ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁char ▁[ ▁] ▁HEX ▁= ▁STR ▁. ▁toCharArray ▁( ▁) ▁; ▁private ▁static ▁GraphBuilder Configuration ▁build Lambda Parser Config ▁( ▁Class Initialization Plugin ▁c ip ▁) ▁{ ▁GraphBuilder Configuration ▁. ▁P lugins ▁plugins ▁= ▁new ▁GraphBuilder Configuration ▁. ▁P lugins ▁( ▁new ▁Invocation Plugins ▁( ▁) ▁) ▁; ▁plugins ▁. ▁setClass Initialization Plugin ▁( ▁c ip ▁) ▁; ▁return ▁GraphBuilder Configuration ▁. ▁getDefault ▁( ▁plugins ▁) ▁. ▁with Eager Resol ving ▁( ▁true ▁) ▁; ▁} ▁private ▁Lambda Utils ▁( ▁) ▁{ ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁static ▁String ▁find Stable Lambda Name ▁( ▁Class Initialization Plugin ▁c ip ▁, ▁Providers ▁providers ▁, ▁ResolvedJava Type ▁lambda Type ▁, ▁OptionValues ▁options ▁, ▁DebugContext ▁debug ▁, ▁Object ▁ctx ▁) ▁throws ▁Runtime Exception ▁{ ▁ResolvedJava Method ▁[ ▁] ▁lambda Proxy Methods ▁= ▁Arrays ▁. ▁stream ▁( ▁lambda Type ▁. ▁getDeclared Methods ▁( ▁) ▁) ▁. ▁filter ▁( ▁m ▁-> ▁! ▁m ▁. ▁is Bridge ▁( ▁) ▁&& ▁m ▁. ▁isPublic ▁( ▁) ▁) ▁. ▁toArray ▁( ▁ResolvedJava Method ▁[ ▁] ▁:: ▁new ▁) ▁; ▁assert ▁lambda Proxy Methods ▁. ▁length ▁== ▁1 ▁: ▁STR ▁; ▁StructuredGraph ▁graph ▁= ▁new ▁StructuredGraph ▁. ▁Builder ▁( ▁options ▁, ▁debug ▁) ▁. ▁method ▁( ▁lambda Proxy Methods ▁[ ▁0 ▁] ▁) ▁. ▁build ▁( ▁) ▁; ▁try ▁( ▁DebugContext ▁. ▁Scope ▁ignored ▁= ▁debug ▁. ▁scope ▁( ▁STR ▁, ▁graph ▁, ▁lambda Type ▁, ▁ctx ▁) ▁) ▁{ ▁GraphBuilder Phase ▁lambda Parser Phase ▁= ▁new ▁GraphBuilder Phase ▁( ▁build Lambda Parser Config ▁( ▁c ip ▁) ▁) ▁; ▁High TierContext ▁context ▁= ▁new ▁High TierContext ▁( ▁providers ▁, ▁null ▁, ▁Optim istic Optim izations ▁. ▁NONE ▁) ▁; ▁lambda Parser Phase ▁. ▁apply ▁( ▁graph ▁, ▁context ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁e ▁) ▁{ ▁throw ▁debug ▁. ▁handle ▁( ▁e ▁) ▁; ▁} ▁List ▁< ▁ResolvedJava Method ▁> ▁invok ed Methods ▁= ▁StreamSupport ▁. ▁stream ▁( ▁graph ▁. ▁getIn vok es ▁( ▁) ▁. ▁spliterator ▁( ▁) ▁, ▁false ▁) ▁. ▁map ▁( ▁( ▁inv ▁) ▁-> ▁inv ▁. ▁getTarget Method ▁( ▁) ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toList ▁( ▁) ▁) ▁; ▁if ▁( ▁invok ed Methods ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁StringBuilder ▁sb ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁sb ▁. ▁append ▁( ▁STR ▁) ▁. ▁append ▁( ▁lambda Type ▁. ▁to ClassName ▁( ▁) ▁) ▁; ▁for ▁( ▁ResolvedJava Method ▁m ▁: ▁lambda Type ▁. ▁getDeclared Methods ▁( ▁) ▁) ▁{ ▁sb ▁. ▁append ▁( ▁STR ▁) ▁. ▁append ▁( ▁m ▁) ▁; ▁} ▁throw ▁new ▁JVM CI Error ▁( ▁sb ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁String ▁lambda Target Name ▁= ▁create Stable Lambda Name ▁( ▁lambda Type ▁, ▁invok ed Methods ▁) ▁; ▁return ▁lambda Target Name ▁; ▁} ▁public ▁static ▁boolean ▁is Lambda Type ▁( ▁ResolvedJava Type ▁type ▁) ▁{ ▁String ▁typeName ▁= ▁type ▁. ▁getName ▁( ▁) ▁;
▁ByteArray Support ▁. ▁big Endian ▁( ▁) ▁. ▁put Float ▁( ▁buffer ▁, ▁3 ▁, ▁Float ▁. ▁int BitsTo Float ▁( ▁0 x 4 24 1 40 39 ▁) ▁) ▁; ▁assert Bytes Equal ▁( ▁buffer ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁put Float LittleEndian ▁( ▁) ▁{ ▁byte ▁[ ▁] ▁buffer ▁= ▁new ▁byte ▁[ ▁10 ▁] ▁; ▁ByteArray Support ▁. ▁l ittleEndian ▁( ▁) ▁. ▁put Float ▁( ▁buffer ▁, ▁2 ▁, ▁Float ▁. ▁int BitsTo Float ▁( ▁0 x 4 24 1 40 39 ▁) ▁) ▁; ▁assert Bytes Equal ▁( ▁buffer ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁( ▁expected ▁= ▁Index OutOfBounds Exception ▁. ▁class ▁) ▁public ▁void ▁put Float BigEndian OutOfBounds ▁( ▁) ▁throws ▁Index OutOfBounds Exception ▁{ ▁byte ▁[ ▁] ▁buffer ▁= ▁new ▁byte ▁[ ▁10 ▁] ▁; ▁ByteArray Support ▁. ▁big Endian ▁( ▁) ▁. ▁put Float ▁( ▁buffer ▁, ▁7 ▁, ▁1. 7 f ▁) ▁; ▁} ▁@ ▁Test ▁( ▁expected ▁= ▁Index OutOfBounds Exception ▁. ▁class ▁) ▁public ▁void ▁put Float LittleEndian OutOfBounds ▁( ▁) ▁throws ▁Index OutOfBounds Exception ▁{ ▁byte ▁[ ▁] ▁buffer ▁= ▁new ▁byte ▁[ ▁10 ▁] ▁; ▁ByteArray Support ▁. ▁l ittleEndian ▁( ▁) ▁. ▁put Float ▁( ▁buffer ▁, ▁9 ▁, ▁1. 7 f ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁getFloat BigEndian ▁( ▁) ▁{ ▁byte ▁[ ▁] ▁buffer ▁= ▁hex ToBytes ▁( ▁STR ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁Float ▁. ▁int BitsTo Float ▁( ▁0 x 4 24 1 40 39 ▁) ▁, ▁ByteArray Support ▁. ▁big Endian ▁( ▁) ▁. ▁getFloat ▁( ▁buffer ▁, ▁0 ▁) ▁, ▁0 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁getFloat LittleEndian ▁( ▁) ▁{ ▁byte ▁[ ▁] ▁buffer ▁= ▁hex ToBytes ▁( ▁STR ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁Float ▁. ▁int BitsTo Float ▁( ▁0 x 4 24 1 40 39 ▁) ▁, ▁ByteArray Support ▁. ▁l ittleEndian ▁( ▁) ▁. ▁getFloat ▁( ▁buffer ▁, ▁0 ▁) ▁, ▁0 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁double BigEndian ▁( ▁) ▁{ ▁byte ▁[ ▁] ▁buffer ▁= ▁new ▁byte ▁[ ▁10 ▁] ▁; ▁ByteArray Support ▁. ▁big Endian ▁( ▁) ▁. ▁put Double ▁( ▁buffer ▁, ▁1 ▁, ▁Double ▁. ▁long BitsTo Double ▁( ▁0 x 4 24 1 40 39 3 83 7 36 35 L ▁) ▁) ▁; ▁assert Bytes Equal ▁( ▁buffer ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁double LittleEndian ▁( ▁) ▁{ ▁byte ▁[ ▁] ▁buffer ▁= ▁new ▁byte ▁[ ▁10 ▁] ▁; ▁ByteArray Support ▁. ▁l ittleEndian ▁( ▁) ▁. ▁put Double ▁( ▁buffer ▁, ▁2 ▁, ▁Double ▁. ▁long BitsTo Double ▁( ▁0 x 4 24 1 40 39 3 83 7 36 35 L ▁) ▁) ▁; ▁assert Bytes Equal ▁( ▁buffer ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁( ▁expected ▁= ▁Index OutOfBounds Exception ▁. ▁class ▁) ▁public ▁void ▁double BigEndian OutOfBounds ▁( ▁) ▁throws ▁Index OutOfBounds Exception ▁{ ▁byte ▁[ ▁] ▁buffer ▁= ▁new ▁byte ▁[ ▁8 ▁] ▁;
▁public ▁class ▁Feature d St icker Set Cell 2 ▁extends ▁FrameLayout ▁{ ▁private ▁final ▁int ▁current Account ▁= ▁User Config ▁. ▁selected Account ▁; ▁private ▁final ▁TextView ▁textView ▁; ▁private ▁final ▁TextView ▁value TextView ▁; ▁private ▁final ▁Backup ImageView ▁imageView ▁; ▁private ▁final ▁Progress Button ▁add Button ▁; ▁private ▁final ▁TextView ▁del Button ▁; ▁private ▁Animator Set ▁current Animation ▁; ▁private ▁TLRPC ▁. ▁Sticker Set Co ver ed ▁st ick ers Set ▁; ▁private ▁boolean ▁is Installed ▁; ▁private ▁boolean ▁need Divider ▁; ▁public ▁Feature d St icker Set Cell 2 ▁( ▁Context ▁context ▁) ▁{ ▁super ▁( ▁context ▁) ▁; ▁textView ▁= ▁new ▁TextView ▁( ▁context ▁) ▁; ▁textView ▁. ▁setTextColor ▁( ▁Theme ▁. ▁getColor ▁( ▁Theme ▁. ▁key _ window Background White Black Text ▁) ▁) ▁; ▁textView ▁. ▁setText Size ▁( ▁TypedValue ▁. ▁COMP LEX _ UNIT _ DI P ▁, ▁16 ▁) ▁; ▁textView ▁. ▁set Lines ▁( ▁1 ▁) ▁; ▁textView ▁. ▁setMax Lines ▁( ▁1 ▁) ▁; ▁textView ▁. ▁set Single Line ▁( ▁true ▁) ▁; ▁textView ▁. ▁set El li ps ize ▁( ▁TextUtils ▁. ▁Tr uncate At ▁. ▁END ▁) ▁; ▁textView ▁. ▁setG ravity ▁( ▁Locale Controller ▁. ▁isRTL ▁? ▁Gravity ▁. ▁RIGHT ▁: ▁Gravity ▁. ▁LEFT ▁) ▁; ▁addView ▁( ▁textView ▁, ▁LayoutHelper ▁. ▁create Frame ▁( ▁LayoutHelper ▁. ▁WRAP _ CONTENT ▁, ▁LayoutHelper ▁. ▁WRAP _ CONTENT ▁, ▁Locale Controller ▁. ▁isRTL ▁? ▁Gravity ▁. ▁RIGHT ▁: ▁Gravity ▁. ▁LEFT ▁, ▁Locale Controller ▁. ▁isRTL ▁? ▁22 ▁: ▁7 1 ▁, ▁10 ▁, ▁Locale Controller ▁. ▁isRTL ▁? ▁7 1 ▁: ▁22 ▁, ▁0 ▁) ▁) ▁; ▁value TextView ▁= ▁new ▁TextView ▁( ▁context ▁) ▁; ▁value TextView ▁. ▁setTextColor ▁( ▁Theme ▁. ▁getColor ▁( ▁Theme ▁. ▁key _ window Background White G ray Text 2 ▁) ▁) ▁; ▁value TextView ▁. ▁setText Size ▁( ▁TypedValue ▁. ▁COMP LEX _ UNIT _ DI P ▁, ▁13 ▁) ▁; ▁value TextView ▁. ▁set Lines ▁( ▁1 ▁) ▁; ▁value TextView ▁. ▁setMax Lines ▁( ▁1 ▁) ▁; ▁value TextView ▁. ▁set Single Line ▁( ▁true ▁) ▁; ▁value TextView ▁. ▁set El li ps ize ▁( ▁TextUtils ▁. ▁Tr uncate At ▁. ▁END ▁) ▁; ▁value TextView ▁. ▁setG ravity ▁( ▁Locale Controller ▁. ▁isRTL ▁? ▁Gravity ▁. ▁RIGHT ▁: ▁Gravity ▁. ▁LEFT ▁) ▁; ▁addView ▁( ▁value TextView ▁, ▁LayoutHelper ▁. ▁create Frame ▁( ▁LayoutHelper ▁. ▁WRAP _ CONTENT ▁, ▁LayoutHelper ▁. ▁WRAP _ CONTENT ▁, ▁Locale Controller ▁. ▁isRTL ▁? ▁Gravity ▁. ▁RIGHT ▁: ▁Gravity ▁. ▁LEFT ▁, ▁Locale Controller ▁. ▁isRTL ▁? ▁100 ▁: ▁7 1 ▁, ▁35 ▁, ▁Locale Controller ▁. ▁isRTL ▁? ▁7 1 ▁: ▁100 ▁, ▁0 ▁) ▁) ▁; ▁imageView ▁= ▁new ▁Backup ImageView ▁( ▁context ▁) ▁; ▁imageView ▁. ▁set Aspect F it ▁( ▁true ▁) ▁; ▁imageView ▁. ▁set Layer Num ▁( ▁1 ▁) ▁;
▁public ▁class ▁Account Instance ▁{ ▁private ▁int ▁current Account ▁; ▁private ▁static ▁volatile ▁Account Instance ▁[ ▁] ▁Instance ▁= ▁new ▁Account Instance ▁[ ▁User Config ▁. ▁MAX _ AC COUNT _ COUNT ▁] ▁; ▁public ▁static ▁Account Instance ▁getInstance ▁( ▁int ▁num ▁) ▁{ ▁Account Instance ▁local Instance ▁= ▁Instance ▁[ ▁num ▁] ▁; ▁if ▁( ▁local Instance ▁== ▁null ▁) ▁{ ▁synchronized ▁( ▁Account Instance ▁. ▁class ▁) ▁{ ▁local Instance ▁= ▁Instance ▁[ ▁num ▁] ▁; ▁if ▁( ▁local Instance ▁== ▁null ▁) ▁{ ▁Instance ▁[ ▁num ▁] ▁= ▁local Instance ▁= ▁new ▁Account Instance ▁( ▁num ▁) ▁; ▁} ▁} ▁} ▁return ▁local Instance ▁; ▁} ▁public ▁Account Instance ▁( ▁int ▁instance ▁) ▁{ ▁current Account ▁= ▁instance ▁; ▁} ▁public ▁Messages Controller ▁getM essages Controller ▁( ▁) ▁{ ▁return ▁Messages Controller ▁. ▁getInstance ▁( ▁current Account ▁) ▁; ▁} ▁public ▁Messages Storage ▁getM essages Storage ▁( ▁) ▁{ ▁return ▁Messages Storage ▁. ▁getInstance ▁( ▁current Account ▁) ▁; ▁} ▁public ▁Contact s Controller ▁get Contact s Controller ▁( ▁) ▁{ ▁return ▁Contact s Controller ▁. ▁getInstance ▁( ▁current Account ▁) ▁; ▁} ▁public ▁Media Data Controller ▁getM edia Data Controller ▁( ▁) ▁{ ▁return ▁Media Data Controller ▁. ▁getInstance ▁( ▁current Account ▁) ▁; ▁} ▁public ▁Connection s Manager ▁getConnection s Manager ▁( ▁) ▁{ ▁return ▁Connection s Manager ▁. ▁getInstance ▁( ▁current Account ▁) ▁; ▁} ▁public ▁Notification s Controller ▁get Notification s Controller ▁( ▁) ▁{ ▁return ▁Notification s Controller ▁. ▁getInstance ▁( ▁current Account ▁) ▁; ▁} ▁public ▁Notification Center ▁get Notification Center ▁( ▁) ▁{ ▁return ▁Notification Center ▁. ▁getInstance ▁( ▁current Account ▁) ▁; ▁} ▁public ▁Location Controller ▁getLocation Controller ▁( ▁) ▁{ ▁return ▁Location Controller ▁. ▁getInstance ▁( ▁current Account ▁) ▁; ▁} ▁public ▁User Config ▁getUser Config ▁( ▁) ▁{ ▁return ▁User Config ▁. ▁getInstance ▁( ▁current Account ▁) ▁; ▁} ▁public ▁Download Controller ▁get Download Controller ▁( ▁) ▁{ ▁return ▁Download Controller ▁. ▁getInstance ▁( ▁current Account ▁) ▁; ▁} ▁public ▁Send Messages Helper ▁getSend Messages Helper ▁( ▁) ▁{ ▁return ▁Send Messages Helper ▁. ▁getInstance ▁( ▁current Account ▁) ▁; ▁} ▁public ▁Secret Chat Helper ▁getSecret Chat Helper ▁( ▁) ▁{ ▁return ▁Secret Chat Helper ▁. ▁getInstance ▁( ▁current Account ▁) ▁; ▁} ▁public ▁Stats Controller ▁getStats Controller ▁( ▁) ▁{ ▁return ▁Stats Controller ▁. ▁getInstance ▁( ▁current Account ▁) ▁; ▁} ▁public ▁File Loader ▁getFile Loader ▁( ▁) ▁{ ▁return ▁File Loader ▁. ▁getInstance ▁( ▁current Account ▁) ▁; ▁} ▁public ▁File Ref Controller ▁getFile Ref Controller ▁( ▁) ▁{ ▁return ▁File Ref Controller ▁. ▁getInstance ▁( ▁current Account ▁) ▁; ▁} ▁public ▁Shared Preferences ▁get Notification s Settings ▁( ▁) ▁{ ▁return ▁Messages Controller ▁. ▁get Notification s Settings ▁( ▁current Account ▁) ▁; ▁} ▁public ▁int ▁getCurrent Account ▁( ▁) ▁{ ▁return ▁current Account ▁; ▁} ▁}
▁public ▁class ▁SignalService Group ▁{ ▁public ▁enum ▁Type ▁{ ▁UNKNOWN ▁, ▁UPDATE ▁, ▁DE LI VER ▁, ▁ QU IT ▁, ▁REQUEST _ INFO ▁} ▁private ▁final ▁byte ▁[ ▁] ▁groupId ▁; ▁private ▁final ▁Type ▁type ▁; ▁private ▁final ▁Optional ▁< ▁String ▁> ▁name ▁; ▁private ▁final ▁Optional ▁< ▁List ▁< ▁SignalService Address ▁> ▁> ▁members ▁; ▁private ▁final ▁Optional ▁< ▁SignalService Attachment ▁> ▁avatar ▁; ▁public ▁SignalService Group ▁( ▁byte ▁[ ▁] ▁groupId ▁) ▁{ ▁this ▁( ▁Type ▁. ▁DE LI VER ▁, ▁groupId ▁, ▁null ▁, ▁null ▁, ▁null ▁) ▁; ▁} ▁public ▁SignalService Group ▁( ▁Type ▁type ▁, ▁byte ▁[ ▁] ▁groupId ▁, ▁String ▁name ▁, ▁List ▁< ▁SignalService Address ▁> ▁members ▁, ▁SignalService Attachment ▁avatar ▁) ▁{ ▁this ▁. ▁type ▁= ▁type ▁; ▁this ▁. ▁groupId ▁= ▁groupId ▁; ▁this ▁. ▁name ▁= ▁Optional ▁. ▁from Nullable ▁( ▁name ▁) ▁; ▁this ▁. ▁members ▁= ▁Optional ▁. ▁from Nullable ▁( ▁members ▁) ▁; ▁this ▁. ▁avatar ▁= ▁Optional ▁. ▁from Nullable ▁( ▁avatar ▁) ▁; ▁} ▁public ▁byte ▁[ ▁] ▁getGroupId ▁( ▁) ▁{ ▁return ▁groupId ▁; ▁} ▁public ▁Type ▁getType ▁( ▁) ▁{ ▁return ▁type ▁; ▁} ▁public ▁Optional ▁< ▁String ▁> ▁getName ▁( ▁) ▁{ ▁return ▁name ▁; ▁} ▁public ▁Optional ▁< ▁List ▁< ▁SignalService Address ▁> ▁> ▁getMem bers ▁( ▁) ▁{ ▁return ▁members ▁; ▁} ▁public ▁Optional ▁< ▁SignalService Attachment ▁> ▁getA vatar ▁( ▁) ▁{ ▁return ▁avatar ▁; ▁} ▁public ▁static ▁Builder ▁new Update Builder ▁( ▁) ▁{ ▁return ▁new ▁Builder ▁( ▁Type ▁. ▁UPDATE ▁) ▁; ▁} ▁public ▁static ▁Builder ▁newBuilder ▁( ▁Type ▁type ▁) ▁{ ▁return ▁new ▁Builder ▁( ▁type ▁) ▁; ▁} ▁public ▁static ▁class ▁Builder ▁{ ▁private ▁Type ▁type ▁; ▁private ▁byte ▁[ ▁] ▁id ▁; ▁private ▁String ▁name ▁; ▁private ▁List ▁< ▁SignalService Address ▁> ▁members ▁; ▁private ▁SignalService Attachment ▁avatar ▁; ▁private ▁Builder ▁( ▁Type ▁type ▁) ▁{ ▁this ▁. ▁type ▁= ▁type ▁; ▁} ▁public ▁Builder ▁with Id ▁( ▁byte ▁[ ▁] ▁id ▁) ▁{ ▁this ▁. ▁id ▁= ▁id ▁; ▁return ▁this ▁; ▁} ▁public ▁Builder ▁withName ▁( ▁String ▁name ▁) ▁{ ▁this ▁. ▁name ▁= ▁name ▁; ▁return ▁this ▁; ▁} ▁public ▁Builder ▁with Members ▁( ▁List ▁< ▁SignalService Address ▁> ▁members ▁) ▁{ ▁this ▁. ▁members ▁= ▁members ▁; ▁return ▁this ▁; ▁} ▁public ▁Builder ▁with Avatar ▁( ▁SignalService Attachment ▁avatar ▁) ▁{ ▁this ▁. ▁avatar ▁= ▁avatar ▁; ▁return ▁this ▁; ▁} ▁public ▁SignalService Group ▁build ▁( ▁) ▁{ ▁if ▁( ▁id ▁== ▁null ▁) ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁if ▁( ▁type ▁== ▁Type ▁. ▁UPDATE ▁&& ▁name ▁== ▁null ▁&& ▁members ▁== ▁null ▁&& ▁avatar ▁== ▁null ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁return ▁new ▁SignalService Group ▁( ▁type ▁, ▁id ▁, ▁name ▁, ▁members ▁, ▁avatar ▁) ▁; ▁} ▁} ▁}
▁public ▁abstract ▁class ▁Native Info TreeVisitor ▁extends ▁Info TreeVisitor ▁{ ▁protected ▁final ▁Native Libraries ▁native Libs ▁; ▁protected ▁Native Info TreeVisitor ▁( ▁Native Libraries ▁native Libs ▁) ▁{ ▁this ▁. ▁native Libs ▁= ▁native Libs ▁; ▁} ▁protected ▁final ▁void ▁add Error ▁( ▁String ▁msg ▁, ▁Object ▁... ▁context ▁) ▁{ ▁native Libs ▁. ▁add Error ▁( ▁msg ▁, ▁context ▁) ▁; ▁} ▁protected ▁final ▁int ▁getSizeInBytes ▁( ▁JavaKind ▁kind ▁) ▁{ ▁return ▁native Libs ▁. ▁getTarget ▁( ▁) ▁. ▁arch ▁. ▁getPlatform Kind ▁( ▁kind ▁) ▁. ▁getSizeInBytes ▁( ▁) ▁; ▁} ▁protected ▁final ▁int ▁getSizeInBytes ▁( ▁ResolvedJava Type ▁type ▁) ▁{ ▁return ▁getSizeInBytes ▁( ▁type ▁. ▁getJava Kind ▁( ▁) ▁) ▁; ▁} ▁protected ▁final ▁boolean ▁isS igned ▁( ▁ResolvedJava Type ▁type ▁) ▁{ ▁return ▁native Libs ▁. ▁isS igned ▁( ▁type ▁) ▁; ▁} ▁}
▁public ▁class ▁Close IndexRequest Tests ▁extends ▁ESTestCase ▁{ ▁public ▁void ▁test Serialization ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁Close IndexRequest ▁request ▁= ▁random Request ▁( ▁) ▁; ▁try ▁( ▁Bytes StreamOutput ▁out ▁= ▁new ▁Bytes StreamOutput ▁( ▁) ▁) ▁{ ▁request ▁. ▁writeTo ▁( ▁out ▁) ▁; ▁final ▁Close IndexRequest ▁deserialized Request ▁; ▁try ▁( ▁StreamInput ▁in ▁= ▁out ▁. ▁bytes ▁( ▁) ▁. ▁streamInput ▁( ▁) ▁) ▁{ ▁deserialized Request ▁= ▁new ▁Close IndexRequest ▁( ▁in ▁) ▁; ▁} ▁assertEquals ▁( ▁request ▁. ▁timeout ▁( ▁) ▁, ▁deserialized Request ▁. ▁timeout ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁request ▁. ▁masterNode Timeout ▁( ▁) ▁, ▁deserialized Request ▁. ▁masterNode Timeout ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁request ▁. ▁indicesOptions ▁( ▁) ▁, ▁deserialized Request ▁. ▁indicesOptions ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁request ▁. ▁getParent Task ▁( ▁) ▁, ▁deserialized Request ▁. ▁getParent Task ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁request ▁. ▁waitFor ActiveShards ▁( ▁) ▁, ▁deserialized Request ▁. ▁waitFor ActiveShards ▁( ▁) ▁) ▁; ▁assert ArrayEquals ▁( ▁request ▁. ▁indices ▁( ▁) ▁, ▁deserialized Request ▁. ▁indices ▁( ▁) ▁) ▁; ▁} ▁} ▁public ▁void ▁testB wc Serialization ▁( ▁) ▁throws ▁Exception ▁{ ▁{ ▁final ▁Close IndexRequest ▁request ▁= ▁random Request ▁( ▁) ▁; ▁try ▁( ▁Bytes StreamOutput ▁out ▁= ▁new ▁Bytes StreamOutput ▁( ▁) ▁) ▁{ ▁out ▁. ▁setVersion ▁( ▁Version Utils ▁. ▁random Compatible Version ▁( ▁random ▁( ▁) ▁, ▁Version ▁. ▁CURRENT ▁) ▁) ▁; ▁request ▁. ▁writeTo ▁( ▁out ▁) ▁; ▁try ▁( ▁StreamInput ▁in ▁= ▁out ▁. ▁bytes ▁( ▁) ▁. ▁streamInput ▁( ▁) ▁) ▁{ ▁in ▁. ▁setVersion ▁( ▁out ▁. ▁getVersion ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁request ▁. ▁getParent Task ▁( ▁) ▁, ▁TaskId ▁. ▁readFrom Stream ▁( ▁in ▁) ▁) ▁; ▁assertEquals ▁( ▁request ▁. ▁masterNode Timeout ▁( ▁) ▁, ▁in ▁. ▁read TimeValue ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁request ▁. ▁timeout ▁( ▁) ▁, ▁in ▁. ▁read TimeValue ▁( ▁) ▁) ▁; ▁assert ArrayEquals ▁( ▁request ▁. ▁indices ▁( ▁) ▁, ▁in ▁. ▁readString Array ▁( ▁) ▁) ▁; ▁final ▁IndicesOptions ▁indicesOptions ▁= ▁IndicesOptions ▁. ▁read Indices Options ▁( ▁in ▁) ▁; ▁if ▁( ▁out ▁. ▁getVersion ▁( ▁) ▁. ▁onOrAfter ▁( ▁Version ▁. ▁V _7 _7 _0 ▁) ▁|| ▁request ▁. ▁indicesOptions ▁( ▁) ▁. ▁expand Wildcard s Hidden ▁( ▁) ▁) ▁{ ▁assertEquals ▁( ▁request ▁. ▁indicesOptions ▁( ▁) ▁, ▁indicesOptions ▁) ▁; ▁} ▁if ▁( ▁in ▁. ▁getVersion ▁( ▁) ▁. ▁onOrAfter ▁( ▁Version ▁. ▁V _7 _2 _0 ▁) ▁) ▁{ ▁assertEquals ▁( ▁request ▁. ▁waitFor ActiveShards ▁( ▁) ▁, ▁Active ShardCount ▁. ▁readFrom ▁( ▁in ▁) ▁) ▁; ▁} ▁else ▁{ ▁assertEquals ▁( ▁0 ▁, ▁in ▁. ▁available ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁} ▁{ ▁final ▁Close IndexRequest ▁sample ▁= ▁random Request ▁( ▁) ▁; ▁final ▁Version ▁version ▁= ▁Version Utils ▁. ▁random Compatible Version ▁( ▁random ▁( ▁) ▁, ▁Version ▁. ▁CURRENT ▁) ▁; ▁try ▁( ▁Bytes StreamOutput ▁out ▁= ▁new ▁Bytes StreamOutput ▁( ▁) ▁) ▁{ ▁out ▁. ▁setVersion ▁( ▁version ▁) ▁;
▁public ▁class ▁Agent Grpc DataSender ▁extends ▁Grpc DataSender ▁implements ▁Enhanced DataSender ▁< ▁Object ▁> ▁{ ▁static ▁{ ▁Channel Buffers ▁. ▁buffer ▁( ▁2 ▁) ▁; ▁} ▁private ▁final ▁Agent Grpc ▁. ▁Agent Stub ▁agentInfo Stub ▁; ▁private ▁final ▁Agent Grpc ▁. ▁Agent Stub ▁agent Ping Stub ▁; ▁private ▁Grpc CommandService ▁grpc CommandService ▁; ▁private ▁final ▁Re connect Executor ▁reconnect Executor ▁; ▁private ▁volatile ▁Ping Stream Context ▁ping Stream Context ▁; ▁private ▁final ▁Re con nector ▁re con nector ▁; ▁public ▁Agent Grpc DataSender ▁( ▁String ▁host ▁, ▁int ▁port ▁, ▁int ▁executor QueueSize ▁, ▁Message Converter ▁< ▁Generated MessageV 3 ▁> ▁message Converter ▁, ▁Re connect Executor ▁reconnect Executor ▁, ▁final ▁Scheduled ExecutorService ▁ret r ans mission Executor ▁, ▁Channel Factory ▁channel Factory ▁, ▁Profiler CommandService Locator ▁profiler CommandService Locator ▁) ▁{ ▁super ▁( ▁host ▁, ▁port ▁, ▁executor QueueSize ▁, ▁message Converter ▁, ▁channel Factory ▁) ▁; ▁this ▁. ▁agentInfo Stub ▁= ▁Agent Grpc ▁. ▁new Stub ▁( ▁managed Channel ▁) ▁; ▁this ▁. ▁agent Ping Stub ▁= ▁new Agent Ping Stub ▁( ▁) ▁; ▁this ▁. ▁reconnect Executor ▁= ▁reconnect Executor ▁; ▁Command Service Stub Factory ▁command Service Stub Factory ▁= ▁new ▁Command Service Stub Factory ▁( ▁managed Channel ▁) ▁; ▁this ▁. ▁grpc CommandService ▁= ▁new ▁Grpc CommandService ▁( ▁command Service Stub Factory ▁, ▁reconnect Executor ▁, ▁profiler CommandService Locator ▁) ▁; ▁{ ▁final ▁Runnable ▁reconnect Job ▁= ▁new ▁Runnable ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁run ▁( ▁) ▁{ ▁ping Stream Context ▁= ▁new Ping Stream ▁( ▁agent Ping Stub ▁, ▁ret r ans mission Executor ▁) ▁; ▁} ▁} ▁; ▁this ▁. ▁re con nector ▁= ▁reconnect Executor ▁. ▁new Recon nector ▁( ▁reconnect Job ▁) ▁; ▁reconnect Job ▁. ▁run ▁( ▁) ▁; ▁} ▁} ▁private ▁Agent Grpc ▁. ▁Agent Stub ▁new Agent Ping Stub ▁( ▁) ▁{ ▁Agent Grpc ▁. ▁Agent Stub ▁agent Stub ▁= ▁Agent Grpc ▁. ▁new Stub ▁( ▁managed Channel ▁) ▁; ▁return ▁agent Stub ▁. ▁with Interceptors ▁( ▁new ▁Socket Id Client Interceptor ▁( ▁) ▁) ▁; ▁} ▁private ▁Ping Stream Context ▁new Ping Stream ▁( ▁Agent Grpc ▁. ▁Agent Stub ▁agent Stub ▁, ▁Scheduled ExecutorService ▁reconnect Scheduler ▁) ▁{ ▁final ▁Ping Stream Context ▁ping Stream Context ▁= ▁new ▁Ping Stream Context ▁( ▁agent Stub ▁, ▁re con nector ▁, ▁reconnect Scheduler ▁) ▁; ▁logger ▁. ▁info ▁( ▁STR ▁, ▁ping Stream Context ▁) ▁; ▁return ▁ping Stream Context ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁request ▁( ▁Object ▁data ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁request ▁( ▁Object ▁data ▁, ▁int ▁retry Count ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁request ▁( ▁Object ▁data ▁, ▁final ▁Future Listener ▁listener ▁) ▁{ ▁final ▁Generated MessageV 3 ▁message ▁= ▁this ▁. ▁message Converter ▁. ▁to Message ▁( ▁data ▁) ▁; ▁if ▁( ▁! ▁( ▁message ▁instanceof ▁P AgentInfo ▁) ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁data ▁) ▁; ▁}
▁create Bucket ed Table ▁( ▁STR ▁, ▁distribution B ▁, ▁DataSize ▁. ▁valueOf ▁( ▁STR ▁) ▁) ▁; ▁create Assignments ▁( ▁distribution B ▁, ▁AV AILABLE _ WOR KER S ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁) ▁; ▁long ▁distribution C ▁= ▁create Distribution ▁( ▁STR ▁, ▁2 ▁) ▁; ▁create Bucket ed Table ▁( ▁STR ▁, ▁distribution C ▁, ▁DataSize ▁. ▁valueOf ▁( ▁STR ▁) ▁) ▁; ▁create Assignments ▁( ▁distribution C ▁, ▁AV AILABLE _ WOR KER S ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁2 ▁, ▁0 ▁) ▁; ▁assert Balan cing ▁( ▁b alan cer ▁, ▁1 ▁) ▁; ▁assertEquals ▁( ▁b alan cer ▁. ▁fetch ClusterState ▁( ▁) ▁. ▁getAss igned Bytes ▁( ▁) ▁. ▁values ▁( ▁) ▁. ▁stream ▁( ▁) ▁. ▁distinct ▁( ▁) ▁. ▁count ▁( ▁) ▁, ▁1 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Multiple Distribution Un balance d With Disk Space 2 ▁( ▁) ▁{ ▁long ▁distribution A ▁= ▁create Distribution ▁( ▁STR ▁, ▁4 ▁) ▁; ▁create Bucket ed Table ▁( ▁STR ▁, ▁distribution A ▁, ▁DataSize ▁. ▁valueOf ▁( ▁STR ▁) ▁) ▁; ▁create Assignments ▁( ▁distribution A ▁, ▁AV AILABLE _ WOR KER S ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁) ▁; ▁long ▁distribution B ▁= ▁create Distribution ▁( ▁STR ▁, ▁4 ▁) ▁; ▁create Bucket ed Table ▁( ▁STR ▁, ▁distribution B ▁, ▁DataSize ▁. ▁valueOf ▁( ▁STR ▁) ▁) ▁; ▁create Assignments ▁( ▁distribution B ▁, ▁AV AILABLE _ WOR KER S ▁, ▁2 ▁, ▁1 ▁, ▁1 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁assert Balan cing ▁( ▁b alan cer ▁, ▁1 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Multiple Distribution Un balance d W or st Case ▁( ▁) ▁{ ▁long ▁distribution A ▁= ▁create Distribution ▁( ▁STR ▁, ▁4 ▁) ▁; ▁create Bucket ed Table ▁( ▁STR ▁, ▁distribution A ▁, ▁DataSize ▁. ▁valueOf ▁( ▁STR ▁) ▁) ▁; ▁create Assignments ▁( ▁distribution A ▁, ▁AV AILABLE _ WOR KER S ▁, ▁4 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁long ▁distribution B ▁= ▁create Distribution ▁( ▁STR ▁, ▁4 ▁) ▁; ▁create Bucket ed Table ▁( ▁STR ▁, ▁distribution B ▁, ▁DataSize ▁. ▁valueOf ▁( ▁STR ▁) ▁) ▁; ▁create Assignments ▁( ▁distribution B ▁, ▁AV AILABLE _ WOR KER S ▁, ▁4 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁long ▁distribution C ▁= ▁create Distribution ▁( ▁STR ▁, ▁4 ▁) ▁; ▁create Bucket ed Table ▁( ▁STR ▁, ▁distribution C ▁, ▁DataSize ▁. ▁valueOf ▁( ▁STR ▁) ▁) ▁; ▁create Assignments ▁( ▁distribution C ▁, ▁AV AILABLE _ WOR KER S ▁, ▁4 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁long ▁distribution D ▁= ▁create Distribution ▁( ▁STR ▁, ▁4 ▁) ▁; ▁create Bucket ed Table ▁( ▁STR ▁, ▁distribution D ▁, ▁DataSize ▁. ▁valueOf ▁( ▁STR ▁) ▁) ▁;
▁public ▁void ▁draw ▁( ▁Canvas ▁canvas ▁, ▁Group Call Mini Texture View ▁view ▁) ▁{ ▁long ▁currentTime ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁; ▁if ▁( ▁last UpdateTime ▁!= ▁0 ▁) ▁{ ▁long ▁dt ▁= ▁currentTime ▁- ▁last UpdateTime ▁; ▁if ▁( ▁dt ▁> ▁10 ▁) ▁{ ▁progress ▁+= ▁dt ▁ / ▁500 f ▁; ▁if ▁( ▁progress ▁> ▁4 f ▁) ▁{ ▁progress ▁= ▁0 ▁; ▁} ▁last UpdateTime ▁= ▁currentTime ▁; ▁} ▁} ▁else ▁{ ▁last UpdateTime ▁= ▁currentTime ▁; ▁} ▁if ▁( ▁progress ▁> ▁1 f ▁) ▁{ ▁return ▁; ▁} ▁float ▁x ▁= ▁( ▁parent Width ▁+ ▁size ▁ * ▁2 ▁) ▁ * ▁progress ▁- ▁size ▁- ▁view ▁. ▁getX ▁( ▁) ▁; ▁matrix ▁. ▁set Translate ▁( ▁x ▁, ▁0 ▁) ▁; ▁gradient Shader ▁. ▁setLocal Matrix ▁( ▁matrix ▁) ▁; ▁gradient Shader 2 ▁. ▁setLocal Matrix ▁( ▁matrix ▁) ▁; ▁Android Utilities ▁. ▁rect Tmp ▁. ▁set ▁( ▁view ▁. ▁texture View ▁. ▁current Clip H orizontal ▁, ▁view ▁. ▁texture View ▁. ▁current Clip Vertical ▁, ▁view ▁. ▁texture View ▁. ▁getMeasured Width ▁( ▁) ▁- ▁view ▁. ▁texture View ▁. ▁current Clip H orizontal ▁, ▁view ▁. ▁texture View ▁. ▁getMeasured Height ▁( ▁) ▁- ▁view ▁. ▁texture View ▁. ▁current Clip Vertical ▁) ▁; ▁canvas ▁. ▁draw Rect ▁( ▁Android Utilities ▁. ▁rect Tmp ▁, ▁paint ▁) ▁; ▁if ▁( ▁draw Frame ▁) ▁{ ▁canvas ▁. ▁draw Round Rect ▁( ▁Android Utilities ▁. ▁rect Tmp ▁, ▁view ▁. ▁texture View ▁. ▁round Radius ▁, ▁view ▁. ▁texture View ▁. ▁round Radius ▁, ▁paint Out line ▁) ▁; ▁} ▁} ▁public ▁void ▁setParent Width ▁( ▁int ▁parent Width ▁) ▁{ ▁this ▁. ▁parent Width ▁= ▁parent Width ▁; ▁} ▁}
▁public ▁class ▁Check Origin Header ▁implements ▁Filter ▁{ ▁private ▁final ▁Set ▁< ▁String ▁> ▁allowed Hosts ▁; ▁private ▁final ▁Set ▁< ▁String ▁> ▁skip Checks On ▁; ▁public ▁Check Origin Header ▁( ▁Collection ▁< ▁String ▁> ▁allowed Origin Hosts ▁, ▁Set ▁< ▁String ▁> ▁skip Checks On ▁) ▁{ ▁Require ▁. ▁nonNull ▁( ▁STR ▁, ▁allowed Origin Hosts ▁) ▁; ▁allowed Hosts ▁= ▁ImmutableSet ▁. ▁copyOf ▁( ▁allowed Origin Hosts ▁) ▁; ▁this ▁. ▁skip Checks On ▁= ▁ImmutableSet ▁. ▁copyOf ▁( ▁Require ▁. ▁nonNull ▁( ▁STR ▁, ▁skip Checks On ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁HttpHandler ▁apply ▁( ▁HttpHandler ▁httpHandler ▁) ▁{ ▁Require ▁. ▁nonNull ▁( ▁STR ▁, ▁httpHandler ▁) ▁; ▁return ▁req ▁-> ▁{ ▁if ▁( ▁skip Checks On ▁. ▁contains ▁( ▁req ▁. ▁getUri ▁( ▁) ▁) ▁) ▁{ ▁return ▁httpHandler ▁. ▁execute ▁( ▁req ▁) ▁; ▁} ▁String ▁origin ▁= ▁req ▁. ▁getHeader ▁( ▁STR ▁) ▁; ▁if ▁( ▁origin ▁!= ▁null ▁&& ▁! ▁allowed Hosts ▁. ▁contains ▁( ▁origin ▁) ▁) ▁{ ▁return ▁new ▁HttpResponse ▁( ▁) ▁. ▁setStatus ▁( ▁HTTP _ INTERNAL _ ERROR ▁) ▁. ▁addHeader ▁( ▁STR ▁, ▁JSON _ UTF _8 ▁) ▁. ▁setContent ▁( ▁ Contents ▁. ▁as Json ▁( ▁ImmutableMap ▁. ▁of ▁( ▁STR ▁, ▁ImmutableMap ▁. ▁of ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁+ ▁origin ▁, ▁STR ▁, ▁STR ▁) ▁) ▁) ▁) ▁; ▁} ▁return ▁httpHandler ▁. ▁execute ▁( ▁req ▁) ▁; ▁} ▁; ▁} ▁}
▁public ▁final ▁class ▁B undled H ls Media Chunk Extractor ▁implements ▁H ls Media Chunk Extractor ▁{ ▁private ▁static ▁final ▁Position Holder ▁POSITION _ HOLDER ▁= ▁new ▁Position Holder ▁( ▁) ▁; ▁@ ▁Visible ForTesting ▁final ▁Extractor ▁extractor ▁; ▁private ▁final ▁Format ▁master Playlist Format ▁; ▁private ▁final ▁Timestamp Adj uster ▁timestamp Adj uster ▁; ▁public ▁B undled H ls Media Chunk Extractor ▁( ▁Extractor ▁extractor ▁, ▁Format ▁master Playlist Format ▁, ▁Timestamp Adj uster ▁timestamp Adj uster ▁) ▁{ ▁this ▁. ▁extractor ▁= ▁extractor ▁; ▁this ▁. ▁master Playlist Format ▁= ▁master Playlist Format ▁; ▁this ▁. ▁timestamp Adj uster ▁= ▁timestamp Adj uster ▁; ▁} ▁@ ▁Override ▁public ▁void ▁init ▁( ▁Extractor Output ▁extractor Output ▁) ▁{ ▁extractor ▁. ▁init ▁( ▁extractor Output ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁read ▁( ▁Extractor Input ▁extractor Input ▁) ▁throws ▁IOException ▁{ ▁return ▁extractor ▁. ▁read ▁( ▁extractor Input ▁, ▁POSITION _ HOLDER ▁) ▁== ▁Extractor ▁. ▁RESULT _ CON TINUE ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is Pack ed Audio Extractor ▁( ▁) ▁{ ▁return ▁extractor ▁instanceof ▁Ad ts Extractor ▁|| ▁extractor ▁instanceof ▁Ac 3 Extractor ▁|| ▁extractor ▁instanceof ▁Ac 4 Extractor ▁|| ▁extractor ▁instanceof ▁M p 3 Extractor ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁isRe usable ▁( ▁) ▁{ ▁return ▁extractor ▁instanceof ▁T s Extractor ▁|| ▁extractor ▁instanceof ▁F rag mented Mp 4 Extractor ▁; ▁} ▁@ ▁Override ▁public ▁H ls Media Chunk Extractor ▁rec reate ▁( ▁) ▁{ ▁Assertions ▁. ▁checkState ▁( ▁! ▁isRe usable ▁( ▁) ▁) ▁; ▁Extractor ▁new Extractor Instance ▁; ▁if ▁( ▁extractor ▁instanceof ▁Web vtt Extractor ▁) ▁{ ▁new Extractor Instance ▁= ▁new ▁Web vtt Extractor ▁( ▁master Playlist Format ▁. ▁language ▁, ▁timestamp Adj uster ▁) ▁; ▁} ▁else ▁if ▁( ▁extractor ▁instanceof ▁Ad ts Extractor ▁) ▁{ ▁new Extractor Instance ▁= ▁new ▁Ad ts Extractor ▁( ▁) ▁; ▁} ▁else ▁if ▁( ▁extractor ▁instanceof ▁Ac 3 Extractor ▁) ▁{ ▁new Extractor Instance ▁= ▁new ▁Ac 3 Extractor ▁( ▁) ▁; ▁} ▁else ▁if ▁( ▁extractor ▁instanceof ▁Ac 4 Extractor ▁) ▁{ ▁new Extractor Instance ▁= ▁new ▁Ac 4 Extractor ▁( ▁) ▁; ▁} ▁else ▁if ▁( ▁extractor ▁instanceof ▁M p 3 Extractor ▁) ▁{ ▁new Extractor Instance ▁= ▁new ▁M p 3 Extractor ▁( ▁) ▁; ▁} ▁else ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁+ ▁extractor ▁. ▁getClass ▁( ▁) ▁. ▁getSimpleName ▁( ▁) ▁) ▁; ▁} ▁return ▁new ▁B undled H ls Media Chunk Extractor ▁( ▁new Extractor Instance ▁, ▁master Playlist Format ▁, ▁timestamp Adj uster ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁on Tr uncated Segment Parsed ▁( ▁) ▁{ ▁extractor ▁. ▁seek ▁( ▁0 ▁, ▁0 ▁) ▁; ▁} ▁}
▁Assert ▁. ▁assertNotEquals ▁( ▁STR ▁, ▁null ▁, ▁vt Match Set ▁) ▁; ▁Set ▁< ▁VTAssociation Pair ▁> ▁test Match Pairs ▁= ▁getMatch Address Pairs ▁( ▁vt Match Set ▁) ▁; ▁Set ▁< ▁VTAssociation Pair ▁> ▁expected Match Pairs ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁expected Match Pairs ▁. ▁add ▁( ▁assoc iate ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁) ▁) ▁; ▁assertMatch Pairs ▁( ▁expected Match Pairs ▁, ▁test Match Pairs ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Function Reference Correlator _ all Function Matches ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁exact Symbol Name Correlator ▁= ▁STR ▁; ▁runTest Correlator ▁( ▁exact Symbol Name Correlator ▁) ▁; ▁Assert ▁. ▁assertNotEquals ▁( ▁STR ▁, ▁null ▁, ▁getV T Match Set ▁( ▁exact Symbol Name Correlator ▁) ▁) ▁; ▁String ▁exact Data Correlator ▁= ▁STR ▁; ▁runTest Correlator ▁( ▁exact Data Correlator ▁) ▁; ▁Assert ▁. ▁assertNotEquals ▁( ▁STR ▁, ▁null ▁, ▁getV T Match Set ▁( ▁exact Data Correlator ▁) ▁) ▁; ▁List ▁< ▁VTMatch Set ▁> ▁match Sets ▁= ▁session ▁. ▁getMatch Sets ▁( ▁) ▁; ▁for ▁( ▁VTMatch Set ▁ms ▁: ▁match Sets ▁) ▁{ ▁Accept Match Task ▁task ▁= ▁new ▁Accept Match Task ▁( ▁controller ▁, ▁( ▁List ▁< ▁VTMatch ▁> ▁) ▁ms ▁. ▁get Matches ▁( ▁) ▁) ▁; ▁run Task ▁( ▁task ▁) ▁; ▁} ▁List ▁< ▁VTAssociation Pair ▁> ▁assoc i ations ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁assoc i ations ▁. ▁add ▁( ▁assoc iate ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁, ▁FUNCTION ▁) ▁) ▁; ▁assoc i ations ▁. ▁add ▁( ▁assoc iate ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁, ▁FUNCTION ▁) ▁) ▁; ▁assoc i ations ▁. ▁add ▁( ▁assoc iate ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁, ▁FUNCTION ▁) ▁) ▁; ▁assoc i ations ▁. ▁add ▁( ▁assoc iate ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁, ▁FUNCTION ▁) ▁) ▁; ▁assoc i ations ▁. ▁add ▁( ▁assoc iate ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁, ▁FUNCTION ▁) ▁) ▁; ▁assoc i ations ▁. ▁add ▁( ▁assoc iate ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁, ▁FUNCTION ▁) ▁) ▁; ▁assoc i ations ▁. ▁add ▁( ▁assoc iate ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁, ▁FUNCTION ▁) ▁) ▁; ▁assoc i ations ▁. ▁add ▁( ▁assoc iate ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁, ▁FUNCTION ▁) ▁) ▁; ▁assoc i ations ▁. ▁add ▁( ▁assoc iate ▁( ▁addr ▁( ▁src Prog ▁, ▁STR ▁) ▁, ▁addr ▁( ▁dest Prog ▁, ▁STR ▁) ▁, ▁FUNCTION ▁) ▁) ▁;
▁public ▁class ▁ThreadPool Ex ha usted Event Test ▁{ ▁@ ▁Test ▁public ▁void ▁test ▁( ▁) ▁{ ▁String ▁msg ▁= ▁STR ▁; ▁ThreadPool Ex ha usted Event ▁event ▁= ▁new ▁ThreadPool Ex ha usted Event ▁( ▁msg ▁) ▁; ▁assertEquals ▁( ▁msg ▁, ▁event ▁. ▁getMsg ▁( ▁) ▁) ▁; ▁} ▁}
▁create Assignments ▁( ▁distribution D ▁, ▁AV AILABLE _ WOR KER S ▁, ▁4 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁long ▁distribution E ▁= ▁create Distribution ▁( ▁STR ▁, ▁4 ▁) ▁; ▁create Bucket ed Table ▁( ▁STR ▁, ▁distribution E ▁, ▁DataSize ▁. ▁valueOf ▁( ▁STR ▁) ▁) ▁; ▁create Assignments ▁( ▁distribution E ▁, ▁AV AILABLE _ WOR KER S ▁, ▁4 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁assert Balan cing ▁( ▁b alan cer ▁, ▁15 ▁) ▁; ▁} ▁private ▁static ▁void ▁assert Balan cing ▁( ▁Bucket Balancer ▁b alan cer ▁, ▁int ▁expected M ov es ▁) ▁{ ▁int ▁actual M ov es ▁= ▁b alan cer ▁. ▁balance ▁( ▁) ▁; ▁assertEquals ▁( ▁actual M ov es ▁, ▁expected M ov es ▁) ▁; ▁ClusterState ▁clusterState ▁= ▁b alan cer ▁. ▁fetch ClusterState ▁( ▁) ▁; ▁for ▁( ▁Distribution ▁distribution ▁: ▁clusterState ▁. ▁getDist ribution Assignments ▁( ▁) ▁. ▁keySet ▁( ▁) ▁) ▁{ ▁Multiset ▁< ▁String ▁> ▁allocation Counts ▁= ▁Hash Multiset ▁. ▁create ▁( ▁) ▁; ▁clusterState ▁. ▁getDist ribution Assignments ▁( ▁) ▁. ▁get ▁( ▁distribution ▁) ▁. ▁stream ▁( ▁) ▁. ▁map ▁( ▁Bucket Assignment ▁:: ▁getNode Identifier ▁) ▁. ▁forEach ▁( ▁allocation Counts ▁:: ▁add ▁) ▁; ▁double ▁buckets PerNode ▁= ▁( ▁1.0 ▁ * ▁allocation Counts ▁. ▁size ▁( ▁) ▁) ▁ / ▁clusterState ▁. ▁getActive Nodes ▁( ▁) ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁String ▁node ▁: ▁allocation Counts ▁) ▁{ ▁assert GreaterThan OrEqual ▁( ▁allocation Counts ▁. ▁count ▁( ▁node ▁) ▁, ▁( ▁int ▁) ▁Math ▁. ▁floor ▁( ▁buckets PerNode ▁) ▁, ▁node ▁+ ▁STR ▁) ▁; ▁assert LessThan OrEqual ▁( ▁allocation Counts ▁. ▁count ▁( ▁node ▁) ▁, ▁( ▁int ▁) ▁Math ▁. ▁ceil ▁( ▁buckets PerNode ▁) ▁, ▁node ▁+ ▁STR ▁) ▁; ▁} ▁} ▁assertEquals ▁( ▁b alan cer ▁. ▁balance ▁( ▁) ▁, ▁0 ▁) ▁; ▁} ▁private ▁long ▁create Distribution ▁( ▁String ▁distribution Name ▁, ▁int ▁bucketCount ▁) ▁{ ▁Metadata Dao ▁dao ▁= ▁db i ▁. ▁on Dem and ▁( ▁Metadata Dao ▁. ▁class ▁) ▁; ▁long ▁distribution Id ▁= ▁dao ▁. ▁insert Distribution ▁( ▁distribution Name ▁, ▁serialize Column Types ▁( ▁ImmutableList ▁. ▁of ▁( ▁BIGINT ▁) ▁) ▁, ▁bucketCount ▁) ▁; ▁shard Manager ▁. ▁create Buckets ▁( ▁distribution Id ▁, ▁bucketCount ▁) ▁; ▁return ▁distribution Id ▁; ▁} ▁private ▁long ▁create Bucket ed Table ▁( ▁String ▁tableName ▁, ▁long ▁distribution Id ▁) ▁{ ▁return ▁create Bucket ed Table ▁( ▁tableName ▁, ▁distribution Id ▁, ▁DataSize ▁. ▁valueOf ▁( ▁STR ▁) ▁) ▁; ▁} ▁private ▁long ▁create Bucket ed Table ▁( ▁String ▁tableName ▁, ▁long ▁distribution Id ▁, ▁DataSize ▁compressed Size ▁) ▁{ ▁Metadata Dao ▁dao ▁= ▁db i ▁. ▁on Dem and ▁( ▁Metadata Dao ▁. ▁class ▁) ▁; ▁long ▁tableId ▁= ▁dao ▁. ▁insert Table ▁( ▁STR ▁, ▁tableName ▁, ▁false ▁, ▁false ▁, ▁distribution Id ▁, ▁0 ▁, ▁false ▁) ▁;
▁Mockito ▁. ▁doReturn ▁( ▁STR ▁) ▁. ▁when ▁( ▁service Spy ▁) ▁. ▁getName ▁( ▁) ▁; ▁Mockito ▁. ▁doReturn ▁( ▁true ▁) ▁. ▁when ▁( ▁distro Mapper Spy ▁) ▁. ▁res pon s ible ▁( ▁Mockito ▁. ▁anyString ▁( ▁) ▁) ▁; ▁Mockito ▁. ▁doReturn ▁( ▁true ▁) ▁. ▁when ▁( ▁switch Domain ▁) ▁. ▁is Health Check Enabled ▁( ▁) ▁; ▁when ▁( ▁service Spy ▁. ▁all IP s ▁( ▁true ▁) ▁) ▁. ▁thenReturn ▁( ▁instances ▁) ▁; ▁client Beat Check Task ▁. ▁run ▁( ▁) ▁; ▁Assert ▁. ▁assertFalse ▁( ▁instance ▁. ▁is Healthy ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Ip Delete Time Out ▁( ▁) ▁{ ▁Instance ▁instance ▁= ▁new ▁Instance ▁( ▁) ▁; ▁instance ▁. ▁setLast Beat ▁( ▁System ▁. ▁current TimeMillis ▁( ▁) ▁) ▁; ▁instance ▁. ▁set Mark ed ▁( ▁true ▁) ▁; ▁instance ▁. ▁set Healthy ▁( ▁true ▁) ▁; ▁Map ▁< ▁String ▁, ▁String ▁> ▁metadata ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁metadata ▁. ▁put ▁( ▁Pre served Metadata Keys ▁. ▁IP _ DELETE _ TIMEOUT ▁, ▁STR ▁) ▁; ▁instance ▁. ▁set Metadata ▁( ▁metadata ▁) ▁; ▁Mockito ▁. ▁doReturn ▁( ▁true ▁) ▁. ▁when ▁( ▁distro Mapper Spy ▁) ▁. ▁res pon s ible ▁( ▁null ▁) ▁; ▁client Beat Check Task ▁. ▁run ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Ip Delete Not Time Out ▁( ▁) ▁{ ▁Instance ▁instance ▁= ▁new ▁Instance ▁( ▁) ▁; ▁instance ▁. ▁setLast Beat ▁( ▁System ▁. ▁current TimeMillis ▁( ▁) ▁) ▁; ▁instance ▁. ▁set Mark ed ▁( ▁true ▁) ▁; ▁instance ▁. ▁set Healthy ▁( ▁true ▁) ▁; ▁Map ▁< ▁String ▁, ▁String ▁> ▁metadata ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁metadata ▁. ▁put ▁( ▁Pre served Metadata Keys ▁. ▁IP _ DELETE _ TIMEOUT ▁, ▁STR ▁) ▁; ▁instance ▁. ▁set Metadata ▁( ▁metadata ▁) ▁; ▁Mockito ▁. ▁doReturn ▁( ▁true ▁) ▁. ▁when ▁( ▁distro Mapper Spy ▁) ▁. ▁res pon s ible ▁( ▁null ▁) ▁; ▁client Beat Check Task ▁. ▁run ▁( ▁) ▁; ▁} ▁}
▁@ ▁SpringBoot Application ▁public ▁class ▁C art Event Consumer ▁{ ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Spring Application ▁. ▁run ▁( ▁C art Event Consumer ▁. ▁class ▁, ▁args ▁) ▁; ▁} ▁@ ▁Service ▁@ ▁R ocket MQ MessageListener ▁( ▁topic ▁= ▁STR ▁, ▁consumer Group ▁= ▁STR ▁) ▁public ▁class ▁Card Item Add Consumer ▁implements ▁R ocket MQ Listener ▁< ▁C artItem Event ▁> ▁{ ▁public ▁void ▁on Message ▁( ▁C artItem Event ▁addItem Event ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁addItem Event ▁) ▁; ▁} ▁} ▁@ ▁Service ▁@ ▁R ocket MQ MessageListener ▁( ▁topic ▁= ▁STR ▁, ▁consumer Group ▁= ▁STR ▁) ▁public ▁class ▁Card Item Remove Consumer ▁implements ▁R ocket MQ Listener ▁< ▁C artItem Event ▁> ▁{ ▁public ▁void ▁on Message ▁( ▁C artItem Event ▁remove Item Event ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁remove Item Event ▁) ▁; ▁} ▁} ▁}
▁@ ▁DirtiesContext ▁@ ▁SpringBootTest ▁( ▁webEnvironment ▁= ▁WebEnvironment ▁. ▁RANDOM _ PORT ▁, ▁properties ▁= ▁{ ▁STR ▁} ▁) ▁class ▁SpringBootTest Web Environment Random Port Custom Port Tests ▁{ ▁@ ▁Autowired ▁private ▁Environment ▁environment ▁; ▁@ ▁Test ▁void ▁validate Port IsNot Over written ▁( ▁) ▁{ ▁String ▁port ▁= ▁this ▁. ▁environment ▁. ▁getProperty ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁port ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Configuration ▁( ▁proxyBean Methods ▁= ▁false ▁) ▁@ ▁EnableWeb Mvc ▁static ▁class ▁Config ▁extends ▁Abstract Config ▁{ ▁} ▁}
▁public ▁class ▁In fer TrainedModel Deployment Action ▁extends ▁ActionType ▁< ▁In fer TrainedModel Deployment Action ▁. ▁Response ▁> ▁{ ▁public ▁static ▁final ▁In fer TrainedModel Deployment Action ▁INSTANCE ▁= ▁new ▁In fer TrainedModel Deployment Action ▁( ▁) ▁; ▁public ▁static ▁final ▁String ▁NAME ▁= ▁STR ▁; ▁public ▁In fer TrainedModel Deployment Action ▁( ▁) ▁{ ▁super ▁( ▁NAME ▁, ▁In fer TrainedModel Deployment Action ▁. ▁Response ▁:: ▁new ▁) ▁; ▁} ▁public ▁static ▁class ▁Request ▁extends ▁Base Tasks Request ▁< ▁Request ▁> ▁implements ▁ToXContent Object ▁{ ▁public ▁static ▁final ▁ParseField ▁DE P LO Y MENT _ ID ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁public ▁static ▁final ▁ParseField ▁INPUT ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁public ▁static ▁final ▁ParseField ▁TIMEOUT ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁public ▁static ▁final ▁TimeValue ▁DEFAULT _ TIMEOUT ▁= ▁TimeValue ▁. ▁timeValue Seconds ▁( ▁10 ▁) ▁; ▁static ▁final ▁ObjectParser ▁< ▁Request ▁, ▁Void ▁> ▁PARSER ▁= ▁new ▁ObjectParser ▁< ▁> ▁( ▁NAME ▁, ▁Request ▁:: ▁new ▁) ▁; ▁static ▁{ ▁PARSER ▁. ▁declareString ▁( ▁Request ▁:: ▁set Deployment Id ▁, ▁DE P LO Y MENT _ ID ▁) ▁; ▁PARSER ▁. ▁declareString ▁( ▁( ▁request ▁, ▁inputs ▁) ▁-> ▁request ▁. ▁input ▁= ▁inputs ▁, ▁INPUT ▁) ▁; ▁PARSER ▁. ▁declareString ▁( ▁( ▁r ▁, ▁value ▁) ▁-> ▁r ▁. ▁setTimeout ▁( ▁TimeValue ▁. ▁parse TimeValue ▁( ▁value ▁, ▁TIMEOUT ▁. ▁getPreferred Name ▁( ▁) ▁) ▁) ▁, ▁TIMEOUT ▁) ▁; ▁} ▁public ▁static ▁Request ▁parse Request ▁( ▁String ▁de ployment Id ▁, ▁XContentParser ▁parser ▁) ▁{ ▁Request ▁r ▁= ▁PARSER ▁. ▁apply ▁( ▁parser ▁, ▁null ▁) ▁; ▁if ▁( ▁de ployment Id ▁!= ▁null ▁) ▁{ ▁r ▁. ▁de ployment Id ▁= ▁de ployment Id ▁; ▁} ▁return ▁r ▁; ▁} ▁private ▁String ▁de ployment Id ▁; ▁private ▁String ▁input ▁; ▁private ▁Request ▁( ▁) ▁{ ▁} ▁Request ▁( ▁String ▁de ployment Id ▁, ▁String ▁input ▁) ▁{ ▁this ▁. ▁de ployment Id ▁= ▁Objects ▁. ▁requireNonNull ▁( ▁de ployment Id ▁) ▁; ▁this ▁. ▁input ▁= ▁Objects ▁. ▁requireNonNull ▁( ▁input ▁) ▁; ▁} ▁public ▁Request ▁( ▁StreamInput ▁in ▁) ▁throws ▁IOException ▁{ ▁super ▁( ▁in ▁) ▁; ▁de ployment Id ▁= ▁in ▁. ▁readString ▁( ▁) ▁; ▁input ▁= ▁in ▁. ▁readString ▁( ▁) ▁; ▁} ▁public ▁String ▁get Deployment Id ▁( ▁) ▁{ ▁return ▁de ployment Id ▁; ▁} ▁private ▁void ▁set Deployment Id ▁( ▁String ▁de ployment Id ▁) ▁{ ▁this ▁. ▁de ployment Id ▁= ▁de ployment Id ▁; ▁} ▁public ▁String ▁getInput ▁( ▁) ▁{ ▁return ▁input ▁; ▁} ▁@ ▁Override ▁public ▁TimeValue ▁getTimeout ▁( ▁) ▁{ ▁TimeValue ▁tv ▁= ▁super ▁. ▁getTimeout ▁( ▁) ▁; ▁if ▁( ▁tv ▁== ▁null ▁) ▁{ ▁return ▁DEFAULT _ TIMEOUT ▁; ▁} ▁return ▁tv ▁; ▁} ▁@ ▁Override ▁public ▁void ▁writeTo ▁( ▁StreamOutput ▁out ▁) ▁throws ▁IOException ▁{ ▁super ▁. ▁writeTo ▁( ▁out ▁) ▁; ▁out ▁. ▁writeString ▁( ▁de ployment Id ▁) ▁; ▁out ▁. ▁writeString ▁( ▁input ▁) ▁; ▁}
▁public ▁final ▁class ▁Target Pattern Resolver Util ▁{ ▁private ▁Target Pattern Resolver Util ▁( ▁) ▁{ ▁} ▁public ▁static ▁String ▁get Parsing ErrorMessage ▁( ▁String ▁message ▁, ▁String ▁original Pattern ▁) ▁{ ▁if ▁( ▁original Pattern ▁== ▁null ▁) ▁{ ▁return ▁message ▁; ▁} ▁else ▁{ ▁return ▁String ▁. ▁format ▁( ▁STR ▁, ▁original Pattern ▁, ▁message ▁) ▁; ▁} ▁} ▁public ▁static ▁Collection ▁< ▁Target ▁> ▁resolve Package Targets ▁( ▁Package ▁pkg ▁, ▁Filter ing Policy ▁policy ▁) ▁{ ▁if ▁( ▁policy ▁== ▁Filter ing Policies ▁. ▁NO _ FILTER ▁) ▁{ ▁return ▁pkg ▁. ▁getTarget s ▁( ▁) ▁. ▁values ▁( ▁) ▁; ▁} ▁Compact HashSet ▁< ▁Target ▁> ▁builder ▁= ▁Compact HashSet ▁. ▁create ▁( ▁) ▁; ▁for ▁( ▁Target ▁target ▁: ▁pkg ▁. ▁getTarget s ▁( ▁) ▁. ▁values ▁( ▁) ▁) ▁{ ▁if ▁( ▁policy ▁. ▁should Retain ▁( ▁target ▁, ▁false ▁) ▁) ▁{ ▁builder ▁. ▁add ▁( ▁target ▁) ▁; ▁} ▁} ▁return ▁builder ▁; ▁} ▁public ▁static ▁PathFragment ▁getPath Fragment ▁( ▁String ▁path Prefix ▁) ▁throws ▁Target ParsingException ▁{ ▁PathFragment ▁directory ▁= ▁PathFragment ▁. ▁create ▁( ▁path Prefix ▁) ▁; ▁if ▁( ▁directory ▁. ▁contains Up level References ▁( ▁) ▁) ▁{ ▁throw ▁new ▁Target ParsingException ▁( ▁STR ▁+ ▁directory ▁. ▁getPath String ▁( ▁) ▁+ ▁STR ▁, ▁Target Patterns ▁. ▁Code ▁. ▁UP _ LEVEL _ RE FERENCE S _ NOT _ ALLOW ED ▁) ▁; ▁} ▁if ▁( ▁! ▁path Prefix ▁. ▁isEmpty ▁( ▁) ▁&& ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁path Prefix ▁) ▁!= ▁null ▁) ▁) ▁{ ▁throw ▁new ▁Target ParsingException ▁( ▁STR ▁+ ▁path Prefix ▁+ ▁STR ▁, ▁Target Patterns ▁. ▁Code ▁. ▁PACKAGE _ NAME _ INVALID ▁) ▁; ▁} ▁return ▁directory ▁; ▁} ▁}
▁public ▁class ▁P f x Options Converter ▁{ ▁static ▁void ▁fromJson ▁( ▁Iterable ▁< ▁java ▁. ▁util ▁. ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁Object ▁> ▁> ▁json ▁, ▁P f x Options ▁obj ▁) ▁{ ▁for ▁( ▁java ▁. ▁util ▁. ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁Object ▁> ▁member ▁: ▁json ▁) ▁{ ▁switch ▁( ▁member ▁. ▁getKey ▁( ▁) ▁) ▁{ ▁case ▁STR ▁: ▁if ▁( ▁member ▁. ▁getValue ▁( ▁) ▁instanceof ▁String ▁) ▁{ ▁obj ▁. ▁set Alias ▁( ▁( ▁String ▁) ▁member ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁break ▁; ▁case ▁STR ▁: ▁if ▁( ▁member ▁. ▁getValue ▁( ▁) ▁instanceof ▁String ▁) ▁{ ▁obj ▁. ▁set Alias Password ▁( ▁( ▁String ▁) ▁member ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁break ▁; ▁case ▁STR ▁: ▁if ▁( ▁member ▁. ▁getValue ▁( ▁) ▁instanceof ▁String ▁) ▁{ ▁obj ▁. ▁setPassword ▁( ▁( ▁String ▁) ▁member ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁break ▁; ▁case ▁STR ▁: ▁if ▁( ▁member ▁. ▁getValue ▁( ▁) ▁instanceof ▁String ▁) ▁{ ▁obj ▁. ▁setPath ▁( ▁( ▁String ▁) ▁member ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁break ▁; ▁case ▁STR ▁: ▁if ▁( ▁member ▁. ▁getValue ▁( ▁) ▁instanceof ▁String ▁) ▁{ ▁obj ▁. ▁setValue ▁( ▁io ▁. ▁vertx ▁. ▁core ▁. ▁buffer ▁. ▁Buffer ▁. ▁buffer ▁( ▁Json Util ▁. ▁BASE 64_ DE CODER ▁. ▁decode ▁( ▁( ▁String ▁) ▁member ▁. ▁getValue ▁( ▁) ▁) ▁) ▁) ▁; ▁} ▁break ▁; ▁} ▁} ▁} ▁static ▁void ▁toJson ▁( ▁P f x Options ▁obj ▁, ▁JsonObject ▁json ▁) ▁{ ▁toJson ▁( ▁obj ▁, ▁json ▁. ▁getMap ▁( ▁) ▁) ▁; ▁} ▁static ▁void ▁toJson ▁( ▁P f x Options ▁obj ▁, ▁java ▁. ▁util ▁. ▁Map ▁< ▁String ▁, ▁Object ▁> ▁json ▁) ▁{ ▁if ▁( ▁obj ▁. ▁getAlias ▁( ▁) ▁!= ▁null ▁) ▁{ ▁json ▁. ▁put ▁( ▁STR ▁, ▁obj ▁. ▁getAlias ▁( ▁) ▁) ▁; ▁} ▁if ▁( ▁obj ▁. ▁getAlias Password ▁( ▁) ▁!= ▁null ▁) ▁{ ▁json ▁. ▁put ▁( ▁STR ▁, ▁obj ▁. ▁getAlias Password ▁( ▁) ▁) ▁; ▁} ▁if ▁( ▁obj ▁. ▁getPassword ▁( ▁) ▁!= ▁null ▁) ▁{ ▁json ▁. ▁put ▁( ▁STR ▁, ▁obj ▁. ▁getPassword ▁( ▁) ▁) ▁; ▁} ▁if ▁( ▁obj ▁. ▁getPath ▁( ▁) ▁!= ▁null ▁) ▁{ ▁json ▁. ▁put ▁( ▁STR ▁, ▁obj ▁. ▁getPath ▁( ▁) ▁) ▁; ▁} ▁if ▁( ▁obj ▁. ▁getValue ▁( ▁) ▁!= ▁null ▁) ▁{ ▁json ▁. ▁put ▁( ▁STR ▁, ▁Json Util ▁. ▁BASE 64_ EN CODER ▁. ▁encodeToString ▁( ▁obj ▁. ▁getValue ▁( ▁) ▁. ▁getBytes ▁( ▁) ▁) ▁) ▁; ▁} ▁} ▁}
▁@ ▁Override ▁public ▁boolean ▁maybe Refresh ▁( ▁String ▁source ▁) ▁throws ▁Engine Exception ▁{ ▁return ▁false ▁; ▁} ▁@ ▁Override ▁public ▁void ▁write Index ingBuffer ▁( ▁) ▁throws ▁Engine Exception ▁{ ▁} ▁@ ▁Override ▁public ▁boolean ▁should Periodic ally Flush ▁( ▁) ▁{ ▁return ▁false ▁; ▁} ▁@ ▁Override ▁public ▁void ▁flush ▁( ▁boolean ▁force ▁, ▁boolean ▁wait If On going ▁) ▁throws ▁Engine Exception ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁force Merge ▁( ▁boolean ▁flush ▁, ▁int ▁maxNum Segments ▁, ▁boolean ▁only Exp un ge Delet es ▁, ▁String ▁force Merge UUID ▁) ▁{ ▁if ▁( ▁maxNum Segments ▁== ▁Force Merge Request ▁. ▁Default s ▁. ▁MAX _ NUM _ SEGMENT S ▁) ▁{ ▁} ▁else ▁if ▁( ▁maxNum Segments ▁< ▁last Committed Segment Infos ▁. ▁size ▁( ▁) ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁STR ▁+ ▁STR ▁+ ▁maxNum Segments ▁+ ▁STR ▁+ ▁STR ▁+ ▁last Committed Segment Infos ▁. ▁size ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁else ▁{ ▁logger ▁. ▁debug ▁( ▁STR ▁, ▁last Committed Segment Infos ▁. ▁size ▁( ▁) ▁, ▁maxNum Segments ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁Index Commit Ref ▁acquire Last Index Commit ▁( ▁boolean ▁flush First ▁) ▁{ ▁store ▁. ▁inc Ref ▁( ▁) ▁; ▁return ▁new ▁Index Commit Ref ▁( ▁index Commit ▁, ▁store ▁:: ▁dec Ref ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Index Commit Ref ▁acquire Safe Index Commit ▁( ▁) ▁{ ▁return ▁acquire Last Index Commit ▁( ▁false ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Safe Commit Info ▁getS afe Commit Info ▁( ▁) ▁{ ▁return ▁safe Commit Info ▁; ▁} ▁@ ▁Override ▁public ▁void ▁activate Thrott ling ▁( ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁de act ivate Thrott ling ▁( ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁trim Un re ference d Trans log Files ▁( ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁boolean ▁should Roll Trans log Generation ▁( ▁) ▁{ ▁return ▁false ▁; ▁} ▁@ ▁Override ▁public ▁void ▁roll Trans log Generation ▁( ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁int ▁restore Local History From Trans log ▁( ▁Translog Recovery Runner ▁trans log Recovery Runner ▁) ▁{ ▁return ▁0 ▁; ▁} ▁@ ▁Override ▁public ▁int ▁fill SeqNo Gap s ▁( ▁long ▁primary Term ▁) ▁{ ▁return ▁0 ▁; ▁} ▁@ ▁Override ▁public ▁Engine ▁recover From Trans log ▁( ▁final ▁Translog Recovery Runner ▁trans log Recovery Runner ▁, ▁final ▁long ▁recover Up To SeqNo ▁) ▁{ ▁try ▁( ▁Releasable Lock ▁lock ▁= ▁readLock ▁. ▁acquire ▁( ▁) ▁) ▁{ ▁ensure Open ▁( ▁) ▁; ▁try ▁( ▁Translog ▁. ▁Snapshot ▁snapshot ▁= ▁new Empty Snapshot ▁( ▁) ▁) ▁{ ▁trans log Recovery Runner ▁. ▁run ▁( ▁this ▁, ▁snapshot ▁) ▁; ▁} ▁catch ▁( ▁final ▁Exception ▁e ▁) ▁{ ▁throw ▁new ▁Engine Exception ▁( ▁shardId ▁, ▁STR ▁, ▁e ▁) ▁; ▁} ▁} ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁void ▁skip Trans log Recovery ▁( ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁trim Operations From Trans log ▁( ▁long ▁b el ow Term ▁, ▁long ▁a bove SeqNo ▁) ▁{ ▁}
▁assert ▁offset ▁>= ▁0 ▁; ▁if ▁( ▁offset ▁> ▁Integer ▁. ▁MAX _ VALUE ▁) ▁{ ▁throw ▁Compiler Directives ▁. ▁shouldNot ReachHere ▁( ▁STR ▁) ▁; ▁} ▁global Offsets ▁[ ▁i ▁] ▁= ▁( ▁int ▁) ▁offset ▁; ▁} ▁LLVM Symbol ▁symbol ▁= ▁file Scope ▁. ▁get ▁( ▁global ▁. ▁getName ▁( ▁) ▁) ▁; ▁global s ▁[ ▁i ▁] ▁= ▁symbol ▁; ▁} ▁List ▁< ▁Function Symbol ▁> ▁defined Functions ▁= ▁result ▁. ▁get Defined Functions ▁( ▁) ▁; ▁int ▁function Count ▁= ▁defined Functions ▁. ▁size ▁( ▁) ▁; ▁this ▁. ▁functions ▁= ▁new ▁LLVM Symbol ▁[ ▁function Count ▁] ▁; ▁this ▁. ▁alloc Func s ▁= ▁new ▁Alloc Symbol Node ▁[ ▁function Count ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁function Count ▁; ▁i ▁++ ▁) ▁{ ▁Function Symbol ▁function Symbol ▁= ▁defined Functions ▁. ▁get ▁( ▁i ▁) ▁; ▁LLVM Function ▁function ▁= ▁file Scope ▁. ▁getFunction ▁( ▁function Symbol ▁. ▁getName ▁( ▁) ▁) ▁; ▁LLVM Function Code ▁function Code ▁= ▁new ▁LLVM Function Code ▁( ▁function ▁) ▁; ▁if ▁( ▁isInternal S ulong Library ▁&& ▁in trinsic Provider ▁. ▁isIn trins ified ▁( ▁function ▁. ▁getName ▁( ▁) ▁) ▁) ▁{ ▁alloc Func s ▁[ ▁i ▁] ▁= ▁new ▁Alloc Intrinsic Function Node ▁( ▁function ▁, ▁function Code ▁, ▁node Factory ▁, ▁in trinsic Provider ▁) ▁; ▁} ▁else ▁if ▁( ▁lazy Parsing ▁) ▁{ ▁alloc Func s ▁[ ▁i ▁] ▁= ▁new ▁Alloc LLVM Function Node ▁( ▁function ▁, ▁function Code ▁) ▁; ▁} ▁else ▁{ ▁alloc Func s ▁[ ▁i ▁] ▁= ▁new ▁Alloc LL V ME ager Function Node ▁( ▁function ▁, ▁function Code ▁) ▁; ▁} ▁functions ▁[ ▁i ▁] ▁= ▁function ▁; ▁} ▁this ▁. ▁alloc R o Section ▁= ▁ro Section ▁. ▁get Allocate Node ▁( ▁node Factory ▁, ▁STR ▁, ▁true ▁) ▁; ▁this ▁. ▁alloc R w Section ▁= ▁rw Section ▁. ▁get Allocate Node ▁( ▁node Factory ▁, ▁STR ▁, ▁false ▁) ▁; ▁} ▁public ▁void ▁initialize Symbol Table ▁( ▁LLVMContext ▁context ▁) ▁{ ▁context ▁. ▁initialize Symbol Table ▁( ▁bit code ID ▁, ▁global Length ▁) ▁; ▁context ▁. ▁register Scope ▁( ▁file Scope ▁) ▁; ▁} ▁public ▁LLVMPointer ▁execute ▁( ▁LLVMContext ▁ctx ▁) ▁{ ▁if ▁( ▁ctx ▁. ▁loader Trace Stream ▁( ▁) ▁!= ▁null ▁) ▁{ ▁Library Locator ▁. ▁trace Static Init s ▁( ▁ctx ▁, ▁STR ▁, ▁moduleName ▁) ▁; ▁} ▁LLVMPointer ▁ro Base ▁= ▁alloc OrNull ▁( ▁alloc R o Section ▁) ▁; ▁LLVMPointer ▁rw Base ▁= ▁alloc OrNull ▁( ▁alloc R w Section ▁) ▁; ▁alloc Global s ▁( ▁ctx ▁, ▁ro Base ▁, ▁rw Base ▁) ▁; ▁alloc Functions ▁( ▁ctx ▁) ▁; ▁if ▁( ▁alloc R o Section ▁!= ▁null ▁) ▁{ ▁ctx ▁. ▁register ReadOnly Global s ▁( ▁bit code ID ▁. ▁getId ▁( ▁) ▁, ▁ro Base ▁, ▁node Factory ▁) ▁; ▁} ▁if ▁( ▁alloc R w Section ▁!= ▁null ▁) ▁{ ▁ctx ▁. ▁register Global s ▁( ▁rw Base ▁, ▁node Factory ▁) ▁; ▁} ▁return ▁ro Base ▁;
▁public ▁class ▁Many Message Transfer ▁extends ▁Abstract Reference Counted ▁implements ▁File Region ▁{ ▁private ▁final ▁ByteBuffer ▁byteBuffer Header ▁; ▁private ▁final ▁Get Message Result ▁getMessage Result ▁; ▁private ▁long ▁trans ferred ▁; ▁public ▁Many Message Transfer ▁( ▁ByteBuffer ▁byteBuffer Header ▁, ▁Get Message Result ▁getMessage Result ▁) ▁{ ▁this ▁. ▁byteBuffer Header ▁= ▁byteBuffer Header ▁; ▁this ▁. ▁getMessage Result ▁= ▁getMessage Result ▁; ▁} ▁@ ▁Override ▁public ▁long ▁position ▁( ▁) ▁{ ▁int ▁pos ▁= ▁byteBuffer Header ▁. ▁position ▁( ▁) ▁; ▁List ▁< ▁ByteBuffer ▁> ▁message Buffer List ▁= ▁this ▁. ▁getMessage Result ▁. ▁getMessage Buffer List ▁( ▁) ▁; ▁for ▁( ▁ByteBuffer ▁bb ▁: ▁message Buffer List ▁) ▁{ ▁pos ▁+= ▁bb ▁. ▁position ▁( ▁) ▁; ▁} ▁return ▁pos ▁; ▁} ▁@ ▁Override ▁public ▁long ▁transfer ed ▁( ▁) ▁{ ▁return ▁trans ferred ▁; ▁} ▁@ ▁Override ▁public ▁long ▁count ▁( ▁) ▁{ ▁return ▁byteBuffer Header ▁. ▁limit ▁( ▁) ▁+ ▁this ▁. ▁getMessage Result ▁. ▁getBuffer Total Size ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁long ▁transferTo ▁( ▁Writable ByteChannel ▁target ▁, ▁long ▁position ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁this ▁. ▁byteBuffer Header ▁. ▁has Remaining ▁( ▁) ▁) ▁{ ▁trans ferred ▁+= ▁target ▁. ▁write ▁( ▁this ▁. ▁byteBuffer Header ▁) ▁; ▁return ▁trans ferred ▁; ▁} ▁else ▁{ ▁List ▁< ▁ByteBuffer ▁> ▁message Buffer List ▁= ▁this ▁. ▁getMessage Result ▁. ▁getMessage Buffer List ▁( ▁) ▁; ▁for ▁( ▁ByteBuffer ▁bb ▁: ▁message Buffer List ▁) ▁{ ▁if ▁( ▁bb ▁. ▁has Remaining ▁( ▁) ▁) ▁{ ▁trans ferred ▁+= ▁target ▁. ▁write ▁( ▁bb ▁) ▁; ▁return ▁trans ferred ▁; ▁} ▁} ▁} ▁return ▁0 ▁; ▁} ▁public ▁void ▁close ▁( ▁) ▁{ ▁this ▁. ▁de alloc ate ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁de alloc ate ▁( ▁) ▁{ ▁this ▁. ▁getMessage Result ▁. ▁release ▁( ▁) ▁; ▁} ▁}
▁@ ▁SpringBoot Application ▁public ▁class ▁Sample Qu art z Application ▁{ ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Spring Application ▁. ▁run ▁( ▁Sample Qu art z Application ▁. ▁class ▁, ▁args ▁) ▁; ▁} ▁@ ▁Bean ▁public ▁Job Detail ▁hello Job Detail ▁( ▁) ▁{ ▁return ▁Job Builder ▁. ▁new Job ▁( ▁Sample Job ▁. ▁class ▁) ▁. ▁with Identity ▁( ▁STR ▁, ▁STR ▁) ▁. ▁using Job Data ▁( ▁STR ▁, ▁STR ▁) ▁. ▁store D ur a bly ▁( ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁@ ▁Bean ▁public ▁Job Detail ▁another Job Detail ▁( ▁) ▁{ ▁return ▁Job Builder ▁. ▁new Job ▁( ▁Sample Job ▁. ▁class ▁) ▁. ▁with Identity ▁( ▁STR ▁, ▁STR ▁) ▁. ▁using Job Data ▁( ▁STR ▁, ▁STR ▁) ▁. ▁store D ur a bly ▁( ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁@ ▁Bean ▁public ▁Trigger ▁e very Two Sec Trigger ▁( ▁) ▁{ ▁return ▁Trigger Builder ▁. ▁new Trigger ▁( ▁) ▁. ▁for Job ▁( ▁STR ▁, ▁STR ▁) ▁. ▁with Identity ▁( ▁STR ▁) ▁. ▁with Schedule ▁( ▁Simple Schedule Builder ▁. ▁simple Schedule ▁( ▁) ▁. ▁with Interval InSeconds ▁( ▁2 ▁) ▁. ▁repeat F ore ver ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁@ ▁Bean ▁public ▁Trigger ▁e very Day Trigger ▁( ▁) ▁{ ▁return ▁Trigger Builder ▁. ▁new Trigger ▁( ▁) ▁. ▁for Job ▁( ▁STR ▁, ▁STR ▁) ▁. ▁with Identity ▁( ▁STR ▁, ▁STR ▁) ▁. ▁with Schedule ▁( ▁Simple Schedule Builder ▁. ▁repeat Hour ly F ore ver ▁( ▁24 ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁@ ▁Bean ▁public ▁Trigger ▁th ree A m Week day s Trigger ▁( ▁) ▁{ ▁return ▁Trigger Builder ▁. ▁new Trigger ▁( ▁) ▁. ▁for Job ▁( ▁STR ▁, ▁STR ▁) ▁. ▁with Identity ▁( ▁STR ▁, ▁STR ▁) ▁. ▁with Schedule ▁( ▁Cron Schedule Builder ▁. ▁at Hour And Minute On Given Days Of Week ▁( ▁3 ▁, ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁@ ▁Bean ▁public ▁Trigger ▁on ce AW eek Trigger ▁( ▁) ▁{ ▁return ▁Trigger Builder ▁. ▁new Trigger ▁( ▁) ▁. ▁for Job ▁( ▁STR ▁, ▁STR ▁) ▁. ▁with Identity ▁( ▁STR ▁, ▁STR ▁) ▁. ▁with Schedule ▁( ▁Calendar Interval Schedule Builder ▁. ▁calendar Interval Schedule ▁( ▁) ▁. ▁with Interval In Week s ▁( ▁1 ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁}
▁set Decompiler Location ▁( ▁line ▁, ▁char Position ▁) ▁; ▁perform Find DataTypes ▁( ▁) ▁; ▁assert Find All Reference sTo DataType Was Called ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testFind DataType References _ To Current Address ▁( ▁) ▁throws ▁Exception ▁{ ▁decomp ile ▁( ▁INIT _ STRING _ ADDR ▁) ▁; ▁int ▁line ▁= ▁5 ▁; ▁int ▁char Position ▁= ▁7 ▁; ▁set Decompiler Location ▁( ▁line ▁, ▁char Position ▁) ▁; ▁perform Find Reference sTo Address ▁( ▁) ▁; ▁assert Find All Reference sTo Address Was Called ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testFind DataType References _ To Current Function ▁( ▁) ▁throws ▁Exception ▁{ ▁decomp ile ▁( ▁INIT _ STRING _ ADDR ▁) ▁; ▁int ▁line ▁= ▁2 ▁; ▁int ▁char Position ▁= ▁10 ▁; ▁set Decompiler Location ▁( ▁line ▁, ▁char Position ▁) ▁; ▁perform Find Reference sTo Symbol ▁( ▁) ▁; ▁assert Find All Reference sTo Symbol Was Called ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁Sh Library ▁implements ▁Rule ConfiguredTarget Factory ▁{ ▁@ ▁Override ▁public ▁Config uredTarget ▁create ▁( ▁RuleContext ▁ruleContext ▁) ▁throws ▁Interrupted Exception ▁, ▁Rule ErrorException ▁, ▁Action Conflict Exception ▁{ ▁NestedSet ▁< ▁Artifact ▁> ▁file sTo Build ▁= ▁NestedSet Builder ▁. ▁< ▁Artifact ▁> ▁stable Order ▁( ▁) ▁. ▁addAll ▁( ▁ruleContext ▁. ▁getPr erequisite Artifacts ▁( ▁STR ▁) ▁. ▁list ▁( ▁) ▁) ▁. ▁addAll ▁( ▁ruleContext ▁. ▁getPr erequisite Artifacts ▁( ▁STR ▁) ▁. ▁list ▁( ▁) ▁) ▁. ▁addAll ▁( ▁ruleContext ▁. ▁getPr erequisite Artifacts ▁( ▁STR ▁) ▁. ▁list ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁Runfiles ▁runfiles ▁= ▁new ▁Runfiles ▁. ▁Builder ▁( ▁ruleContext ▁. ▁getWorkspace Name ▁( ▁) ▁, ▁ruleContext ▁. ▁get Configuration ▁( ▁) ▁. ▁legacy External Runfiles ▁( ▁) ▁) ▁. ▁addTransitive Artifacts ▁( ▁file sTo Build ▁) ▁. ▁add Runfiles ▁( ▁ruleContext ▁, ▁Runfiles Provider ▁. ▁DEFAULT _ RUN FILES ▁) ▁. ▁build ▁( ▁) ▁; ▁return ▁new ▁Rule ConfiguredTarget Builder ▁( ▁ruleContext ▁) ▁. ▁set Files To Build ▁( ▁file sTo Build ▁) ▁. ▁add Provider ▁( ▁Runfiles Provider ▁. ▁class ▁, ▁Runfiles Provider ▁. ▁simple ▁( ▁runfiles ▁) ▁) ▁. ▁add Native Declared Provider ▁( ▁In strumented Files Collector ▁. ▁collect ▁( ▁ruleContext ▁, ▁Sh Coverage ▁. ▁IN STR UMENT ATION _ SPEC ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁}
▁final ▁Inner Join OperatorBase ▁< ▁Tuple 3 ▁< ▁String ▁, ▁Double ▁, ▁Integer ▁> ▁, ▁Tuple 2 ▁< ▁Integer ▁, ▁String ▁> ▁, ▁Tuple 2 ▁< ▁Double ▁, ▁String ▁> ▁, ▁Flat Join Function ▁< ▁Tuple 3 ▁< ▁String ▁, ▁Double ▁, ▁Integer ▁> ▁, ▁Tuple 2 ▁< ▁Integer ▁, ▁String ▁> ▁, ▁Tuple 2 ▁< ▁Double ▁, ▁String ▁> ▁> ▁> ▁base ▁= ▁new ▁Inner Join OperatorBase ▁< ▁Tuple 3 ▁< ▁String ▁, ▁Double ▁, ▁Integer ▁> ▁, ▁Tuple 2 ▁< ▁Integer ▁, ▁String ▁> ▁, ▁Tuple 2 ▁< ▁Double ▁, ▁String ▁> ▁, ▁Flat Join Function ▁< ▁Tuple 3 ▁< ▁String ▁, ▁Double ▁, ▁Integer ▁> ▁, ▁Tuple 2 ▁< ▁Integer ▁, ▁String ▁> ▁, ▁Tuple 2 ▁< ▁Double ▁, ▁String ▁> ▁> ▁> ▁( ▁join er ▁, ▁binary Op Info ▁, ▁left Keys ▁, ▁right Keys ▁, ▁taskName ▁) ▁; ▁final ▁List ▁< ▁Tuple 3 ▁< ▁String ▁, ▁Double ▁, ▁Integer ▁> ▁> ▁input Data 1 ▁= ▁new ▁ArrayList ▁< ▁Tuple 3 ▁< ▁String ▁, ▁Double ▁, ▁Integer ▁> ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁new ▁Tuple 3 ▁< ▁> ▁( ▁STR ▁, ▁42 .0 ▁, ▁1 ▁) ▁, ▁new ▁Tuple 3 ▁< ▁> ▁( ▁STR ▁, ▁1.0 ▁, ▁2 ▁) ▁, ▁new ▁Tuple 3 ▁< ▁> ▁( ▁STR ▁, ▁2.0 ▁, ▁3 ▁) ▁, ▁new ▁Tuple 3 ▁< ▁> ▁( ▁STR ▁, ▁3.0 ▁, ▁4 ▁) ▁, ▁new ▁Tuple 3 ▁< ▁> ▁( ▁STR ▁, ▁3.0 ▁, ▁3 ▁) ▁) ▁) ▁; ▁final ▁List ▁< ▁Tuple 2 ▁< ▁Integer ▁, ▁String ▁> ▁> ▁input Data 2 ▁= ▁new ▁ArrayList ▁< ▁Tuple 2 ▁< ▁Integer ▁, ▁String ▁> ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁new ▁Tuple 2 ▁< ▁> ▁( ▁3 ▁, ▁STR ▁) ▁, ▁new ▁Tuple 2 ▁< ▁> ▁( ▁4 ▁, ▁STR ▁) ▁, ▁new ▁Tuple 2 ▁< ▁> ▁( ▁2 ▁, ▁STR ▁) ▁) ▁) ▁; ▁final ▁Set ▁< ▁Tuple 2 ▁< ▁Double ▁, ▁String ▁> ▁> ▁expected ▁= ▁new ▁HashSet ▁< ▁Tuple 2 ▁< ▁Double ▁, ▁String ▁> ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁new ▁Tuple 2 ▁< ▁> ▁( ▁2.0 ▁, ▁STR ▁) ▁, ▁new ▁Tuple 2 ▁< ▁> ▁( ▁3.0 ▁, ▁STR ▁) ▁, ▁new ▁Tuple 2 ▁< ▁> ▁( ▁3.0 ▁, ▁STR ▁) ▁) ▁) ▁; ▁try ▁{ ▁final ▁TaskInfo ▁task Info ▁= ▁new ▁TaskInfo ▁( ▁STR ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁, ▁0 ▁) ▁; ▁ExecutionConfig ▁executionConfig ▁= ▁new ▁ExecutionConfig ▁( ▁) ▁; ▁executionConfig ▁. ▁disable Object Reuse ▁( ▁) ▁; ▁List ▁< ▁Tuple 2 ▁< ▁Double ▁, ▁String ▁> ▁> ▁result Safe ▁= ▁base ▁. ▁execute On Collections ▁( ▁input Data 1 ▁, ▁input Data 2 ▁, ▁new ▁Runtime U DF Context ▁( ▁task Info ▁, ▁null ▁, ▁executionConfig ▁, ▁new ▁HashMap ▁< ▁String ▁, ▁Future ▁< ▁Path ▁> ▁> ▁( ▁) ▁, ▁new ▁HashMap ▁< ▁String ▁, ▁Accumulator ▁< ▁? ▁, ▁? ▁> ▁> ▁( ▁) ▁, ▁new ▁Un registered Metrics Group ▁( ▁) ▁) ▁, ▁executionConfig ▁) ▁; ▁executionConfig ▁. ▁enable Object Reuse ▁( ▁) ▁;
▁for ▁( ▁Timeline Put Response ▁. ▁Timeline Put Error ▁e ▁: ▁response ▁. ▁get Errors ▁( ▁) ▁) ▁{ ▁LOG ▁. ▁warn ▁( ▁STR ▁, ▁e ▁. ▁getEntity Id ▁( ▁) ▁, ▁e ▁. ▁getEntity Type ▁( ▁) ▁, ▁e ▁. ▁getErrorCode ▁( ▁) ▁) ▁; ▁} ▁set Offset ▁( ▁getOffset ▁( ▁) ▁+ ▁bytes Parsed ▁- ▁bytes Parsed Last Batch ▁) ▁; ▁bytes Parsed Last Batch ▁= ▁bytes Parsed ▁; ▁entity List ▁. ▁clear ▁( ▁) ▁; ▁} ▁catch ▁( ▁YarnException ▁e ▁) ▁{ ▁post Error ▁= ▁true ▁; ▁throw ▁new ▁IOException ▁( ▁STR ▁, ▁e ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁post Error ▁= ▁true ▁; ▁throw ▁new ▁IOException ▁( ▁STR ▁, ▁e ▁) ▁; ▁} ▁} ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁if ▁( ▁app Completed ▁|| ▁post Error ▁) ▁{ ▁throw ▁e ▁; ▁} ▁} ▁catch ▁( ▁Runtime Exception ▁e ▁) ▁{ ▁if ▁( ▁app Completed ▁|| ▁! ▁( ▁e ▁. ▁getCause ▁( ▁) ▁instanceof ▁Json ParseException ▁) ▁) ▁{ ▁throw ▁e ▁; ▁} ▁} ▁return ▁count ▁; ▁} ▁} ▁class ▁Domain Log Info ▁extends ▁Log Info ▁{ ▁private ▁static ▁final ▁Logger ▁LOG ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Entity Group F ST imeline Store ▁. ▁class ▁) ▁; ▁public ▁Domain Log Info ▁( ▁String ▁attempt Dir Name ▁, ▁String ▁file ▁, ▁String ▁owner ▁) ▁{ ▁super ▁( ▁attempt Dir Name ▁, ▁file ▁, ▁owner ▁) ▁; ▁} ▁protected ▁long ▁doParse ▁( ▁Timeline Data Manager ▁tdm ▁, ▁JsonParser ▁parser ▁, ▁ObjectMapper ▁obj Mapper ▁, ▁UserGroup Information ▁ugi ▁, ▁boolean ▁app Completed ▁) ▁throws ▁IOException ▁{ ▁long ▁count ▁= ▁0 ▁; ▁long ▁bytes Parsed ▁; ▁long ▁bytes Parsed Last Batch ▁= ▁0 ▁; ▁boolean ▁put Error ▁= ▁false ▁; ▁try ▁{ ▁Mapping Iterator ▁< ▁Timeline Domain ▁> ▁iter ▁= ▁obj Mapper ▁. ▁read Values ▁( ▁parser ▁, ▁Timeline Domain ▁. ▁class ▁) ▁; ▁while ▁( ▁iter ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁Timeline Domain ▁domain ▁= ▁iter ▁. ▁next ▁( ▁) ▁; ▁domain ▁. ▁setOwner ▁( ▁ugi ▁. ▁getShort UserName ▁( ▁) ▁) ▁; ▁LOG ▁. ▁trace ▁( ▁STR ▁, ▁domain ▁. ▁getId ▁( ▁) ▁) ▁; ▁++ ▁count ▁; ▁bytes Parsed ▁= ▁parser ▁. ▁getCurrent Location ▁( ▁) ▁. ▁getChar Offset ▁( ▁) ▁+ ▁1 ▁; ▁LOG ▁. ▁trace ▁( ▁STR ▁, ▁bytes Parsed ▁) ▁; ▁try ▁{ ▁tdm ▁. ▁put Domain ▁( ▁domain ▁, ▁ugi ▁) ▁; ▁set Offset ▁( ▁getOffset ▁( ▁) ▁+ ▁bytes Parsed ▁- ▁bytes Parsed Last Batch ▁) ▁; ▁bytes Parsed Last Batch ▁= ▁bytes Parsed ▁; ▁} ▁catch ▁( ▁YarnException ▁e ▁) ▁{ ▁put Error ▁= ▁true ▁; ▁throw ▁new ▁IOException ▁( ▁STR ▁, ▁e ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁put Error ▁= ▁true ▁; ▁throw ▁new ▁IOException ▁( ▁STR ▁, ▁e ▁) ▁; ▁} ▁} ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁if ▁( ▁app Completed ▁|| ▁put Error ▁) ▁{ ▁throw ▁e ▁; ▁} ▁}
▁assertEquals ▁( ▁columnHandle ▁. ▁is Partition Key ▁( ▁) ▁, ▁true ▁) ▁; ▁} ▁private ▁void ▁test Json Equals ▁( ▁String ▁json ▁, ▁Map ▁< ▁String ▁, ▁Object ▁> ▁expected Map ▁) ▁throws ▁Exception ▁{ ▁Map ▁< ▁String ▁, ▁Object ▁> ▁json Map ▁= ▁objectMapper ▁. ▁readValue ▁( ▁json ▁, ▁new ▁TypeReference ▁< ▁Map ▁< ▁String ▁, ▁Object ▁> ▁> ▁( ▁) ▁{ ▁} ▁) ▁; ▁assertEquals Ignore Order ▁( ▁json Map ▁. ▁entrySet ▁( ▁) ▁, ▁expected Map ▁. ▁entrySet ▁( ▁) ▁) ▁; ▁} ▁}
▁assertEquals ▁( ▁all Splits ▁. ▁size ▁( ▁) ▁, ▁1 ▁) ▁; ▁assertEquals ▁( ▁( ▁( ▁Jmx Split ▁) ▁all Splits ▁. ▁get ▁( ▁0 ▁) ▁) ▁. ▁getAddress es ▁( ▁) ▁. ▁size ▁( ▁) ▁, ▁1 ▁) ▁; ▁assertEquals ▁( ▁( ▁( ▁Jmx Split ▁) ▁all Splits ▁. ▁get ▁( ▁0 ▁) ▁) ▁. ▁getAddress es ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁getHost Text ▁( ▁) ▁, ▁node Identifier ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁testNo Predicate ▁( ▁) ▁throws ▁Exception ▁{ ▁Connector TableLayout Handle ▁layout ▁= ▁new ▁Jmx TableLayout Handle ▁( ▁tableHandle ▁, ▁TupleDomain ▁. ▁all ▁( ▁) ▁) ▁; ▁ConnectorSplit Source ▁split Source ▁= ▁split Manager ▁. ▁getSplit s ▁( ▁Jmx Transaction Handle ▁. ▁INSTANCE ▁, ▁SESSION ▁, ▁layout ▁, ▁new ▁Split Scheduling Context ▁( ▁UN GR OU PED _ SCHED UL ING ▁, ▁false ▁, ▁Warning Collector ▁. ▁NOOP ▁) ▁) ▁; ▁List ▁< ▁ConnectorSplit ▁> ▁all Splits ▁= ▁getAll Splits ▁( ▁split Source ▁) ▁; ▁assertEquals ▁( ▁all Splits ▁. ▁size ▁( ▁) ▁, ▁nodes ▁. ▁size ▁( ▁) ▁) ▁; ▁Set ▁< ▁String ▁> ▁actual Nodes ▁= ▁nodes ▁. ▁stream ▁( ▁) ▁. ▁map ▁( ▁Node ▁:: ▁getNode Identifier ▁) ▁. ▁collect ▁( ▁toSet ▁( ▁) ▁) ▁; ▁Set ▁< ▁String ▁> ▁expected Nodes ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁ConnectorSplit ▁split ▁: ▁all Splits ▁) ▁{ ▁List ▁< ▁HostAddress ▁> ▁addresses ▁= ▁( ▁( ▁Jmx Split ▁) ▁split ▁) ▁. ▁getAddress es ▁( ▁) ▁; ▁assertEquals ▁( ▁addresses ▁. ▁size ▁( ▁) ▁, ▁1 ▁) ▁; ▁expected Nodes ▁. ▁add ▁( ▁addresses ▁. ▁get ▁( ▁0 ▁) ▁. ▁getHost Text ▁( ▁) ▁) ▁; ▁} ▁assertEquals ▁( ▁actual Nodes ▁, ▁expected Nodes ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test RecordSet Provider ▁( ▁) ▁throws ▁Exception ▁{ ▁for ▁( ▁SchemaTableName ▁schemaTableName ▁: ▁metadata ▁. ▁list Tables ▁( ▁SESSION ▁, ▁JMX _ SCHEMA _ NAME ▁) ▁) ▁{ ▁Record Set ▁record Set ▁= ▁getRecord Set ▁( ▁schemaTableName ▁) ▁; ▁try ▁( ▁Record Cursor ▁cursor ▁= ▁record Set ▁. ▁cursor ▁( ▁) ▁) ▁{ ▁while ▁( ▁cursor ▁. ▁advance Next Position ▁( ▁) ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁record Set ▁. ▁getColumn Types ▁( ▁) ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁cursor ▁. ▁isNull ▁( ▁i ▁) ▁; ▁} ▁} ▁} ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test History RecordSet Provider ▁( ▁) ▁throws ▁Exception ▁{ ▁for ▁( ▁SchemaTableName ▁schemaTableName ▁: ▁metadata ▁. ▁list Tables ▁( ▁SESSION ▁, ▁H ISTORY _ SCHEMA _ NAME ▁) ▁) ▁{ ▁List ▁< ▁Long ▁> ▁timeStamp s ▁= ▁ImmutableList ▁. ▁of ▁( ▁) ▁; ▁for ▁( ▁int ▁w a ited ▁= ▁0 ▁; ▁w a ited ▁< ▁TIMEOUT _ TIME ▁; ▁w a ited ▁+= ▁S LE EP _ TIME ▁) ▁{ ▁Record Set ▁record Set ▁= ▁getRecord Set ▁( ▁schemaTableName ▁) ▁; ▁timeStamp s ▁= ▁read Time Stamp sFrom ▁( ▁record Set ▁) ▁; ▁if ▁( ▁timeStamp s ▁. ▁size ▁( ▁) ▁>= ▁2 ▁) ▁{ ▁break ▁; ▁}
▁public ▁abstract ▁class ▁Send Data To Flink Service ▁{ ▁private ▁final ▁Logger ▁logger ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁this ▁. ▁getClass ▁( ▁) ▁) ▁; ▁private ▁volatile ▁List ▁< ▁Flink Tcp DataSender ▁> ▁flink Tcp DataSender List ▁= ▁new ▁CopyOnWrite ArrayList ▁< ▁> ▁( ▁) ▁; ▁private ▁final ▁AtomicInteger ▁call Count ▁= ▁new ▁AtomicInteger ▁( ▁1 ▁) ▁; ▁protected ▁void ▁send Data ▁( ▁TBase ▁< ▁? ▁, ▁? ▁> ▁data ▁) ▁{ ▁Flink Tcp DataSender ▁tcp DataSender ▁= ▁round Robin Tcp DataSender ▁( ▁) ▁; ▁if ▁( ▁tcp DataSender ▁== ▁null ▁) ▁{ ▁logger ▁. ▁warn ▁( ▁STR ▁) ▁; ▁return ▁; ▁} ▁try ▁{ ▁tcp DataSender ▁. ▁send ▁( ▁data ▁) ▁; ▁if ▁( ▁logger ▁. ▁isDebugEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁debug ▁( ▁STR ▁, ▁data ▁) ▁; ▁} ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁logger ▁. ▁error ▁( ▁STR ▁, ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁e ▁) ▁; ▁} ▁} ▁private ▁Flink Tcp DataSender ▁round Robin Tcp DataSender ▁( ▁) ▁{ ▁if ▁( ▁flink Tcp DataSender List ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁int ▁count ▁= ▁call Count ▁. ▁getAndIncrement ▁( ▁) ▁; ▁int ▁tcp DataSender Index ▁= ▁count ▁ % ▁flink Tcp DataSender List ▁. ▁size ▁( ▁) ▁; ▁if ▁( ▁tcp DataSender Index ▁< ▁0 ▁) ▁{ ▁tcp DataSender Index ▁= ▁tcp DataSender Index ▁ * ▁- ▁1 ▁; ▁call Count ▁. ▁set ▁( ▁0 ▁) ▁; ▁} ▁try ▁{ ▁return ▁flink Tcp DataSender List ▁. ▁get ▁( ▁tcp DataSender Index ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁logger ▁. ▁warn ▁( ▁STR ▁, ▁e ▁) ▁; ▁} ▁return ▁null ▁; ▁} ▁public ▁void ▁replace Flink Tcp DataSender List ▁( ▁List ▁< ▁Flink Tcp DataSender ▁> ▁flink Tcp DataSender List ▁) ▁{ ▁this ▁. ▁flink Tcp DataSender List ▁= ▁new ▁CopyOnWrite ArrayList ▁< ▁Flink Tcp DataSender ▁> ▁( ▁flink Tcp DataSender List ▁) ▁; ▁} ▁}
▁public ▁class ▁Candidate State ▁implements ▁E poch State ▁{ ▁private ▁final ▁int ▁local Id ▁; ▁private ▁final ▁int ▁epoch ▁; ▁private ▁final ▁int ▁retries ▁; ▁private ▁final ▁Map ▁< ▁Integer ▁, ▁State ▁> ▁v ote States ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁private ▁final ▁Optional ▁< ▁Log Offset Metadata ▁> ▁high Watermark ▁; ▁private ▁final ▁int ▁e lection TimeoutMs ▁; ▁private ▁final ▁Timer ▁e lection Timer ▁; ▁private ▁final ▁Timer ▁back off Timer ▁; ▁private ▁final ▁Logger ▁log ▁; ▁private ▁boolean ▁is Back ing Off ▁; ▁protected ▁Candidate State ▁( ▁Time ▁time ▁, ▁int ▁local Id ▁, ▁int ▁epoch ▁, ▁Set ▁< ▁Integer ▁> ▁vo ter s ▁, ▁Optional ▁< ▁Log Offset Metadata ▁> ▁high Watermark ▁, ▁int ▁retries ▁, ▁int ▁e lection TimeoutMs ▁, ▁Log Context ▁log Context ▁) ▁{ ▁this ▁. ▁local Id ▁= ▁local Id ▁; ▁this ▁. ▁epoch ▁= ▁epoch ▁; ▁this ▁. ▁high Watermark ▁= ▁high Watermark ▁; ▁this ▁. ▁retries ▁= ▁retries ▁; ▁this ▁. ▁is Back ing Off ▁= ▁false ▁; ▁this ▁. ▁e lection TimeoutMs ▁= ▁e lection TimeoutMs ▁; ▁this ▁. ▁e lection Timer ▁= ▁time ▁. ▁timer ▁( ▁e lection TimeoutMs ▁) ▁; ▁this ▁. ▁back off Timer ▁= ▁time ▁. ▁timer ▁( ▁0 ▁) ▁; ▁this ▁. ▁log ▁= ▁log Context ▁. ▁logger ▁( ▁Candidate State ▁. ▁class ▁) ▁; ▁for ▁( ▁Integer ▁vo ter Id ▁: ▁vo ter s ▁) ▁{ ▁v ote States ▁. ▁put ▁( ▁vo ter Id ▁, ▁State ▁. ▁UN REC OR DED ▁) ▁; ▁} ▁v ote States ▁. ▁put ▁( ▁local Id ▁, ▁State ▁. ▁GR AN TED ▁) ▁; ▁} ▁public ▁int ▁local Id ▁( ▁) ▁{ ▁return ▁local Id ▁; ▁} ▁public ▁int ▁m a j ority Size ▁( ▁) ▁{ ▁return ▁v ote States ▁. ▁size ▁( ▁) ▁ / ▁2 ▁+ ▁1 ▁; ▁} ▁private ▁long ▁num G ranted ▁( ▁) ▁{ ▁return ▁v ote States ▁. ▁values ▁( ▁) ▁. ▁stream ▁( ▁) ▁. ▁filter ▁( ▁state ▁-> ▁state ▁== ▁State ▁. ▁GR AN TED ▁) ▁. ▁count ▁( ▁) ▁; ▁} ▁private ▁long ▁num Un rec orded ▁( ▁) ▁{ ▁return ▁v ote States ▁. ▁values ▁( ▁) ▁. ▁stream ▁( ▁) ▁. ▁filter ▁( ▁state ▁-> ▁state ▁== ▁State ▁. ▁UN REC OR DED ▁) ▁. ▁count ▁( ▁) ▁; ▁} ▁public ▁boolean ▁is Back ing Off ▁( ▁) ▁{ ▁return ▁is Back ing Off ▁; ▁} ▁public ▁int ▁retries ▁( ▁) ▁{ ▁return ▁retries ▁; ▁} ▁public ▁boolean ▁isV ote G ranted ▁( ▁) ▁{ ▁return ▁num G ranted ▁( ▁) ▁>= ▁m a j ority Size ▁( ▁) ▁; ▁} ▁public ▁boolean ▁isV ote Rejected ▁( ▁) ▁{ ▁return ▁num G ranted ▁( ▁) ▁+ ▁num Un rec orded ▁( ▁) ▁< ▁m a j ority Size ▁( ▁) ▁; ▁} ▁public ▁boolean ▁record G ranted V ote ▁( ▁int ▁remote NodeId ▁) ▁{ ▁State ▁state ▁= ▁v ote States ▁. ▁get ▁( ▁remote NodeId ▁) ▁;
▁public ▁class ▁Byte Benchmark ▁{ ▁static ▁String ▁json ▁= ▁STR ▁; ▁static ▁String ▁json 2 ▁= ▁STR ▁; ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁throws ▁Exception ▁{ ▁Model ▁model ▁= ▁new ▁Model ▁( ▁) ▁; ▁model ▁. ▁v 1 ▁= ▁( ▁byte ▁) ▁new ▁Random ▁( ▁) ▁. ▁nextInt ▁( ▁) ▁; ▁model ▁. ▁v 2 ▁= ▁( ▁byte ▁) ▁new ▁Random ▁( ▁) ▁. ▁nextInt ▁( ▁) ▁; ▁model ▁. ▁v 3 ▁= ▁( ▁byte ▁) ▁new ▁Random ▁( ▁) ▁. ▁nextInt ▁( ▁) ▁; ▁model ▁. ▁v 4 ▁= ▁( ▁byte ▁) ▁new ▁Random ▁( ▁) ▁. ▁nextInt ▁( ▁) ▁; ▁model ▁. ▁v 5 ▁= ▁( ▁byte ▁) ▁new ▁Random ▁( ▁) ▁. ▁nextInt ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁JSON ▁. ▁toJSONString ▁( ▁model ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁10 ▁; ▁++ ▁i ▁) ▁{ ▁perf 2 ▁( ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁perf ▁( ▁) ▁{ ▁long ▁start ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁1000 ▁ * ▁1000 ▁ * ▁10 ▁; ▁++ ▁i ▁) ▁{ ▁JSON ▁. ▁parseObject ▁( ▁json ▁, ▁Model ▁. ▁class ▁) ▁; ▁} ▁long ▁millis ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁- ▁start ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁millis ▁) ▁; ▁} ▁public ▁static ▁void ▁perf 2 ▁( ▁) ▁{ ▁long ▁start ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁1000 ▁ * ▁1000 ▁ * ▁10 ▁; ▁++ ▁i ▁) ▁{ ▁JSON ▁. ▁parseObject ▁( ▁json 2 ▁, ▁Model ▁. ▁class ▁) ▁; ▁} ▁long ▁millis ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁- ▁start ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁millis ▁) ▁; ▁} ▁public ▁static ▁class ▁Model ▁{ ▁public ▁byte ▁v 1 ▁; ▁public ▁byte ▁v 2 ▁; ▁public ▁byte ▁v 3 ▁; ▁public ▁byte ▁v 4 ▁; ▁public ▁byte ▁v 5 ▁; ▁} ▁}
▁public ▁void ▁build Wrapped ▁( ▁StringBuilder ▁buffer ▁, ▁int ▁next Line Tab Stop ▁, ▁String ▁text ▁) ▁{ ▁render Wrapped Text Block ▁( ▁buffer ▁, ▁width ▁, ▁next Line Tab Stop ▁, ▁text ▁) ▁; ▁buffer ▁. ▁append ▁( ▁new Line ▁) ▁; ▁} ▁protected ▁StringBuilder ▁render Commands ▁( ▁StringBuilder ▁sb ▁, ▁Collection ▁< ▁CLI ▁> ▁commands ▁) ▁{ ▁final ▁String ▁l pad ▁= ▁create Padding ▁( ▁left P ad ▁) ▁; ▁final ▁String ▁dp ad ▁= ▁create Padding ▁( ▁desc P ad ▁) ▁; ▁int ▁max ▁= ▁0 ▁; ▁List ▁< ▁StringBuilder ▁> ▁prefix List ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁CLI ▁command ▁: ▁commands ▁) ▁{ ▁if ▁( ▁! ▁command ▁. ▁isH idden ▁( ▁) ▁) ▁{ ▁StringBuilder ▁buf ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁buf ▁. ▁append ▁( ▁l pad ▁) ▁. ▁append ▁( ▁STR ▁) ▁. ▁append ▁( ▁command ▁. ▁getName ▁( ▁) ▁) ▁; ▁prefix List ▁. ▁add ▁( ▁buf ▁) ▁; ▁max ▁= ▁Math ▁. ▁max ▁( ▁buf ▁. ▁length ▁( ▁) ▁, ▁max ▁) ▁; ▁} ▁} ▁int ▁x ▁= ▁0 ▁; ▁for ▁( ▁Iterator ▁< ▁CLI ▁> ▁it ▁= ▁commands ▁. ▁iterator ▁( ▁) ▁; ▁it ▁. ▁hasNext ▁( ▁) ▁; ▁) ▁{ ▁CLI ▁command ▁= ▁it ▁. ▁next ▁( ▁) ▁; ▁if ▁( ▁command ▁. ▁isH idden ▁( ▁) ▁) ▁{ ▁continue ▁; ▁} ▁StringBuilder ▁buf ▁= ▁new ▁StringBuilder ▁( ▁prefix List ▁. ▁get ▁( ▁x ▁++ ▁) ▁. ▁toString ▁( ▁) ▁) ▁; ▁if ▁( ▁buf ▁. ▁length ▁( ▁) ▁< ▁max ▁) ▁{ ▁buf ▁. ▁append ▁( ▁create Padding ▁( ▁max ▁- ▁buf ▁. ▁length ▁( ▁) ▁) ▁) ▁; ▁} ▁buf ▁. ▁append ▁( ▁dp ad ▁) ▁; ▁int ▁next Line Tab Stop ▁= ▁max ▁+ ▁desc P ad ▁; ▁buf ▁. ▁append ▁( ▁command ▁. ▁getS ummary ▁( ▁) ▁) ▁; ▁render Wrapped Text ▁( ▁sb ▁, ▁width ▁, ▁next Line Tab Stop ▁, ▁buf ▁. ▁toString ▁( ▁) ▁) ▁; ▁if ▁( ▁it ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁sb ▁. ▁append ▁( ▁getNew Line ▁( ▁) ▁) ▁; ▁} ▁} ▁return ▁sb ▁; ▁} ▁public ▁static ▁boolean ▁isNullOrEmpty ▁( ▁String ▁s ▁) ▁{ ▁return ▁s ▁== ▁null ▁|| ▁s ▁. ▁trim ▁( ▁) ▁. ▁length ▁( ▁) ▁== ▁0 ▁; ▁} ▁protected ▁StringBuilder ▁render Options And Arguments ▁( ▁StringBuilder ▁sb ▁, ▁List ▁< ▁Option ▁> ▁options ▁, ▁List ▁< ▁Argument ▁> ▁arguments ▁) ▁{ ▁final ▁String ▁l pad ▁= ▁create Padding ▁( ▁left P ad ▁) ▁; ▁final ▁String ▁dp ad ▁= ▁create Padding ▁( ▁desc P ad ▁) ▁; ▁int ▁max ▁= ▁0 ▁; ▁List ▁< ▁StringBuilder ▁> ▁prefix List ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁if ▁( ▁getOption Comparator ▁( ▁) ▁!= ▁null ▁) ▁{ ▁Collections ▁. ▁sort ▁( ▁options ▁, ▁getOption Comparator ▁( ▁) ▁) ▁; ▁} ▁for ▁( ▁Option ▁option ▁: ▁options ▁) ▁{ ▁StringBuilder ▁buf ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁if ▁( ▁option ▁. ▁isH idden ▁( ▁) ▁) ▁{ ▁continue ▁; ▁}
▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁number ▁; ▁i ▁++ ▁) ▁{ ▁callback ▁. ▁on Worker ▁( ▁i ▁, ▁new ▁EventLoop Worker ▁( ▁event Loops ▁[ ▁index ▁] ▁) ▁) ▁; ▁if ▁( ▁++ ▁index ▁== ▁c ▁) ▁{ ▁index ▁= ▁0 ▁; ▁} ▁} ▁n ▁= ▁index ▁; ▁} ▁} ▁} ▁public ▁Comp utation Scheduler ▁( ▁) ▁{ ▁this ▁( ▁THREAD _ FACTORY ▁) ▁; ▁} ▁public ▁Comp utation Scheduler ▁( ▁ThreadFactory ▁threadFactory ▁) ▁{ ▁this ▁. ▁threadFactory ▁= ▁threadFactory ▁; ▁this ▁. ▁pool ▁= ▁new ▁AtomicReference ▁< ▁> ▁( ▁NONE ▁) ▁; ▁start ▁( ▁) ▁; ▁} ▁@ ▁NonNull ▁@ ▁Override ▁public ▁Worker ▁create Worker ▁( ▁) ▁{ ▁return ▁new ▁EventLoop Worker ▁( ▁pool ▁. ▁get ▁( ▁) ▁. ▁getEvent Loop ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁create Workers ▁( ▁int ▁number ▁, ▁Worker Callback ▁callback ▁) ▁{ ▁Object Helper ▁. ▁verify Positive ▁( ▁number ▁, ▁STR ▁) ▁; ▁pool ▁. ▁get ▁( ▁) ▁. ▁create Workers ▁( ▁number ▁, ▁callback ▁) ▁; ▁} ▁@ ▁NonNull ▁@ ▁Override ▁public ▁Disposable ▁schedule Direct ▁( ▁@ ▁NonNull ▁Runnable ▁run ▁, ▁long ▁delay ▁, ▁TimeUnit ▁unit ▁) ▁{ ▁Pool Worker ▁w ▁= ▁pool ▁. ▁get ▁( ▁) ▁. ▁getEvent Loop ▁( ▁) ▁; ▁return ▁w ▁. ▁schedule Direct ▁( ▁run ▁, ▁delay ▁, ▁unit ▁) ▁; ▁} ▁@ ▁NonNull ▁@ ▁Override ▁public ▁Disposable ▁schedule Periodic ally Direct ▁( ▁@ ▁NonNull ▁Runnable ▁run ▁, ▁long ▁initialDelay ▁, ▁long ▁period ▁, ▁TimeUnit ▁unit ▁) ▁{ ▁Pool Worker ▁w ▁= ▁pool ▁. ▁get ▁( ▁) ▁. ▁getEvent Loop ▁( ▁) ▁; ▁return ▁w ▁. ▁schedule Periodic ally Direct ▁( ▁run ▁, ▁initialDelay ▁, ▁period ▁, ▁unit ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁start ▁( ▁) ▁{ ▁Fixed Scheduler Pool ▁update ▁= ▁new ▁Fixed Scheduler Pool ▁( ▁MAX _ THREADS ▁, ▁threadFactory ▁) ▁; ▁if ▁( ▁! ▁pool ▁. ▁compareAndSet ▁( ▁NONE ▁, ▁update ▁) ▁) ▁{ ▁update ▁. ▁shutdown ▁( ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁shutdown ▁( ▁) ▁{ ▁Fixed Scheduler Pool ▁curr ▁= ▁pool ▁. ▁getAndSet ▁( ▁NONE ▁) ▁; ▁if ▁( ▁curr ▁!= ▁NONE ▁) ▁{ ▁curr ▁. ▁shutdown ▁( ▁) ▁; ▁} ▁} ▁static ▁final ▁class ▁EventLoop Worker ▁extends ▁Scheduler ▁. ▁Worker ▁{ ▁private ▁final ▁List Composite Disposable ▁serial ▁; ▁private ▁final ▁Composite Disposable ▁t imed ▁; ▁private ▁final ▁List Composite Disposable ▁b oth ▁; ▁private ▁final ▁Pool Worker ▁pool Worker ▁; ▁volatile ▁boolean ▁disposed ▁; ▁EventLoop Worker ▁( ▁Pool Worker ▁pool Worker ▁) ▁{ ▁this ▁. ▁pool Worker ▁= ▁pool Worker ▁; ▁this ▁. ▁serial ▁= ▁new ▁List Composite Disposable ▁( ▁) ▁; ▁this ▁. ▁t imed ▁= ▁new ▁Composite Disposable ▁( ▁) ▁; ▁this ▁. ▁b oth ▁= ▁new ▁List Composite Disposable ▁( ▁) ▁; ▁this ▁. ▁b oth ▁. ▁add ▁( ▁serial ▁) ▁; ▁this ▁. ▁b oth ▁. ▁add ▁( ▁t imed ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁dispose ▁( ▁) ▁{ ▁if ▁( ▁! ▁disposed ▁) ▁{ ▁disposed ▁= ▁true ▁; ▁b oth ▁. ▁dispose ▁( ▁) ▁; ▁} ▁}
▁try ▁{ ▁String ▁[ ▁] ▁security Provider Classes ▁= ▁security Provider Classes Str ▁. ▁replaceAll ▁( ▁STR ▁, ▁STR ▁) ▁. ▁split ▁( ▁STR ▁) ▁; ▁for ▁( ▁int ▁index ▁= ▁0 ▁; ▁index ▁< ▁security Provider Classes ▁. ▁length ▁; ▁index ▁++ ▁) ▁{ ▁Security Provider Creator ▁security Provider Creator ▁= ▁( ▁Security Provider Creator ▁) ▁Class ▁. ▁forName ▁( ▁security Provider Classes ▁[ ▁index ▁] ▁) ▁. ▁getConstructor ▁( ▁) ▁. ▁newInstance ▁( ▁) ▁; ▁security Provider Creator ▁. ▁configure ▁( ▁configs ▁) ▁; ▁Security ▁. ▁insert Provider At ▁( ▁security Provider Creator ▁. ▁getProvider ▁( ▁) ▁, ▁index ▁+ ▁1 ▁) ▁; ▁} ▁} ▁catch ▁( ▁Class CastException ▁e ▁) ▁{ ▁LOGGER ▁. ▁error ▁( ▁STR ▁+ ▁Security Config ▁. ▁SECURITY _ PROVIDER S _ CONFIG ▁+ ▁STR ▁) ▁; ▁} ▁catch ▁( ▁ClassNot FoundException ▁cn f e ▁) ▁{ ▁LOGGER ▁. ▁error ▁( ▁STR ▁, ▁cn f e ▁) ▁; ▁} ▁catch ▁( ▁Reflective Operation Exception ▁e ▁) ▁{ ▁LOGGER ▁. ▁error ▁( ▁STR ▁, ▁e ▁) ▁; ▁} ▁} ▁public ▁static ▁ResourceType ▁resourceType ▁( ▁String ▁name ▁) ▁{ ▁return ▁value From Map ▁( ▁NAME _ TO _ RESOURCE _ TYPES ▁, ▁name ▁, ▁ResourceType ▁. ▁UNKNOWN ▁) ▁; ▁} ▁public ▁static ▁Acl Operation ▁operation ▁( ▁String ▁name ▁) ▁{ ▁return ▁value From Map ▁( ▁NAME _ TO _ OPER ATIONS ▁, ▁name ▁, ▁Acl Operation ▁. ▁UNKNOWN ▁) ▁; ▁} ▁public ▁static ▁Acl Permission Type ▁permission Type ▁( ▁String ▁name ▁) ▁{ ▁return ▁value From Map ▁( ▁NAME _ TO _ PER MISSION _ TYPES ▁, ▁name ▁, ▁Acl Permission Type ▁. ▁UNKNOWN ▁) ▁; ▁} ▁private ▁static ▁< ▁T ▁> ▁T ▁value From Map ▁( ▁Map ▁< ▁String ▁, ▁T ▁> ▁map ▁, ▁String ▁key ▁, ▁T ▁unknown ▁) ▁{ ▁T ▁value ▁= ▁map ▁. ▁get ▁( ▁key ▁) ▁; ▁if ▁( ▁value ▁== ▁null ▁) ▁{ ▁value ▁= ▁map ▁. ▁get ▁( ▁key ▁. ▁toUpperCase ▁( ▁Locale ▁. ▁ROOT ▁) ▁) ▁; ▁} ▁return ▁value ▁== ▁null ▁? ▁unknown ▁: ▁value ▁; ▁} ▁public ▁static ▁String ▁resource TypeName ▁( ▁ResourceType ▁resourceType ▁) ▁{ ▁return ▁toP as cal Case ▁( ▁resourceType ▁. ▁name ▁( ▁) ▁) ▁; ▁} ▁public ▁static ▁String ▁operationName ▁( ▁Acl Operation ▁operation ▁) ▁{ ▁return ▁toP as cal Case ▁( ▁operation ▁. ▁name ▁( ▁) ▁) ▁; ▁} ▁public ▁static ▁String ▁permission TypeName ▁( ▁Acl Permission Type ▁permission Type ▁) ▁{ ▁return ▁toP as cal Case ▁( ▁permission Type ▁. ▁name ▁( ▁) ▁) ▁; ▁} ▁private ▁static ▁String ▁toP as cal Case ▁( ▁String ▁name ▁) ▁{ ▁StringBuilder ▁builder ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁boolean ▁capital ize Next ▁= ▁true ▁; ▁for ▁( ▁char ▁c ▁: ▁name ▁. ▁toCharArray ▁( ▁) ▁) ▁{ ▁if ▁( ▁c ▁== ▁CHAR ▁) ▁capital ize Next ▁= ▁true ▁; ▁else ▁if ▁( ▁capital ize Next ▁) ▁{ ▁builder ▁. ▁append ▁( ▁Character ▁. ▁toUpperCase ▁( ▁c ▁) ▁) ▁; ▁capital ize Next ▁= ▁false ▁; ▁} ▁else ▁builder ▁. ▁append ▁( ▁Character ▁. ▁toLowerCase ▁( ▁c ▁) ▁) ▁; ▁}
▁private ▁static ▁Object ▁apply Caching ▁( ▁Object ▁response ▁, ▁long ▁timeToLive ▁) ▁{ ▁if ▁( ▁response ▁instanceof ▁Mono ▁) ▁{ ▁return ▁( ▁( ▁Mono ▁< ▁? ▁> ▁) ▁response ▁) ▁. ▁cache ▁( ▁Duration ▁. ▁ofMillis ▁( ▁timeToLive ▁) ▁) ▁; ▁} ▁if ▁( ▁response ▁instanceof ▁Flux ▁) ▁{ ▁return ▁( ▁( ▁Flux ▁< ▁? ▁> ▁) ▁response ▁) ▁. ▁cache ▁( ▁Duration ▁. ▁ofMillis ▁( ▁timeToLive ▁) ▁) ▁; ▁} ▁return ▁response ▁; ▁} ▁} ▁private ▁static ▁final ▁class ▁CacheKey ▁{ ▁private ▁final ▁ApiVersion ▁api Version ▁; ▁private ▁final ▁Principal ▁principal ▁; ▁private ▁CacheKey ▁( ▁ApiVersion ▁api Version ▁, ▁Principal ▁principal ▁) ▁{ ▁this ▁. ▁principal ▁= ▁principal ▁; ▁this ▁. ▁api Version ▁= ▁api Version ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁obj ▁) ▁{ ▁if ▁( ▁this ▁== ▁obj ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁obj ▁== ▁null ▁|| ▁getClass ▁( ▁) ▁!= ▁obj ▁. ▁getClass ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁CacheKey ▁other ▁= ▁( ▁CacheKey ▁) ▁obj ▁; ▁return ▁this ▁. ▁api Version ▁. ▁equals ▁( ▁other ▁. ▁api Version ▁) ▁&& ▁ObjectUtils ▁. ▁nullSafeEquals ▁( ▁this ▁. ▁principal ▁, ▁other ▁. ▁principal ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁final ▁int ▁prime ▁= ▁31 ▁; ▁int ▁result ▁= ▁1 ▁; ▁result ▁= ▁prime ▁ * ▁result ▁+ ▁this ▁. ▁api Version ▁. ▁hashCode ▁( ▁) ▁; ▁result ▁= ▁prime ▁ * ▁result ▁+ ▁ObjectUtils ▁. ▁nullSafe HashCode ▁( ▁this ▁. ▁principal ▁) ▁; ▁return ▁result ▁; ▁} ▁} ▁}
▁public ▁class ▁L CS Test ▁extends ▁AbstractGeneric Test ▁{ ▁@ ▁Test ▁public ▁void ▁test Ident ical ▁( ▁) ▁{ ▁compare Strings ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Sim il ar ▁( ▁) ▁{ ▁compare Strings ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁compare Strings ▁( ▁STR ▁+ ▁STR ▁, ▁STR ▁+ ▁STR ▁, ▁STR ▁+ ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Different ▁( ▁) ▁{ ▁compare Strings ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁compare Strings ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁compare Strings ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Size Limit ▁( ▁) ▁{ ▁String ▁input ▁= ▁STR ▁; ▁String L cs ▁sl cs ▁= ▁new ▁String L cs ▁( ▁input ▁, ▁input ▁) ▁; ▁List ▁< ▁Character ▁> ▁l cs ▁= ▁sl cs ▁. ▁getL cs ▁( ▁) ▁; ▁String ▁result ▁= ▁StringUtils ▁. ▁join ▁( ▁l cs ▁, ▁STR ▁) ▁; ▁assertEquals ▁( ▁input ▁, ▁result ▁) ▁; ▁sl cs ▁= ▁new ▁String L cs ▁( ▁input ▁, ▁input ▁) ▁; ▁sl cs ▁. ▁setSize Limit ▁( ▁10 ▁) ▁; ▁List ▁< ▁Character ▁> ▁actual ▁= ▁sl cs ▁. ▁getL cs ▁( ▁) ▁; ▁assertTrue ▁( ▁actual ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁} ▁private ▁void ▁compare Strings ▁( ▁String ▁x ▁, ▁String ▁y ▁, ▁String ▁expected ▁) ▁{ ▁String L cs ▁sl cs ▁= ▁new ▁String L cs ▁( ▁x ▁, ▁y ▁) ▁; ▁List ▁< ▁Character ▁> ▁actual ▁= ▁sl cs ▁. ▁getL cs ▁( ▁) ▁; ▁assertEquals ▁( ▁convert String ▁( ▁expected ▁) ▁, ▁actual ▁) ▁; ▁} ▁private ▁List ▁< ▁Character ▁> ▁convert String ▁( ▁String ▁s ▁) ▁{ ▁List ▁< ▁Character ▁> ▁char List ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁char ▁c ▁: ▁s ▁. ▁toCharArray ▁( ▁) ▁) ▁{ ▁char List ▁. ▁add ▁( ▁c ▁) ▁; ▁} ▁return ▁char List ▁; ▁} ▁private ▁class ▁String L cs ▁extends ▁L cs ▁< ▁Character ▁> ▁{ ▁private ▁String ▁x ▁; ▁private ▁String ▁y ▁; ▁public ▁String L cs ▁( ▁String ▁x ▁, ▁String ▁y ▁) ▁{ ▁super ▁( ▁) ▁; ▁this ▁. ▁x ▁= ▁x ▁; ▁this ▁. ▁y ▁= ▁y ▁; ▁} ▁@ ▁Override ▁protected ▁int ▁length Of X ▁( ▁) ▁{ ▁return ▁x ▁. ▁length ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁int ▁length Of Y ▁( ▁) ▁{ ▁return ▁y ▁. ▁length ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁boolean ▁matches ▁( ▁Character ▁my X ▁, ▁Character ▁my Y ▁) ▁{ ▁return ▁my X ▁. ▁equals ▁( ▁my Y ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Character ▁valueOf X ▁( ▁int ▁index ▁) ▁{ ▁return ▁x ▁. ▁charAt ▁( ▁index ▁- ▁1 ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Character ▁valueOf Y ▁( ▁int ▁index ▁) ▁{ ▁return ▁y ▁. ▁charAt ▁( ▁index ▁- ▁1 ▁) ▁; ▁} ▁} ▁}
▁if ▁( ▁node ▁. ▁asJava Constant ▁( ▁) ▁. ▁isNull ▁( ▁) ▁) ▁{ ▁Type Flow Builder ▁< ▁SourceType Flow ▁> ▁sourceBuilder ▁= ▁Type Flow Builder ▁. ▁create ▁( ▁bb ▁, ▁node ▁, ▁SourceType Flow ▁. ▁class ▁, ▁( ▁) ▁-> ▁{ ▁SourceType Flow ▁constant Source ▁= ▁new ▁SourceType Flow ▁( ▁node ▁, ▁Type State ▁. ▁for Null ▁( ▁) ▁) ▁; ▁method Flow ▁. ▁add M isc Entry ▁( ▁constant Source ▁) ▁; ▁return ▁constant Source ▁; ▁} ▁) ▁; ▁type Flows ▁. ▁add ▁( ▁node ▁, ▁sourceBuilder ▁) ▁; ▁} ▁else ▁if ▁( ▁node ▁. ▁asJava Constant ▁( ▁) ▁. ▁getJava Kind ▁( ▁) ▁== ▁JavaKind ▁. ▁Object ▁) ▁{ ▁assert ▁Stamp Tool ▁. ▁is Exact Type ▁( ▁node ▁) ▁; ▁Analysis Type ▁type ▁= ▁( ▁Analysis Type ▁) ▁Stamp Tool ▁. ▁type OrNull ▁( ▁node ▁) ▁; ▁assert ▁type ▁. ▁isIn stant iated ▁( ▁) ▁; ▁Type Flow Builder ▁< ▁SourceType Flow ▁> ▁sourceBuilder ▁= ▁Type Flow Builder ▁. ▁create ▁( ▁bb ▁, ▁node ▁, ▁SourceType Flow ▁. ▁class ▁, ▁( ▁) ▁-> ▁{ ▁SourceType Flow ▁constant Source ▁= ▁new ▁SourceType Flow ▁( ▁node ▁, ▁Type State ▁. ▁for Constant ▁( ▁this ▁. ▁bb ▁, ▁node ▁. ▁asJava Constant ▁( ▁) ▁, ▁type ▁) ▁) ▁; ▁method Flow ▁. ▁add M isc Entry ▁( ▁constant Source ▁) ▁; ▁return ▁constant Source ▁; ▁} ▁) ▁; ▁type Flows ▁. ▁add ▁( ▁node ▁, ▁sourceBuilder ▁) ▁; ▁} ▁} ▁} ▁} ▁new ▁Node Iterator ▁( ▁graph ▁. ▁start ▁( ▁) ▁, ▁type Flows ▁) ▁. ▁apply ▁( ▁) ▁; ▁type Flow GraphBuilder ▁. ▁build ▁( ▁) ▁; ▁for ▁( ▁Node ▁n ▁: ▁graph ▁. ▁getNodes ▁( ▁) ▁) ▁{ ▁if ▁( ▁n ▁instanceof ▁Instance Of Node ▁) ▁{ ▁Instance Of Node ▁instanceOf ▁= ▁( ▁Instance Of Node ▁) ▁n ▁; ▁mark Fields Used In Comparison ▁( ▁instanceOf ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁n ▁instanceof ▁Object Equals Node ▁) ▁{ ▁Object Equals Node ▁compare Node ▁= ▁( ▁Object Equals Node ▁) ▁n ▁; ▁mark Fields Used In Comparison ▁( ▁compare Node ▁. ▁getX ▁( ▁) ▁) ▁; ▁mark Fields Used In Comparison ▁( ▁compare Node ▁. ▁getY ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁private ▁static ▁void ▁mark Fields Used In Comparison ▁( ▁ValueNode ▁comp ared Value ▁) ▁{ ▁if ▁( ▁comp ared Value ▁instanceof ▁Load Field Node ▁) ▁{ ▁Load Field Node ▁load ▁= ▁( ▁Load Field Node ▁) ▁comp ared Value ▁; ▁Analysis Field ▁field ▁= ▁( ▁Analysis Field ▁) ▁load ▁. ▁field ▁( ▁) ▁; ▁if ▁( ▁! ▁field ▁. ▁isStatic ▁( ▁) ▁) ▁{ ▁field ▁. ▁mark As Used In Comparison ▁( ▁) ▁; ▁} ▁} ▁} ▁protected ▁class ▁Type Flow sOf Nodes ▁extends ▁Merge able State ▁< ▁Type Flow sOf Nodes ▁> ▁implements ▁Clone able ▁{ ▁private ▁final ▁Map ▁< ▁Node ▁, ▁Type Flow Builder ▁< ▁? ▁> ▁> ▁flow s ▁; ▁Type Flow sOf Nodes ▁( ▁) ▁{ ▁this ▁. ▁flow s ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁}
▁options ▁. ▁include ▁( ▁compute Projection Mask ▁( ▁schema ▁, ▁selected Fields ▁) ▁) ▁; ▁RecordReader ▁orc Rows Reader ▁= ▁create RecordReader ▁( ▁orc Reader ▁, ▁options ▁) ▁; ▁schema ▁. ▁getId ▁( ▁) ▁; ▁return ▁orc Rows Reader ▁; ▁} ▁@ ▁Override ▁public ▁Hive Orc Batch Wrapper ▁create Batch Wrapper ▁( ▁Type Description ▁schema ▁, ▁int ▁batchSize ▁) ▁{ ▁return ▁new ▁Hive Orc Batch Wrapper ▁( ▁schema ▁. ▁create Row Batch ▁( ▁batchSize ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁next Batch ▁( ▁RecordReader ▁reader ▁, ▁V ect orized Row Batch ▁row Batch ▁) ▁throws ▁IOException ▁{ ▁try ▁{ ▁if ▁( ▁hasNext Method ▁== ▁null ▁) ▁{ ▁hasNext Method ▁= ▁Class ▁. ▁forName ▁( ▁STR ▁) ▁. ▁getMethod ▁( ▁STR ▁) ▁; ▁hasNext Method ▁. ▁setAccessible ▁( ▁true ▁) ▁; ▁} ▁if ▁( ▁next Batch Method ▁== ▁null ▁) ▁{ ▁next Batch Method ▁= ▁RecordReader ▁. ▁class ▁. ▁getMethod ▁( ▁STR ▁, ▁V ect orized Row Batch ▁. ▁class ▁) ▁; ▁next Batch Method ▁. ▁setAccessible ▁( ▁true ▁) ▁; ▁} ▁boolean ▁hasNext ▁= ▁( ▁boolean ▁) ▁hasNext Method ▁. ▁invoke ▁( ▁reader ▁) ▁; ▁if ▁( ▁hasNext ▁) ▁{ ▁next Batch Method ▁. ▁invoke ▁( ▁reader ▁, ▁row Batch ▁) ▁; ▁return ▁true ▁; ▁} ▁else ▁{ ▁return ▁false ▁; ▁} ▁} ▁catch ▁( ▁Illegal AccessException ▁| ▁Invocation TargetException ▁| ▁NoSuch MethodException ▁| ▁ClassNot FoundException ▁e ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁e ▁) ▁; ▁} ▁} ▁@ ▁Visible ForTesting ▁public ▁static ▁Tuple 2 ▁< ▁Long ▁, ▁Long ▁> ▁getOffset And Length For Split ▁( ▁long ▁split Start ▁, ▁long ▁split Length ▁, ▁List ▁< ▁St ripe Information ▁> ▁stripe s ▁) ▁{ ▁long ▁split End ▁= ▁split Start ▁+ ▁split Length ▁; ▁long ▁read Start ▁= ▁Long ▁. ▁MAX _ VALUE ▁; ▁long ▁read End ▁= ▁Long ▁. ▁MIN _ VALUE ▁; ▁for ▁( ▁St ripe Information ▁s ▁: ▁stripe s ▁) ▁{ ▁if ▁( ▁split Start ▁<= ▁s ▁. ▁getOffset ▁( ▁) ▁&& ▁s ▁. ▁getOffset ▁( ▁) ▁< ▁split End ▁) ▁{ ▁read Start ▁= ▁Math ▁. ▁min ▁( ▁read Start ▁, ▁s ▁. ▁getOffset ▁( ▁) ▁) ▁; ▁read End ▁= ▁Math ▁. ▁max ▁( ▁read End ▁, ▁s ▁. ▁getOffset ▁( ▁) ▁+ ▁s ▁. ▁getLength ▁( ▁) ▁) ▁; ▁} ▁} ▁if ▁( ▁read Start ▁< ▁Long ▁. ▁MAX _ VALUE ▁) ▁{ ▁return ▁Tuple 2 ▁. ▁of ▁( ▁read Start ▁, ▁read End ▁- ▁read Start ▁) ▁; ▁} ▁else ▁{ ▁return ▁Tuple 2 ▁. ▁of ▁( ▁0 L ▁, ▁0 L ▁) ▁; ▁} ▁} ▁public ▁static ▁boolean ▁[ ▁] ▁compute Projection Mask ▁( ▁Type Description ▁schema ▁, ▁int ▁[ ▁] ▁selected Fields ▁) ▁{ ▁boolean ▁[ ▁] ▁projection Mask ▁= ▁new ▁boolean ▁[ ▁schema ▁. ▁getMaximum Id ▁( ▁) ▁+ ▁1 ▁] ▁; ▁for ▁( ▁int ▁in Idx ▁: ▁selected Fields ▁) ▁{ ▁Type Description ▁field Schema ▁= ▁schema ▁. ▁getChildren ▁( ▁) ▁. ▁get ▁( ▁in Idx ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁field Schema ▁. ▁getId ▁( ▁) ▁;
▁public ▁class ▁Default Execution Deployment Recon c iler Test ▁extends ▁TestLogger ▁{ ▁@ ▁Test ▁public ▁void ▁test Matching De ploy ments ▁( ▁) ▁{ ▁Testing Execution Deployment Recon c il iation Handler ▁handler ▁= ▁new ▁Testing Execution Deployment Recon c il iation Handler ▁( ▁) ▁; ▁Default Execution Deployment Recon c iler ▁re con c iler ▁= ▁new ▁Default Execution Deployment Recon c iler ▁( ▁handler ▁) ▁; ▁ResourceID ▁resourceId ▁= ▁generate ▁( ▁) ▁; ▁Execution AttemptID ▁attempt Id ▁= ▁new ▁Execution AttemptID ▁( ▁) ▁; ▁re con c iler ▁. ▁re con c ile Execution De ploy ments ▁( ▁resourceId ▁, ▁new ▁Execution Deployment Report ▁( ▁Collections ▁. ▁singleton ▁( ▁attempt Id ▁) ▁) ▁, ▁Collections ▁. ▁singletonMap ▁( ▁attempt Id ▁, ▁Execution Deployment State ▁. ▁DE P LO Y ED ▁) ▁) ▁; ▁assertThat ▁( ▁handler ▁. ▁getM issing Execution s ▁( ▁) ▁, ▁empty ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁handler ▁. ▁getUn known Execution s ▁( ▁) ▁, ▁empty ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Missing De ploy ments ▁( ▁) ▁{ ▁Testing Execution Deployment Recon c il iation Handler ▁handler ▁= ▁new ▁Testing Execution Deployment Recon c il iation Handler ▁( ▁) ▁; ▁Default Execution Deployment Recon c iler ▁re con c iler ▁= ▁new ▁Default Execution Deployment Recon c iler ▁( ▁handler ▁) ▁; ▁ResourceID ▁resourceId ▁= ▁generate ▁( ▁) ▁; ▁Execution AttemptID ▁attempt Id ▁= ▁new ▁Execution AttemptID ▁( ▁) ▁; ▁re con c iler ▁. ▁re con c ile Execution De ploy ments ▁( ▁resourceId ▁, ▁new ▁Execution Deployment Report ▁( ▁Collections ▁. ▁emptySet ▁( ▁) ▁) ▁, ▁Collections ▁. ▁singletonMap ▁( ▁attempt Id ▁, ▁Execution Deployment State ▁. ▁DE P LO Y ED ▁) ▁) ▁; ▁assertThat ▁( ▁handler ▁. ▁getUn known Execution s ▁( ▁) ▁, ▁empty ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁handler ▁. ▁getM issing Execution s ▁( ▁) ▁, ▁has Item ▁( ▁attempt Id ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Unknown De ploy ments ▁( ▁) ▁{ ▁Testing Execution Deployment Recon c il iation Handler ▁handler ▁= ▁new ▁Testing Execution Deployment Recon c il iation Handler ▁( ▁) ▁; ▁Default Execution Deployment Recon c iler ▁re con c iler ▁= ▁new ▁Default Execution Deployment Recon c iler ▁( ▁handler ▁) ▁; ▁ResourceID ▁resourceId ▁= ▁generate ▁( ▁) ▁; ▁Execution AttemptID ▁attempt Id ▁= ▁new ▁Execution AttemptID ▁( ▁) ▁; ▁re con c iler ▁. ▁re con c ile Execution De ploy ments ▁( ▁resourceId ▁, ▁new ▁Execution Deployment Report ▁( ▁Collections ▁. ▁singleton ▁( ▁attempt Id ▁) ▁) ▁, ▁Collections ▁. ▁emptyMap ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁handler ▁. ▁getM issing Execution s ▁( ▁) ▁, ▁empty ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁handler ▁. ▁getUn known Execution s ▁( ▁) ▁, ▁has Item ▁( ▁attempt Id ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Missing And Unknown De ploy ments ▁( ▁) ▁{ ▁Testing Execution Deployment Recon c il iation Handler ▁handler ▁= ▁new ▁Testing Execution Deployment Recon c il iation Handler ▁( ▁) ▁;
▁public ▁class ▁RM StateStore Remove App Event ▁extends ▁RM StateStore Event ▁{ ▁Application State Data ▁app State ▁; ▁RM StateStore Remove App Event ▁( ▁Application State Data ▁app State ▁) ▁{ ▁super ▁( ▁RM StateStore EventType ▁. ▁REMOVE _ APP ▁) ▁; ▁this ▁. ▁app State ▁= ▁app State ▁; ▁} ▁public ▁Application State Data ▁getApp State ▁( ▁) ▁{ ▁return ▁app State ▁; ▁} ▁}
▁public ▁class ▁DataBuffer Wrapper ▁implements ▁DataBuffer ▁{ ▁private ▁final ▁DataBuffer ▁delegate ▁; ▁public ▁DataBuffer Wrapper ▁( ▁DataBuffer ▁delegate ▁) ▁{ ▁Assert ▁. ▁notNull ▁( ▁delegate ▁, ▁STR ▁) ▁; ▁this ▁. ▁delegate ▁= ▁delegate ▁; ▁} ▁public ▁DataBuffer ▁dataBuffer ▁( ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁; ▁} ▁@ ▁Override ▁public ▁DataBuffer Factory ▁factory ▁( ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁factory ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁indexOf ▁( ▁Int Predicate ▁predicate ▁, ▁int ▁fromIndex ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁indexOf ▁( ▁predicate ▁, ▁fromIndex ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁lastIndexOf ▁( ▁Int Predicate ▁predicate ▁, ▁int ▁fromIndex ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁lastIndexOf ▁( ▁predicate ▁, ▁fromIndex ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁readable Byte Count ▁( ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁readable Byte Count ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁writable Byte Count ▁( ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁writable Byte Count ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁capacity ▁( ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁capacity ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁DataBuffer ▁capacity ▁( ▁int ▁capacity ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁capacity ▁( ▁capacity ▁) ▁; ▁} ▁@ ▁Override ▁public ▁DataBuffer ▁ensureCapacity ▁( ▁int ▁capacity ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁ensureCapacity ▁( ▁capacity ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁read Position ▁( ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁read Position ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁DataBuffer ▁read Position ▁( ▁int ▁read Position ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁read Position ▁( ▁read Position ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁write Position ▁( ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁write Position ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁DataBuffer ▁write Position ▁( ▁int ▁write Position ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁write Position ▁( ▁write Position ▁) ▁; ▁} ▁@ ▁Override ▁public ▁byte ▁getByte ▁( ▁int ▁index ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁getByte ▁( ▁index ▁) ▁; ▁} ▁@ ▁Override ▁public ▁byte ▁read ▁( ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁read ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁DataBuffer ▁read ▁( ▁byte ▁[ ▁] ▁destination ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁read ▁( ▁destination ▁) ▁; ▁} ▁@ ▁Override ▁public ▁DataBuffer ▁read ▁( ▁byte ▁[ ▁] ▁destination ▁, ▁int ▁offset ▁, ▁int ▁length ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁read ▁( ▁destination ▁, ▁offset ▁, ▁length ▁) ▁; ▁} ▁@ ▁Override ▁public ▁DataBuffer ▁write ▁( ▁byte ▁b ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁write ▁( ▁b ▁) ▁; ▁} ▁@ ▁Override ▁public ▁DataBuffer ▁write ▁( ▁byte ▁[ ▁] ▁source ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁write ▁( ▁source ▁) ▁; ▁} ▁@ ▁Override ▁public ▁DataBuffer ▁write ▁( ▁byte ▁[ ▁] ▁source ▁, ▁int ▁offset ▁, ▁int ▁length ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁write ▁( ▁source ▁, ▁offset ▁, ▁length ▁) ▁; ▁} ▁@ ▁Override ▁public ▁DataBuffer ▁write ▁( ▁DataBuffer ▁... ▁buffers ▁) ▁{ ▁return ▁this ▁. ▁delegate ▁. ▁write ▁( ▁buffers ▁) ▁; ▁}
▁public ▁static ▁List ▁< ▁String ▁> ▁getB oot class path ▁( ▁Java Compile Action ▁jav ac ▁) ▁throws ▁Exception ▁{ ▁return ▁getOptions ▁( ▁jav ac ▁) ▁. ▁getB oot ClassPath ▁( ▁) ▁; ▁} ▁public ▁static ▁List ▁< ▁String ▁> ▁getJ av ac Command ▁( ▁Java Compile Action ▁action ▁) ▁throws ▁Exception ▁{ ▁List ▁< ▁String ▁> ▁args ▁= ▁action ▁. ▁getCommand Lines ▁( ▁) ▁. ▁allArguments ▁( ▁) ▁; ▁return ▁args ▁. ▁subList ▁( ▁0 ▁, ▁main Class Index ▁( ▁args ▁) ▁) ▁; ▁} ▁public ▁static ▁List ▁< ▁String ▁> ▁getJ av ac Arguments ▁( ▁Java Compile Action ▁action ▁) ▁throws ▁Exception ▁{ ▁List ▁< ▁String ▁> ▁args ▁= ▁action ▁. ▁getCommand Lines ▁( ▁) ▁. ▁allArguments ▁( ▁) ▁; ▁return ▁args ▁. ▁subList ▁( ▁main Class Index ▁( ▁args ▁) ▁, ▁args ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁private ▁static ▁int ▁main Class Index ▁( ▁List ▁< ▁String ▁> ▁args ▁) ▁{ ▁for ▁( ▁int ▁idx ▁= ▁0 ▁; ▁idx ▁< ▁args ▁. ▁size ▁( ▁) ▁; ▁idx ▁++ ▁) ▁{ ▁String ▁arg ▁= ▁args ▁. ▁get ▁( ▁idx ▁) ▁; ▁if ▁( ▁arg ▁. ▁equals ▁( ▁STR ▁) ▁) ▁{ ▁return ▁idx ▁+ ▁2 ▁; ▁} ▁if ▁( ▁arg ▁. ▁contains ▁( ▁STR ▁) ▁&& ▁! ▁arg ▁. ▁endsWith ▁( ▁STR ▁) ▁) ▁{ ▁return ▁idx ▁+ ▁1 ▁; ▁} ▁} ▁throw ▁new ▁Illegal StateException ▁( ▁args ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁private ▁static ▁Options Parser ▁getOptions ▁( ▁Java Compile Action ▁jav ac ▁) ▁throws ▁Exception ▁{ ▁checkArgument ▁( ▁jav ac ▁. ▁getMnemonic ▁( ▁) ▁. ▁equals ▁( ▁STR ▁) ▁, ▁STR ▁, ▁jav ac ▁. ▁getMnemonic ▁( ▁) ▁) ▁; ▁return ▁new ▁Options Parser ▁( ▁getJ av ac Arguments ▁( ▁jav ac ▁) ▁) ▁; ▁} ▁private ▁Java Compile Action TestHelper ▁( ▁) ▁{ ▁} ▁}
▁class ▁Font Character Parser ▁{ ▁private ▁static ▁final ▁JsonReader ▁. ▁Options ▁NAME S ▁= ▁JsonReader ▁. ▁Options ▁. ▁of ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁private ▁static ▁final ▁JsonReader ▁. ▁Options ▁DATA _ NAMES ▁= ▁JsonReader ▁. ▁Options ▁. ▁of ▁( ▁STR ▁) ▁; ▁private ▁Font Character Parser ▁( ▁) ▁{ ▁} ▁static ▁Font Character ▁parse ▁( ▁JsonReader ▁reader ▁, ▁Lottie Comp osition ▁comp osition ▁) ▁throws ▁IOException ▁{ ▁char ▁character ▁= ▁CHAR ▁; ▁double ▁size ▁= ▁0 ▁; ▁double ▁width ▁= ▁0 ▁; ▁String ▁style ▁= ▁null ▁; ▁String ▁font Family ▁= ▁null ▁; ▁List ▁< ▁Shape Group ▁> ▁sh apes ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁reader ▁. ▁begin Object ▁( ▁) ▁; ▁while ▁( ▁reader ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁switch ▁( ▁reader ▁. ▁select Name ▁( ▁NAME S ▁) ▁) ▁{ ▁case ▁0 ▁: ▁character ▁= ▁reader ▁. ▁next String ▁( ▁) ▁. ▁charAt ▁( ▁0 ▁) ▁; ▁break ▁; ▁case ▁1 ▁: ▁size ▁= ▁reader ▁. ▁nextDouble ▁( ▁) ▁; ▁break ▁; ▁case ▁2 ▁: ▁width ▁= ▁reader ▁. ▁nextDouble ▁( ▁) ▁; ▁break ▁; ▁case ▁3 ▁: ▁style ▁= ▁reader ▁. ▁next String ▁( ▁) ▁; ▁break ▁; ▁case ▁4 ▁: ▁font Family ▁= ▁reader ▁. ▁next String ▁( ▁) ▁; ▁break ▁; ▁case ▁5 ▁: ▁reader ▁. ▁begin Object ▁( ▁) ▁; ▁while ▁( ▁reader ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁switch ▁( ▁reader ▁. ▁select Name ▁( ▁DATA _ NAMES ▁) ▁) ▁{ ▁case ▁0 ▁: ▁reader ▁. ▁begin Array ▁( ▁) ▁; ▁while ▁( ▁reader ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁sh apes ▁. ▁add ▁( ▁( ▁Shape Group ▁) ▁Content Model Parser ▁. ▁parse ▁( ▁reader ▁, ▁comp osition ▁) ▁) ▁; ▁} ▁reader ▁. ▁endArray ▁( ▁) ▁; ▁break ▁; ▁default ▁: ▁reader ▁. ▁skip Name ▁( ▁) ▁; ▁reader ▁. ▁skip Value ▁( ▁) ▁; ▁} ▁} ▁reader ▁. ▁endObject ▁( ▁) ▁; ▁break ▁; ▁default ▁: ▁reader ▁. ▁skip Name ▁( ▁) ▁; ▁reader ▁. ▁skip Value ▁( ▁) ▁; ▁} ▁} ▁reader ▁. ▁endObject ▁( ▁) ▁; ▁return ▁new ▁Font Character ▁( ▁sh apes ▁, ▁character ▁, ▁size ▁, ▁width ▁, ▁style ▁, ▁font Family ▁) ▁; ▁} ▁}
▁public ▁class ▁Re vert Model SnapshotAction RequestTests ▁extends ▁Abstract Serializing TestCase ▁< ▁Request ▁> ▁{ ▁@ ▁Override ▁protected ▁Request ▁createTest Instance ▁( ▁) ▁{ ▁Re vert Model SnapshotAction ▁. ▁Request ▁request ▁= ▁new ▁Re vert Model SnapshotAction ▁. ▁Request ▁( ▁randomAlpha OfLengthBetween ▁( ▁1 ▁, ▁20 ▁) ▁, ▁randomAlpha OfLengthBetween ▁( ▁1 ▁, ▁20 ▁) ▁) ▁; ▁if ▁( ▁randomBoolean ▁( ▁) ▁) ▁{ ▁request ▁. ▁set Delete Inter ven ing Results ▁( ▁randomBoolean ▁( ▁) ▁) ▁; ▁} ▁if ▁( ▁randomBoolean ▁( ▁) ▁) ▁{ ▁request ▁. ▁set Force ▁( ▁randomBoolean ▁( ▁) ▁) ▁; ▁} ▁return ▁request ▁; ▁} ▁@ ▁Override ▁protected ▁Writeable ▁. ▁Reader ▁< ▁Request ▁> ▁instanceReader ▁( ▁) ▁{ ▁return ▁Request ▁:: ▁new ▁; ▁} ▁@ ▁Override ▁protected ▁boolean ▁supports UnknownFields ▁( ▁) ▁{ ▁return ▁false ▁; ▁} ▁@ ▁Override ▁protected ▁Request ▁doParseInstance ▁( ▁XContentParser ▁parser ▁) ▁{ ▁return ▁Re vert Model SnapshotAction ▁. ▁Request ▁. ▁parse Request ▁( ▁null ▁, ▁null ▁, ▁parser ▁) ▁; ▁} ▁}
▁class ▁Android ElfRelocation Offset ▁extends ▁Abstract L eb 128 DataType ▁{ ▁private ▁final ▁long ▁base Offset ▁; ▁private ▁long ▁relocation Offset ▁; ▁Android ElfRelocation Offset ▁( ▁DataTypeManager ▁dtm ▁, ▁long ▁base Offset ▁) ▁{ ▁super ▁( ▁STR ▁, ▁true ▁, ▁dtm ▁) ▁; ▁this ▁. ▁base Offset ▁= ▁base Offset ▁; ▁} ▁@ ▁Override ▁public ▁DataType ▁clone ▁( ▁DataTypeManager ▁dtm ▁) ▁{ ▁if ▁( ▁dtm ▁== ▁getDataType Manager ▁( ▁) ▁) ▁{ ▁return ▁this ▁; ▁} ▁return ▁new ▁Android ElfRelocation Offset ▁( ▁dtm ▁, ▁base Offset ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getMnemonic ▁( ▁Settings ▁settings ▁) ▁{ ▁return ▁name ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getDescription ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getDefault Label Prefix ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁protected ▁Settings Definition ▁[ ▁] ▁getB uiltIn Settings Definitions ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁Class ▁< ▁? ▁> ▁getValue Class ▁( ▁Settings ▁settings ▁) ▁{ ▁return ▁Address ▁. ▁class ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁getValue ▁( ▁MemBuffer ▁buf ▁, ▁Settings ▁settings ▁, ▁int ▁length ▁) ▁{ ▁Scalar ▁s ▁= ▁( ▁Scalar ▁) ▁super ▁. ▁getValue ▁( ▁buf ▁, ▁settings ▁, ▁length ▁) ▁; ▁if ▁( ▁s ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁AddressSpace ▁space ▁= ▁buf ▁. ▁getAddress ▁( ▁) ▁. ▁getAddressSpace ▁( ▁) ▁. ▁getPh ysical Space ▁( ▁) ▁; ▁return ▁space ▁. ▁getAddress ▁( ▁s ▁. ▁getUnsigned Value ▁( ▁) ▁+ ▁base Offset ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getRe presentation ▁( ▁MemBuffer ▁buf ▁, ▁Settings ▁settings ▁, ▁int ▁length ▁) ▁{ ▁Scalar ▁s ▁= ▁( ▁Scalar ▁) ▁super ▁. ▁getValue ▁( ▁buf ▁, ▁settings ▁, ▁length ▁) ▁; ▁if ▁( ▁s ▁== ▁null ▁) ▁{ ▁return ▁STR ▁; ▁} ▁StringBuilder ▁b ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁if ▁( ▁base Offset ▁!= ▁0 ▁) ▁{ ▁b ▁. ▁append ▁( ▁STR ▁) ▁; ▁b ▁. ▁append ▁( ▁Long ▁. ▁toHexString ▁( ▁base Offset ▁) ▁) ▁; ▁b ▁. ▁append ▁( ▁STR ▁) ▁; ▁} ▁b ▁. ▁append ▁( ▁STR ▁) ▁; ▁b ▁. ▁append ▁( ▁Long ▁. ▁toHexString ▁( ▁s ▁. ▁getUnsigned Value ▁( ▁) ▁) ▁) ▁; ▁return ▁b ▁. ▁toString ▁( ▁) ▁; ▁} ▁long ▁getRe location Offset ▁( ▁) ▁{ ▁return ▁relocation Offset ▁; ▁} ▁void ▁setRe location Offset ▁( ▁long ▁relocation Offset ▁) ▁{ ▁this ▁. ▁relocation Offset ▁= ▁relocation Offset ▁; ▁} ▁}
▁public ▁class ▁Table ▁extends ▁W idget Group ▁{ ▁static ▁public ▁Color ▁debug Table Color ▁= ▁new ▁Color ▁( ▁0 ▁, ▁0 ▁, ▁1 ▁, ▁1 ▁) ▁; ▁static ▁public ▁Color ▁debug Cell Color ▁= ▁new ▁Color ▁( ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁) ▁; ▁static ▁public ▁Color ▁debug Actor Color ▁= ▁new ▁Color ▁( ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁) ▁; ▁static ▁final ▁Pool ▁< ▁Cell ▁> ▁cell Pool ▁= ▁new ▁Pool ▁< ▁Cell ▁> ▁( ▁) ▁{ ▁protected ▁Cell ▁new Object ▁( ▁) ▁{ ▁return ▁new ▁Cell ▁( ▁) ▁; ▁} ▁} ▁; ▁static ▁private ▁float ▁[ ▁] ▁column W eighted Width ▁, ▁row W eighted Height ▁; ▁private ▁int ▁columns ▁, ▁rows ▁; ▁private ▁boolean ▁impl icit End Row ▁; ▁private ▁final ▁Array ▁< ▁Cell ▁> ▁cell s ▁= ▁new ▁Array ▁( ▁4 ▁) ▁; ▁private ▁final ▁Cell ▁cell Defaults ▁; ▁private ▁final ▁Array ▁< ▁Cell ▁> ▁column Defaults ▁= ▁new ▁Array ▁( ▁2 ▁) ▁; ▁private ▁Cell ▁row Defaults ▁; ▁private ▁boolean ▁size Invalid ▁= ▁true ▁; ▁private ▁float ▁[ ▁] ▁column Min Width ▁, ▁row Min Height ▁; ▁private ▁float ▁[ ▁] ▁column Pref Width ▁, ▁row Pref Height ▁; ▁private ▁float ▁table Min Width ▁, ▁table Min Height ▁; ▁private ▁float ▁table Pref Width ▁, ▁table Pref Height ▁; ▁private ▁float ▁[ ▁] ▁column Width ▁, ▁row Height ▁; ▁private ▁float ▁[ ▁] ▁expand Width ▁, ▁expand Height ▁; ▁Value ▁pad Top ▁= ▁background Top ▁, ▁pad Left ▁= ▁background Left ▁, ▁pad Bottom ▁= ▁background Bottom ▁, ▁pad Right ▁= ▁background Right ▁; ▁int ▁align ▁= ▁Align ▁. ▁center ▁; ▁Debug ▁debug ▁= ▁Debug ▁. ▁none ▁; ▁Array ▁< ▁Debug Rect ▁> ▁debug Rect s ▁; ▁@ ▁Null ▁Drawable ▁background ▁; ▁private ▁boolean ▁clip ▁; ▁private ▁@ ▁Null ▁S kin ▁skin ▁; ▁boolean ▁round ▁= ▁true ▁; ▁public ▁Table ▁( ▁) ▁{ ▁this ▁( ▁null ▁) ▁; ▁} ▁public ▁Table ▁( ▁@ ▁Null ▁S kin ▁skin ▁) ▁{ ▁this ▁. ▁skin ▁= ▁skin ▁; ▁cell Defaults ▁= ▁obtain Cell ▁( ▁) ▁; ▁set Transform ▁( ▁false ▁) ▁; ▁set Touch able ▁( ▁T ouch able ▁. ▁children Only ▁) ▁; ▁} ▁private ▁Cell ▁obtain Cell ▁( ▁) ▁{ ▁Cell ▁cell ▁= ▁cell Pool ▁. ▁obtain ▁( ▁) ▁; ▁cell ▁. ▁setTable ▁( ▁this ▁) ▁; ▁return ▁cell ▁; ▁} ▁public ▁void ▁draw ▁( ▁Batch ▁batch ▁, ▁float ▁parent Alpha ▁) ▁{ ▁validate ▁( ▁) ▁; ▁if ▁( ▁is Transform ▁( ▁) ▁) ▁{ ▁apply Transform ▁( ▁batch ▁, ▁compute Transform ▁( ▁) ▁) ▁; ▁draw Background ▁( ▁batch ▁, ▁parent Alpha ▁, ▁0 ▁, ▁0 ▁) ▁; ▁if ▁( ▁clip ▁) ▁{ ▁batch ▁. ▁flush ▁( ▁) ▁; ▁float ▁pad Left ▁= ▁this ▁. ▁pad Left ▁. ▁get ▁( ▁this ▁) ▁, ▁pad Bottom ▁= ▁this ▁. ▁pad Bottom ▁. ▁get ▁( ▁this ▁) ▁;
▁catch ▁( ▁S ft p Exception ▁e ▁) ▁{ ▁if ▁( ▁false ▁== ▁StrUtil ▁. ▁startWith IgnoreCase ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁STR ▁) ▁) ▁{ ▁throw ▁new ▁J sch RuntimeException ▁( ▁e ▁) ▁; ▁} ▁} ▁return ▁entry List ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁mkdir ▁( ▁String ▁dir ▁) ▁{ ▁if ▁( ▁is Dir ▁( ▁dir ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁try ▁{ ▁this ▁. ▁channel ▁. ▁mkdir ▁( ▁dir ▁) ▁; ▁return ▁true ▁; ▁} ▁catch ▁( ▁S ft p Exception ▁e ▁) ▁{ ▁throw ▁new ▁J sch RuntimeException ▁( ▁e ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁boolean ▁is Dir ▁( ▁String ▁dir ▁) ▁{ ▁final ▁S ft p ATTR S ▁s ft p ATTR S ▁; ▁try ▁{ ▁s ft p ATTR S ▁= ▁this ▁. ▁channel ▁. ▁stat ▁( ▁dir ▁) ▁; ▁} ▁catch ▁( ▁S ft p Exception ▁e ▁) ▁{ ▁if ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁. ▁contains ▁( ▁STR ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁throw ▁new ▁F tp Exception ▁( ▁e ▁) ▁; ▁} ▁return ▁s ft p ATTR S ▁. ▁is Dir ▁( ▁) ▁; ▁} ▁@ ▁Override ▁synchronized ▁public ▁boolean ▁cd ▁( ▁String ▁directory ▁) ▁throws ▁F tp Exception ▁{ ▁if ▁( ▁StrUtil ▁. ▁isBlank ▁( ▁directory ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁try ▁{ ▁channel ▁. ▁cd ▁( ▁directory ▁. ▁replace ▁( ▁CHAR ▁, ▁CHAR ▁) ▁) ▁; ▁return ▁true ▁; ▁} ▁catch ▁( ▁S ft p Exception ▁e ▁) ▁{ ▁throw ▁new ▁F tp Exception ▁( ▁e ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁boolean ▁del File ▁( ▁String ▁filePath ▁) ▁{ ▁try ▁{ ▁channel ▁. ▁rm ▁( ▁filePath ▁) ▁; ▁} ▁catch ▁( ▁S ft p Exception ▁e ▁) ▁{ ▁throw ▁new ▁J sch RuntimeException ▁( ▁e ▁) ▁; ▁} ▁return ▁true ▁; ▁} ▁@ ▁Override ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁boolean ▁del Dir ▁( ▁String ▁dir Path ▁) ▁{ ▁if ▁( ▁false ▁== ▁cd ▁( ▁dir Path ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁Vector ▁< ▁L s Entry ▁> ▁list ▁; ▁try ▁{ ▁list ▁= ▁channel ▁. ▁ls ▁( ▁channel ▁. ▁pw d ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁S ft p Exception ▁e ▁) ▁{ ▁throw ▁new ▁J sch RuntimeException ▁( ▁e ▁) ▁; ▁} ▁String ▁fileName ▁; ▁for ▁( ▁L s Entry ▁entry ▁: ▁list ▁) ▁{ ▁fileName ▁= ▁entry ▁. ▁getFilename ▁( ▁) ▁; ▁if ▁( ▁false ▁== ▁STR ▁. ▁equals ▁( ▁fileName ▁) ▁&& ▁false ▁== ▁STR ▁. ▁equals ▁( ▁fileName ▁) ▁) ▁{ ▁if ▁( ▁entry ▁. ▁get Attrs ▁( ▁) ▁. ▁is Dir ▁( ▁) ▁) ▁{ ▁del Dir ▁( ▁fileName ▁) ▁; ▁} ▁else ▁{ ▁del File ▁( ▁fileName ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁false ▁== ▁cd ▁( ▁STR ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁try ▁{ ▁channel ▁. ▁r md ir ▁( ▁dir Path ▁) ▁; ▁return ▁true ▁; ▁} ▁catch ▁( ▁S ft p Exception ▁e ▁) ▁{ ▁throw ▁new ▁J sch RuntimeException ▁( ▁e ▁) ▁; ▁} ▁}
▁public ▁class ▁Blob Server SSL Test ▁extends ▁TestLogger ▁{ ▁@ ▁Test ▁public ▁void ▁test Failed To Init With Two Protocols Set ▁( ▁) ▁{ ▁final ▁Configuration ▁config ▁= ▁new ▁Configuration ▁( ▁) ▁; ▁config ▁. ▁setBoolean ▁( ▁Security Options ▁. ▁SSL _ INTERNAL _ ENABLED ▁, ▁true ▁) ▁; ▁config ▁. ▁setString ▁( ▁Security Options ▁. ▁SSL _ KEY STORE ▁, ▁getClass ▁( ▁) ▁. ▁getResource ▁( ▁STR ▁) ▁. ▁getPath ▁( ▁) ▁) ▁; ▁config ▁. ▁setString ▁( ▁Security Options ▁. ▁SSL _ KEY STORE _ PASSWORD ▁, ▁STR ▁) ▁; ▁config ▁. ▁setString ▁( ▁Security Options ▁. ▁SSL _ KEY _ PASSWORD ▁, ▁STR ▁) ▁; ▁config ▁. ▁setString ▁( ▁Security Options ▁. ▁SSL _ TR UST STORE ▁, ▁getClass ▁( ▁) ▁. ▁getResource ▁( ▁STR ▁) ▁. ▁getPath ▁( ▁) ▁) ▁; ▁config ▁. ▁setString ▁( ▁Security Options ▁. ▁SSL _ TR UST STORE _ PASSWORD ▁, ▁STR ▁) ▁; ▁config ▁. ▁setString ▁( ▁Security Options ▁. ▁SSL _ ALG ORITH MS ▁, ▁STR ▁) ▁; ▁try ▁( ▁final ▁Blob Server ▁ignored ▁= ▁new ▁Blob Server ▁( ▁config ▁, ▁new ▁Void BlobStore ▁( ▁) ▁) ▁) ▁{ ▁fail ▁( ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁find Throwable ▁( ▁e ▁, ▁IOException ▁. ▁class ▁) ▁; ▁find Throwable WithMessage ▁( ▁e ▁, ▁STR ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Failed To Init With Invalid Ssl Key store Configured ▁( ▁) ▁{ ▁final ▁Configuration ▁config ▁= ▁new ▁Configuration ▁( ▁) ▁; ▁config ▁. ▁setBoolean ▁( ▁Security Options ▁. ▁SSL _ INTERNAL _ ENABLED ▁, ▁true ▁) ▁; ▁config ▁. ▁setString ▁( ▁Security Options ▁. ▁SSL _ KEY STORE ▁, ▁STR ▁) ▁; ▁config ▁. ▁setString ▁( ▁Security Options ▁. ▁SSL _ KEY STORE _ PASSWORD ▁, ▁STR ▁) ▁; ▁config ▁. ▁setString ▁( ▁Security Options ▁. ▁SSL _ KEY _ PASSWORD ▁, ▁STR ▁) ▁; ▁config ▁. ▁setString ▁( ▁Security Options ▁. ▁SSL _ TR UST STORE ▁, ▁STR ▁) ▁; ▁config ▁. ▁setString ▁( ▁Security Options ▁. ▁SSL _ TR UST STORE _ PASSWORD ▁, ▁STR ▁) ▁; ▁try ▁( ▁final ▁Blob Server ▁ignored ▁= ▁new ▁Blob Server ▁( ▁config ▁, ▁new ▁Void BlobStore ▁( ▁) ▁) ▁) ▁{ ▁fail ▁( ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁find Throwable ▁( ▁e ▁, ▁IOException ▁. ▁class ▁) ▁; ▁find Throwable WithMessage ▁( ▁e ▁, ▁STR ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Failed To Init With Missing M andatory Ssl Configuration ▁( ▁) ▁{ ▁final ▁Configuration ▁config ▁= ▁new ▁Configuration ▁( ▁) ▁; ▁config ▁. ▁setBoolean ▁( ▁Security Options ▁. ▁SSL _ INTERNAL _ ENABLED ▁, ▁true ▁) ▁; ▁try ▁( ▁final ▁Blob Server ▁ignored ▁= ▁new ▁Blob Server ▁( ▁config ▁, ▁new ▁Void BlobStore ▁( ▁) ▁) ▁) ▁{ ▁fail ▁( ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁find Throwable ▁( ▁e ▁, ▁IOException ▁. ▁class ▁) ▁; ▁find Throwable WithMessage ▁( ▁e ▁, ▁STR ▁) ▁; ▁} ▁} ▁}
▁@ ▁Table ▁( ▁STR ▁) ▁public ▁class ▁Role ▁extends ▁Model ▁{ ▁public ▁Role ▁( ▁) ▁{ ▁} ▁public ▁Role ▁( ▁String ▁role ▁, ▁String ▁created By ▁) ▁{ ▁set ▁( ▁STR ▁, ▁role ▁) ▁; ▁set ▁( ▁STR ▁, ▁created By ▁) ▁; ▁} ▁public ▁String ▁getRole Name ▁( ▁) ▁{ ▁return ▁getString ▁( ▁STR ▁) ▁; ▁} ▁}
▁@ ▁Deprecated ▁public ▁MediaCodec Video Renderer ▁( ▁Context ▁context ▁, ▁MediaCodec Selector ▁media Codec Selector ▁, ▁long ▁allowed Join ing TimeMs ▁, ▁@ ▁Nullable ▁Drm SessionManager ▁< ▁Framework Media Crypto ▁> ▁d rm SessionManager ▁, ▁boolean ▁play Clear Sample sWith out Keys ▁, ▁boolean ▁enable Decoder Fallback ▁, ▁@ ▁Nullable ▁Handler ▁eventHandler ▁, ▁@ ▁Nullable ▁Video Renderer EventListener ▁eventListener ▁, ▁int ▁max Drop ped Frame sTo Notify ▁) ▁{ ▁super ▁( ▁C ▁. ▁TR ACK _ TYPE _ VID EO ▁, ▁media Codec Selector ▁, ▁d rm SessionManager ▁, ▁play Clear Sample sWith out Keys ▁, ▁enable Decoder Fallback ▁, ▁30 ▁) ▁; ▁this ▁. ▁allowed Join ing TimeMs ▁= ▁allowed Join ing TimeMs ▁; ▁this ▁. ▁max Drop ped Frame sTo Notify ▁= ▁max Drop ped Frame sTo Notify ▁; ▁this ▁. ▁context ▁= ▁context ▁. ▁getApplication Context ▁( ▁) ▁; ▁frame Release Time Helper ▁= ▁new ▁Video Frame Release Time Helper ▁( ▁this ▁. ▁context ▁) ▁; ▁event Dispatcher ▁= ▁new ▁Event Dispatcher ▁( ▁eventHandler ▁, ▁eventListener ▁) ▁; ▁device Need s No Post Process Work a round ▁= ▁device Need s No Post Process Work a round ▁( ▁) ▁; ▁pending OutputStream Offsets Us ▁= ▁new ▁long ▁[ ▁MAX _ PENDING _ OUTPUT _ STREAM _ OFFSET _ COUNT ▁] ▁; ▁pending OutputStream Switch Times Us ▁= ▁new ▁long ▁[ ▁MAX _ PENDING _ OUTPUT _ STREAM _ OFFSET _ COUNT ▁] ▁; ▁outputStream Offset Us ▁= ▁C ▁. ▁TIME _ UNSET ▁; ▁last Input TimeUs ▁= ▁C ▁. ▁TIME _ UNSET ▁; ▁joining De adline Ms ▁= ▁C ▁. ▁TIME _ UNSET ▁; ▁current Width ▁= ▁Format ▁. ▁NO _ VALUE ▁; ▁current Height ▁= ▁Format ▁. ▁NO _ VALUE ▁; ▁current Pixel Width Height Ratio ▁= ▁Format ▁. ▁NO _ VALUE ▁; ▁pending Pixel Width Height Ratio ▁= ▁Format ▁. ▁NO _ VALUE ▁; ▁scaling Mode ▁= ▁C ▁. ▁V IDE O _ SC AL ING _ MODE _ DEFAULT ▁; ▁clear Re ported Video Size ▁( ▁) ▁; ▁} ▁@ ▁Override ▁@ ▁Capabilities ▁protected ▁int ▁supports Format ▁( ▁MediaCodec Selector ▁media Codec Selector ▁, ▁@ ▁Nullable ▁Drm SessionManager ▁< ▁Framework Media Crypto ▁> ▁d rm SessionManager ▁, ▁Format ▁format ▁) ▁throws ▁Decoder Query Exception ▁{ ▁String ▁mimeType ▁= ▁format ▁. ▁sample MimeType ▁; ▁if ▁( ▁! ▁MimeTypes ▁. ▁is Video ▁( ▁mimeType ▁) ▁) ▁{ ▁return ▁Renderer Capabilities ▁. ▁create ▁( ▁FORMAT _ UNSUPPORTED _ TYPE ▁) ▁; ▁} ▁@ ▁Nullable ▁Drm Init Data ▁d rm Init Data ▁= ▁format ▁. ▁d rm Init Data ▁; ▁boolean ▁requires Secure Dec ry ption ▁= ▁d rm Init Data ▁!= ▁null ▁; ▁List ▁< ▁MediaCodec Info ▁> ▁decoder Infos ▁= ▁getDecoder Infos ▁( ▁media Codec Selector ▁, ▁format ▁, ▁requires Secure Dec ry ption ▁, ▁false ▁) ▁; ▁if ▁( ▁requires Secure Dec ry ption ▁&& ▁decoder Infos ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁decoder Infos ▁= ▁getDecoder Infos ▁( ▁media Codec Selector ▁, ▁format ▁, ▁false ▁, ▁false ▁) ▁; ▁}
▁public ▁class ▁Analyze RequestBuilder ▁extends ▁Single Shard Operation RequestBuilder ▁< ▁Analyze Action ▁. ▁Request ▁, ▁Analyze Action ▁. ▁Response ▁, ▁Analyze RequestBuilder ▁> ▁{ ▁public ▁Analyze RequestBuilder ▁( ▁Elasticsearch Client ▁client ▁, ▁Analyze Action ▁action ▁) ▁{ ▁super ▁( ▁client ▁, ▁action ▁, ▁new ▁Analyze Action ▁. ▁Request ▁( ▁) ▁) ▁; ▁} ▁public ▁Analyze RequestBuilder ▁( ▁Elasticsearch Client ▁client ▁, ▁Analyze Action ▁action ▁, ▁String ▁index ▁, ▁String ▁... ▁text ▁) ▁{ ▁super ▁( ▁client ▁, ▁action ▁, ▁new ▁Analyze Action ▁. ▁Request ▁( ▁index ▁) ▁. ▁text ▁( ▁text ▁) ▁) ▁; ▁} ▁public ▁Analyze RequestBuilder ▁set Analyzer ▁( ▁String ▁analyzer ▁) ▁{ ▁request ▁. ▁analyzer ▁( ▁analyzer ▁) ▁; ▁return ▁this ▁; ▁} ▁public ▁Analyze RequestBuilder ▁setField ▁( ▁String ▁field ▁) ▁{ ▁request ▁. ▁field ▁( ▁field ▁) ▁; ▁return ▁this ▁; ▁} ▁public ▁Analyze RequestBuilder ▁set Tokenizer ▁( ▁String ▁tokenizer ▁) ▁{ ▁request ▁. ▁tokenizer ▁( ▁tokenizer ▁) ▁; ▁return ▁this ▁; ▁} ▁public ▁Analyze RequestBuilder ▁set Tokenizer ▁( ▁Map ▁< ▁String ▁, ▁? ▁> ▁tokenizer ▁) ▁{ ▁request ▁. ▁tokenizer ▁( ▁tokenizer ▁) ▁; ▁return ▁this ▁; ▁} ▁public ▁Analyze RequestBuilder ▁add Token Filter ▁( ▁Map ▁< ▁String ▁, ▁? ▁> ▁token Filter ▁) ▁{ ▁request ▁. ▁add Token Filter ▁( ▁token Filter ▁) ▁; ▁return ▁this ▁; ▁} ▁public ▁Analyze RequestBuilder ▁add Token Filter ▁( ▁String ▁token Filter ▁) ▁{ ▁request ▁. ▁add Token Filter ▁( ▁token Filter ▁) ▁; ▁return ▁this ▁; ▁} ▁public ▁Analyze RequestBuilder ▁add Char Filter ▁( ▁Map ▁< ▁String ▁, ▁? ▁> ▁char Filter ▁) ▁{ ▁request ▁. ▁add Char Filter ▁( ▁char Filter ▁) ▁; ▁return ▁this ▁; ▁} ▁public ▁Analyze RequestBuilder ▁add Char Filter ▁( ▁String ▁token Filter ▁) ▁{ ▁request ▁. ▁add Char Filter ▁( ▁token Filter ▁) ▁; ▁return ▁this ▁; ▁} ▁public ▁Analyze RequestBuilder ▁set Explain ▁( ▁boolean ▁explain ▁) ▁{ ▁request ▁. ▁explain ▁( ▁explain ▁) ▁; ▁return ▁this ▁; ▁} ▁public ▁Analyze RequestBuilder ▁set Attributes ▁( ▁String ▁... ▁attributes ▁) ▁{ ▁request ▁. ▁attributes ▁( ▁attributes ▁) ▁; ▁return ▁this ▁; ▁} ▁public ▁Analyze RequestBuilder ▁setText ▁( ▁String ▁... ▁text s ▁) ▁{ ▁request ▁. ▁text ▁( ▁text s ▁) ▁; ▁return ▁this ▁; ▁} ▁public ▁Analyze RequestBuilder ▁set Normalizer ▁( ▁String ▁normal izer ▁) ▁{ ▁request ▁. ▁normal izer ▁( ▁normal izer ▁) ▁; ▁return ▁this ▁; ▁} ▁}
▁public ▁class ▁Test Storage Policy Permission Settings ▁{ ▁private ▁static ▁final ▁short ▁REP L ▁= ▁1 ▁; ▁private ▁static ▁final ▁int ▁SI Z E ▁= ▁128 ▁; ▁private ▁static ▁Configuration ▁conf ▁; ▁private ▁static ▁MiniDFSCluster ▁cluster ▁; ▁private ▁static ▁Distributed FileSystem ▁fs ▁; ▁private ▁static ▁Block Storage Policy Suite ▁suite ▁; ▁private ▁static ▁Block Storage Policy ▁col d ▁; ▁private ▁static ▁UserGroup Information ▁non Admin ▁; ▁private ▁static ▁UserGroup Information ▁admin ▁; ▁@ ▁BeforeClass ▁public ▁static ▁void ▁cluster Set Up ▁( ▁) ▁throws ▁IOException ▁{ ▁conf ▁= ▁new ▁Hdfs Configuration ▁( ▁) ▁; ▁cluster ▁= ▁new ▁MiniDFSCluster ▁. ▁Builder ▁( ▁conf ▁) ▁. ▁numDataNodes ▁( ▁REP L ▁) ▁. ▁build ▁( ▁) ▁; ▁cluster ▁. ▁waitActive ▁( ▁) ▁; ▁fs ▁= ▁cluster ▁. ▁getFileSystem ▁( ▁) ▁; ▁suite ▁= ▁Block Storage Policy Suite ▁. ▁createDefault Suite ▁( ▁) ▁; ▁col d ▁= ▁suite ▁. ▁getPolicy ▁( ▁STR ▁) ▁; ▁non Admin ▁= ▁UserGroup Information ▁. ▁createUser ForTesting ▁( ▁STR ▁, ▁new ▁String ▁[ ▁] ▁{ ▁STR ▁} ▁) ▁; ▁admin ▁= ▁UserGroup Information ▁. ▁createUser ForTesting ▁( ▁STR ▁, ▁new ▁String ▁[ ▁] ▁{ ▁STR ▁} ▁) ▁; ▁} ▁@ ▁AfterClass ▁public ▁static ▁void ▁cluster Shutdown ▁( ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁fs ▁!= ▁null ▁) ▁{ ▁fs ▁. ▁close ▁( ▁) ▁; ▁fs ▁= ▁null ▁; ▁} ▁if ▁( ▁cluster ▁!= ▁null ▁) ▁{ ▁cluster ▁. ▁shutdown ▁( ▁) ▁; ▁cluster ▁= ▁null ▁; ▁} ▁} ▁private ▁void ▁set FS Name System Final Field ▁( ▁String ▁field ▁, ▁boolean ▁value ▁) ▁throws ▁NoSuch FieldException ▁, ▁Illegal AccessException ▁{ ▁Field ▁f ▁= ▁FS Names ystem ▁. ▁class ▁. ▁getDeclared Field ▁( ▁field ▁) ▁; ▁f ▁. ▁setAccessible ▁( ▁true ▁) ▁; ▁Field ▁modifiers Field ▁= ▁Field ▁. ▁class ▁. ▁getDeclared Field ▁( ▁STR ▁) ▁; ▁modifiers Field ▁. ▁setAccessible ▁( ▁true ▁) ▁; ▁modifiers Field ▁. ▁setInt ▁( ▁f ▁, ▁f ▁. ▁getModifiers ▁( ▁) ▁& ▁ ~ ▁Modifier ▁. ▁FIN AL ▁) ▁; ▁f ▁. ▁set ▁( ▁cluster ▁. ▁getName system ▁( ▁) ▁, ▁value ▁) ▁; ▁} ▁private ▁void ▁set Storage Policy Permissions ▁( ▁boolean ▁is Storage Policy Enabled ▁, ▁boolean ▁is Storage Policy Super user Only ▁) ▁throws ▁NoSuch FieldException ▁, ▁Illegal AccessException ▁{ ▁set FS Name System Final Field ▁( ▁STR ▁, ▁is Storage Policy Enabled ▁) ▁; ▁set FS Name System Final Field ▁( ▁STR ▁, ▁is Storage Policy Super user Only ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Storage Policy Permission Default ▁( ▁) ▁throws ▁Exception ▁{ ▁Path ▁foo ▁= ▁new ▁Path ▁( ▁STR ▁) ▁; ▁DFSTestUtil ▁. ▁createFile ▁( ▁fs ▁, ▁foo ▁, ▁SI Z E ▁, ▁REP L ▁, ▁0 ▁) ▁; ▁set Storage Policy Permissions ▁( ▁true ▁, ▁false ▁) ▁; ▁final ▁FileSystem ▁fileSystem Non Admin ▁= ▁DFSTestUtil ▁. ▁getFileSystem As ▁( ▁non Admin ▁, ▁conf ▁) ▁; ▁Lambda TestUtils ▁. ▁intercept ▁( ▁AccessControl Exception ▁. ▁class ▁, ▁STR ▁, ▁STR ▁, ▁( ▁) ▁-> ▁fileSystem Non Admin ▁. ▁set Storage Policy ▁( ▁foo ▁, ▁col d ▁. ▁getName ▁( ▁) ▁) ▁) ▁;
▁public ▁class ▁Shell Command F encer ▁extends ▁Configured ▁implements ▁F ence Method ▁{ ▁private ▁static ▁final ▁int ▁AB B RE V _ LENGTH ▁= ▁20 ▁; ▁private ▁static ▁final ▁String ▁TARGET _ PREFIX ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁SOURCE _ PREFIX ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁ARG _ DELIMITER ▁= ▁STR ▁; ▁@ ▁Visible ForTesting ▁static ▁Logger ▁LOG ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Shell Command F encer ▁. ▁class ▁) ▁; ▁@ ▁Override ▁public ▁void ▁check Args ▁( ▁String ▁args ▁) ▁throws ▁Bad F encing Configuration Exception ▁{ ▁if ▁( ▁args ▁== ▁null ▁|| ▁args ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁throw ▁new ▁Bad F encing Configuration Exception ▁( ▁STR ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁boolean ▁try Fence ▁( ▁HA Service Target ▁target ▁, ▁String ▁args ▁) ▁{ ▁ProcessBuilder ▁builder ▁; ▁String ▁cmd ▁= ▁parse Args ▁( ▁target ▁. ▁get Transition Target HA Status ▁( ▁) ▁, ▁args ▁) ▁; ▁if ▁( ▁! ▁Shell ▁. ▁WINDOWS ▁) ▁{ ▁builder ▁= ▁new ▁ProcessBuilder ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁cmd ▁) ▁; ▁} ▁else ▁{ ▁builder ▁= ▁new ▁ProcessBuilder ▁( ▁STR ▁, ▁STR ▁, ▁cmd ▁) ▁; ▁} ▁setConf As Env Vars ▁( ▁builder ▁. ▁environment ▁( ▁) ▁) ▁; ▁add Target Info As Env Vars ▁( ▁target ▁, ▁builder ▁. ▁environment ▁( ▁) ▁) ▁; ▁Process ▁p ▁; ▁try ▁{ ▁p ▁= ▁builder ▁. ▁start ▁( ▁) ▁; ▁p ▁. ▁getOutputStream ▁( ▁) ▁. ▁close ▁( ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁LOG ▁. ▁warn ▁( ▁STR ▁+ ▁cmd ▁, ▁e ▁) ▁; ▁return ▁false ▁; ▁} ▁String ▁pid ▁= ▁try Get Pid ▁( ▁p ▁) ▁; ▁LOG ▁. ▁info ▁( ▁STR ▁+ ▁cmd ▁+ ▁STR ▁+ ▁( ▁( ▁pid ▁!= ▁null ▁) ▁? ▁( ▁STR ▁+ ▁pid ▁) ▁: ▁STR ▁) ▁) ▁; ▁String ▁log Prefix ▁= ▁ab brev iate ▁( ▁cmd ▁, ▁AB B RE V _ LENGTH ▁) ▁; ▁if ▁( ▁pid ▁!= ▁null ▁) ▁{ ▁log Prefix ▁= ▁STR ▁+ ▁pid ▁+ ▁STR ▁+ ▁log Prefix ▁; ▁} ▁Stream P ump er ▁err P ump er ▁= ▁new ▁Stream P ump er ▁( ▁LOG ▁, ▁log Prefix ▁, ▁p ▁. ▁getError Stream ▁( ▁) ▁, ▁Stream P ump er ▁. ▁Stream Type ▁. ▁ST D ERR ▁) ▁; ▁err P ump er ▁. ▁start ▁( ▁) ▁; ▁Stream P ump er ▁out P ump er ▁= ▁new ▁Stream P ump er ▁( ▁LOG ▁, ▁log Prefix ▁, ▁p ▁. ▁getInputStream ▁( ▁) ▁, ▁Stream P ump er ▁. ▁Stream Type ▁. ▁ST D OUT ▁) ▁; ▁out P ump er ▁. ▁start ▁( ▁) ▁; ▁int ▁rc ▁; ▁try ▁{ ▁rc ▁= ▁p ▁. ▁waitFor ▁( ▁) ▁; ▁err P ump er ▁. ▁join ▁( ▁) ▁; ▁out P ump er ▁. ▁join ▁( ▁) ▁; ▁} ▁catch ▁( ▁Interrupted Exception ▁ie ▁) ▁{ ▁LOG ▁. ▁warn ▁( ▁STR ▁+ ▁cmd ▁) ▁; ▁return ▁false ▁; ▁} ▁return ▁rc ▁== ▁0 ▁; ▁}
▁public ▁class ▁Default Login Authentication Filter ▁implements ▁Login Authentication Filter ▁{ ▁private ▁static ▁final ▁Ant Path Matcher ▁PATH _ MATCH ER ▁= ▁new ▁Ant Path Matcher ▁( ▁) ▁; ▁private ▁static ▁final ▁String ▁URL _ SUFFIX _ D OT ▁= ▁STR ▁; ▁@ ▁Value ▁( ▁STR ▁) ▁private ▁List ▁< ▁String ▁> ▁auth Filter Exclude Urls ▁; ▁@ ▁Value ▁( ▁STR ▁) ▁private ▁List ▁< ▁String ▁> ▁auth Filter Exclude Url Suffix es ▁; ▁private ▁final ▁Auth Service ▁< ▁HttpServlet Request ▁> ▁auth Service ▁; ▁public ▁Default Login Authentication Filter ▁( ▁Auth Service ▁< ▁HttpServlet Request ▁> ▁auth Service ▁) ▁{ ▁this ▁. ▁auth Service ▁= ▁auth Service ▁; ▁} ▁@ ▁Override ▁public ▁void ▁init ▁( ▁Filter Config ▁filterConfig ▁) ▁throws ▁Servlet Exception ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁doFilter ▁( ▁ServletRequest ▁request ▁, ▁ServletResponse ▁response ▁, ▁FilterChain ▁chain ▁) ▁throws ▁IOException ▁, ▁Servlet Exception ▁{ ▁HttpServlet Request ▁httpRequest ▁= ▁( ▁HttpServlet Request ▁) ▁request ▁; ▁String ▁servlet Path ▁= ▁httpRequest ▁. ▁getServlet Path ▁( ▁) ▁; ▁boolean ▁auth Filter Exclude Match ▁= ▁auth Filter Exclude Urls ▁. ▁stream ▁( ▁) ▁. ▁anyMatch ▁( ▁auth Filter Exclude Url ▁-> ▁PATH _ MATCH ER ▁. ▁match ▁( ▁auth Filter Exclude Url ▁, ▁servlet Path ▁) ▁) ▁; ▁if ▁( ▁auth Filter Exclude Match ▁) ▁{ ▁chain ▁. ▁doFilter ▁( ▁request ▁, ▁response ▁) ▁; ▁return ▁; ▁} ▁for ▁( ▁String ▁auth Filter Exclude Url Suffix ▁: ▁auth Filter Exclude Url Suffix es ▁) ▁{ ▁if ▁( ▁StringUtils ▁. ▁isBlank ▁( ▁auth Filter Exclude Url Suffix ▁) ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁! ▁auth Filter Exclude Url Suffix ▁. ▁startsWith ▁( ▁URL _ SUFFIX _ D OT ▁) ▁) ▁{ ▁auth Filter Exclude Url Suffix ▁= ▁URL _ SUFFIX _ D OT ▁+ ▁auth Filter Exclude Url Suffix ▁; ▁} ▁if ▁( ▁servlet Path ▁. ▁endsWith ▁( ▁auth Filter Exclude Url Suffix ▁) ▁) ▁{ ▁chain ▁. ▁doFilter ▁( ▁request ▁, ▁response ▁) ▁; ▁return ▁; ▁} ▁} ▁Auth Service ▁. ▁AuthUser ▁auth User ▁= ▁auth Service ▁. ▁getAuth User ▁( ▁httpRequest ▁) ▁; ▁HttpServlet Response ▁httpResponse ▁= ▁( ▁HttpServlet Response ▁) ▁response ▁; ▁if ▁( ▁auth User ▁== ▁null ▁) ▁{ ▁httpResponse ▁. ▁setStatus ▁( ▁HttpStatus ▁. ▁UN AUTHORI Z ED ▁. ▁value ▁( ▁) ▁) ▁; ▁} ▁else ▁{ ▁chain ▁. ▁doFilter ▁( ▁request ▁, ▁response ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁destroy ▁( ▁) ▁{ ▁} ▁}
▁public ▁class ▁Sh e ets Service Util ▁{ ▁private ▁static ▁final ▁String ▁APPLICATION _ NAME ▁= ▁STR ▁; ▁public ▁static ▁Sh e ets ▁getSh e ets Service ▁( ▁) ▁throws ▁IOException ▁, ▁GeneralSecurity Exception ▁{ ▁Credential ▁credential ▁= ▁Google Auth orize Util ▁. ▁authorize ▁( ▁) ▁; ▁return ▁new ▁Sh e ets ▁. ▁Builder ▁( ▁Google Net Http Transport ▁. ▁new Trusted Transport ▁( ▁) ▁, ▁Jackson Factory ▁. ▁getDefault Instance ▁( ▁) ▁, ▁credential ▁) ▁. ▁setApplication Name ▁( ▁APPLICATION _ NAME ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁Mock Pre paredStatement ▁extends ▁Pre paredStatement Base ▁implements ▁Mock Statement Base ▁, ▁Pre paredStatement ▁{ ▁private ▁final ▁String ▁sql ▁; ▁public ▁Mock Pre paredStatement ▁( ▁MockConnection ▁conn ▁, ▁String ▁sql ▁) ▁{ ▁super ▁( ▁conn ▁) ▁; ▁this ▁. ▁sql ▁= ▁sql ▁; ▁} ▁public ▁String ▁getSql ▁( ▁) ▁{ ▁return ▁sql ▁; ▁} ▁public ▁MockConnection ▁getConnection ▁( ▁) ▁throws ▁SQLException ▁{ ▁return ▁( ▁MockConnection ▁) ▁super ▁. ▁getConnection ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁ResultSet ▁executeQuery ▁( ▁) ▁throws ▁SQLException ▁{ ▁check Open ▁( ▁) ▁; ▁MockConnection ▁conn ▁= ▁getConnection ▁( ▁) ▁; ▁if ▁( ▁conn ▁!= ▁null ▁&& ▁conn ▁. ▁getDriver ▁( ▁) ▁!= ▁null ▁) ▁{ ▁return ▁conn ▁. ▁getDriver ▁( ▁) ▁. ▁executeQuery ▁( ▁this ▁, ▁sql ▁) ▁; ▁} ▁if ▁( ▁conn ▁!= ▁null ▁) ▁{ ▁conn ▁. ▁handle Sleep ▁( ▁) ▁; ▁return ▁conn ▁. ▁getDriver ▁( ▁) ▁. ▁createMock ResultSet ▁( ▁this ▁) ▁; ▁} ▁return ▁new ▁Mock ResultSet ▁( ▁this ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁executeUpdate ▁( ▁) ▁throws ▁SQLException ▁{ ▁check Open ▁( ▁) ▁; ▁if ▁( ▁getConnection ▁( ▁) ▁!= ▁null ▁) ▁{ ▁getConnection ▁( ▁) ▁. ▁handle Sleep ▁( ▁) ▁; ▁} ▁return ▁0 ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁execute ▁( ▁) ▁throws ▁SQLException ▁{ ▁check Open ▁( ▁) ▁; ▁if ▁( ▁getConnection ▁( ▁) ▁!= ▁null ▁) ▁{ ▁getConnection ▁( ▁) ▁. ▁handle Sleep ▁( ▁) ▁; ▁} ▁return ▁false ▁; ▁} ▁@ ▁Override ▁public ▁ResultSet ▁getResult Set ▁( ▁) ▁throws ▁SQLException ▁{ ▁check Open ▁( ▁) ▁; ▁if ▁( ▁resultSet ▁== ▁null ▁) ▁{ ▁resultSet ▁= ▁this ▁. ▁getConnection ▁( ▁) ▁. ▁getDriver ▁( ▁) ▁. ▁create ResultSet ▁( ▁this ▁) ▁; ▁} ▁return ▁resultSet ▁; ▁} ▁}
▁public ▁class ▁DBTrace AddressSnapRange PropertyMap O c clusion Into P ast Iterable Test ▁extends ▁AbstractG hidra Head less IntegrationTest ▁{ ▁protected ▁static ▁class ▁My Object ▁extends ▁DBC ached Domain Object Adapter ▁{ ▁protected ▁My Object ▁( ▁Object ▁consumer ▁) ▁throws ▁IOException ▁{ ▁super ▁( ▁new ▁DBHandle ▁( ▁) ▁, ▁DB Open Mode ▁. ▁CREATE ▁, ▁new ▁Console Task Monitor ▁( ▁) ▁, ▁STR ▁, ▁500 ▁, ▁1000 ▁, ▁consumer ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is Change able ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getDescription ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁} ▁@ ▁DB Annotated Object Info ▁( ▁version ▁= ▁0 ▁) ▁protected ▁static ▁class ▁My Entry ▁extends ▁Abstract DBTrace AddressSnapRange PropertyMap Data ▁< ▁String ▁> ▁{ ▁public ▁static ▁final ▁String ▁VALUE _ COLUMN _ NAME ▁= ▁STR ▁; ▁@ ▁DB Annotated Column ▁( ▁VALUE _ COLUMN _ NAME ▁) ▁static ▁DB Object Column ▁VALUE _ COLUMN ▁; ▁@ ▁DB Annotated Field ▁( ▁column ▁= ▁VALUE _ COLUMN _ NAME ▁) ▁String ▁value ▁; ▁public ▁My Entry ▁( ▁DBTrace AddressSnapRange PropertyMap Tree ▁< ▁String ▁, ▁? ▁> ▁tree ▁, ▁DBC ached Object Store ▁< ▁? ▁> ▁store ▁, ▁DBRecord ▁record ▁) ▁{ ▁super ▁( ▁tree ▁, ▁store ▁, ▁record ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁set Record Value ▁( ▁String ▁value ▁) ▁{ ▁this ▁. ▁value ▁= ▁value ▁; ▁update ▁( ▁VALUE _ COLUMN ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁String ▁getRecord Value ▁( ▁) ▁{ ▁return ▁value ▁; ▁} ▁} ▁protected ▁My Object ▁obj ▁; ▁protected ▁DBC ached Object Store Factory ▁factory ▁; ▁protected ▁Language ▁to y ▁; ▁protected ▁DBTrace AddressSnapRange PropertyMap Space ▁< ▁String ▁, ▁My Entry ▁> ▁space ▁; ▁protected ▁Address ▁addr ▁( ▁long ▁offset ▁) ▁{ ▁return ▁to y ▁. ▁getDefault Space ▁( ▁) ▁. ▁getAddress ▁( ▁offset ▁) ▁; ▁} ▁protected ▁AddressRange ▁rng ▁( ▁long ▁min ▁, ▁long ▁max ▁) ▁{ ▁return ▁new ▁AddressRange Impl ▁( ▁addr ▁( ▁min ▁) ▁, ▁addr ▁( ▁max ▁) ▁) ▁; ▁} ▁protected ▁AddressSetView ▁set ▁( ▁AddressRange ▁... ▁ranges ▁) ▁{ ▁AddressSet ▁result ▁= ▁new ▁AddressSet ▁( ▁) ▁; ▁for ▁( ▁AddressRange ▁r ▁: ▁ranges ▁) ▁{ ▁result ▁. ▁add ▁( ▁r ▁) ▁; ▁} ▁return ▁result ▁; ▁} ▁protected ▁Trace AddressSnapRange ▁t as r ▁( ▁long ▁min Off ▁, ▁long ▁max Off ▁, ▁long ▁min Snap ▁, ▁long ▁max Snap ▁) ▁{ ▁return ▁new ▁Immutable Trace AddressSnapRange ▁( ▁addr ▁( ▁min Off ▁) ▁, ▁addr ▁( ▁max Off ▁) ▁, ▁min Snap ▁, ▁max Snap ▁) ▁; ▁} ▁protected ▁< ▁T ▁> ▁Entry ▁< ▁Trace AddressSnapRange ▁, ▁T ▁> ▁ent ▁( ▁long ▁min Off ▁, ▁long ▁max Off ▁, ▁long ▁min Snap ▁, ▁long ▁max Snap ▁, ▁T ▁value ▁) ▁{ ▁return ▁new ▁Immutable Pair ▁< ▁> ▁( ▁t as r ▁( ▁min Off ▁, ▁max Off ▁, ▁min Snap ▁, ▁max Snap ▁) ▁, ▁value ▁) ▁; ▁} ▁protected ▁< ▁T ▁> ▁List ▁< ▁T ▁> ▁list ▁( ▁Iterator ▁< ▁T ▁> ▁it ▁) ▁{ ▁List ▁< ▁T ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁;
▁public ▁class ▁Program Symbol ActionContext ▁extends ▁Program ActionContext ▁{ ▁private ▁List ▁< ▁Symbol ▁> ▁symbols ▁= ▁new ▁ArrayList ▁< ▁Symbol ▁> ▁( ▁) ▁; ▁public ▁Program Symbol ActionContext ▁( ▁Component Provider ▁provider ▁, ▁Program ▁program ▁, ▁List ▁< ▁Symbol ▁> ▁symbols ▁, ▁Component ▁source Component ▁) ▁{ ▁super ▁( ▁provider ▁, ▁program ▁, ▁source Component ▁) ▁; ▁this ▁. ▁symbols ▁= ▁symbols ▁== ▁null ▁? ▁Collections ▁. ▁emptyList ▁( ▁) ▁: ▁symbols ▁; ▁} ▁public ▁int ▁getSymbol Count ▁( ▁) ▁{ ▁return ▁symbols ▁. ▁size ▁( ▁) ▁; ▁} ▁public ▁Symbol ▁getFirst Symbol ▁( ▁) ▁{ ▁if ▁( ▁symbols ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁return ▁symbols ▁. ▁get ▁( ▁0 ▁) ▁; ▁} ▁public ▁Iterable ▁< ▁Symbol ▁> ▁getSymbol s ▁( ▁) ▁{ ▁return ▁symbols ▁; ▁} ▁}
▁@ ▁Override ▁protected ▁boolean ▁isEnabledFor Context ▁( ▁Navigatable ActionContext ▁context ▁) ▁{ ▁return ▁context ▁. ▁has Selection ▁( ▁) ▁; ▁} ▁} ▁; ▁set Search M nemonic Ops No Const Action ▁. ▁setMenu BarData ▁( ▁new ▁MenuData ▁( ▁new ▁String ▁[ ▁] ▁{ ▁STR ▁, ▁MENU _ P ULL RIGHT ▁, ▁STR ▁} ▁, ▁null ▁, ▁group ▁, ▁MenuData ▁. ▁NO _ M NE MON IC ▁, ▁STR ▁) ▁) ▁; ▁set Search M nemonic Ops No Const Action ▁. ▁setHelpLocation ▁( ▁help Location ▁) ▁; ▁set Search M nemonic Ops No Const Action ▁. ▁addTo Window When ▁( ▁Navigatable ActionContext ▁. ▁class ▁) ▁; ▁set Search M nemonic Ops Const Action ▁= ▁new ▁Navigatable Context Action ▁( ▁STR ▁, ▁getName ▁( ▁) ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁actionPerformed ▁( ▁Navigatable ActionContext ▁context ▁) ▁{ ▁process Action ▁( ▁context ▁, ▁true ▁, ▁true ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁boolean ▁isEnabledFor Context ▁( ▁Navigatable ActionContext ▁context ▁) ▁{ ▁return ▁context ▁. ▁has Selection ▁( ▁) ▁; ▁} ▁} ▁; ▁set Search M nemonic Ops Const Action ▁. ▁setMenu BarData ▁( ▁new ▁MenuData ▁( ▁new ▁String ▁[ ▁] ▁{ ▁STR ▁, ▁MENU _ P ULL RIGHT ▁, ▁STR ▁} ▁, ▁null ▁, ▁group ▁, ▁MenuData ▁. ▁NO _ M NE MON IC ▁, ▁STR ▁) ▁) ▁; ▁set Search M nemonic Ops Const Action ▁. ▁setHelpLocation ▁( ▁help Location ▁) ▁; ▁set Search M nemonic Ops Const Action ▁. ▁addTo Window When ▁( ▁Navigatable ActionContext ▁. ▁class ▁) ▁; ▁set Search M nemonic No Ops No Const Action ▁= ▁new ▁Navigatable Context Action ▁( ▁STR ▁, ▁getName ▁( ▁) ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁actionPerformed ▁( ▁Navigatable ActionContext ▁context ▁) ▁{ ▁process Action ▁( ▁context ▁, ▁false ▁, ▁false ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁boolean ▁isEnabledFor Context ▁( ▁Navigatable ActionContext ▁context ▁) ▁{ ▁return ▁context ▁. ▁has Selection ▁( ▁) ▁; ▁} ▁} ▁; ▁set Search M nemonic No Ops No Const Action ▁. ▁setMenu BarData ▁( ▁new ▁MenuData ▁( ▁new ▁String ▁[ ▁] ▁{ ▁STR ▁, ▁MENU _ P ULL RIGHT ▁, ▁STR ▁} ▁, ▁null ▁, ▁group ▁, ▁MenuData ▁. ▁NO _ M NE MON IC ▁, ▁STR ▁) ▁) ▁; ▁set Search M nemonic No Ops No Const Action ▁. ▁setHelpLocation ▁( ▁help Location ▁) ▁; ▁set Search M nemonic No Ops No Const Action ▁. ▁addTo Window When ▁( ▁Navigatable ActionContext ▁. ▁class ▁) ▁; ▁tool ▁. ▁addAction ▁( ▁set Search M nemonic Ops No Const Action ▁) ▁; ▁tool ▁. ▁addAction ▁( ▁set Search M nemonic Ops Const Action ▁) ▁; ▁tool ▁. ▁addAction ▁( ▁set Search M nemonic No Ops No Const Action ▁) ▁; ▁tool ▁. ▁setMenu Group ▁( ▁new ▁String ▁[ ▁] ▁{ ▁MENU _ P ULL RIGHT ▁} ▁, ▁P OP UP _ MEN U _ GROUP ▁) ▁; ▁} ▁private ▁String ▁create Mask ed Bit String ▁( ▁byte ▁values ▁[ ▁] ▁, ▁byte ▁mask s ▁[ ▁] ▁) ▁{ ▁String ▁bit String ▁= ▁new ▁String ▁( ▁) ▁;
▁public ▁class ▁Object Codecs ▁{ ▁private ▁final ▁Object Codec Registry ▁codec Registry ▁; ▁private ▁final ▁Serialization Context ▁serialization Context ▁; ▁private ▁final ▁Deserialization Context ▁deser ialization Context ▁; ▁public ▁Object Codecs ▁( ▁Object Codec Registry ▁codec Registry ▁, ▁Immutable Class To Instance Map ▁< ▁Object ▁> ▁dependencies ▁) ▁{ ▁this ▁. ▁codec Registry ▁= ▁codec Registry ▁; ▁serialization Context ▁= ▁new ▁Serialization Context ▁( ▁codec Registry ▁, ▁dependencies ▁) ▁; ▁deser ialization Context ▁= ▁new ▁Deserialization Context ▁( ▁codec Registry ▁, ▁dependencies ▁) ▁; ▁} ▁public ▁Object Codecs ▁( ▁Object Codec Registry ▁codec Registry ▁) ▁{ ▁this ▁( ▁codec Registry ▁, ▁Immutable Class To Instance Map ▁. ▁of ▁( ▁) ▁) ▁; ▁} ▁@ ▁Visible ForTesting ▁public ▁Serialization Context ▁get Serialization Context ▁( ▁) ▁{ ▁return ▁serialization Context ▁; ▁} ▁@ ▁Visible ForTesting ▁public ▁Deserialization Context ▁get Deserialization Context ▁( ▁) ▁{ ▁return ▁deser ialization Context ▁; ▁} ▁public ▁ByteString ▁serialize ▁( ▁Object ▁subject ▁) ▁throws ▁Serialization Exception ▁{ ▁return ▁serialize To Byte String ▁( ▁subject ▁, ▁this ▁:: ▁serialize ▁) ▁; ▁} ▁public ▁void ▁serialize ▁( ▁Object ▁subject ▁, ▁Coded OutputStream ▁coded Out ▁) ▁throws ▁Serialization Exception ▁{ ▁serialize Impl ▁( ▁subject ▁, ▁coded Out ▁, ▁serialization Context ▁) ▁; ▁} ▁public ▁ByteString ▁serialize Mem o ized ▁( ▁Object ▁subject ▁) ▁throws ▁Serialization Exception ▁{ ▁return ▁serialize To Byte String ▁( ▁subject ▁, ▁this ▁:: ▁serialize Mem o ized ▁) ▁; ▁} ▁public ▁void ▁serialize Mem o ized ▁( ▁Object ▁subject ▁, ▁Coded OutputStream ▁coded Out ▁) ▁throws ▁Serialization Exception ▁{ ▁serialize Impl ▁( ▁subject ▁, ▁coded Out ▁, ▁serialization Context ▁. ▁getM emo izing Context ▁( ▁) ▁) ▁; ▁} ▁public ▁Serialization Result ▁< ▁ByteString ▁> ▁serialize Mem o ized And Blocking ▁( ▁Object ▁subject ▁) ▁throws ▁Serialization Exception ▁{ ▁Serialization Context ▁mem o izing Context ▁= ▁serialization Context ▁. ▁getM emo izing And Blocking OnWrite Context ▁( ▁) ▁; ▁ByteString ▁byte String ▁= ▁serialize To Byte String ▁( ▁subject ▁, ▁( ▁su bj ▁, ▁coded Out ▁) ▁-> ▁serialize Impl ▁( ▁su bj ▁, ▁coded Out ▁, ▁mem o izing Context ▁) ▁) ▁; ▁return ▁Serialization Result ▁. ▁create ▁( ▁byte String ▁, ▁mem o izing Context ▁. ▁create Future To Block W riting On ▁( ▁) ▁) ▁; ▁} ▁public ▁Object ▁deserialize ▁( ▁ByteString ▁data ▁) ▁throws ▁Serialization Exception ▁{ ▁return ▁deserialize ▁( ▁data ▁. ▁new Coded Input ▁( ▁) ▁) ▁; ▁} ▁public ▁Object ▁deserialize ▁( ▁Coded InputStream ▁coded In ▁) ▁throws ▁Serialization Exception ▁{ ▁return ▁deserialize Impl ▁( ▁coded In ▁, ▁false ▁) ▁; ▁} ▁public ▁Object ▁deserialize Mem o ized ▁( ▁ByteString ▁data ▁) ▁throws ▁Serialization Exception ▁{ ▁return ▁deserialize Mem o ized ▁( ▁data ▁. ▁new Coded Input ▁( ▁) ▁) ▁; ▁} ▁public ▁Object ▁deserialize Mem o ized ▁( ▁Coded InputStream ▁coded In ▁) ▁throws ▁Serialization Exception ▁{ ▁return ▁deserialize Impl ▁( ▁coded In ▁, ▁true ▁) ▁; ▁} ▁public ▁Object Codec Registry ▁getCodec Registry ▁( ▁) ▁{ ▁return ▁codec Registry ▁; ▁}
▁public ▁class ▁DruidPooled Callable Statement ▁extends ▁DruidPooled Pre paredStatement ▁implements ▁Callable Statement ▁{ ▁private ▁Callable Statement ▁stmt ▁; ▁public ▁DruidPooled Callable Statement ▁( ▁DruidPooled Connection ▁conn ▁, ▁Pre paredStatement Holder ▁holder ▁) ▁throws ▁SQLException ▁{ ▁super ▁( ▁conn ▁, ▁holder ▁) ▁; ▁this ▁. ▁stmt ▁= ▁( ▁Callable Statement ▁) ▁holder ▁. ▁statement ▁; ▁} ▁public ▁Callable Statement ▁get Callable Statement Raw ▁( ▁) ▁{ ▁return ▁stmt ▁; ▁} ▁@ ▁Override ▁public ▁void ▁register Out Parameter ▁( ▁int ▁parameterIndex ▁, ▁int ▁sql Type ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁stmt ▁. ▁register Out Parameter ▁( ▁parameterIndex ▁, ▁sql Type ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁register Out Parameter ▁( ▁int ▁parameterIndex ▁, ▁int ▁sql Type ▁, ▁int ▁scale ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁stmt ▁. ▁register Out Parameter ▁( ▁parameterIndex ▁, ▁sql Type ▁, ▁scale ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁boolean ▁wasNull ▁( ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁wasNull ▁( ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁String ▁getString ▁( ▁int ▁parameterIndex ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁getString ▁( ▁parameterIndex ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁boolean ▁getBoolean ▁( ▁int ▁parameterIndex ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁getBoolean ▁( ▁parameterIndex ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁byte ▁getByte ▁( ▁int ▁parameterIndex ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁getByte ▁( ▁parameterIndex ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁short ▁getShort ▁( ▁int ▁parameterIndex ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁getShort ▁( ▁parameterIndex ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁int ▁getInt ▁( ▁int ▁parameterIndex ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁getInt ▁( ▁parameterIndex ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁long ▁getLong ▁( ▁int ▁parameterIndex ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁getLong ▁( ▁parameterIndex ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁float ▁getFloat ▁( ▁int ▁parameterIndex ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁getFloat ▁( ▁parameterIndex ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁double ▁getDouble ▁( ▁int ▁parameterIndex ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁getDouble ▁( ▁parameterIndex ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁}
▁public ▁class ▁Metadata Create Index Service Tests ▁extends ▁ESTestCase ▁{ ▁private ▁Alias Validator ▁alias Validator ▁; ▁private ▁Create Index ClusterState Update Request ▁request ▁; ▁private ▁Search ExecutionContext ▁search ExecutionContext ▁; ▁private ▁IndexName Expression Resolver ▁indexName Expression Resolver ▁; ▁@ ▁Before ▁public ▁void ▁setup Create IndexRequest And Alias Validator ▁( ▁) ▁{ ▁indexName Expression Resolver ▁= ▁new ▁IndexName Expression Resolver ▁( ▁new ▁ThreadContext ▁( ▁Settings ▁. ▁EMPTY ▁) ▁, ▁Empty System Indices ▁. ▁INSTANCE ▁) ▁; ▁alias Validator ▁= ▁new ▁Alias Validator ▁( ▁) ▁; ▁request ▁= ▁new ▁Create Index ClusterState Update Request ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁Settings ▁indexSettings ▁= ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁SETTING _ VERSION _ CREATED ▁, ▁Version ▁. ▁CURRENT ▁) ▁. ▁put ▁( ▁IndexMetadata ▁. ▁SETTING _ NUMBER _ OF _ SHAR DS ▁, ▁1 ▁) ▁. ▁put ▁( ▁IndexMetadata ▁. ▁SETTING _ NUMBER _ OF _ REP LIC AS ▁, ▁1 ▁) ▁. ▁build ▁( ▁) ▁; ▁search ExecutionContext ▁= ▁new ▁Search ExecutionContext ▁( ▁0 ▁, ▁0 ▁, ▁new ▁IndexSettings ▁( ▁IndexMetadata ▁. ▁builder ▁( ▁STR ▁) ▁. ▁settings ▁( ▁indexSettings ▁) ▁. ▁build ▁( ▁) ▁, ▁indexSettings ▁) ▁, ▁null ▁, ▁null ▁, ▁null ▁, ▁null ▁, ▁null ▁, ▁null ▁, ▁xContent Registry ▁( ▁) ▁, ▁writable Registry ▁( ▁) ▁, ▁null ▁, ▁null ▁, ▁( ▁) ▁-> ▁random NonNegativeLong ▁( ▁) ▁, ▁null ▁, ▁null ▁, ▁( ▁) ▁-> ▁true ▁, ▁null ▁, ▁emptyMap ▁( ▁) ▁) ▁; ▁} ▁private ▁ClusterState ▁create ClusterState ▁( ▁String ▁name ▁, ▁int ▁num Shards ▁, ▁int ▁num Replicas ▁, ▁Settings ▁settings ▁) ▁{ ▁int ▁num Routing Shards ▁= ▁settings ▁. ▁getAs Int ▁( ▁IndexMetadata ▁. ▁INDEX _ NUMBER _ OF _ R OUT ING _ SHAR DS _ SETTING ▁. ▁getKey ▁( ▁) ▁, ▁num Shards ▁) ▁; ▁Metadata ▁. ▁Builder ▁meta Builder ▁= ▁Metadata ▁. ▁builder ▁( ▁) ▁; ▁IndexMetadata ▁indexMetadata ▁= ▁IndexMetadata ▁. ▁builder ▁( ▁name ▁) ▁. ▁settings ▁( ▁settings ▁( ▁Version ▁. ▁CURRENT ▁) ▁. ▁put ▁( ▁settings ▁) ▁) ▁. ▁numberOf Shards ▁( ▁num Shards ▁) ▁. ▁numberOf Replicas ▁( ▁num Replicas ▁) ▁. ▁set Routing Num Shards ▁( ▁num Routing Shards ▁) ▁. ▁build ▁( ▁) ▁; ▁meta Builder ▁. ▁put ▁( ▁indexMetadata ▁, ▁false ▁) ▁; ▁Metadata ▁metadata ▁= ▁meta Builder ▁. ▁build ▁( ▁) ▁; ▁Routing Table ▁. ▁Builder ▁routingTable Builder ▁= ▁Routing Table ▁. ▁builder ▁( ▁) ▁; ▁routingTable Builder ▁. ▁add As New ▁( ▁metadata ▁. ▁index ▁( ▁name ▁) ▁) ▁; ▁Routing Table ▁routingTable ▁= ▁routingTable Builder ▁. ▁build ▁( ▁) ▁; ▁ClusterState ▁clusterState ▁= ▁ClusterState ▁. ▁builder ▁( ▁org ▁. ▁elasticsearch ▁. ▁cluster ▁. ▁ClusterName ▁. ▁CLUSTER _ NAME _ SETTING ▁. ▁getDefault ▁( ▁Settings ▁. ▁EMPTY ▁) ▁) ▁. ▁metadata ▁( ▁metadata ▁) ▁. ▁routingTable ▁( ▁routingTable ▁) ▁. ▁blocks ▁( ▁Cluster Blocks ▁. ▁builder ▁( ▁) ▁. ▁add Blocks ▁( ▁indexMetadata ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁return ▁clusterState ▁; ▁} ▁public ▁static ▁boolean ▁is Sh rink able ▁( ▁int ▁source ▁, ▁int ▁target ▁) ▁{ ▁int ▁x ▁= ▁source ▁ / ▁target ▁;
▁public ▁class ▁Buffer ing Collector Test ▁{ ▁@ ▁Test ▁public ▁void ▁test N est Remo ves Element ▁( ▁) ▁{ ▁Buffer ing Collector ▁< ▁Integer ▁> ▁collector ▁= ▁new ▁Buffer ing Collector ▁< ▁> ▁( ▁) ▁; ▁collector ▁. ▁collect ▁( ▁1 ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁STR ▁, ▁collector ▁. ▁hasNext ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁Integer ▁. ▁valueOf ▁( ▁1 ▁) ▁, ▁collector ▁. ▁next ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertFalse ▁( ▁STR ▁, ▁collector ▁. ▁hasNext ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testEmpty Collector Returns Null ▁( ▁) ▁{ ▁Buffer ing Collector ▁< ▁Integer ▁> ▁collector ▁= ▁new ▁Buffer ing Collector ▁< ▁> ▁( ▁) ▁; ▁Assert ▁. ▁assertNull ▁( ▁STR ▁, ▁collector ▁. ▁next ▁( ▁) ▁) ▁; ▁} ▁}
▁on Transform Changed ▁( ▁) ▁; ▁if ▁( ▁transform Corre cted ▁) ▁{ ▁m Gesture Detector ▁. ▁restart Gesture ▁( ▁) ▁; ▁} ▁m Was Transform Corre cted ▁= ▁transform Corre cted ▁; ▁} ▁@ ▁Override ▁public ▁void ▁on Gesture End ▁( ▁Transform Gesture Detector ▁detector ▁) ▁{ ▁F Log ▁. ▁v ▁( ▁TAG ▁, ▁STR ▁) ▁; ▁on Transform End ▁( ▁) ▁; ▁} ▁protected ▁boolean ▁calculate Gesture Transform ▁( ▁Matrix ▁out Transform ▁, ▁@ ▁Limit Flag ▁int ▁limit Types ▁) ▁{ ▁Transform Gesture Detector ▁detector ▁= ▁m Gesture Detector ▁; ▁boolean ▁transform Corre cted ▁= ▁false ▁; ▁out Transform ▁. ▁set ▁( ▁m Previous Transform ▁) ▁; ▁if ▁( ▁m Is Rotation Enabled ▁) ▁{ ▁float ▁angle ▁= ▁detector ▁. ▁getR otation ▁( ▁) ▁ * ▁( ▁float ▁) ▁( ▁180 ▁ / ▁Math ▁. ▁PI ▁) ▁; ▁out Transform ▁. ▁post R otate ▁( ▁angle ▁, ▁detector ▁. ▁getP ivot X ▁( ▁) ▁, ▁detector ▁. ▁getP ivot Y ▁( ▁) ▁) ▁; ▁} ▁if ▁( ▁m Is Scale Enabled ▁) ▁{ ▁float ▁scale ▁= ▁detector ▁. ▁getScale ▁( ▁) ▁; ▁out Transform ▁. ▁post Scale ▁( ▁scale ▁, ▁scale ▁, ▁detector ▁. ▁getP ivot X ▁( ▁) ▁, ▁detector ▁. ▁getP ivot Y ▁( ▁) ▁) ▁; ▁} ▁transform Corre cted ▁|= ▁limit Scale ▁( ▁out Transform ▁, ▁detector ▁. ▁getP ivot X ▁( ▁) ▁, ▁detector ▁. ▁getP ivot Y ▁( ▁) ▁, ▁limit Types ▁) ▁; ▁if ▁( ▁m Is Translation Enabled ▁) ▁{ ▁out Transform ▁. ▁post Translate ▁( ▁detector ▁. ▁get Translation X ▁( ▁) ▁, ▁detector ▁. ▁get Translation Y ▁( ▁) ▁) ▁; ▁} ▁transform Corre cted ▁|= ▁limit Translation ▁( ▁out Transform ▁, ▁limit Types ▁) ▁; ▁return ▁transform Corre cted ▁; ▁} ▁private ▁void ▁on Transform Begin ▁( ▁) ▁{ ▁if ▁( ▁m Listener ▁!= ▁null ▁&& ▁isEnabled ▁( ▁) ▁) ▁{ ▁m Listener ▁. ▁on Transform Begin ▁( ▁m Active Transform ▁) ▁; ▁} ▁} ▁private ▁void ▁on Transform Changed ▁( ▁) ▁{ ▁m Active Transform ▁. ▁map Rect ▁( ▁m Transform ed Image Bounds ▁, ▁mImage Bounds ▁) ▁; ▁if ▁( ▁m Listener ▁!= ▁null ▁&& ▁isEnabled ▁( ▁) ▁) ▁{ ▁m Listener ▁. ▁on Transform Changed ▁( ▁m Active Transform ▁) ▁; ▁} ▁} ▁private ▁void ▁on Transform End ▁( ▁) ▁{ ▁if ▁( ▁m Listener ▁!= ▁null ▁&& ▁isEnabled ▁( ▁) ▁) ▁{ ▁m Listener ▁. ▁on Transform End ▁( ▁m Active Transform ▁) ▁; ▁} ▁} ▁private ▁boolean ▁limit Scale ▁( ▁Matrix ▁transform ▁, ▁float ▁pivot X ▁, ▁float ▁pivot Y ▁, ▁@ ▁Limit Flag ▁int ▁limit Types ▁) ▁{ ▁if ▁( ▁! ▁should Limit ▁( ▁limit Types ▁, ▁L IM IT _ SCALE ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁float ▁current Scale ▁= ▁getM atrix Scale Factor ▁( ▁transform ▁) ▁; ▁float ▁target Scale ▁= ▁limit ▁( ▁current Scale ▁, ▁m Min Scale Factor ▁, ▁m Max Scale Factor ▁) ▁; ▁if ▁( ▁target Scale ▁!= ▁current Scale ▁) ▁{ ▁float ▁scale ▁= ▁target Scale ▁ / ▁current Scale ▁;
▁public ▁final ▁class ▁Bind String Test ▁{ ▁@ ▁Test ▁public ▁void ▁type Must Be String ▁( ▁) ▁{ ▁JavaFileObject ▁source ▁= ▁JavaFile Objects ▁. ▁for Source String ▁( ▁STR ▁, ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁; ▁assert About ▁( ▁java Source ▁( ▁) ▁) ▁. ▁that ▁( ▁source ▁) ▁. ▁processed With ▁( ▁new ▁B utter K nife Processor ▁( ▁) ▁) ▁. ▁fail sTo Compile ▁( ▁) ▁. ▁with Error Containing ▁( ▁STR ▁) ▁. ▁in ▁( ▁source ▁) ▁. ▁on Line ▁( ▁4 ▁) ▁; ▁} ▁}
▁public ▁class ▁Parsed Binary Range ▁extends ▁Parsed MultiBucket Aggregation ▁< ▁Parsed Binary Range ▁. ▁ParsedBucket ▁> ▁implements ▁Range ▁{ ▁@ ▁Override ▁public ▁String ▁getType ▁( ▁) ▁{ ▁return ▁Ip Range Aggregation Builder ▁. ▁NAME ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁? ▁extends ▁Range ▁. ▁Bucket ▁> ▁getBuckets ▁( ▁) ▁{ ▁return ▁buckets ▁; ▁} ▁private ▁static ▁final ▁ObjectParser ▁< ▁Parsed Binary Range ▁, ▁Void ▁> ▁PARSER ▁= ▁new ▁ObjectParser ▁< ▁> ▁( ▁Parsed Binary Range ▁. ▁class ▁. ▁getSimpleName ▁( ▁) ▁, ▁true ▁, ▁Parsed Binary Range ▁:: ▁new ▁) ▁; ▁static ▁{ ▁declare MultiBucket Aggregation Fields ▁( ▁PARSER ▁, ▁parser ▁-> ▁ParsedBucket ▁. ▁fromXContent ▁( ▁parser ▁, ▁false ▁) ▁, ▁parser ▁-> ▁ParsedBucket ▁. ▁fromXContent ▁( ▁parser ▁, ▁true ▁) ▁) ▁; ▁} ▁public ▁static ▁Parsed Binary Range ▁fromXContent ▁( ▁XContentParser ▁parser ▁, ▁String ▁name ▁) ▁throws ▁IOException ▁{ ▁Parsed Binary Range ▁aggregation ▁= ▁PARSER ▁. ▁parse ▁( ▁parser ▁, ▁null ▁) ▁; ▁aggregation ▁. ▁setName ▁( ▁name ▁) ▁; ▁return ▁aggregation ▁; ▁} ▁public ▁static ▁class ▁ParsedBucket ▁extends ▁Parsed MultiBucket Aggregation ▁. ▁ParsedBucket ▁implements ▁Range ▁. ▁Bucket ▁{ ▁private ▁String ▁key ▁; ▁private ▁String ▁from ▁; ▁private ▁String ▁to ▁; ▁@ ▁Override ▁public ▁Object ▁getKey ▁( ▁) ▁{ ▁return ▁key ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getKey AsString ▁( ▁) ▁{ ▁return ▁key ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁getFrom ▁( ▁) ▁{ ▁return ▁from ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getFrom AsString ▁( ▁) ▁{ ▁return ▁from ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁getTo ▁( ▁) ▁{ ▁return ▁to ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getTo AsString ▁( ▁) ▁{ ▁return ▁to ▁; ▁} ▁@ ▁Override ▁public ▁XContentBuilder ▁toXContent ▁( ▁XContentBuilder ▁builder ▁, ▁Params ▁params ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁isKey ed ▁( ▁) ▁) ▁{ ▁builder ▁. ▁startObject ▁( ▁key ▁) ▁; ▁} ▁else ▁{ ▁builder ▁. ▁startObject ▁( ▁) ▁; ▁builder ▁. ▁field ▁( ▁CommonFields ▁. ▁KEY ▁. ▁getPreferred Name ▁( ▁) ▁, ▁key ▁) ▁; ▁} ▁if ▁( ▁from ▁!= ▁null ▁) ▁{ ▁builder ▁. ▁field ▁( ▁CommonFields ▁. ▁FROM ▁. ▁getPreferred Name ▁( ▁) ▁, ▁from ▁) ▁; ▁} ▁if ▁( ▁to ▁!= ▁null ▁) ▁{ ▁builder ▁. ▁field ▁( ▁CommonFields ▁. ▁TO ▁. ▁getPreferred Name ▁( ▁) ▁, ▁to ▁) ▁; ▁} ▁builder ▁. ▁field ▁( ▁CommonFields ▁. ▁DO C _ COUNT ▁. ▁getPreferred Name ▁( ▁) ▁, ▁get DocCount ▁( ▁) ▁) ▁; ▁getAggregations ▁( ▁) ▁. ▁toXContent Internal ▁( ▁builder ▁, ▁params ▁) ▁; ▁builder ▁. ▁endObject ▁( ▁) ▁; ▁return ▁builder ▁; ▁} ▁static ▁ParsedBucket ▁fromXContent ▁( ▁final ▁XContentParser ▁parser ▁, ▁final ▁boolean ▁keyed ▁) ▁throws ▁IOException ▁{ ▁final ▁ParsedBucket ▁bucket ▁= ▁new ▁ParsedBucket ▁( ▁) ▁; ▁bucket ▁. ▁setKey ed ▁( ▁keyed ▁) ▁; ▁XContentParser ▁. ▁Token ▁token ▁= ▁parser ▁. ▁currentToken ▁( ▁) ▁; ▁String ▁current FieldName ▁= ▁parser ▁. ▁currentName ▁( ▁) ▁; ▁if ▁( ▁keyed ▁) ▁{ ▁ensure Expected Token ▁( ▁XContentParser ▁. ▁Token ▁. ▁FIELD _ NAME ▁, ▁token ▁, ▁parser ▁) ▁; ▁bucket ▁. ▁key ▁= ▁current FieldName ▁;
▁class ▁Property Migration ▁{ ▁public ▁static ▁final ▁Comparator ▁< ▁Property Migration ▁> ▁COMP ARATOR ▁= ▁Comparator ▁. ▁comparing ▁( ▁( ▁property ▁) ▁-> ▁property ▁. ▁getMetadata ▁( ▁) ▁. ▁getId ▁( ▁) ▁) ▁; ▁private ▁final ▁Configuration Property ▁property ▁; ▁private ▁final ▁Integer ▁lineNumber ▁; ▁private ▁final ▁Configuration Metadata Property ▁metadata ▁; ▁private ▁final ▁Configuration Metadata Property ▁replacement Metadata ▁; ▁private ▁final ▁boolean ▁compatible Type ▁; ▁Property Migration ▁( ▁Configuration Property ▁property ▁, ▁Configuration Metadata Property ▁metadata ▁, ▁Configuration Metadata Property ▁replacement Metadata ▁) ▁{ ▁this ▁. ▁property ▁= ▁property ▁; ▁this ▁. ▁lineNumber ▁= ▁determine LineNumber ▁( ▁property ▁) ▁; ▁this ▁. ▁metadata ▁= ▁metadata ▁; ▁this ▁. ▁replacement Metadata ▁= ▁replacement Metadata ▁; ▁this ▁. ▁compatible Type ▁= ▁determine Compatible Type ▁( ▁metadata ▁, ▁replacement Metadata ▁) ▁; ▁} ▁private ▁static ▁Integer ▁determine LineNumber ▁( ▁Configuration Property ▁property ▁) ▁{ ▁Origin ▁origin ▁= ▁property ▁. ▁getOrigin ▁( ▁) ▁; ▁if ▁( ▁origin ▁instanceof ▁Text Resource Origin ▁) ▁{ ▁Text Resource Origin ▁text Origin ▁= ▁( ▁Text Resource Origin ▁) ▁origin ▁; ▁if ▁( ▁text Origin ▁. ▁getLocation ▁( ▁) ▁!= ▁null ▁) ▁{ ▁return ▁text Origin ▁. ▁getLocation ▁( ▁) ▁. ▁getLine ▁( ▁) ▁+ ▁1 ▁; ▁} ▁} ▁return ▁null ▁; ▁} ▁private ▁static ▁boolean ▁determine Compatible Type ▁( ▁Configuration Metadata Property ▁metadata ▁, ▁Configuration Metadata Property ▁replacement Metadata ▁) ▁{ ▁String ▁current Type ▁= ▁metadata ▁. ▁getType ▁( ▁) ▁; ▁String ▁replacement Type ▁= ▁determine Replacement Type ▁( ▁replacement Metadata ▁) ▁; ▁if ▁( ▁replacement Type ▁== ▁null ▁|| ▁current Type ▁== ▁null ▁) ▁{ ▁return ▁false ▁; ▁} ▁if ▁( ▁replacement Type ▁. ▁equals ▁( ▁current Type ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁replacement Type ▁. ▁equals ▁( ▁Duration ▁. ▁class ▁. ▁getName ▁( ▁) ▁) ▁&& ▁( ▁current Type ▁. ▁equals ▁( ▁Long ▁. ▁class ▁. ▁getName ▁( ▁) ▁) ▁|| ▁current Type ▁. ▁equals ▁( ▁Integer ▁. ▁class ▁. ▁getName ▁( ▁) ▁) ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁private ▁static ▁String ▁determine Replacement Type ▁( ▁Configuration Metadata Property ▁replacement Metadata ▁) ▁{ ▁if ▁( ▁replacement Metadata ▁== ▁null ▁|| ▁replacement Metadata ▁. ▁getType ▁( ▁) ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁String ▁candidate ▁= ▁replacement Metadata ▁. ▁getType ▁( ▁) ▁; ▁if ▁( ▁candidate ▁. ▁startsWith ▁( ▁Map ▁. ▁class ▁. ▁getName ▁( ▁) ▁) ▁) ▁{ ▁int ▁last Comma ▁= ▁candidate ▁. ▁lastIndexOf ▁( ▁CHAR ▁) ▁; ▁if ▁( ▁last Comma ▁!= ▁- ▁1 ▁) ▁{ ▁return ▁candidate ▁. ▁substring ▁( ▁last Comma ▁+ ▁1 ▁, ▁candidate ▁. ▁length ▁( ▁) ▁- ▁1 ▁) ▁. ▁trim ▁( ▁) ▁; ▁} ▁} ▁return ▁candidate ▁; ▁} ▁Configuration Property ▁getProperty ▁( ▁) ▁{ ▁return ▁this ▁. ▁property ▁; ▁} ▁Integer ▁getLineNumber ▁( ▁) ▁{ ▁return ▁this ▁. ▁lineNumber ▁; ▁} ▁Configuration Metadata Property ▁getMetadata ▁( ▁) ▁{ ▁return ▁this ▁. ▁metadata ▁; ▁} ▁boolean ▁isCompatible Type ▁( ▁) ▁{ ▁return ▁this ▁. ▁compatible Type ▁; ▁}
▁public ▁class ▁Encoded Resource Resolver ▁extends ▁Abstract Resource Resolver ▁{ ▁public ▁static ▁final ▁List ▁< ▁String ▁> ▁DEFAULT _ CODING S ▁= ▁Arrays ▁. ▁asList ▁( ▁STR ▁, ▁STR ▁) ▁; ▁private ▁final ▁List ▁< ▁String ▁> ▁content Co d ings ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁DEFAULT _ CODING S ▁) ▁; ▁private ▁final ▁Map ▁< ▁String ▁, ▁String ▁> ▁extensions ▁= ▁new ▁LinkedHashMap ▁< ▁> ▁( ▁) ▁; ▁public ▁Encoded Resource Resolver ▁( ▁) ▁{ ▁this ▁. ▁extensions ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁; ▁this ▁. ▁extensions ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁; ▁} ▁public ▁void ▁setContent Co d ings ▁( ▁List ▁< ▁String ▁> ▁c odings ▁) ▁{ ▁Assert ▁. ▁notEmpty ▁( ▁c odings ▁, ▁STR ▁) ▁; ▁this ▁. ▁content Co d ings ▁. ▁clear ▁( ▁) ▁; ▁this ▁. ▁content Co d ings ▁. ▁addAll ▁( ▁c odings ▁) ▁; ▁} ▁public ▁List ▁< ▁String ▁> ▁getContent Co d ings ▁( ▁) ▁{ ▁return ▁Collections ▁. ▁unmodifiable List ▁( ▁this ▁. ▁content Co d ings ▁) ▁; ▁} ▁public ▁void ▁set Extensions ▁( ▁Map ▁< ▁String ▁, ▁String ▁> ▁extensions ▁) ▁{ ▁extensions ▁. ▁forEach ▁( ▁this ▁:: ▁register Extension ▁) ▁; ▁} ▁public ▁Map ▁< ▁String ▁, ▁String ▁> ▁get Extensions ▁( ▁) ▁{ ▁return ▁Collections ▁. ▁unmodifiableMap ▁( ▁this ▁. ▁extensions ▁) ▁; ▁} ▁public ▁void ▁register Extension ▁( ▁String ▁c oding ▁, ▁String ▁extension ▁) ▁{ ▁this ▁. ▁extensions ▁. ▁put ▁( ▁c oding ▁, ▁( ▁extension ▁. ▁startsWith ▁( ▁STR ▁) ▁? ▁extension ▁: ▁STR ▁+ ▁extension ▁) ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Mono ▁< ▁Resource ▁> ▁resolve Resource Internal ▁( ▁@ ▁Nullable ▁Server WebExchange ▁exchange ▁, ▁String ▁request Path ▁, ▁List ▁< ▁? ▁extends ▁Resource ▁> ▁locations ▁, ▁Resource Resolver Chain ▁chain ▁) ▁{ ▁return ▁chain ▁. ▁resolve Resource ▁( ▁exchange ▁, ▁request Path ▁, ▁locations ▁) ▁. ▁map ▁( ▁resource ▁-> ▁{ ▁if ▁( ▁exchange ▁== ▁null ▁) ▁{ ▁return ▁resource ▁; ▁} ▁String ▁accept Encoding ▁= ▁getAc cept Encoding ▁( ▁exchange ▁) ▁; ▁if ▁( ▁accept Encoding ▁== ▁null ▁) ▁{ ▁return ▁resource ▁; ▁} ▁for ▁( ▁String ▁c oding ▁: ▁this ▁. ▁content Co d ings ▁) ▁{ ▁if ▁( ▁accept Encoding ▁. ▁contains ▁( ▁c oding ▁) ▁) ▁{ ▁try ▁{ ▁String ▁extension ▁= ▁getExtension ▁( ▁c oding ▁) ▁; ▁Resource ▁encoded ▁= ▁new ▁Encoded Resource ▁( ▁resource ▁, ▁c oding ▁, ▁extension ▁) ▁; ▁if ▁( ▁encoded ▁. ▁exists ▁( ▁) ▁) ▁{ ▁return ▁encoded ▁; ▁} ▁} ▁catch ▁( ▁IOException ▁ex ▁) ▁{ ▁logger ▁. ▁trace ▁( ▁exchange ▁. ▁getLog Prefix ▁( ▁) ▁+ ▁STR ▁+ ▁c oding ▁+ ▁STR ▁+ ▁resource ▁. ▁getFilename ▁( ▁) ▁+ ▁STR ▁, ▁ex ▁) ▁; ▁} ▁} ▁} ▁return ▁resource ▁; ▁} ▁) ▁; ▁} ▁@ ▁Nullable ▁private ▁String ▁getAc cept Encoding ▁( ▁Server WebExchange ▁exchange ▁) ▁{ ▁Server HttpRequest ▁request ▁= ▁exchange ▁. ▁getRequest ▁( ▁) ▁; ▁String ▁header ▁= ▁request ▁. ▁getHeaders ▁( ▁) ▁. ▁getFirst ▁( ▁HttpHeaders ▁. ▁ACCEPT _ ENCODING ▁) ▁;
▁public ▁class ▁ReadOnly ByteBuf Test ▁{ ▁@ ▁Test ▁public ▁void ▁shouldNot Allow Null In Constructor ▁( ▁) ▁{ ▁assertThrows ▁( ▁NullPointer Exception ▁. ▁class ▁, ▁new ▁Executable ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁) ▁{ ▁new ▁ReadOnly ByteBuf ▁( ▁null ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Unm odifiable Buffer ▁( ▁) ▁{ ▁assertTrue ▁( ▁unmodifiable Buffer ▁( ▁buffer ▁( ▁1 ▁) ▁) ▁instanceof ▁ReadOnly ByteBuf ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testUn w rap ▁( ▁) ▁{ ▁ByteBuf ▁buf ▁= ▁buffer ▁( ▁1 ▁) ▁; ▁assertSame ▁( ▁buf ▁, ▁unmodifiable Buffer ▁( ▁buf ▁) ▁. ▁unwrap ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁should Have Same Byte Order ▁( ▁) ▁{ ▁ByteBuf ▁buf ▁= ▁buffer ▁( ▁1 ▁) ▁; ▁assertSame ▁( ▁BIG _ ENDIAN ▁, ▁unmodifiable Buffer ▁( ▁buf ▁) ▁. ▁order ▁( ▁) ▁) ▁; ▁buf ▁= ▁buf ▁. ▁order ▁( ▁LITTLE _ ENDIAN ▁) ▁; ▁assertSame ▁( ▁LITTLE _ ENDIAN ▁, ▁unmodifiable Buffer ▁( ▁buf ▁) ▁. ▁order ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁should Return ReadOnly D erived Buffer ▁( ▁) ▁{ ▁ByteBuf ▁buf ▁= ▁unmodifiable Buffer ▁( ▁buffer ▁( ▁1 ▁) ▁) ▁; ▁assertTrue ▁( ▁buf ▁. ▁duplicate ▁( ▁) ▁instanceof ▁ReadOnly ByteBuf ▁) ▁; ▁assertTrue ▁( ▁buf ▁. ▁slice ▁( ▁) ▁instanceof ▁ReadOnly ByteBuf ▁) ▁; ▁assertTrue ▁( ▁buf ▁. ▁slice ▁( ▁0 ▁, ▁1 ▁) ▁instanceof ▁ReadOnly ByteBuf ▁) ▁; ▁assertTrue ▁( ▁buf ▁. ▁duplicate ▁( ▁) ▁instanceof ▁ReadOnly ByteBuf ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁should Return Writable Copy ▁( ▁) ▁{ ▁ByteBuf ▁buf ▁= ▁unmodifiable Buffer ▁( ▁buffer ▁( ▁1 ▁) ▁) ▁; ▁assertFalse ▁( ▁buf ▁. ▁copy ▁( ▁) ▁instanceof ▁ReadOnly ByteBuf ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁should Forward Read Calls Bl ind ly ▁( ▁) ▁throws ▁Exception ▁{ ▁ByteBuf ▁buf ▁= ▁mock ▁( ▁ByteBuf ▁. ▁class ▁) ▁; ▁when ▁( ▁buf ▁. ▁order ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁BIG _ ENDIAN ▁) ▁; ▁when ▁( ▁buf ▁. ▁max Capacity ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁655 36 ▁) ▁; ▁when ▁( ▁buf ▁. ▁readerIndex ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁0 ▁) ▁; ▁when ▁( ▁buf ▁. ▁writerIndex ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁0 ▁) ▁; ▁when ▁( ▁buf ▁. ▁capacity ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁0 ▁) ▁; ▁when ▁( ▁buf ▁. ▁getBytes ▁( ▁1 ▁, ▁( ▁G ather ing ByteChannel ▁) ▁null ▁, ▁2 ▁) ▁) ▁. ▁thenReturn ▁( ▁3 ▁) ▁; ▁when ▁( ▁buf ▁. ▁getBytes ▁( ▁4 ▁, ▁( ▁OutputStream ▁) ▁null ▁, ▁5 ▁) ▁) ▁. ▁thenReturn ▁( ▁buf ▁) ▁; ▁when ▁( ▁buf ▁. ▁getBytes ▁( ▁6 ▁, ▁( ▁byte ▁[ ▁] ▁) ▁null ▁, ▁7 ▁, ▁8 ▁) ▁) ▁. ▁thenReturn ▁( ▁buf ▁) ▁; ▁when ▁( ▁buf ▁. ▁getBytes ▁( ▁9 ▁, ▁( ▁ByteBuf ▁) ▁null ▁, ▁10 ▁, ▁11 ▁) ▁) ▁. ▁thenReturn ▁( ▁buf ▁) ▁; ▁when ▁( ▁buf ▁. ▁getBytes ▁( ▁12 ▁, ▁( ▁ByteBuffer ▁) ▁null ▁) ▁) ▁. ▁thenReturn ▁( ▁buf ▁) ▁;
▁@ ▁ThreadSafe ▁public ▁class ▁TaskState Machine ▁{ ▁private ▁static ▁final ▁Logger ▁log ▁= ▁Logger ▁. ▁get ▁( ▁TaskState Machine ▁. ▁class ▁) ▁; ▁private ▁final ▁DateTime ▁created Time ▁= ▁DateTime ▁. ▁now ▁( ▁) ▁; ▁private ▁final ▁TaskId ▁taskId ▁; ▁private ▁final ▁StateMachine ▁< ▁TaskState ▁> ▁task State ▁; ▁private ▁final ▁Linked BlockingQueue ▁< ▁Throwable ▁> ▁failure Cause s ▁= ▁new ▁Linked BlockingQueue ▁< ▁> ▁( ▁) ▁; ▁public ▁TaskState Machine ▁( ▁TaskId ▁taskId ▁, ▁Executor ▁executor ▁) ▁{ ▁this ▁. ▁taskId ▁= ▁requireNonNull ▁( ▁taskId ▁, ▁STR ▁) ▁; ▁task State ▁= ▁new ▁StateMachine ▁< ▁> ▁( ▁STR ▁+ ▁taskId ▁, ▁executor ▁, ▁TaskState ▁. ▁RUNNING ▁, ▁TERMIN AL _ TASK _ STATE S ▁) ▁; ▁task State ▁. ▁add State ChangeListener ▁( ▁new ▁State ChangeListener ▁< ▁TaskState ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁state Changed ▁( ▁TaskState ▁newState ▁) ▁{ ▁log ▁. ▁debug ▁( ▁STR ▁, ▁taskId ▁, ▁newState ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁public ▁DateTime ▁getCreate d Time ▁( ▁) ▁{ ▁return ▁created Time ▁; ▁} ▁public ▁TaskId ▁getTaskId ▁( ▁) ▁{ ▁return ▁taskId ▁; ▁} ▁public ▁TaskState ▁getState ▁( ▁) ▁{ ▁return ▁task State ▁. ▁get ▁( ▁) ▁; ▁} ▁public ▁List enableFuture ▁< ▁TaskState ▁> ▁getState Change ▁( ▁TaskState ▁currentState ▁) ▁{ ▁requireNonNull ▁( ▁currentState ▁, ▁STR ▁) ▁; ▁checkArgument ▁( ▁! ▁currentState ▁. ▁isDone ▁( ▁) ▁, ▁STR ▁) ▁; ▁List enableFuture ▁< ▁TaskState ▁> ▁future ▁= ▁task State ▁. ▁getState Change ▁( ▁currentState ▁) ▁; ▁TaskState ▁state ▁= ▁task State ▁. ▁get ▁( ▁) ▁; ▁if ▁( ▁state ▁. ▁isDone ▁( ▁) ▁) ▁{ ▁return ▁immediate Future ▁( ▁state ▁) ▁; ▁} ▁return ▁future ▁; ▁} ▁public ▁Linked BlockingQueue ▁< ▁Throwable ▁> ▁getFailure Cause s ▁( ▁) ▁{ ▁return ▁failure Cause s ▁; ▁} ▁public ▁void ▁finished ▁( ▁) ▁{ ▁transitionTo Done State ▁( ▁TaskState ▁. ▁FIN ISHED ▁) ▁; ▁} ▁public ▁void ▁cancel ▁( ▁) ▁{ ▁transitionTo Done State ▁( ▁TaskState ▁. ▁CANCE LED ▁) ▁; ▁} ▁public ▁void ▁abort ▁( ▁) ▁{ ▁transitionTo Done State ▁( ▁TaskState ▁. ▁AB ORTED ▁) ▁; ▁} ▁public ▁void ▁failed ▁( ▁Throwable ▁cause ▁) ▁{ ▁failure Cause s ▁. ▁add ▁( ▁cause ▁) ▁; ▁transitionTo Done State ▁( ▁TaskState ▁. ▁FAILED ▁) ▁; ▁} ▁private ▁void ▁transitionTo Done State ▁( ▁TaskState ▁done State ▁) ▁{ ▁requireNonNull ▁( ▁done State ▁, ▁STR ▁) ▁; ▁checkArgument ▁( ▁done State ▁. ▁isDone ▁( ▁) ▁, ▁STR ▁, ▁done State ▁) ▁; ▁task State ▁. ▁set If ▁( ▁done State ▁, ▁currentState ▁-> ▁! ▁currentState ▁. ▁isDone ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁add State ChangeListener ▁( ▁State ChangeListener ▁< ▁TaskState ▁> ▁state ChangeListener ▁) ▁{ ▁task State ▁. ▁add State ChangeListener ▁( ▁state ChangeListener ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁toStringHelper ▁( ▁this ▁) ▁. ▁add ▁( ▁STR ▁, ▁taskId ▁) ▁. ▁add ▁( ▁STR ▁, ▁task State ▁) ▁. ▁add ▁( ▁STR ▁, ▁failure Cause s ▁) ▁. ▁toString ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁Write As Array _ byte _ pu blic ▁extends ▁TestCase ▁{ ▁public ▁void ▁test _0 ▁( ▁) ▁throws ▁Exception ▁{ ▁VO ▁vo ▁= ▁new ▁VO ▁( ▁) ▁; ▁vo ▁. ▁setId ▁( ▁( ▁byte ▁) ▁123 ▁) ▁; ▁vo ▁. ▁setName ▁( ▁STR ▁) ▁; ▁String ▁text ▁= ▁JSON ▁. ▁toJSONString ▁( ▁vo ▁, ▁Serializer Feature ▁. ▁Bean ToArray ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁text ▁) ▁; ▁} ▁public ▁static ▁class ▁VO ▁{ ▁private ▁byte ▁id ▁; ▁private ▁String ▁name ▁; ▁public ▁byte ▁getId ▁( ▁) ▁{ ▁return ▁id ▁; ▁} ▁public ▁void ▁setId ▁( ▁byte ▁id ▁) ▁{ ▁this ▁. ▁id ▁= ▁id ▁; ▁} ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁name ▁; ▁} ▁public ▁void ▁setName ▁( ▁String ▁name ▁) ▁{ ▁this ▁. ▁name ▁= ▁name ▁; ▁} ▁} ▁}
▁observer Pairs ▁. ▁f ore ach ▁( ▁new ▁Observer Pair List ▁. ▁Callback ▁< ▁TestObserver Pair ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁on Called ▁( ▁TestObserver Pair ▁pair ▁, ▁Object ▁observer ▁) ▁{ ▁assertEquals ▁( ▁ONE ▁, ▁observer ▁) ▁; ▁f ore ach Called ▁. ▁set ▁( ▁true ▁) ▁; ▁} ▁} ▁) ▁; ▁assertTrue ▁( ▁f ore ach Called ▁. ▁get ▁( ▁) ▁) ▁; ▁} ▁@ ▁SuppressLint ▁( ▁{ ▁STR ▁, ▁STR ▁} ▁) ▁@ ▁Test ▁public ▁void ▁remove ▁( ▁) ▁{ ▁TestObserver Pair ▁pair ▁= ▁new ▁TestObserver Pair ▁( ▁ONE ▁, ▁test Listener ▁) ▁; ▁observer Pairs ▁. ▁add ▁( ▁pair ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁observer Pairs ▁. ▁size ▁( ▁) ▁) ▁; ▁observer Pairs ▁. ▁remove ▁( ▁new ▁Integer ▁( ▁1 ▁) ▁, ▁test Listener ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁observer Pairs ▁. ▁size ▁( ▁) ▁) ▁; ▁observer Pairs ▁. ▁remove ▁( ▁ONE ▁, ▁new ▁Test Listener ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁observer Pairs ▁. ▁size ▁( ▁) ▁) ▁; ▁observer Pairs ▁. ▁remove ▁( ▁ONE ▁, ▁test Listener ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁observer Pairs ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁remove By Observer ▁( ▁) ▁{ ▁TestObserver Pair ▁pair ▁= ▁new ▁TestObserver Pair ▁( ▁ONE ▁, ▁test Listener ▁) ▁; ▁observer Pairs ▁. ▁add ▁( ▁pair ▁) ▁; ▁pair ▁= ▁new ▁TestObserver Pair ▁( ▁ONE ▁, ▁new ▁Test Listener ▁( ▁) ▁) ▁; ▁observer Pairs ▁. ▁add ▁( ▁pair ▁) ▁; ▁assertEquals ▁( ▁2 ▁, ▁observer Pairs ▁. ▁size ▁( ▁) ▁) ▁; ▁pair ▁= ▁new ▁TestObserver Pair ▁( ▁TWO ▁, ▁test Listener ▁) ▁; ▁observer Pairs ▁. ▁add ▁( ▁pair ▁) ▁; ▁assertEquals ▁( ▁3 ▁, ▁observer Pairs ▁. ▁size ▁( ▁) ▁) ▁; ▁observer Pairs ▁. ▁remove By Observer ▁( ▁ONE ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁observer Pairs ▁. ▁size ▁( ▁) ▁) ▁; ▁observer Pairs ▁. ▁remove By Observer ▁( ▁TWO ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁observer Pairs ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁clear ▁( ▁) ▁{ ▁TestObserver Pair ▁pair ▁= ▁new ▁TestObserver Pair ▁( ▁ONE ▁, ▁new ▁Test Listener ▁( ▁) ▁) ▁; ▁observer Pairs ▁. ▁add ▁( ▁pair ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁observer Pairs ▁. ▁size ▁( ▁) ▁) ▁; ▁observer Pairs ▁. ▁clear ▁( ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁observer Pairs ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁isEmpty ▁( ▁) ▁{ ▁assertTrue ▁( ▁observer Pairs ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁TestObserver Pair ▁pair ▁= ▁new ▁TestObserver Pair ▁( ▁ONE ▁, ▁new ▁Test Listener ▁( ▁) ▁) ▁; ▁observer Pairs ▁. ▁add ▁( ▁pair ▁) ▁; ▁assertFalse ▁( ▁observer Pairs ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁observer Pairs ▁. ▁clear ▁( ▁) ▁; ▁assertTrue ▁( ▁observer Pairs ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁f ore ach ▁( ▁) ▁{ ▁final ▁boolean ▁[ ▁] ▁on Changes Called ▁= ▁{ ▁false ▁, ▁false ▁} ▁;
▁class ▁Symbol Tree TestUtils ▁{ ▁private ▁Program ▁program ▁; ▁private ▁Symbol Tree Plugin ▁plugin ▁; ▁private ▁DockingActionIf ▁sym Tree Action ▁; ▁private ▁Symbol G Tree ▁tree ▁; ▁private ▁GTreeNode ▁root G TreeNode ▁; ▁private ▁Symbol Tree Provider ▁provider ▁; ▁private ▁DockingActionIf ▁rename Action ▁; ▁private ▁DockingActionIf ▁c ut Action ▁; ▁private ▁DockingActionIf ▁p ast e Action ▁; ▁private ▁DockingActionIf ▁delete Action ▁; ▁private ▁DockingActionIf ▁selection Action ▁; ▁private ▁DockingActionIf ▁create Namespace Action ▁; ▁private ▁DockingActionIf ▁create Class Action ▁; ▁private ▁T oggle D ock ingAction ▁goTo Toggle Action ▁; ▁private ▁Comparator ▁< ▁Symbol ▁> ▁symbol Comparator ▁= ▁( ▁s 1 ▁, ▁s 2 ▁) ▁-> ▁{ ▁int ▁name Compare ▁= ▁s 1 ▁. ▁getName ▁( ▁) ▁. ▁compareTo IgnoreCase ▁( ▁s 2 ▁. ▁getName ▁( ▁) ▁) ▁; ▁if ▁( ▁name Compare ▁!= ▁0 ▁) ▁{ ▁return ▁name Compare ▁; ▁} ▁int ▁result ▁= ▁Symbol TreeNode ▁. ▁SY MBOL _ COMP ARATOR ▁. ▁compare ▁( ▁s 1 ▁, ▁s 2 ▁) ▁; ▁return ▁result ▁; ▁} ▁; ▁private ▁Comparator ▁< ▁Symbol ▁> ▁function Comparator ▁= ▁new ▁Function Symbol Comparator ▁( ▁) ▁; ▁Symbol Tree TestUtils ▁( ▁Symbol Tree Plugin ▁plugin ▁) ▁throws ▁Exception ▁{ ▁this ▁. ▁plugin ▁= ▁plugin ▁; ▁this ▁. ▁program ▁= ▁build Program ▁( ▁) ▁; ▁sym Tree Action ▁= ▁getAction ▁( ▁plugin ▁, ▁STR ▁) ▁; ▁} ▁Symbol Tree TestUtils ▁( ▁Symbol Tree Plugin ▁plugin ▁, ▁Program ▁program ▁) ▁{ ▁this ▁. ▁plugin ▁= ▁plugin ▁; ▁this ▁. ▁program ▁= ▁program ▁; ▁sym Tree Action ▁= ▁getAction ▁( ▁plugin ▁, ▁STR ▁) ▁; ▁} ▁public ▁static ▁Program ▁build Program ▁( ▁) ▁throws ▁Exception ▁{ ▁To y Program Builder ▁builder ▁= ▁new ▁To y Program Builder ▁( ▁STR ▁, ▁true ▁) ▁; ▁Program ▁program ▁= ▁builder ▁. ▁getProgram ▁( ▁) ▁; ▁builder ▁. ▁create Memory ▁( ▁STR ▁, ▁STR ▁, ▁0 x 55 00 ▁) ▁; ▁builder ▁. ▁create EntryPoint ▁( ▁STR ▁, ▁STR ▁) ▁; ▁builder ▁. ▁createLabel ▁( ▁STR ▁, ▁STR ▁) ▁; ▁builder ▁. ▁create External Libraries ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁builder ▁. ▁create External Reference ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁0 ▁) ▁; ▁builder ▁. ▁createLabel ▁( ▁STR ▁, ▁STR ▁) ▁; ▁builder ▁. ▁create External Reference ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁0 ▁) ▁; ▁builder ▁. ▁createLabel ▁( ▁STR ▁, ▁STR ▁) ▁; ▁builder ▁. ▁create External Reference ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁0 ▁) ▁; ▁builder ▁. ▁createLabel ▁( ▁STR ▁, ▁STR ▁) ▁; ▁builder ▁. ▁create External Reference ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁0 ▁) ▁; ▁builder ▁. ▁createLabel ▁( ▁STR ▁, ▁STR ▁) ▁; ▁builder ▁. ▁create External Reference ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁0 ▁) ▁; ▁builder ▁. ▁createLabel ▁( ▁STR ▁, ▁STR ▁) ▁; ▁builder ▁. ▁create External Reference ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁0 ▁) ▁; ▁builder ▁. ▁createLabel ▁( ▁STR ▁, ▁STR ▁) ▁; ▁builder ▁. ▁create External Reference ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁0 ▁) ▁;
▁IndexRequest ▁index Request ▁= ▁new ▁IndexRequest ▁( ▁STR ▁) ▁. ▁id ▁( ▁partition ▁. ▁id ▁) ▁. ▁source ▁( ▁STR ▁, ▁random ▁. ▁nextInt ▁( ▁) ▁) ▁. ▁set If Primary Term ▁( ▁version ▁. ▁primary Term ▁) ▁. ▁set If SeqNo ▁( ▁version ▁. ▁seqNo ▁) ▁; ▁Consumer ▁< ▁History Output ▁> ▁history Response ▁= ▁partition ▁. ▁invoke ▁( ▁version ▁) ▁; ▁try ▁{ ▁Index Response ▁index Response ▁= ▁client ▁( ▁) ▁. ▁index ▁( ▁index Request ▁) ▁. ▁actionGet ▁( ▁timeout ▁, ▁TimeUnit ▁. ▁SECONDS ▁) ▁; ▁Index Response History Output ▁history Output ▁= ▁new ▁Index Response History Output ▁( ▁index Response ▁) ▁; ▁history Response ▁. ▁accept ▁( ▁history Output ▁) ▁; ▁assertThat ▁( ▁history Output ▁. ▁output Version ▁, ▁greaterThan ▁( ▁version ▁) ▁) ▁; ▁assertThat ▁( ▁history Output ▁. ▁output Version ▁. ▁seqNo ▁, ▁greaterThan ▁( ▁version ▁. ▁seqNo ▁) ▁) ▁; ▁} ▁catch ▁( ▁Version Conflict Engine Exception ▁e ▁) ▁{ ▁if ▁( ▁version ▁. ▁compareTo ▁( ▁partition ▁. ▁latest Successful Version ▁( ▁) ▁) ▁<= ▁0 ▁) ▁{ ▁history Response ▁. ▁accept ▁( ▁new ▁C AS Failure History Output ▁( ▁e ▁) ▁) ▁; ▁} ▁} ▁catch ▁( ▁Runtime Exception ▁e ▁) ▁{ ▁if ▁( ▁version ▁. ▁compareTo ▁( ▁partition ▁. ▁latest Successful Version ▁( ▁) ▁) ▁<= ▁0 ▁) ▁{ ▁history Response ▁. ▁accept ▁( ▁new ▁Failure History Output ▁( ▁) ▁) ▁; ▁} ▁logger ▁. ▁info ▁( ▁new ▁Parameterized Message ▁( ▁STR ▁, ▁index Request ▁, ▁version ▁) ▁, ▁e ▁) ▁; ▁if ▁( ▁stop ▁) ▁{ ▁return ▁; ▁} ▁} ▁} ▁} ▁catch ▁( ▁Interrupted Exception ▁e ▁) ▁{ ▁assert ▁stop ▁: ▁STR ▁; ▁} ▁catch ▁( ▁B roken Barrier Exception ▁e ▁) ▁{ ▁} ▁catch ▁( ▁Timeout Exception ▁e ▁) ▁{ ▁throw ▁new ▁AssertionError ▁( ▁STR ▁+ ▁Thread ▁. ▁currentThread ▁( ▁) ▁, ▁e ▁) ▁; ▁} ▁} ▁} ▁public ▁void ▁terminate ▁( ▁) ▁{ ▁stop ▁= ▁true ▁; ▁this ▁. ▁interrupt ▁( ▁) ▁; ▁} ▁public ▁void ▁await ▁( ▁) ▁{ ▁try ▁{ ▁join ▁( ▁60000 ▁) ▁; ▁} ▁catch ▁( ▁Interrupted Exception ▁e ▁) ▁{ ▁Thread ▁. ▁currentThread ▁( ▁) ▁. ▁interrupt ▁( ▁) ▁; ▁} ▁} ▁} ▁private ▁static ▁final ▁class ▁Version ▁implements ▁NamedWriteable ▁, ▁Comparable ▁< ▁Version ▁> ▁{ ▁public ▁final ▁long ▁primary Term ▁; ▁public ▁final ▁long ▁seqNo ▁; ▁Version ▁( ▁long ▁primary Term ▁, ▁long ▁seqNo ▁) ▁{ ▁this ▁. ▁primary Term ▁= ▁primary Term ▁; ▁this ▁. ▁seqNo ▁= ▁seqNo ▁; ▁} ▁Version ▁( ▁StreamInput ▁input ▁) ▁throws ▁IOException ▁{ ▁this ▁. ▁primary Term ▁= ▁input ▁. ▁readLong ▁( ▁) ▁; ▁this ▁. ▁seqNo ▁= ▁input ▁. ▁readLong ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁o ▁) ▁{ ▁if ▁( ▁this ▁== ▁o ▁) ▁return ▁true ▁; ▁if ▁( ▁o ▁== ▁null ▁|| ▁getClass ▁( ▁) ▁!= ▁o ▁. ▁getClass ▁( ▁) ▁) ▁return ▁false ▁; ▁Version ▁version ▁= ▁( ▁Version ▁) ▁o ▁; ▁return ▁primary Term ▁== ▁version ▁. ▁primary Term ▁&& ▁seqNo ▁== ▁version ▁. ▁seqNo ▁; ▁}
▁public ▁class ▁N ir v ana Output List ▁implements ▁List ▁< ▁Record ▁> ▁{ ▁@ ▁Override ▁public ▁boolean ▁add ▁( ▁Record ▁arg 0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁void ▁add ▁( ▁int ▁arg 0 ▁, ▁Record ▁arg 1 ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁boolean ▁addAll ▁( ▁Collection ▁< ▁? ▁extends ▁Record ▁> ▁arg 0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁addAll ▁( ▁int ▁arg 0 ▁, ▁Collection ▁< ▁? ▁extends ▁Record ▁> ▁arg 1 ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁void ▁clear ▁( ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁boolean ▁contains ▁( ▁Object ▁arg 0 ▁) ▁{ ▁return ▁false ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁containsAll ▁( ▁Collection ▁< ▁? ▁> ▁arg 0 ▁) ▁{ ▁return ▁false ▁; ▁} ▁@ ▁Override ▁public ▁Record ▁get ▁( ▁int ▁arg 0 ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁int ▁indexOf ▁( ▁Object ▁arg 0 ▁) ▁{ ▁return ▁- ▁1 ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁isEmpty ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁Iterator ▁< ▁Record ▁> ▁iterator ▁( ▁) ▁{ ▁return ▁new ▁Iterator ▁< ▁Record ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁boolean ▁hasNext ▁( ▁) ▁{ ▁return ▁false ▁; ▁} ▁@ ▁Override ▁public ▁Record ▁next ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁void ▁remove ▁( ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁} ▁; ▁} ▁@ ▁Override ▁public ▁int ▁lastIndexOf ▁( ▁Object ▁arg 0 ▁) ▁{ ▁return ▁- ▁1 ▁; ▁} ▁@ ▁Override ▁public ▁ListIterator ▁< ▁Record ▁> ▁listIterator ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁ListIterator ▁< ▁Record ▁> ▁listIterator ▁( ▁int ▁arg 0 ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁remove ▁( ▁Object ▁arg 0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁Record ▁remove ▁( ▁int ▁arg 0 ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁removeAll ▁( ▁Collection ▁< ▁? ▁> ▁arg 0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁retainAll ▁( ▁Collection ▁< ▁? ▁> ▁arg 0 ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁Record ▁set ▁( ▁int ▁arg 0 ▁, ▁Record ▁arg 1 ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁int ▁size ▁( ▁) ▁{ ▁return ▁0 ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁Record ▁> ▁subList ▁( ▁int ▁arg 0 ▁, ▁int ▁arg 1 ▁) ▁{ ▁return ▁new ▁N ir v ana Output List ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁[ ▁] ▁toArray ▁( ▁) ▁{ ▁return ▁new ▁Object ▁[ ▁0 ▁] ▁; ▁} ▁@ ▁Override ▁public ▁< ▁T ▁> ▁T ▁[ ▁] ▁toArray ▁( ▁T ▁[ ▁] ▁arg 0 ▁) ▁{ ▁return ▁null ▁; ▁} ▁}
▁@ ▁Gradle Compatibility ▁( ▁configuration Cache ▁= ▁true ▁) ▁class ▁Boot W ar IntegrationTests ▁extends ▁Abstract Boot Archive IntegrationTests ▁{ ▁Boot W ar IntegrationTests ▁( ▁) ▁{ ▁super ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁String ▁[ ▁] ▁getExpected Application Layer Contents ▁( ▁String ▁... ▁additional Files ▁) ▁{ ▁Set ▁< ▁String ▁> ▁contents ▁= ▁new ▁TreeSet ▁< ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁additional Files ▁) ▁) ▁; ▁contents ▁. ▁addAll ▁( ▁Arrays ▁. ▁asList ▁( ▁STR ▁, ▁STR ▁) ▁) ▁; ▁return ▁contents ▁. ▁toArray ▁( ▁new ▁String ▁[ ▁0 ▁] ▁) ▁; ▁} ▁}
▁public ▁class ▁Pcode Exception ▁extends ▁Exception ▁{ ▁public ▁Pcode Exception ▁( ▁String ▁msg ▁) ▁{ ▁super ▁( ▁STR ▁+ ▁msg ▁) ▁; ▁} ▁public ▁Pcode Exception ▁( ▁String ▁msg ▁, ▁Throwable ▁cause ▁) ▁{ ▁super ▁( ▁STR ▁+ ▁msg ▁, ▁cause ▁) ▁; ▁} ▁}
▁static ▁boolean ▁has Valid Topic Partition ▁( ▁Be gin Quorum Epoch RequestData ▁data ▁, ▁TopicPartition ▁topicPartition ▁) ▁{ ▁return ▁data ▁. ▁topics ▁( ▁) ▁. ▁size ▁( ▁) ▁== ▁1 ▁&& ▁data ▁. ▁topics ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁topicName ▁( ▁) ▁. ▁equals ▁( ▁topicPartition ▁. ▁topic ▁( ▁) ▁) ▁&& ▁data ▁. ▁topics ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁partitions ▁( ▁) ▁. ▁size ▁( ▁) ▁== ▁1 ▁&& ▁data ▁. ▁topics ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁partitions ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁partition Index ▁( ▁) ▁== ▁topicPartition ▁. ▁partition ▁( ▁) ▁; ▁} ▁static ▁boolean ▁has Valid Topic Partition ▁( ▁Be gin Quorum Epoch ResponseData ▁data ▁, ▁TopicPartition ▁topicPartition ▁) ▁{ ▁return ▁data ▁. ▁topics ▁( ▁) ▁. ▁size ▁( ▁) ▁== ▁1 ▁&& ▁data ▁. ▁topics ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁topicName ▁( ▁) ▁. ▁equals ▁( ▁topicPartition ▁. ▁topic ▁( ▁) ▁) ▁&& ▁data ▁. ▁topics ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁partitions ▁( ▁) ▁. ▁size ▁( ▁) ▁== ▁1 ▁&& ▁data ▁. ▁topics ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁partitions ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁partition Index ▁( ▁) ▁== ▁topicPartition ▁. ▁partition ▁( ▁) ▁; ▁} ▁static ▁boolean ▁has Valid Topic Partition ▁( ▁End Quorum Epoch RequestData ▁data ▁, ▁TopicPartition ▁topicPartition ▁) ▁{ ▁return ▁data ▁. ▁topics ▁( ▁) ▁. ▁size ▁( ▁) ▁== ▁1 ▁&& ▁data ▁. ▁topics ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁topicName ▁( ▁) ▁. ▁equals ▁( ▁topicPartition ▁. ▁topic ▁( ▁) ▁) ▁&& ▁data ▁. ▁topics ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁partitions ▁( ▁) ▁. ▁size ▁( ▁) ▁== ▁1 ▁&& ▁data ▁. ▁topics ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁partitions ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁partition Index ▁( ▁) ▁== ▁topicPartition ▁. ▁partition ▁( ▁) ▁; ▁} ▁static ▁boolean ▁has Valid Topic Partition ▁( ▁End Quorum Epoch ResponseData ▁data ▁, ▁TopicPartition ▁topicPartition ▁) ▁{ ▁return ▁data ▁. ▁topics ▁( ▁) ▁. ▁size ▁( ▁) ▁== ▁1 ▁&& ▁data ▁. ▁topics ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁topicName ▁( ▁) ▁. ▁equals ▁( ▁topicPartition ▁. ▁topic ▁( ▁) ▁) ▁&& ▁data ▁. ▁topics ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁partitions ▁( ▁) ▁. ▁size ▁( ▁) ▁== ▁1 ▁&& ▁data ▁. ▁topics ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁partitions ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁partition Index ▁( ▁) ▁== ▁topicPartition ▁. ▁partition ▁( ▁) ▁; ▁}
▁public ▁final ▁class ▁M acos x Language Helper ▁{ ▁public ▁static ▁Language CompilerSpec Pair ▁getLanguage CompilerSpec Pair ▁( ▁Language Service ▁language Service ▁, ▁int ▁cpu Type ▁, ▁int ▁cpu Sub Type ▁) ▁throws ▁IOException ▁{ ▁Processor ▁AR M ▁= ▁Processor ▁. ▁find Or P o ssi bly Create Processor ▁( ▁STR ▁) ▁; ▁Processor ▁AR M 64 ▁= ▁Processor ▁. ▁find Or P o ssi bly Create Processor ▁( ▁STR ▁) ▁; ▁Processor ▁x 86 ▁= ▁Processor ▁. ▁find Or P o ssi bly Create Processor ▁( ▁STR ▁) ▁; ▁Processor ▁Power PC ▁= ▁Processor ▁. ▁find Or P o ssi bly Create Processor ▁( ▁STR ▁) ▁; ▁Processor ▁processor ▁= ▁null ▁; ▁En di an ▁end ian ▁= ▁null ▁; ▁Integer ▁size ▁= ▁null ▁; ▁String ▁variant ▁= ▁STR ▁; ▁CompilerSpec ID ▁compiler Spec ID ▁= ▁new ▁CompilerSpec ID ▁( ▁STR ▁) ▁; ▁if ▁( ▁cpu Type ▁== ▁Cpu Types ▁. ▁CPU _ TYPE _ AR M ▁) ▁{ ▁processor ▁= ▁AR M ▁; ▁end ian ▁= ▁En di an ▁. ▁LITTLE ▁; ▁if ▁( ▁cpu Sub Type ▁== ▁Cpu Sub Types ▁. ▁CPU _ SUB TYPE _ AR M _ V 6 ▁) ▁{ ▁variant ▁= ▁STR ▁; ▁} ▁else ▁if ▁( ▁cpu Sub Type ▁== ▁Cpu Sub Types ▁. ▁CPU _ SUB TYPE _ AR M _ V 7 ▁|| ▁cpu Sub Type ▁== ▁Cpu Sub Types ▁. ▁CPU _ SUB TYPE _ AR M _ V 7 F ▁|| ▁cpu Sub Type ▁== ▁Cpu Sub Types ▁. ▁CPU _ SUB TYPE _ AR M _ V 7 S ▁|| ▁cpu Sub Type ▁== ▁Cpu Sub Types ▁. ▁CPU _ SUB TYPE _ AR M _ V 7 K ▁|| ▁cpu Sub Type ▁== ▁Cpu Sub Types ▁. ▁CPU _ SUB TYPE _ AR M _ ALL ▁) ▁{ ▁variant ▁= ▁STR ▁; ▁} ▁} ▁else ▁if ▁( ▁cpu Type ▁== ▁Cpu Types ▁. ▁CPU _ TYPE _ X 86 ▁|| ▁cpu Type ▁== ▁Cpu Types ▁. ▁CPU _ TYPE _ X 86 _64 ▁) ▁{ ▁processor ▁= ▁x 86 ▁; ▁end ian ▁= ▁En di an ▁. ▁LITTLE ▁; ▁size ▁= ▁cpu Type ▁== ▁Cpu Types ▁. ▁CPU _ TYPE _ X 86 _64 ▁? ▁64 ▁: ▁32 ▁; ▁compiler Spec ID ▁= ▁new ▁CompilerSpec ID ▁( ▁STR ▁) ▁; ▁} ▁else ▁if ▁( ▁cpu Type ▁== ▁Cpu Types ▁. ▁CPU _ TYPE _ POWER PC ▁|| ▁cpu Type ▁== ▁Cpu Types ▁. ▁CPU _ TYPE _ POWER PC 64 ▁) ▁{ ▁processor ▁= ▁Power PC ▁; ▁end ian ▁= ▁En di an ▁. ▁BIG ▁; ▁size ▁= ▁cpu Type ▁== ▁Cpu Types ▁. ▁CPU _ TYPE _ POWER PC 64 ▁? ▁64 ▁: ▁32 ▁; ▁compiler Spec ID ▁= ▁new ▁CompilerSpec ID ▁( ▁STR ▁) ▁; ▁} ▁else ▁if ▁( ▁cpu Type ▁== ▁Cpu Types ▁. ▁CPU _ TYPE _ AR M _64 ▁) ▁{ ▁processor ▁= ▁AR M 64 ▁; ▁end ian ▁= ▁En di an ▁. ▁LITTLE ▁; ▁size ▁= ▁64 ▁; ▁variant ▁= ▁STR ▁; ▁}
▁class ▁WebSocket Message Broker Stats Tests ▁{ ▁private ▁final ▁WebSocket Message Broker Stats ▁stats ▁= ▁new ▁WebSocket Message Broker Stats ▁( ▁) ▁; ▁@ ▁Test ▁void ▁null Values ▁( ▁) ▁{ ▁String ▁expected ▁= ▁STR ▁+ ▁STR ▁; ▁assertThat ▁( ▁stats ▁) ▁. ▁has ToString ▁( ▁expected ▁) ▁; ▁} ▁@ ▁Test ▁void ▁in bound And Outbound Channel sWith ThreadPool TaskExecutor ▁( ▁) ▁{ ▁ThreadPool TaskExecutor ▁executor ▁= ▁new ▁ThreadPool TaskExecutor ▁( ▁) ▁; ▁executor ▁. ▁after PropertiesSet ▁( ▁) ▁; ▁stats ▁. ▁set Inbound Channel Executor ▁( ▁executor ▁) ▁; ▁stats ▁. ▁set Outbound Channel Executor ▁( ▁executor ▁) ▁; ▁assertThat ▁( ▁stats ▁. ▁getClient Inbound Executor Stats Info ▁( ▁) ▁) ▁. ▁as ▁( ▁STR ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁stats ▁. ▁getClient Outbound Executor Stats Info ▁( ▁) ▁) ▁. ▁as ▁( ▁STR ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁void ▁in bound And Outbound Channel sWith Mock ed TaskExecutor ▁( ▁) ▁{ ▁TaskExecutor ▁executor ▁= ▁mock ▁( ▁TaskExecutor ▁. ▁class ▁) ▁; ▁stats ▁. ▁set Inbound Channel Executor ▁( ▁executor ▁) ▁; ▁stats ▁. ▁set Outbound Channel Executor ▁( ▁executor ▁) ▁; ▁assertThat ▁( ▁stats ▁. ▁getClient Inbound Executor Stats Info ▁( ▁) ▁) ▁. ▁as ▁( ▁STR ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁stats ▁. ▁getClient Outbound Executor Stats Info ▁( ▁) ▁) ▁. ▁as ▁( ▁STR ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁void ▁s ockJs Task Scheduler With ThreadPool Task Scheduler ▁( ▁) ▁{ ▁ThreadPool Task Scheduler ▁scheduler ▁= ▁new ▁ThreadPool Task Scheduler ▁( ▁) ▁; ▁scheduler ▁. ▁after PropertiesSet ▁( ▁) ▁; ▁stats ▁. ▁setS ockJs Task Scheduler ▁( ▁scheduler ▁) ▁; ▁assertThat ▁( ▁stats ▁. ▁getS ockJs Task Scheduler Stats Info ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁void ▁s ockJs Task Scheduler With Mock ed Task Scheduler ▁( ▁) ▁{ ▁Task Scheduler ▁scheduler ▁= ▁mock ▁( ▁Task Scheduler ▁. ▁class ▁) ▁; ▁stats ▁. ▁setS ockJs Task Scheduler ▁( ▁scheduler ▁) ▁; ▁assertThat ▁( ▁stats ▁. ▁getS ockJs Task Scheduler Stats Info ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁} ▁}
▁public ▁class ▁Snapshot Shards Stats ▁implements ▁ToXContent Object ▁{ ▁private ▁int ▁init ializing Shards ▁; ▁private ▁int ▁started Shards ▁; ▁private ▁int ▁final izing Shards ▁; ▁private ▁int ▁done Shards ▁; ▁private ▁int ▁failed Shards ▁; ▁private ▁int ▁total Shards ▁; ▁Snapshot Shards Stats ▁( ▁Collection ▁< ▁Snapshot Index Shard Status ▁> ▁shards ▁) ▁{ ▁for ▁( ▁Snapshot Index Shard Status ▁shard ▁: ▁shards ▁) ▁{ ▁total Shards ▁++ ▁; ▁switch ▁( ▁shard ▁. ▁getSt age ▁( ▁) ▁) ▁{ ▁case ▁INIT ▁: ▁init ializing Shards ▁++ ▁; ▁break ▁; ▁case ▁STARTED ▁: ▁started Shards ▁++ ▁; ▁break ▁; ▁case ▁FIN ALI Z E ▁: ▁final izing Shards ▁++ ▁; ▁break ▁; ▁case ▁D ONE ▁: ▁done Shards ▁++ ▁; ▁break ▁; ▁case ▁FAILURE ▁: ▁failed Shards ▁++ ▁; ▁break ▁; ▁default ▁: ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁shard ▁. ▁getSt age ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁public ▁Snapshot Shards Stats ▁( ▁int ▁init ializing Shards ▁, ▁int ▁started Shards ▁, ▁int ▁final izing Shards ▁, ▁int ▁done Shards ▁, ▁int ▁failed Shards ▁, ▁int ▁total Shards ▁) ▁{ ▁this ▁. ▁init ializing Shards ▁= ▁init ializing Shards ▁; ▁this ▁. ▁started Shards ▁= ▁started Shards ▁; ▁this ▁. ▁final izing Shards ▁= ▁final izing Shards ▁; ▁this ▁. ▁done Shards ▁= ▁done Shards ▁; ▁this ▁. ▁failed Shards ▁= ▁failed Shards ▁; ▁this ▁. ▁total Shards ▁= ▁total Shards ▁; ▁} ▁public ▁int ▁getInit ializing Shards ▁( ▁) ▁{ ▁return ▁init ializing Shards ▁; ▁} ▁public ▁int ▁get Started Shards ▁( ▁) ▁{ ▁return ▁started Shards ▁; ▁} ▁public ▁int ▁getF inal izing Shards ▁( ▁) ▁{ ▁return ▁final izing Shards ▁; ▁} ▁public ▁int ▁getD one Shards ▁( ▁) ▁{ ▁return ▁done Shards ▁; ▁} ▁public ▁int ▁getFailed Shards ▁( ▁) ▁{ ▁return ▁failed Shards ▁; ▁} ▁public ▁int ▁getTotal Shards ▁( ▁) ▁{ ▁return ▁total Shards ▁; ▁} ▁static ▁final ▁class ▁Fields ▁{ ▁static ▁final ▁String ▁SHAR DS _ STATS ▁= ▁STR ▁; ▁static ▁final ▁String ▁INIT IALI Z ING ▁= ▁STR ▁; ▁static ▁final ▁String ▁STARTED ▁= ▁STR ▁; ▁static ▁final ▁String ▁FIN ALI Z ING ▁= ▁STR ▁; ▁static ▁final ▁String ▁D ONE ▁= ▁STR ▁; ▁static ▁final ▁String ▁FAILED ▁= ▁STR ▁; ▁static ▁final ▁String ▁TOTAL ▁= ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁XContentBuilder ▁toXContent ▁( ▁XContentBuilder ▁builder ▁, ▁ToXContent ▁. ▁Params ▁params ▁) ▁throws ▁IOException ▁{ ▁builder ▁. ▁startObject ▁( ▁) ▁; ▁{ ▁builder ▁. ▁field ▁( ▁Fields ▁. ▁INIT IALI Z ING ▁, ▁getInit ializing Shards ▁( ▁) ▁) ▁; ▁builder ▁. ▁field ▁( ▁Fields ▁. ▁STARTED ▁, ▁get Started Shards ▁( ▁) ▁) ▁; ▁builder ▁. ▁field ▁( ▁Fields ▁. ▁FIN ALI Z ING ▁, ▁getF inal izing Shards ▁( ▁) ▁) ▁; ▁builder ▁. ▁field ▁( ▁Fields ▁. ▁D ONE ▁, ▁getD one Shards ▁( ▁) ▁) ▁; ▁builder ▁. ▁field ▁( ▁Fields ▁. ▁FAILED ▁, ▁getFailed Shards ▁( ▁) ▁) ▁; ▁builder ▁. ▁field ▁( ▁Fields ▁. ▁TOTAL ▁, ▁getTotal Shards ▁( ▁) ▁) ▁; ▁} ▁builder ▁. ▁endObject ▁( ▁) ▁; ▁return ▁builder ▁;
▁public ▁interface ▁F ocus Utils ▁{ ▁static ▁boolean ▁is Focus In ▁( ▁Component ▁c ▁) ▁{ ▁Component ▁owner ▁= ▁Key board Focus Manager ▁. ▁getCurrent Keyboard Focus Manager ▁( ▁) ▁. ▁getF ocus Owner ▁( ▁) ▁; ▁if ▁( ▁c ▁== ▁owner ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁owner ▁== ▁null ▁) ▁{ ▁return ▁false ▁; ▁} ▁return ▁Swing Utilities ▁. ▁is Desc ending From ▁( ▁owner ▁, ▁c ▁) ▁; ▁} ▁}
▁Cre ation Record ▁record ▁= ▁new ▁Cre ation Record ▁( ▁object ▁) ▁; ▁Cre ation Record ▁exists ▁= ▁valid ▁. ▁put ▁( ▁object ▁, ▁record ▁) ▁; ▁off ▁. ▁catch ing ▁( ▁( ▁) ▁-> ▁{ ▁if ▁( ▁exists ▁!= ▁null ▁) ▁{ ▁Msg ▁. ▁error ▁( ▁this ▁, ▁STR ▁, ▁exists ▁. ▁stack ▁) ▁; ▁Msg ▁. ▁error ▁( ▁this ▁, ▁STR ▁, ▁record ▁. ▁stack ▁) ▁; ▁if ▁( ▁exists ▁. ▁object ▁== ▁object ▁) ▁{ ▁fail ▁( ▁STR ▁+ ▁object ▁. ▁getJoin ed Path ▁( ▁STR ▁) ▁) ▁; ▁} ▁else ▁{ ▁fail ▁( ▁STR ▁+ ▁exists ▁. ▁object ▁+ ▁STR ▁+ ▁object ▁) ▁; ▁} ▁} ▁validate Callback Thread ▁( ▁STR ▁) ▁; ▁validate Object ▁( ▁STR ▁, ▁object ▁) ▁; ▁} ▁) ▁; ▁} ▁@ ▁Override ▁public ▁synchronized ▁void ▁event ▁( ▁TargetObject ▁object ▁, ▁Target Thread ▁event Thread ▁, ▁Target EventType ▁type ▁, ▁String ▁description ▁, ▁List ▁< ▁Object ▁> ▁parameters ▁) ▁{ ▁if ▁( ▁log ▁) ▁{ ▁Msg ▁. ▁info ▁( ▁this ▁, ▁STR ▁+ ▁object ▁+ ▁STR ▁+ ▁event Thread ▁+ ▁STR ▁+ ▁type ▁+ ▁STR ▁+ ▁description ▁+ ▁STR ▁+ ▁parameters ▁+ ▁STR ▁) ▁; ▁} ▁off ▁. ▁catch ing ▁( ▁( ▁) ▁-> ▁{ ▁validate Callback Thread ▁( ▁STR ▁+ ▁type ▁+ ▁STR ▁) ▁; ▁validate Object ▁( ▁STR ▁+ ▁type ▁+ ▁STR ▁, ▁object ▁) ▁; ▁if ▁( ▁type ▁== ▁Target EventType ▁. ▁THREAD _ CREATED ▁|| ▁type ▁== ▁Target EventType ▁. ▁THREAD _ EX IT ED ▁) ▁{ ▁validate Object ▁( ▁STR ▁+ ▁type ▁+ ▁STR ▁, ▁event Thread ▁) ▁; ▁} ▁else ▁{ ▁validate Object Optional ▁( ▁STR ▁+ ▁type ▁+ ▁STR ▁, ▁event Thread ▁) ▁; ▁} ▁assertNotNull ▁( ▁type ▁) ▁; ▁assertNotNull ▁( ▁description ▁) ▁; ▁validate Objects In Collection ▁( ▁STR ▁+ ▁type ▁+ ▁STR ▁, ▁parameters ▁) ▁; ▁} ▁) ▁; ▁} ▁@ ▁Override ▁public ▁synchronized ▁void ▁invalidate Cache Requested ▁( ▁TargetObject ▁object ▁) ▁{ ▁if ▁( ▁log ▁) ▁{ ▁Msg ▁. ▁info ▁( ▁this ▁, ▁STR ▁+ ▁object ▁+ ▁STR ▁) ▁; ▁} ▁off ▁. ▁catch ing ▁( ▁( ▁) ▁-> ▁{ ▁validate Callback Thread ▁( ▁STR ▁) ▁; ▁validate Object ▁( ▁STR ▁, ▁object ▁) ▁; ▁} ▁) ▁; ▁} ▁@ ▁Override ▁public ▁synchronized ▁void ▁invalid ated ▁( ▁TargetObject ▁object ▁, ▁TargetObject ▁branch ▁, ▁String ▁reason ▁) ▁{ ▁if ▁( ▁log ▁) ▁{ ▁Msg ▁. ▁info ▁( ▁this ▁, ▁STR ▁+ ▁object ▁+ ▁STR ▁+ ▁branch ▁+ ▁STR ▁+ ▁reason ▁+ ▁STR ▁) ▁; ▁} ▁off ▁. ▁catch ing ▁( ▁( ▁) ▁-> ▁{ ▁validate Callback Thread ▁( ▁STR ▁) ▁; ▁validate Object ▁( ▁STR ▁, ▁object ▁) ▁; ▁valid ▁. ▁remove ▁( ▁object ▁) ▁; ▁validate Invalid Object ▁( ▁STR ▁, ▁branch ▁) ▁; ▁assertNotNull ▁( ▁reason ▁) ▁; ▁} ▁) ▁; ▁} ▁@ ▁Override ▁public ▁synchronized ▁void ▁memory Read Error ▁( ▁TargetObject ▁memory ▁, ▁AddressRange ▁range ▁, ▁Debugger Memory AccessException ▁e ▁) ▁{ ▁if ▁( ▁log ▁) ▁{ ▁Msg ▁. ▁info ▁( ▁this ▁, ▁STR ▁+ ▁memory ▁+ ▁STR ▁+ ▁range ▁+ ▁STR ▁+ ▁e ▁+ ▁STR ▁) ▁; ▁}
▁public ▁class ▁TrainedModel Deployment Task ▁extends ▁Alloc ated Persistent Task ▁implements ▁Start TrainedModel Deployment Action ▁. ▁Task Matcher ▁{ ▁private ▁static ▁final ▁Logger ▁logger ▁= ▁LogManager ▁. ▁getLogger ▁( ▁TrainedModel Deployment Task ▁. ▁class ▁) ▁; ▁private ▁final ▁Task Params ▁params ▁; ▁private ▁volatile ▁Deployment Manager ▁manager ▁; ▁public ▁TrainedModel Deployment Task ▁( ▁long ▁id ▁, ▁String ▁type ▁, ▁String ▁action ▁, ▁TaskId ▁parent Task ▁, ▁Map ▁< ▁String ▁, ▁String ▁> ▁headers ▁, ▁Task Params ▁task Params ▁) ▁{ ▁super ▁( ▁id ▁, ▁type ▁, ▁action ▁, ▁Ml Tasks ▁. ▁TR AIN ED _ MODE L _ DE P LO Y MENT _ TASK _ ID _ PREFIX ▁+ ▁task Params ▁. ▁getModel Id ▁( ▁) ▁, ▁parent Task ▁, ▁headers ▁) ▁; ▁this ▁. ▁params ▁= ▁task Params ▁; ▁} ▁public ▁String ▁getModel Id ▁( ▁) ▁{ ▁return ▁params ▁. ▁getModel Id ▁( ▁) ▁; ▁} ▁public ▁String ▁getIndex ▁( ▁) ▁{ ▁return ▁params ▁. ▁getIndex ▁( ▁) ▁; ▁} ▁public ▁long ▁estimate MemoryUsage Bytes ▁( ▁) ▁{ ▁return ▁params ▁. ▁estimate MemoryUsage Bytes ▁( ▁) ▁; ▁} ▁public ▁void ▁stop ▁( ▁String ▁reason ▁) ▁{ ▁logger ▁. ▁debug ▁( ▁STR ▁, ▁getModel Id ▁( ▁) ▁, ▁reason ▁) ▁; ▁assert ▁manager ▁!= ▁null ▁: ▁STR ▁; ▁manager ▁. ▁stop Deployment ▁( ▁this ▁) ▁; ▁mark As Completed ▁( ▁) ▁; ▁} ▁public ▁void ▁set Deployment Manager ▁( ▁Deployment Manager ▁manager ▁) ▁{ ▁this ▁. ▁manager ▁= ▁manager ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁on Cancelled ▁( ▁) ▁{ ▁String ▁reason ▁= ▁getReason Cancelled ▁( ▁) ▁; ▁stop ▁( ▁reason ▁) ▁; ▁} ▁public ▁void ▁infer ▁( ▁String ▁input ▁, ▁TimeValue ▁timeout ▁, ▁ActionListener ▁< ▁Inference Results ▁> ▁listener ▁) ▁{ ▁manager ▁. ▁infer ▁( ▁this ▁, ▁input ▁, ▁timeout ▁, ▁listener ▁) ▁; ▁} ▁}
▁public ▁class ▁Delete Topics Result Test ▁{ ▁@ ▁Test ▁public ▁void ▁test Delete Topics Result With Names ▁( ▁) ▁{ ▁KafkaFutureImpl ▁< ▁Void ▁> ▁future ▁= ▁new ▁KafkaFutureImpl ▁< ▁> ▁( ▁) ▁; ▁future ▁. ▁complete ▁( ▁null ▁) ▁; ▁Map ▁< ▁String ▁, ▁KafkaFuture ▁< ▁Void ▁> ▁> ▁topic Names ▁= ▁Collections ▁. ▁singletonMap ▁( ▁STR ▁, ▁future ▁) ▁; ▁Delete Topics Result ▁topicName Futures ▁= ▁Delete Topics Result ▁. ▁of Topic Names ▁( ▁topic Names ▁) ▁; ▁assertEquals ▁( ▁topic Names ▁, ▁topicName Futures ▁. ▁topicName Values ▁( ▁) ▁) ▁; ▁assertNull ▁( ▁topicName Futures ▁. ▁topic Id Values ▁( ▁) ▁) ▁; ▁assertTrue ▁( ▁topicName Futures ▁. ▁all ▁( ▁) ▁. ▁isDone ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Delete Topics Result With Ids ▁( ▁) ▁{ ▁KafkaFutureImpl ▁< ▁Void ▁> ▁future ▁= ▁new ▁KafkaFutureImpl ▁< ▁> ▁( ▁) ▁; ▁future ▁. ▁complete ▁( ▁null ▁) ▁; ▁Map ▁< ▁Uuid ▁, ▁KafkaFuture ▁< ▁Void ▁> ▁> ▁topic Ids ▁= ▁Collections ▁. ▁singletonMap ▁( ▁Uuid ▁. ▁random Uuid ▁( ▁) ▁, ▁future ▁) ▁; ▁Delete Topics Result ▁topic Id Futures ▁= ▁Delete Topics Result ▁. ▁of Topic Ids ▁( ▁topic Ids ▁) ▁; ▁assertEquals ▁( ▁topic Ids ▁, ▁topic Id Futures ▁. ▁topic Id Values ▁( ▁) ▁) ▁; ▁assertNull ▁( ▁topic Id Futures ▁. ▁topicName Values ▁( ▁) ▁) ▁; ▁assertTrue ▁( ▁topic Id Futures ▁. ▁all ▁( ▁) ▁. ▁isDone ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testInvalid Configurations ▁( ▁) ▁{ ▁assertThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁Delete Topics Result ▁( ▁null ▁, ▁null ▁) ▁) ▁; ▁assertThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁Delete Topics Result ▁( ▁Collections ▁. ▁emptyMap ▁( ▁) ▁, ▁Collections ▁. ▁emptyMap ▁( ▁) ▁) ▁) ▁; ▁} ▁}
▁Optional ▁< ▁Window Segment ▁> ▁window Segment ▁= ▁Select Statement Handler ▁. ▁getWindow Segment ▁( ▁select Statement ▁) ▁; ▁assertTrue ▁( ▁window Segment ▁. ▁isPresent ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁assertGet Window Segment Without Window Segment For My SQL ▁( ▁) ▁{ ▁MySQL Select Statement ▁select Statement ▁= ▁new ▁MySQL Select Statement ▁( ▁) ▁; ▁Optional ▁< ▁Window Segment ▁> ▁window Segment ▁= ▁Select Statement Handler ▁. ▁getWindow Segment ▁( ▁select Statement ▁) ▁; ▁assertFalse ▁( ▁window Segment ▁. ▁isPresent ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁assertGet Window Segment With Window Segment For Postgre SQL ▁( ▁) ▁{ ▁PostgreSQL Select Statement ▁select Statement ▁= ▁new ▁PostgreSQL Select Statement ▁( ▁) ▁; ▁select Statement ▁. ▁set Window ▁( ▁new ▁Window Segment ▁( ▁0 ▁, ▁0 ▁) ▁) ▁; ▁Optional ▁< ▁Window Segment ▁> ▁window Segment ▁= ▁Select Statement Handler ▁. ▁getWindow Segment ▁( ▁select Statement ▁) ▁; ▁assertTrue ▁( ▁window Segment ▁. ▁isPresent ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁assertGet Window Segment Without Window Segment For Postgre SQL ▁( ▁) ▁{ ▁PostgreSQL Select Statement ▁select Statement ▁= ▁new ▁PostgreSQL Select Statement ▁( ▁) ▁; ▁Optional ▁< ▁Window Segment ▁> ▁window Segment ▁= ▁Select Statement Handler ▁. ▁getWindow Segment ▁( ▁select Statement ▁) ▁; ▁assertFalse ▁( ▁window Segment ▁. ▁isPresent ▁( ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁Sph ere Stack ▁extends ▁Box 2 D Test ▁{ ▁int ▁e _ count ▁= ▁10 ▁; ▁@ ▁Override ▁protected ▁void ▁create World ▁( ▁W orld ▁world ▁) ▁{ ▁{ ▁Body Def ▁bd ▁= ▁new ▁Body Def ▁( ▁) ▁; ▁Body ▁g round ▁= ▁world ▁. ▁create Body ▁( ▁bd ▁) ▁; ▁Edge Shape ▁shape ▁= ▁new ▁Edge Shape ▁( ▁) ▁; ▁shape ▁. ▁set ▁( ▁new ▁Vector 2 ▁( ▁- ▁40 ▁, ▁0 ▁) ▁, ▁new ▁Vector 2 ▁( ▁40 ▁, ▁0 ▁) ▁) ▁; ▁g round ▁. ▁create Fixture ▁( ▁shape ▁, ▁0 ▁) ▁; ▁shape ▁. ▁dispose ▁( ▁) ▁; ▁} ▁{ ▁Circle Shape ▁shape ▁= ▁new ▁Circle Shape ▁( ▁) ▁; ▁shape ▁. ▁setR adius ▁( ▁1.0 f ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁e _ count ▁; ▁i ▁++ ▁) ▁{ ▁Body Def ▁bd ▁= ▁new ▁Body Def ▁( ▁) ▁; ▁bd ▁. ▁type ▁= ▁Body Type ▁. ▁Dynamic Body ▁; ▁bd ▁. ▁position ▁. ▁set ▁( ▁0 ▁, ▁4.0 f ▁+ ▁3.0 f ▁ * ▁i ▁) ▁; ▁Body ▁body ▁= ▁world ▁. ▁create Body ▁( ▁bd ▁) ▁; ▁body ▁. ▁create Fixture ▁( ▁shape ▁, ▁1.0 f ▁) ▁; ▁} ▁shape ▁. ▁dispose ▁( ▁) ▁; ▁} ▁} ▁}
▁public ▁class ▁Default Stack Recorder ▁implements ▁Managed Stack Recorder ▁{ ▁protected ▁static ▁int ▁getFrame Level ▁( ▁Target StackFrame ▁frame ▁) ▁{ ▁return ▁Integer ▁. ▁decode ▁( ▁frame ▁. ▁getIndex ▁( ▁) ▁) ▁; ▁} ▁private ▁NavigableMap ▁< ▁Integer ▁, ▁Target StackFrame ▁> ▁stack ▁= ▁Collections ▁. ▁synchronized Navig able Map ▁( ▁new ▁TreeMap ▁< ▁> ▁( ▁) ▁) ▁; ▁private ▁final ▁TraceThread ▁thread ▁; ▁private ▁final ▁Default Trace Recorder ▁recorder ▁; ▁private ▁final ▁Trace ▁trace ▁; ▁private ▁final ▁Trace Stack Manager ▁stack Manager ▁; ▁public ▁Default Stack Recorder ▁( ▁TraceThread ▁thread ▁, ▁Default Trace Recorder ▁recorder ▁) ▁{ ▁this ▁. ▁thread ▁= ▁thread ▁; ▁this ▁. ▁recorder ▁= ▁recorder ▁; ▁this ▁. ▁trace ▁= ▁recorder ▁. ▁getTrace ▁( ▁) ▁; ▁this ▁. ▁stack Manager ▁= ▁trace ▁. ▁getStack Manager ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁offer StackFrame ▁( ▁Target StackFrame ▁frame ▁) ▁{ ▁record Frame ▁( ▁frame ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁record Stack ▁( ▁) ▁{ ▁long ▁snap ▁= ▁recorder ▁. ▁getS nap ▁( ▁) ▁; ▁Debugger Memory Mapper ▁mm ▁= ▁recorder ▁. ▁getMemory Mapper ▁( ▁) ▁; ▁Map ▁< ▁Integer ▁, ▁Address ▁> ▁pcs By Level ▁; ▁synchronized ▁( ▁stack ▁) ▁{ ▁pcs By Level ▁= ▁stack ▁. ▁entrySet ▁( ▁) ▁. ▁stream ▁( ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toMap ▁( ▁e ▁-> ▁e ▁. ▁getKey ▁( ▁) ▁, ▁e ▁-> ▁{ ▁return ▁mm ▁. ▁target To Trace ▁( ▁e ▁. ▁getValue ▁( ▁) ▁. ▁getProgram Counter ▁( ▁) ▁) ▁; ▁} ▁) ▁) ▁; ▁} ▁recorder ▁. ▁par Tx ▁. ▁execute ▁( ▁STR ▁, ▁( ▁) ▁-> ▁{ ▁Trace Stack ▁trace Stack ▁= ▁stack Manager ▁. ▁getStack ▁( ▁thread ▁, ▁snap ▁, ▁true ▁) ▁; ▁trace Stack ▁. ▁set Depth ▁( ▁stack Depth ▁( ▁) ▁, ▁false ▁) ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Integer ▁, ▁Address ▁> ▁ent ▁: ▁pcs By Level ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁do Record Frame ▁( ▁trace Stack ▁, ▁ent ▁. ▁getKey ▁( ▁) ▁, ▁ent ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁} ▁, ▁thread ▁. ▁getPath ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁pop Stack ▁( ▁) ▁{ ▁long ▁snap ▁= ▁recorder ▁. ▁getS nap ▁( ▁) ▁; ▁recorder ▁. ▁par Tx ▁. ▁execute ▁( ▁STR ▁, ▁( ▁) ▁-> ▁{ ▁Trace Stack ▁trace Stack ▁= ▁stack Manager ▁. ▁getStack ▁( ▁thread ▁, ▁snap ▁, ▁true ▁) ▁; ▁trace Stack ▁. ▁set Depth ▁( ▁stack Depth ▁( ▁) ▁, ▁false ▁) ▁; ▁} ▁, ▁thread ▁. ▁getPath ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁do Record Frame ▁( ▁Trace Stack ▁trace Stack ▁, ▁int ▁frame Level ▁, ▁Address ▁pc ▁) ▁{ ▁Trace StackFrame ▁trace Frame ▁= ▁trace Stack ▁. ▁getFrame ▁( ▁frame Level ▁, ▁true ▁) ▁; ▁trace Frame ▁. ▁set Program Counter ▁( ▁pc ▁) ▁; ▁} ▁public ▁void ▁record Frame ▁( ▁Target StackFrame ▁frame ▁) ▁{ ▁long ▁snap ▁= ▁recorder ▁. ▁getS nap ▁( ▁) ▁; ▁synchronized ▁( ▁stack ▁) ▁{ ▁stack ▁. ▁put ▁( ▁getFrame Level ▁( ▁frame ▁) ▁, ▁frame ▁) ▁; ▁}
▁@ ▁Public ▁@ ▁Evolving ▁public ▁abstract ▁class ▁Update Node Resource Request ▁{ ▁@ ▁Public ▁@ ▁Evolving ▁public ▁static ▁Update Node Resource Request ▁newInstance ▁( ▁Map ▁< ▁NodeId ▁, ▁Resource Option ▁> ▁node Resource Map ▁) ▁{ ▁Update Node Resource Request ▁request ▁= ▁Records ▁. ▁newRecord ▁( ▁Update Node Resource Request ▁. ▁class ▁) ▁; ▁request ▁. ▁setNode Resource Map ▁( ▁node Resource Map ▁) ▁; ▁return ▁request ▁; ▁} ▁@ ▁Public ▁@ ▁Evolving ▁public ▁abstract ▁Map ▁< ▁NodeId ▁, ▁Resource Option ▁> ▁getNode Resource Map ▁( ▁) ▁; ▁@ ▁Public ▁@ ▁Evolving ▁public ▁abstract ▁void ▁setNode Resource Map ▁( ▁Map ▁< ▁NodeId ▁, ▁Resource Option ▁> ▁node Resource Map ▁) ▁; ▁}
▁verify ▁( ▁restTemplate ▁, ▁never ▁( ▁) ▁) ▁. ▁exchange ▁( ▁eq ▁( ▁service Three ▁+ ▁STR ▁+ ▁path ▁) ▁, ▁eq ▁( ▁HttpMethod ▁. ▁GET ▁) ▁, ▁any ▁( ▁HttpEntity ▁. ▁class ▁) ▁, ▁eq ▁( ▁Object ▁. ▁class ▁) ▁) ▁; ▁assertEquals ▁( ▁result ▁, ▁actual Result ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Post Socket Timeout Not Retry ▁( ▁) ▁{ ▁ResponseEntity ▁some Entity ▁= ▁mock ▁( ▁ResponseEntity ▁. ▁class ▁) ▁; ▁when ▁( ▁some Entity ▁. ▁getBody ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁result ▁) ▁; ▁when ▁( ▁service Address Locator ▁. ▁getService List ▁( ▁any ▁( ▁) ▁) ▁) ▁. ▁thenReturn ▁( ▁Arrays ▁. ▁asList ▁( ▁mock Service ▁( ▁service One ▁) ▁, ▁mock Service ▁( ▁service Two ▁) ▁, ▁mock Service ▁( ▁service Three ▁) ▁) ▁) ▁; ▁when ▁( ▁restTemplate ▁. ▁exchange ▁( ▁eq ▁( ▁service One ▁+ ▁STR ▁+ ▁path ▁) ▁, ▁eq ▁( ▁HttpMethod ▁. ▁POST ▁) ▁, ▁any ▁( ▁HttpEntity ▁. ▁class ▁) ▁, ▁eq ▁( ▁Object ▁. ▁class ▁) ▁) ▁) ▁. ▁thenThrow ▁( ▁socket TimeoutException ▁) ▁; ▁when ▁( ▁restTemplate ▁. ▁exchange ▁( ▁eq ▁( ▁service Two ▁+ ▁STR ▁+ ▁path ▁) ▁, ▁eq ▁( ▁HttpMethod ▁. ▁POST ▁) ▁, ▁any ▁( ▁HttpEntity ▁. ▁class ▁) ▁, ▁eq ▁( ▁Object ▁. ▁class ▁) ▁) ▁) ▁. ▁thenReturn ▁( ▁some Entity ▁) ▁; ▁Throwable ▁exception ▁= ▁null ▁; ▁Object ▁actual Result ▁= ▁null ▁; ▁try ▁{ ▁actual Result ▁= ▁retry able RestTemplate ▁. ▁post ▁( ▁Env ▁. ▁DE V ▁, ▁path ▁, ▁request ▁, ▁Object ▁. ▁class ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁ex ▁) ▁{ ▁exception ▁= ▁ex ▁; ▁} ▁assertNull ▁( ▁actual Result ▁) ▁; ▁assertSame ▁( ▁socket TimeoutException ▁, ▁exception ▁) ▁; ▁verify ▁( ▁restTemplate ▁, ▁times ▁( ▁1 ▁) ▁) ▁. ▁exchange ▁( ▁eq ▁( ▁service One ▁+ ▁STR ▁+ ▁path ▁) ▁, ▁eq ▁( ▁HttpMethod ▁. ▁POST ▁) ▁, ▁any ▁( ▁HttpEntity ▁. ▁class ▁) ▁, ▁eq ▁( ▁Object ▁. ▁class ▁) ▁) ▁; ▁verify ▁( ▁restTemplate ▁, ▁never ▁( ▁) ▁) ▁. ▁exchange ▁( ▁eq ▁( ▁service Two ▁+ ▁STR ▁+ ▁path ▁) ▁, ▁eq ▁( ▁HttpMethod ▁. ▁POST ▁) ▁, ▁any ▁( ▁HttpEntity ▁. ▁class ▁) ▁, ▁eq ▁( ▁Object ▁. ▁class ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Delete ▁( ▁) ▁{ ▁ResponseEntity ▁some Entity ▁= ▁mock ▁( ▁ResponseEntity ▁. ▁class ▁) ▁; ▁when ▁( ▁service Address Locator ▁. ▁getService List ▁( ▁any ▁( ▁) ▁) ▁) ▁. ▁thenReturn ▁( ▁Arrays ▁. ▁asList ▁( ▁mock Service ▁( ▁service One ▁) ▁, ▁mock Service ▁( ▁service Two ▁) ▁, ▁mock Service ▁( ▁service Three ▁) ▁) ▁) ▁; ▁when ▁( ▁restTemplate ▁. ▁exchange ▁( ▁eq ▁( ▁service One ▁+ ▁STR ▁+ ▁path ▁) ▁, ▁eq ▁( ▁HttpMethod ▁. ▁DELETE ▁) ▁, ▁any ▁( ▁HttpEntity ▁. ▁class ▁) ▁, ▁( ▁Class ▁< ▁Object ▁> ▁) ▁isNull ▁( ▁) ▁) ▁) ▁. ▁thenReturn ▁( ▁some Entity ▁) ▁; ▁retry able RestTemplate ▁. ▁delete ▁( ▁Env ▁. ▁DE V ▁, ▁path ▁) ▁;
▁public ▁class ▁Service Discovery Migration Invoker ▁< ▁T ▁> ▁extends ▁Migration Invoker ▁< ▁T ▁> ▁{ ▁private ▁static ▁final ▁Logger ▁logger ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Service Discovery Migration Invoker ▁. ▁class ▁) ▁; ▁public ▁Service Discovery Migration Invoker ▁( ▁Registry Protocol ▁registry Protocol ▁, ▁Cluster ▁cluster ▁, ▁Registry ▁registry ▁, ▁Class ▁< ▁T ▁> ▁type ▁, ▁URL ▁url ▁, ▁URL ▁consumer Url ▁) ▁{ ▁super ▁( ▁registry Protocol ▁, ▁cluster ▁, ▁registry ▁, ▁type ▁, ▁url ▁, ▁consumer Url ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is Service Discovery ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁migrate To Force Interface Invoker ▁( ▁Migration Rule ▁new Rule ▁) ▁{ ▁CountDownLatch ▁latch ▁= ▁new ▁CountDownLatch ▁( ▁0 ▁) ▁; ▁refresh Service Discovery Invoker ▁( ▁latch ▁) ▁; ▁setCurrent Available Invoker ▁( ▁getService Discovery Invoker ▁( ▁) ▁) ▁; ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁void ▁migrate To Application First Invoker ▁( ▁Migration Rule ▁new Rule ▁) ▁{ ▁CountDownLatch ▁latch ▁= ▁new ▁CountDownLatch ▁( ▁0 ▁) ▁; ▁refresh Service Discovery Invoker ▁( ▁latch ▁) ▁; ▁setCurrent Available Invoker ▁( ▁getService Discovery Invoker ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Result ▁invoke ▁( ▁Invocation ▁invocation ▁) ▁throws ▁RpcException ▁{ ▁Cluster Invoker ▁< ▁T ▁> ▁invoker ▁= ▁getService Discovery Invoker ▁( ▁) ▁; ▁if ▁( ▁invoker ▁== ▁null ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁+ ▁invocation ▁. ▁getServiceName ▁( ▁) ▁) ▁; ▁} ▁return ▁invoker ▁. ▁invoke ▁( ▁invocation ▁) ▁; ▁} ▁}
▁public ▁final ▁class ▁Call MetaData Provider Factory ▁{ ▁public ▁static ▁final ▁List ▁< ▁String ▁> ▁supported Database Product sFor Procedure s ▁= ▁Arrays ▁. ▁asList ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁public ▁static ▁final ▁List ▁< ▁String ▁> ▁supported Database Product sFor Functions ▁= ▁Arrays ▁. ▁asList ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁private ▁static ▁final ▁Log ▁logger ▁= ▁LogFactory ▁. ▁getLog ▁( ▁Call MetaData Provider Factory ▁. ▁class ▁) ▁; ▁private ▁Call MetaData Provider Factory ▁( ▁) ▁{ ▁} ▁public ▁static ▁Call MetaData Provider ▁create MetaData Provider ▁( ▁DataSource ▁dataSource ▁, ▁final ▁Call MetaData Context ▁context ▁) ▁{ ▁try ▁{ ▁return ▁JdbcUtils ▁. ▁extract Database MetaData ▁( ▁dataSource ▁, ▁database MetaData ▁-> ▁{ ▁String ▁database Product Name ▁= ▁JdbcUtils ▁. ▁common DatabaseName ▁( ▁database MetaData ▁. ▁getDatabase Product Name ▁( ▁) ▁) ▁; ▁boolean ▁access Procedure Column MetaData ▁= ▁context ▁. ▁is Access Call Parameter MetaData ▁( ▁) ▁; ▁if ▁( ▁context ▁. ▁is Function ▁( ▁) ▁) ▁{ ▁if ▁( ▁! ▁supported Database Product sFor Functions ▁. ▁contains ▁( ▁database Product Name ▁) ▁) ▁{ ▁if ▁( ▁logger ▁. ▁isInfoEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁info ▁( ▁database Product Name ▁+ ▁STR ▁+ ▁STR ▁+ ▁supported Database Product sFor Functions ▁) ▁; ▁} ▁if ▁( ▁access Procedure Column MetaData ▁) ▁{ ▁logger ▁. ▁info ▁( ▁STR ▁) ▁; ▁access Procedure Column MetaData ▁= ▁false ▁; ▁} ▁} ▁} ▁else ▁{ ▁if ▁( ▁! ▁supported Database Product sFor Procedure s ▁. ▁contains ▁( ▁database Product Name ▁) ▁) ▁{ ▁if ▁( ▁logger ▁. ▁isInfoEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁info ▁( ▁database Product Name ▁+ ▁STR ▁+ ▁STR ▁+ ▁supported Database Product sFor Procedure s ▁) ▁; ▁} ▁if ▁( ▁access Procedure Column MetaData ▁) ▁{ ▁logger ▁. ▁info ▁( ▁STR ▁) ▁; ▁access Procedure Column MetaData ▁= ▁false ▁; ▁} ▁} ▁} ▁Call MetaData Provider ▁provider ▁; ▁if ▁( ▁STR ▁. ▁equals ▁( ▁database Product Name ▁) ▁) ▁{ ▁provider ▁= ▁new ▁Oracle Call MetaData Provider ▁( ▁database MetaData ▁) ▁; ▁} ▁else ▁if ▁( ▁STR ▁. ▁equals ▁( ▁database Product Name ▁) ▁) ▁{ ▁provider ▁= ▁new ▁Postgre s Call MetaData Provider ▁( ▁( ▁database MetaData ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁STR ▁. ▁equals ▁( ▁database Product Name ▁) ▁) ▁{ ▁provider ▁= ▁new ▁D er by Call MetaData Provider ▁( ▁( ▁database MetaData ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁STR ▁. ▁equals ▁( ▁database Product Name ▁) ▁) ▁{ ▁provider ▁= ▁new ▁Db 2 Call MetaData Provider ▁( ▁( ▁database MetaData ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁STR ▁. ▁equals ▁( ▁database Product Name ▁) ▁) ▁{ ▁provider ▁= ▁new ▁H ana Call MetaData Provider ▁( ▁( ▁database MetaData ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁STR ▁. ▁equals ▁( ▁database Product Name ▁) ▁) ▁{ ▁provider ▁= ▁new ▁Sql Server Call MetaData Provider ▁( ▁( ▁database MetaData ▁) ▁) ▁; ▁}
▁public ▁abstract ▁class ▁Oracle Trigger ▁< ▁PAR ENT ▁extends ▁DBSObject ▁> ▁extends ▁Oracle Object ▁< ▁PAR ENT ▁> ▁implements ▁DBST rigger ▁, ▁DBP Qualified Object ▁, ▁Oracle Source Object ▁{ ▁public ▁enum ▁Base ObjectType ▁{ ▁TABLE ▁, ▁VIEW ▁, ▁SCHEMA ▁, ▁DATABASE ▁} ▁public ▁enum ▁ActionType ▁implements ▁DBP Named Object ▁{ ▁P L SQL ▁( ▁STR ▁) ▁, ▁CALL ▁( ▁STR ▁) ▁; ▁private ▁final ▁String ▁title ▁; ▁ActionType ▁( ▁String ▁title ▁) ▁{ ▁this ▁. ▁title ▁= ▁title ▁; ▁} ▁@ ▁NotNull ▁@ ▁Override ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁title ▁; ▁} ▁} ▁private ▁Base ObjectType ▁objectType ▁; ▁private ▁String ▁trigger Type ▁; ▁private ▁String ▁trigger ing Event ▁; ▁private ▁String ▁columnName ▁; ▁private ▁String ▁ref Names ▁; ▁private ▁String ▁when Clause ▁; ▁private ▁Oracle Object Status ▁status ▁; ▁private ▁String ▁description ▁; ▁private ▁ActionType ▁action Type ▁; ▁private ▁String ▁source Declaration ▁; ▁public ▁Oracle Trigger ▁( ▁PAR ENT ▁parent ▁, ▁String ▁name ▁) ▁{ ▁super ▁( ▁parent ▁, ▁name ▁, ▁false ▁) ▁; ▁} ▁public ▁Oracle Trigger ▁( ▁PAR ENT ▁parent ▁, ▁ResultSet ▁dbResult ▁) ▁{ ▁super ▁( ▁parent ▁, ▁JDBCUtils ▁. ▁safeGetString ▁( ▁dbResult ▁, ▁STR ▁) ▁, ▁true ▁) ▁; ▁this ▁. ▁objectType ▁= ▁CommonUtils ▁. ▁valueOf ▁( ▁Base ObjectType ▁. ▁class ▁, ▁JDBCUtils ▁. ▁safeGetString Tri mmed ▁( ▁dbResult ▁, ▁STR ▁) ▁) ▁; ▁this ▁. ▁trigger Type ▁= ▁JDBCUtils ▁. ▁safeGetString ▁( ▁dbResult ▁, ▁STR ▁) ▁; ▁this ▁. ▁trigger ing Event ▁= ▁JDBCUtils ▁. ▁safeGetString ▁( ▁dbResult ▁, ▁STR ▁) ▁; ▁this ▁. ▁columnName ▁= ▁JDBCUtils ▁. ▁safeGetString ▁( ▁dbResult ▁, ▁STR ▁) ▁; ▁this ▁. ▁ref Names ▁= ▁JDBCUtils ▁. ▁safeGetString ▁( ▁dbResult ▁, ▁STR ▁) ▁; ▁this ▁. ▁when Clause ▁= ▁JDBCUtils ▁. ▁safeGetString ▁( ▁dbResult ▁, ▁STR ▁) ▁; ▁this ▁. ▁status ▁= ▁CommonUtils ▁. ▁valueOf ▁( ▁Oracle Object Status ▁. ▁class ▁, ▁JDBCUtils ▁. ▁safeGetString Tri mmed ▁( ▁dbResult ▁, ▁STR ▁) ▁) ▁; ▁this ▁. ▁description ▁= ▁JDBCUtils ▁. ▁safeGetString ▁( ▁dbResult ▁, ▁STR ▁) ▁; ▁this ▁. ▁action Type ▁= ▁STR ▁. ▁equals ▁( ▁JDBCUtils ▁. ▁safeGetString ▁( ▁dbResult ▁, ▁STR ▁) ▁) ▁? ▁ActionType ▁. ▁CALL ▁: ▁ActionType ▁. ▁P L SQL ▁; ▁} ▁@ ▁NotNull ▁@ ▁Override ▁@ ▁Property ▁( ▁viewable ▁= ▁true ▁, ▁editable ▁= ▁true ▁, ▁order ▁= ▁1 ▁) ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁super ▁. ▁getName ▁( ▁) ▁; ▁} ▁@ ▁Property ▁( ▁viewable ▁= ▁true ▁, ▁order ▁= ▁5 ▁) ▁public ▁Base ObjectType ▁getObjectType ▁( ▁) ▁{ ▁return ▁objectType ▁; ▁} ▁@ ▁Property ▁( ▁viewable ▁= ▁true ▁, ▁order ▁= ▁5 ▁) ▁public ▁String ▁getT rigger Type ▁( ▁) ▁{ ▁return ▁trigger Type ▁; ▁} ▁@ ▁Property ▁( ▁viewable ▁= ▁true ▁, ▁order ▁= ▁6 ▁) ▁public ▁String ▁getT rigger ing Event ▁( ▁) ▁{ ▁return ▁trigger ing Event ▁; ▁} ▁@ ▁Property ▁( ▁viewable ▁= ▁true ▁, ▁order ▁= ▁7 ▁) ▁public ▁String ▁getColumnName ▁( ▁) ▁{ ▁return ▁columnName ▁; ▁} ▁@ ▁Property ▁( ▁order ▁= ▁8 ▁) ▁public ▁String ▁getRef Names ▁( ▁) ▁{ ▁return ▁ref Names ▁; ▁}
▁Store TestUtil ▁. ▁wait Commit Log Re put ▁( ▁( ▁Default Message Store ▁) ▁message Store ▁) ▁; ▁int ▁sk ew ing ▁= ▁2 ▁; ▁Consume Queue ▁consume Queue ▁= ▁getDefault Message Store ▁( ▁) ▁. ▁find Consume Queue ▁( ▁topic ▁, ▁queue Id ▁) ▁; ▁for ▁( ▁Append Message Result ▁append Message Result ▁: ▁append Message Results ▁) ▁{ ▁long ▁offset ▁= ▁message Store ▁. ▁getOffset In Queue By Time ▁( ▁topic ▁, ▁queue Id ▁, ▁append Message Result ▁. ▁getStore Timestamp ▁( ▁) ▁+ ▁sk ew ing ▁) ▁; ▁long ▁offset 2 ▁= ▁message Store ▁. ▁getOffset In Queue By Time ▁( ▁topic ▁, ▁queue Id ▁, ▁append Message Result ▁. ▁getStore Timestamp ▁( ▁) ▁- ▁sk ew ing ▁) ▁; ▁Select Mapped Buffer Result ▁index Buffer ▁= ▁consume Queue ▁. ▁getIndex Buffer ▁( ▁offset ▁) ▁; ▁Select Mapped Buffer Result ▁index Buffer 2 ▁= ▁consume Queue ▁. ▁getIndex Buffer ▁( ▁offset 2 ▁) ▁; ▁assertThat ▁( ▁index Buffer ▁. ▁get ByteBuffer ▁( ▁) ▁. ▁getLong ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁append Message Result ▁. ▁getW ro te Offset ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁index Buffer ▁. ▁get ByteBuffer ▁( ▁) ▁. ▁getInt ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁append Message Result ▁. ▁getW ro te Bytes ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁index Buffer 2 ▁. ▁get ByteBuffer ▁( ▁) ▁. ▁getLong ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁append Message Result ▁. ▁getW ro te Offset ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁index Buffer 2 ▁. ▁get ByteBuffer ▁( ▁) ▁. ▁getInt ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁append Message Result ▁. ▁getW ro te Bytes ▁( ▁) ▁) ▁; ▁index Buffer ▁. ▁release ▁( ▁) ▁; ▁index Buffer 2 ▁. ▁release ▁( ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁testGet Offset In Queue By Time _ Timestamp Sk ew ing Is Large ▁( ▁) ▁{ ▁final ▁int ▁totalCount ▁= ▁10 ▁; ▁int ▁queue Id ▁= ▁0 ▁; ▁String ▁topic ▁= ▁STR ▁; ▁Append Message Result ▁[ ▁] ▁append Message Results ▁= ▁put Messages ▁( ▁totalCount ▁, ▁topic ▁, ▁queue Id ▁, ▁true ▁) ▁; ▁Store TestUtil ▁. ▁wait Commit Log Re put ▁( ▁( ▁Default Message Store ▁) ▁message Store ▁) ▁; ▁int ▁sk ew ing ▁= ▁20000 ▁; ▁Consume Queue ▁consume Queue ▁= ▁getDefault Message Store ▁( ▁) ▁. ▁find Consume Queue ▁( ▁topic ▁, ▁queue Id ▁) ▁; ▁for ▁( ▁Append Message Result ▁append Message Result ▁: ▁append Message Results ▁) ▁{ ▁long ▁offset ▁= ▁message Store ▁. ▁getOffset In Queue By Time ▁( ▁topic ▁, ▁queue Id ▁, ▁append Message Result ▁. ▁getStore Timestamp ▁( ▁) ▁+ ▁sk ew ing ▁) ▁; ▁long ▁offset 2 ▁= ▁message Store ▁. ▁getOffset In Queue By Time ▁( ▁topic ▁, ▁queue Id ▁, ▁append Message Result ▁. ▁getStore Timestamp ▁( ▁) ▁- ▁sk ew ing ▁) ▁; ▁Select Mapped Buffer Result ▁index Buffer ▁= ▁consume Queue ▁. ▁getIndex Buffer ▁( ▁offset ▁) ▁; ▁Select Mapped Buffer Result ▁index Buffer 2 ▁= ▁consume Queue ▁. ▁getIndex Buffer ▁( ▁offset 2 ▁) ▁;
▁@ ▁Internal ▁class ▁Processing Time ServiceImpl ▁implements ▁Processing TimeService ▁{ ▁private ▁final ▁Timer Service ▁timerService ▁; ▁private ▁final ▁Function ▁< ▁Processing Time Callback ▁, ▁Processing Time Callback ▁> ▁processing Time Callback Wrapper ▁; ▁private ▁final ▁AtomicInteger ▁num Running T im ers ▁; ▁private ▁final ▁Completable Future ▁< ▁Void ▁> ▁qu ies ce Completed Future ▁; ▁private ▁volatile ▁boolean ▁qu ies ced ▁; ▁Processing Time ServiceImpl ▁( ▁Timer Service ▁timerService ▁, ▁Function ▁< ▁Processing Time Callback ▁, ▁Processing Time Callback ▁> ▁processing Time Callback Wrapper ▁) ▁{ ▁this ▁. ▁timerService ▁= ▁timerService ▁; ▁this ▁. ▁processing Time Callback Wrapper ▁= ▁processing Time Callback Wrapper ▁; ▁this ▁. ▁num Running T im ers ▁= ▁new ▁AtomicInteger ▁( ▁0 ▁) ▁; ▁this ▁. ▁qu ies ce Completed Future ▁= ▁new ▁Completable Future ▁< ▁> ▁( ▁) ▁; ▁this ▁. ▁qu ies ced ▁= ▁false ▁; ▁} ▁@ ▁Override ▁public ▁long ▁getCurrent ProcessingTime ▁( ▁) ▁{ ▁return ▁timerService ▁. ▁getCurrent ProcessingTime ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁ScheduledFuture ▁< ▁? ▁> ▁register Timer ▁( ▁long ▁timestamp ▁, ▁Processing Time Callback ▁target ▁) ▁{ ▁if ▁( ▁is Qu ies ced ▁( ▁) ▁) ▁{ ▁return ▁new ▁Ne ver Complete Future ▁( ▁Processing TimeService Util ▁. ▁get ProcessingTime Delay ▁( ▁timestamp ▁, ▁getCurrent ProcessingTime ▁( ▁) ▁) ▁) ▁; ▁} ▁return ▁timerService ▁. ▁register Timer ▁( ▁timestamp ▁, ▁add Qu ies ce Processing To Callback ▁( ▁processing Time Callback Wrapper ▁. ▁apply ▁( ▁target ▁) ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁ScheduledFuture ▁< ▁? ▁> ▁scheduleAt FixedRate ▁( ▁Processing Time Callback ▁callback ▁, ▁long ▁initialDelay ▁, ▁long ▁period ▁) ▁{ ▁if ▁( ▁is Qu ies ced ▁( ▁) ▁) ▁{ ▁return ▁new ▁Ne ver Complete Future ▁( ▁initialDelay ▁) ▁; ▁} ▁return ▁timerService ▁. ▁scheduleAt FixedRate ▁( ▁add Qu ies ce Processing To Callback ▁( ▁processing Time Callback Wrapper ▁. ▁apply ▁( ▁callback ▁) ▁) ▁, ▁initialDelay ▁, ▁period ▁) ▁; ▁} ▁@ ▁Override ▁public ▁ScheduledFuture ▁< ▁? ▁> ▁schedule WithFixed Delay ▁( ▁Processing Time Callback ▁callback ▁, ▁long ▁initialDelay ▁, ▁long ▁period ▁) ▁{ ▁if ▁( ▁is Qu ies ced ▁( ▁) ▁) ▁{ ▁return ▁new ▁Ne ver Complete Future ▁( ▁initialDelay ▁) ▁; ▁} ▁return ▁timerService ▁. ▁schedule WithFixed Delay ▁( ▁add Qu ies ce Processing To Callback ▁( ▁processing Time Callback Wrapper ▁. ▁apply ▁( ▁callback ▁) ▁) ▁, ▁initialDelay ▁, ▁period ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Completable Future ▁< ▁Void ▁> ▁qu ies ce ▁( ▁) ▁{ ▁if ▁( ▁! ▁qu ies ced ▁) ▁{ ▁qu ies ced ▁= ▁true ▁; ▁if ▁( ▁num Running T im ers ▁. ▁get ▁( ▁) ▁== ▁0 ▁) ▁{ ▁qu ies ce Completed Future ▁. ▁complete ▁( ▁null ▁) ▁; ▁} ▁} ▁return ▁qu ies ce Completed Future ▁; ▁} ▁private ▁boolean ▁is Qu ies ced ▁( ▁) ▁{ ▁return ▁qu ies ced ▁; ▁} ▁private ▁Processing Time Callback ▁add Qu ies ce Processing To Callback ▁( ▁Processing Time Callback ▁callback ▁) ▁{ ▁return ▁timestamp ▁-> ▁{ ▁if ▁( ▁is Qu ies ced ▁( ▁) ▁) ▁{ ▁return ▁; ▁}
▁public ▁abstract ▁class ▁Get MountTable Entries Request ▁{ ▁public ▁static ▁Get MountTable Entries Request ▁newInstance ▁( ▁) ▁throws ▁IOException ▁{ ▁return ▁StateStore Serializer ▁. ▁newRecord ▁( ▁Get MountTable Entries Request ▁. ▁class ▁) ▁; ▁} ▁public ▁static ▁Get MountTable Entries Request ▁newInstance ▁( ▁String ▁src Path ▁) ▁throws ▁IOException ▁{ ▁Get MountTable Entries Request ▁request ▁= ▁newInstance ▁( ▁) ▁; ▁request ▁. ▁setS rc Path ▁( ▁src Path ▁) ▁; ▁return ▁request ▁; ▁} ▁@ ▁Public ▁@ ▁Unstable ▁public ▁abstract ▁String ▁getS rc Path ▁( ▁) ▁; ▁@ ▁Public ▁@ ▁Unstable ▁public ▁abstract ▁void ▁setS rc Path ▁( ▁String ▁path ▁) ▁; ▁}
▁public ▁class ▁Run Algorithm ▁{ ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁throws ▁Instant iationException ▁, ▁Illegal AccessException ▁{ ▁Scanner ▁in ▁= ▁new ▁Scanner ▁( ▁System ▁. ▁in ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁) ▁; ▁int ▁decision ▁= ▁in ▁. ▁nextInt ▁( ▁) ▁; ▁switch ▁( ▁decision ▁) ▁{ ▁case ▁1 ▁: ▁S lo pe One ▁. ▁s lo pe One ▁( ▁3 ▁) ▁; ▁break ▁; ▁case ▁2 ▁: ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁) ▁; ▁break ▁; ▁default ▁: ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁) ▁; ▁break ▁; ▁} ▁in ▁. ▁close ▁( ▁) ▁; ▁} ▁}
▁@ ▁Test ▁public ▁void ▁testAdd Short ▁( ▁) ▁{ ▁assertThrows ▁( ▁Unsupported Operation Exception ▁. ▁class ▁, ▁new ▁Executable ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁) ▁{ ▁HEADER S ▁. ▁add Short ▁( ▁STR ▁, ▁( ▁short ▁) ▁0 ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testAdd TimeMillis ▁( ▁) ▁{ ▁assertThrows ▁( ▁Unsupported Operation Exception ▁. ▁class ▁, ▁new ▁Executable ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁) ▁{ ▁HEADER S ▁. ▁add TimeMillis ▁( ▁STR ▁, ▁0 ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testSet StringValue ▁( ▁) ▁{ ▁assertThrows ▁( ▁Unsupported Operation Exception ▁. ▁class ▁, ▁new ▁Executable ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁) ▁{ ▁HEADER S ▁. ▁set ▁( ▁STR ▁, ▁STR ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testSet String Values ▁( ▁) ▁{ ▁assertThrows ▁( ▁Unsupported Operation Exception ▁. ▁class ▁, ▁new ▁Executable ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁) ▁{ ▁HEADER S ▁. ▁set ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testSet String Values Iterable ▁( ▁) ▁{ ▁assertThrows ▁( ▁Unsupported Operation Exception ▁. ▁class ▁, ▁new ▁Executable ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁) ▁{ ▁HEADER S ▁. ▁set ▁( ▁STR ▁, ▁Arrays ▁. ▁asList ▁( ▁STR ▁, ▁STR ▁) ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testSet Boolean ▁( ▁) ▁{ ▁assertThrows ▁( ▁Unsupported Operation Exception ▁. ▁class ▁, ▁new ▁Executable ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁) ▁{ ▁HEADER S ▁. ▁setBoolean ▁( ▁STR ▁, ▁true ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testSet Byte ▁( ▁) ▁{ ▁assertThrows ▁( ▁Unsupported Operation Exception ▁. ▁class ▁, ▁new ▁Executable ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁) ▁{ ▁HEADER S ▁. ▁set Byte ▁( ▁STR ▁, ▁( ▁byte ▁) ▁1 ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testSet Char ▁( ▁) ▁{ ▁assertThrows ▁( ▁Unsupported Operation Exception ▁. ▁class ▁, ▁new ▁Executable ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁) ▁{ ▁HEADER S ▁. ▁set Char ▁( ▁STR ▁, ▁CHAR ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testSet Double ▁( ▁) ▁{ ▁assertThrows ▁( ▁Unsupported Operation Exception ▁. ▁class ▁, ▁new ▁Executable ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁) ▁{ ▁HEADER S ▁. ▁set Double ▁( ▁STR ▁, ▁0 ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testSet Float ▁( ▁) ▁{ ▁assertThrows ▁( ▁Unsupported Operation Exception ▁. ▁class ▁, ▁new ▁Executable ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁) ▁{ ▁HEADER S ▁. ▁set Float ▁( ▁STR ▁, ▁0 ▁) ▁; ▁} ▁} ▁) ▁; ▁}
▁public ▁class ▁Proxy Web socket s Into Grid ▁implements ▁BiFunction ▁< ▁String ▁, ▁Consumer ▁< ▁Message ▁> ▁, ▁Optional ▁< ▁Consumer ▁< ▁Message ▁> ▁> ▁> ▁{ ▁private ▁static ▁final ▁Logger ▁LOG ▁= ▁Logger ▁. ▁getLogger ▁( ▁Proxy Web socket s Into Grid ▁. ▁class ▁. ▁getName ▁( ▁) ▁) ▁; ▁private ▁final ▁HttpClient ▁. ▁Factory ▁client Factory ▁; ▁private ▁final ▁Session Map ▁sessions ▁; ▁public ▁Proxy Web socket s Into Grid ▁( ▁HttpClient ▁. ▁Factory ▁client Factory ▁, ▁Session Map ▁sessions ▁) ▁{ ▁this ▁. ▁client Factory ▁= ▁Objects ▁. ▁requireNonNull ▁( ▁client Factory ▁) ▁; ▁this ▁. ▁sessions ▁= ▁Objects ▁. ▁requireNonNull ▁( ▁sessions ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Optional ▁< ▁Consumer ▁< ▁Message ▁> ▁> ▁apply ▁( ▁String ▁uri ▁, ▁Consumer ▁< ▁Message ▁> ▁downstream ▁) ▁{ ▁Objects ▁. ▁requireNonNull ▁( ▁uri ▁) ▁; ▁Objects ▁. ▁requireNonNull ▁( ▁downstream ▁) ▁; ▁Optional ▁< ▁SessionId ▁> ▁sessionId ▁= ▁Http SessionId ▁. ▁getSession Id ▁( ▁uri ▁) ▁. ▁map ▁( ▁SessionId ▁:: ▁new ▁) ▁; ▁if ▁( ▁! ▁sessionId ▁. ▁isPresent ▁( ▁) ▁) ▁{ ▁return ▁Optional ▁. ▁empty ▁( ▁) ▁; ▁} ▁try ▁{ ▁Session ▁session ▁= ▁sessions ▁. ▁get ▁( ▁sessionId ▁. ▁get ▁( ▁) ▁) ▁; ▁HttpClient ▁client ▁= ▁client Factory ▁. ▁createClient ▁( ▁ClientConfig ▁. ▁default Config ▁( ▁) ▁. ▁base Uri ▁( ▁session ▁. ▁getUri ▁( ▁) ▁) ▁) ▁; ▁WebSocket ▁upstream ▁= ▁client ▁. ▁open Socket ▁( ▁new ▁HttpRequest ▁( ▁GET ▁, ▁uri ▁) ▁, ▁new ▁Forwarding Listener ▁( ▁downstream ▁) ▁) ▁; ▁return ▁Optional ▁. ▁of ▁( ▁upstream ▁:: ▁send ▁) ▁; ▁} ▁catch ▁( ▁NoSuch Session Exception ▁e ▁) ▁{ ▁LOG ▁. ▁info ▁( ▁STR ▁+ ▁uri ▁) ▁; ▁return ▁Optional ▁. ▁empty ▁( ▁) ▁; ▁} ▁} ▁private ▁static ▁class ▁Forwarding Listener ▁implements ▁WebSocket ▁. ▁Listener ▁{ ▁private ▁final ▁Consumer ▁< ▁Message ▁> ▁downstream ▁; ▁public ▁Forwarding Listener ▁( ▁Consumer ▁< ▁Message ▁> ▁downstream ▁) ▁{ ▁this ▁. ▁downstream ▁= ▁Objects ▁. ▁requireNonNull ▁( ▁downstream ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁on Binary ▁( ▁byte ▁[ ▁] ▁data ▁) ▁{ ▁downstream ▁. ▁accept ▁( ▁new ▁Binary Message ▁( ▁data ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁on Close ▁( ▁int ▁code ▁, ▁String ▁reason ▁) ▁{ ▁downstream ▁. ▁accept ▁( ▁new ▁Close Message ▁( ▁code ▁, ▁reason ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁on Text ▁( ▁CharSequence ▁data ▁) ▁{ ▁downstream ▁. ▁accept ▁( ▁new ▁Text Message ▁( ▁data ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁onError ▁( ▁Throwable ▁cause ▁) ▁{ ▁LOG ▁. ▁log ▁( ▁Level ▁. ▁WARNING ▁, ▁STR ▁, ▁cause ▁) ▁; ▁} ▁} ▁}
▁@ ▁Override ▁public ▁void ▁initialize State ▁( ▁Function Initialization Context ▁context ▁) ▁throws ▁Exception ▁{ ▁state ▁= ▁context ▁. ▁getOperator StateStore ▁( ▁) ▁. ▁getList State ▁( ▁new ▁List StateDescriptor ▁< ▁> ▁( ▁STR ▁, ▁Int Serializer ▁. ▁INSTANCE ▁) ▁) ▁; ▁if ▁( ▁context ▁. ▁is Restored ▁( ▁) ▁) ▁{ ▁this ▁. ▁emit ted Count ▁= ▁2 ▁; ▁} ▁} ▁} ▁private ▁static ▁class ▁T im ers Process Function ▁extends ▁Keyed Process Function ▁< ▁Integer ▁, ▁Integer ▁, ▁Integer ▁> ▁{ ▁@ ▁Override ▁public ▁void ▁processElement ▁( ▁Integer ▁value ▁, ▁Context ▁ctx ▁, ▁Collector ▁< ▁Integer ▁> ▁out ▁) ▁throws ▁Exception ▁{ ▁if ▁( ▁value ▁== ▁0 ▁) ▁{ ▁ctx ▁. ▁timerService ▁( ▁) ▁. ▁register EventTime Timer ▁( ▁2 L ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁on Timer ▁( ▁long ▁timestamp ▁, ▁On Timer Context ▁ctx ▁, ▁Collector ▁< ▁Integer ▁> ▁out ▁) ▁throws ▁Exception ▁{ ▁out ▁. ▁collect ▁( ▁1 ▁) ▁; ▁result Latch ▁. ▁trigger ▁( ▁) ▁; ▁} ▁} ▁}
▁Abstract Key edStateBackend ▁< ▁K ▁> ▁key edStateBackend ▁= ▁( ▁Abstract Key edStateBackend ▁< ▁K ▁> ▁) ▁context ▁. ▁key edStateBackend ▁( ▁) ▁; ▁final ▁Default Key edState Store ▁key edState Store ▁= ▁new ▁Default Key edState Store ▁( ▁key edStateBackend ▁, ▁getRuntime Context ▁( ▁) ▁. ▁getExecution Config ▁( ▁) ▁) ▁; ▁Savepoint RuntimeContext ▁ctx ▁= ▁new ▁Savepoint RuntimeContext ▁( ▁getRuntime Context ▁( ▁) ▁, ▁key edState Store ▁) ▁; ▁Internal TimeService Manager ▁< ▁K ▁> ▁time Service Manager ▁= ▁( ▁Internal TimeService Manager ▁< ▁K ▁> ▁) ▁context ▁. ▁internal Timer Service Manager ▁( ▁) ▁; ▁try ▁{ ▁operator ▁. ▁setup ▁( ▁getRuntime Context ▁( ▁) ▁. ▁getExecution Config ▁( ▁) ▁, ▁key edStateBackend ▁, ▁time Service Manager ▁, ▁ctx ▁) ▁; ▁operator ▁. ▁open ▁( ▁) ▁; ▁keys And Namespaces ▁= ▁operator ▁. ▁getKeys And Namespaces ▁( ▁ctx ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁STR ▁, ▁e ▁) ▁; ▁} ▁} ▁private ▁Stream Operator State Context ▁getStream Operator State Context ▁( ▁Environment ▁environment ▁) ▁throws ▁IOException ▁{ ▁Stream TaskState Initializer ▁initializer ▁= ▁new ▁Stream TaskState Initializer Impl ▁( ▁environment ▁, ▁state Backend ▁) ▁; ▁try ▁{ ▁return ▁initializer ▁. ▁stream Operator State Context ▁( ▁operator State ▁. ▁getOperator ID ▁( ▁) ▁, ▁operator State ▁. ▁getOperator ID ▁( ▁) ▁. ▁toString ▁( ▁) ▁, ▁new ▁Ne ver Fire ProcessingTime Service ▁( ▁) ▁, ▁operator ▁, ▁operator ▁. ▁getKey Type ▁( ▁) ▁. ▁create Serializer ▁( ▁environment ▁. ▁getExecution Config ▁( ▁) ▁) ▁, ▁registry ▁, ▁getRuntime Context ▁( ▁) ▁. ▁get MetricGroup ▁( ▁) ▁, ▁1.0 ▁, ▁false ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁STR ▁, ▁e ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁close ▁( ▁) ▁throws ▁IOException ▁{ ▁try ▁{ ▁IOUtils ▁. ▁closeQuietly ▁( ▁keys And Namespaces ▁) ▁; ▁operator ▁. ▁close ▁( ▁) ▁; ▁registry ▁. ▁close ▁( ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁STR ▁, ▁e ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁boolean ▁re ached End ▁( ▁) ▁{ ▁return ▁! ▁out ▁. ▁hasNext ▁( ▁) ▁&& ▁! ▁keys And Namespaces ▁. ▁hasNext ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁OUT ▁next Record ▁( ▁OUT ▁reuse ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁out ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁return ▁out ▁. ▁next ▁( ▁) ▁; ▁} ▁final ▁Tuple 2 ▁< ▁K ▁, ▁N ▁> ▁key And Namespace ▁= ▁keys And Namespaces ▁. ▁next ▁( ▁) ▁; ▁operator ▁. ▁setCurrent Key ▁( ▁key And Namespace ▁. ▁f 0 ▁) ▁; ▁try ▁{ ▁operator ▁. ▁processElement ▁( ▁key And Namespace ▁. ▁f 0 ▁, ▁key And Namespace ▁. ▁f 1 ▁, ▁out ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁STR ▁, ▁e ▁) ▁; ▁} ▁keys And Namespaces ▁. ▁remove ▁( ▁) ▁; ▁return ▁out ▁. ▁next ▁( ▁) ▁; ▁}
▁final ▁String ▁[ ▁] ▁live Nodes ▁= ▁new ▁String ▁[ ▁randomInt Between ▁( ▁1 ▁, ▁all Nodes ▁. ▁length ▁) ▁] ▁; ▁random Subset Of ▁( ▁live Nodes ▁. ▁length ▁, ▁all Nodes ▁) ▁. ▁toArray ▁( ▁live Nodes ▁) ▁; ▁final ▁String ▁[ ▁] ▁initial V oting Nodes ▁= ▁new ▁String ▁[ ▁randomInt Between ▁( ▁1 ▁, ▁all Nodes ▁. ▁length ▁) ▁] ▁; ▁random Subset Of ▁( ▁initial V oting Nodes ▁. ▁length ▁, ▁all Nodes ▁) ▁. ▁toArray ▁( ▁initial V oting Nodes ▁) ▁; ▁final ▁Builder ▁settings Builder ▁= ▁Settings ▁. ▁builder ▁( ▁) ▁; ▁if ▁( ▁randomBoolean ▁( ▁) ▁) ▁{ ▁settings Builder ▁. ▁put ▁( ▁CLUSTER _ AUTO _ SH R INK _ V OT ING _ CONFIGURATION ▁. ▁getKey ▁( ▁) ▁, ▁true ▁) ▁; ▁} ▁final ▁Re config urator ▁re config urator ▁= ▁make Re config urator ▁( ▁settings Builder ▁. ▁build ▁( ▁) ▁) ▁; ▁final ▁Set ▁< ▁DiscoveryNode ▁> ▁live Nodes Set ▁= ▁nodes ▁( ▁live Nodes ▁) ▁; ▁final ▁V oting Configuration ▁initial Config ▁= ▁conf ▁( ▁initial V oting Nodes ▁) ▁; ▁final ▁int ▁qu orum Size ▁= ▁Math ▁. ▁max ▁( ▁live Nodes ▁. ▁length ▁ / ▁2 ▁+ ▁1 ▁, ▁initial V oting Nodes ▁. ▁length ▁< ▁3 ▁? ▁1 ▁: ▁2 ▁) ▁; ▁final ▁V oting Configuration ▁final Config ▁= ▁re config urator ▁. ▁re config ure ▁( ▁live Nodes Set ▁, ▁emptySet ▁( ▁) ▁, ▁randomFrom ▁( ▁live Nodes Set ▁) ▁, ▁initial Config ▁) ▁; ▁final ▁String ▁description ▁= ▁STR ▁+ ▁live Nodes Set ▁+ ▁STR ▁+ ▁initial Config ▁+ ▁STR ▁+ ▁final Config ▁; ▁if ▁( ▁qu orum Size ▁> ▁live Nodes ▁. ▁length ▁) ▁{ ▁assertFalse ▁( ▁description ▁+ ▁STR ▁, ▁final Config ▁. ▁has Quorum ▁( ▁Arrays ▁. ▁asList ▁( ▁live Nodes ▁) ▁) ▁) ▁; ▁} ▁else ▁{ ▁final ▁List ▁< ▁String ▁> ▁expected Quorum ▁= ▁random Subset Of ▁( ▁qu orum Size ▁, ▁live Nodes ▁) ▁; ▁assertTrue ▁( ▁description ▁+ ▁STR ▁+ ▁qu orum Size ▁+ ▁STR ▁+ ▁expected Quorum ▁, ▁final Config ▁. ▁has Quorum ▁( ▁expected Quorum ▁) ▁) ▁; ▁} ▁} ▁public ▁void ▁test Manual Sh rink ing ▁( ▁) ▁{ ▁final ▁String ▁[ ▁] ▁all Nodes ▁= ▁new ▁String ▁[ ▁] ▁{ ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁} ▁; ▁final ▁String ▁[ ▁] ▁live Nodes ▁= ▁new ▁String ▁[ ▁randomInt Between ▁( ▁1 ▁, ▁all Nodes ▁. ▁length ▁) ▁] ▁; ▁random Subset Of ▁( ▁live Nodes ▁. ▁length ▁, ▁all Nodes ▁) ▁. ▁toArray ▁( ▁live Nodes ▁) ▁; ▁final ▁String ▁[ ▁] ▁initial V oting Nodes ▁= ▁new ▁String ▁[ ▁randomInt Between ▁( ▁1 ▁, ▁all Nodes ▁. ▁length ▁) ▁] ▁; ▁random Subset Of ▁( ▁initial V oting Nodes ▁. ▁length ▁, ▁all Nodes ▁) ▁. ▁toArray ▁( ▁initial V oting Nodes ▁) ▁;
▁class ▁SHA Common Utils ▁{ ▁public ▁static ▁String ▁bytesTo Hex ▁( ▁byte ▁[ ▁] ▁hash ▁) ▁{ ▁StringBuilder ▁hex String ▁= ▁new ▁StringBuilder ▁( ▁2 ▁ * ▁hash ▁. ▁length ▁) ▁; ▁for ▁( ▁byte ▁h ▁: ▁hash ▁) ▁{ ▁String ▁hex ▁= ▁Integer ▁. ▁toHexString ▁( ▁0 xff ▁& ▁h ▁) ▁; ▁if ▁( ▁hex ▁. ▁length ▁( ▁) ▁== ▁1 ▁) ▁hex String ▁. ▁append ▁( ▁CHAR ▁) ▁; ▁hex String ▁. ▁append ▁( ▁hex ▁) ▁; ▁} ▁return ▁hex String ▁. ▁toString ▁( ▁) ▁; ▁} ▁}
▁@ ▁NotNull ▁@ ▁Override ▁public ▁DBSObject State ▁getObject State ▁( ▁) ▁{ ▁return ▁valid ▁? ▁DBSObject State ▁. ▁NORMAL ▁: ▁DBSObject State ▁. ▁INVALID ▁; ▁} ▁@ ▁Override ▁public ▁void ▁refresh Object State ▁( ▁@ ▁NotNull ▁DBR ProgressMonitor ▁monitor ▁) ▁throws ▁DBCException ▁{ ▁this ▁. ▁valid ▁= ▁Oracle Utils ▁. ▁getObject Status ▁( ▁monitor ▁, ▁this ▁, ▁get Procedure Type ▁( ▁) ▁== ▁DBSProcedure Type ▁. ▁PRO CED URE ▁? ▁Oracle ObjectType ▁. ▁PRO CED URE ▁: ▁Oracle ObjectType ▁. ▁FUNCTION ▁) ▁; ▁} ▁@ ▁Override ▁public ▁DBSObject ▁refresh Object ▁( ▁@ ▁NotNull ▁DBR ProgressMonitor ▁monitor ▁) ▁throws ▁DBException ▁{ ▁return ▁getSchema ▁( ▁) ▁. ▁procedure s Cache ▁. ▁refresh Object ▁( ▁monitor ▁, ▁getSchema ▁( ▁) ▁, ▁this ▁) ▁; ▁} ▁}
▁Memory Attribute ▁attribute ▁= ▁new ▁Memory Attribute ▁( ▁name ▁) ▁; ▁attribute ▁. ▁setMax Size ▁( ▁maxSize ▁) ▁; ▁return ▁attribute ▁; ▁} ▁@ ▁Override ▁public ▁Attribute ▁create Attribute ▁( ▁HttpRequest ▁request ▁, ▁String ▁name ▁, ▁long ▁defined Size ▁) ▁{ ▁if ▁( ▁use Disk ▁) ▁{ ▁Attribute ▁attribute ▁= ▁new ▁Disk Attribute ▁( ▁name ▁, ▁defined Size ▁, ▁charset ▁, ▁baseDir ▁, ▁deleteOnExit ▁) ▁; ▁attribute ▁. ▁setMax Size ▁( ▁maxSize ▁) ▁; ▁List ▁< ▁Http Data ▁> ▁list ▁= ▁getList ▁( ▁request ▁) ▁; ▁list ▁. ▁add ▁( ▁attribute ▁) ▁; ▁return ▁attribute ▁; ▁} ▁if ▁( ▁check Size ▁) ▁{ ▁Attribute ▁attribute ▁= ▁new ▁Mix ed Attribute ▁( ▁name ▁, ▁defined Size ▁, ▁min Size ▁, ▁charset ▁, ▁baseDir ▁, ▁deleteOnExit ▁) ▁; ▁attribute ▁. ▁setMax Size ▁( ▁maxSize ▁) ▁; ▁List ▁< ▁Http Data ▁> ▁list ▁= ▁getList ▁( ▁request ▁) ▁; ▁list ▁. ▁add ▁( ▁attribute ▁) ▁; ▁return ▁attribute ▁; ▁} ▁Memory Attribute ▁attribute ▁= ▁new ▁Memory Attribute ▁( ▁name ▁, ▁defined Size ▁) ▁; ▁attribute ▁. ▁setMax Size ▁( ▁maxSize ▁) ▁; ▁return ▁attribute ▁; ▁} ▁private ▁static ▁void ▁check Http DataSize ▁( ▁Http Data ▁data ▁) ▁{ ▁try ▁{ ▁data ▁. ▁check Size ▁( ▁data ▁. ▁length ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁ignored ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁Attribute ▁create Attribute ▁( ▁HttpRequest ▁request ▁, ▁String ▁name ▁, ▁String ▁value ▁) ▁{ ▁if ▁( ▁use Disk ▁) ▁{ ▁Attribute ▁attribute ▁; ▁try ▁{ ▁attribute ▁= ▁new ▁Disk Attribute ▁( ▁name ▁, ▁value ▁, ▁charset ▁, ▁baseDir ▁, ▁deleteOnExit ▁) ▁; ▁attribute ▁. ▁setMax Size ▁( ▁maxSize ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁attribute ▁= ▁new ▁Mix ed Attribute ▁( ▁name ▁, ▁value ▁, ▁min Size ▁, ▁charset ▁, ▁baseDir ▁, ▁deleteOnExit ▁) ▁; ▁attribute ▁. ▁setMax Size ▁( ▁maxSize ▁) ▁; ▁} ▁check Http DataSize ▁( ▁attribute ▁) ▁; ▁List ▁< ▁Http Data ▁> ▁list ▁= ▁getList ▁( ▁request ▁) ▁; ▁list ▁. ▁add ▁( ▁attribute ▁) ▁; ▁return ▁attribute ▁; ▁} ▁if ▁( ▁check Size ▁) ▁{ ▁Attribute ▁attribute ▁= ▁new ▁Mix ed Attribute ▁( ▁name ▁, ▁value ▁, ▁min Size ▁, ▁charset ▁, ▁baseDir ▁, ▁deleteOnExit ▁) ▁; ▁attribute ▁. ▁setMax Size ▁( ▁maxSize ▁) ▁; ▁check Http DataSize ▁( ▁attribute ▁) ▁; ▁List ▁< ▁Http Data ▁> ▁list ▁= ▁getList ▁( ▁request ▁) ▁; ▁list ▁. ▁add ▁( ▁attribute ▁) ▁; ▁return ▁attribute ▁; ▁} ▁try ▁{ ▁Memory Attribute ▁attribute ▁= ▁new ▁Memory Attribute ▁( ▁name ▁, ▁value ▁, ▁charset ▁) ▁; ▁attribute ▁. ▁setMax Size ▁( ▁maxSize ▁) ▁; ▁check Http DataSize ▁( ▁attribute ▁) ▁; ▁return ▁attribute ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁e ▁) ▁; ▁} ▁}
▁@ ▁RunWith ▁( ▁JUnit 4 ▁. ▁class ▁) ▁public ▁class ▁Platform Configuration Api Test ▁extends ▁Build View TestCase ▁{ ▁@ ▁Test ▁public ▁void ▁test Host Platform ▁( ▁) ▁throws ▁Exception ▁{ ▁scratch ▁. ▁file ▁( ▁STR ▁, ▁STR ▁) ▁; ▁scratch ▁. ▁file ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁scratch ▁. ▁file ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁use Configuration ▁( ▁STR ▁) ▁; ▁Config uredTarget ▁my Rule Target ▁= ▁getConfig uredTarget ▁( ▁STR ▁) ▁; ▁Struct Impl ▁info ▁= ▁( ▁Struct Impl ▁) ▁my Rule Target ▁. ▁get ▁( ▁new ▁Starlark Provider ▁. ▁Key ▁( ▁Label ▁. ▁parseAbsolute ▁( ▁STR ▁, ▁ImmutableMap ▁. ▁of ▁( ▁) ▁) ▁, ▁STR ▁) ▁) ▁; ▁Label ▁host Platform ▁= ▁( ▁Label ▁) ▁info ▁. ▁getValue ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁host Platform ▁) ▁. ▁isEqualTo ▁( ▁Label ▁. ▁parseAbsolute Unchecked ▁( ▁STR ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Target Platform _ single ▁( ▁) ▁throws ▁Exception ▁{ ▁scratch ▁. ▁file ▁( ▁STR ▁, ▁STR ▁) ▁; ▁scratch ▁. ▁file ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁scratch ▁. ▁file ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁use Configuration ▁( ▁STR ▁) ▁; ▁Config uredTarget ▁my Rule Target ▁= ▁getConfig uredTarget ▁( ▁STR ▁) ▁; ▁Struct Impl ▁info ▁= ▁( ▁Struct Impl ▁) ▁my Rule Target ▁. ▁get ▁( ▁new ▁Starlark Provider ▁. ▁Key ▁( ▁Label ▁. ▁parseAbsolute ▁( ▁STR ▁, ▁ImmutableMap ▁. ▁of ▁( ▁) ▁) ▁, ▁STR ▁) ▁) ▁; ▁Label ▁target Platform ▁= ▁( ▁Label ▁) ▁info ▁. ▁getValue ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁target Platform ▁) ▁. ▁isEqualTo ▁( ▁Label ▁. ▁parseAbsolute Unchecked ▁( ▁STR ▁) ▁) ▁; ▁} ▁}
▁public ▁enum ▁Elasticsearch ErrorCode ▁implements ▁ErrorCode Supplier ▁{ ▁E LAST IC SEARCH _ CONNECTION _ ERROR ▁( ▁0 ▁, ▁EXTERNAL ▁) ▁, ▁E LAST IC SEARCH _ INVALID _ RESPONSE ▁( ▁1 ▁, ▁EXTERNAL ▁) ▁, ▁E LAST IC SEARCH _ SSL _ INITIALI Z ATION _ FAILURE ▁( ▁2 ▁, ▁EXTERNAL ▁) ▁, ▁E LAST IC SEARCH _ MAX _ H ITS _ EX CEEDED ▁( ▁3 ▁, ▁EXTERNAL ▁) ▁, ▁E LAST IC SEARCH _ TYPE _ MI SM ATCH ▁( ▁4 ▁, ▁EXTERNAL ▁) ▁, ▁E LAST IC SEARCH _ QUERY _ FAILURE ▁( ▁5 ▁, ▁EXTERNAL ▁) ▁; ▁private ▁final ▁ErrorCode ▁errorCode ▁; ▁Elasticsearch ErrorCode ▁( ▁int ▁code ▁, ▁Error Type ▁type ▁) ▁{ ▁errorCode ▁= ▁new ▁ErrorCode ▁( ▁code ▁+ ▁0 x 0 50 3 _0 000 ▁, ▁name ▁( ▁) ▁, ▁type ▁) ▁; ▁} ▁@ ▁Override ▁public ▁ErrorCode ▁to ErrorCode ▁( ▁) ▁{ ▁return ▁errorCode ▁; ▁} ▁}
▁public ▁class ▁Unary Call De adline Interceptor ▁implements ▁Client Interceptor ▁{ ▁private ▁final ▁Logger ▁logger ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁this ▁. ▁getClass ▁( ▁) ▁) ▁; ▁private ▁final ▁long ▁timeout Millis ▁; ▁public ▁Unary Call De adline Interceptor ▁( ▁long ▁timeout Millis ▁) ▁{ ▁Assert ▁. ▁isTrue ▁( ▁timeout Millis ▁> ▁0 ▁, ▁STR ▁) ▁; ▁this ▁. ▁timeout Millis ▁= ▁timeout Millis ▁; ▁} ▁@ ▁Override ▁public ▁< ▁ReqT ▁, ▁Res p T ▁> ▁Client Call ▁< ▁ReqT ▁, ▁Res p T ▁> ▁intercept Call ▁( ▁Method Descriptor ▁< ▁ReqT ▁, ▁Res p T ▁> ▁method ▁, ▁Call Options ▁call Options ▁, ▁Channel ▁next ▁) ▁{ ▁if ▁( ▁Method Descriptor ▁. ▁Method Type ▁. ▁UN ARY ▁== ▁method ▁. ▁getType ▁( ▁) ▁) ▁{ ▁if ▁( ▁logger ▁. ▁isDebugEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁debug ▁( ▁STR ▁, ▁method ▁. ▁getFull MethodName ▁( ▁) ▁) ▁; ▁} ▁return ▁next ▁. ▁newCall ▁( ▁method ▁, ▁call Options ▁. ▁with De adline After ▁( ▁timeout Millis ▁, ▁TimeUnit ▁. ▁MILLISECONDS ▁) ▁) ▁; ▁} ▁else ▁{ ▁return ▁next ▁. ▁newCall ▁( ▁method ▁, ▁call Options ▁) ▁; ▁} ▁} ▁}
▁@ ▁ESIntegTestCase ▁. ▁Cluster Scope ▁( ▁scope ▁= ▁ESIntegTestCase ▁. ▁Scope ▁. ▁TEST ▁, ▁numDataNodes ▁= ▁0 ▁, ▁num Client Nodes ▁= ▁0 ▁) ▁public ▁class ▁Enrich Multi Node IT ▁extends ▁ESIntegTestCase ▁{ ▁static ▁final ▁String ▁PO LIC Y _ NAME ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁PIPE LINE _ NAME ▁= ▁STR ▁; ▁static ▁final ▁String ▁SOURCE _ INDEX _ NAME ▁= ▁STR ▁; ▁static ▁final ▁String ▁MATCH _ FIELD ▁= ▁STR ▁; ▁static ▁final ▁String ▁[ ▁] ▁DE C OR ATE _ FI ELDS ▁= ▁new ▁String ▁[ ▁] ▁{ ▁STR ▁, ▁STR ▁, ▁STR ▁} ▁; ▁@ ▁Override ▁protected ▁Collection ▁< ▁Class ▁< ▁? ▁extends ▁Plugin ▁> ▁> ▁node Plugins ▁( ▁) ▁{ ▁return ▁List ▁. ▁of ▁( ▁Local State Enrich ▁. ▁class ▁, ▁Re index Plugin ▁. ▁class ▁, ▁Ingest Common Plugin ▁. ▁class ▁) ▁; ▁} ▁public ▁void ▁test Enrich AP Is ▁( ▁) ▁{ ▁final ▁int ▁num Policies ▁= ▁randomInt Between ▁( ▁2 ▁, ▁4 ▁) ▁; ▁internalCluster ▁( ▁) ▁. ▁start Nodes ▁( ▁randomInt Between ▁( ▁2 ▁, ▁3 ▁) ▁) ▁; ▁int ▁num Docs In Source Index ▁= ▁randomInt Between ▁( ▁8 ▁, ▁32 ▁) ▁; ▁create Source Index ▁( ▁num Docs In Source Index ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁num Policies ▁; ▁i ▁++ ▁) ▁{ ▁String ▁policy Name ▁= ▁PO LIC Y _ NAME ▁+ ▁i ▁; ▁Enrich Policy ▁en rich Policy ▁= ▁new ▁Enrich Policy ▁( ▁Enrich Policy ▁. ▁MATCH _ TYPE ▁, ▁null ▁, ▁List ▁. ▁of ▁( ▁SOURCE _ INDEX _ NAME ▁) ▁, ▁MATCH _ FIELD ▁, ▁List ▁. ▁of ▁( ▁DE C OR ATE _ FI ELDS ▁) ▁) ▁; ▁Put Enrich PolicyAction ▁. ▁Request ▁request ▁= ▁new ▁Put Enrich PolicyAction ▁. ▁Request ▁( ▁policy Name ▁, ▁en rich Policy ▁) ▁; ▁client ▁( ▁) ▁. ▁execute ▁( ▁Put Enrich PolicyAction ▁. ▁INSTANCE ▁, ▁request ▁) ▁. ▁actionGet ▁( ▁) ▁; ▁client ▁( ▁) ▁. ▁execute ▁( ▁Execute Enrich PolicyAction ▁. ▁INSTANCE ▁, ▁new ▁Execute Enrich PolicyAction ▁. ▁Request ▁( ▁policy Name ▁) ▁) ▁. ▁actionGet ▁( ▁) ▁; ▁Enrich Policy ▁. ▁Named Policy ▁result ▁= ▁client ▁( ▁) ▁. ▁execute ▁( ▁Get Enrich PolicyAction ▁. ▁INSTANCE ▁, ▁new ▁Get Enrich PolicyAction ▁. ▁Request ▁( ▁new ▁String ▁[ ▁] ▁{ ▁policy Name ▁} ▁) ▁) ▁. ▁actionGet ▁( ▁) ▁. ▁getP olicies ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁; ▁assertThat ▁( ▁result ▁, ▁equalTo ▁( ▁new ▁Enrich Policy ▁. ▁Named Policy ▁( ▁policy Name ▁, ▁en rich Policy ▁) ▁) ▁) ▁; ▁String ▁en rich Index Prefix ▁= ▁Enrich Policy ▁. ▁getBase Name ▁( ▁policy Name ▁) ▁+ ▁STR ▁; ▁refresh ▁( ▁en rich Index Prefix ▁) ▁; ▁SearchResponse ▁searchResponse ▁= ▁client ▁( ▁) ▁. ▁search ▁( ▁new ▁SearchRequest ▁( ▁en rich Index Prefix ▁) ▁) ▁. ▁actionGet ▁( ▁) ▁; ▁assertThat ▁( ▁searchResponse ▁. ▁getHits ▁( ▁) ▁. ▁getTotal Hits ▁( ▁) ▁. ▁relation ▁, ▁equalTo ▁( ▁Total Hits ▁. ▁Relation ▁. ▁EQUAL _ TO ▁) ▁) ▁;
▁public ▁class ▁Rest Put TrainedModel Action ▁extends ▁BaseRestHandler ▁{ ▁@ ▁Override ▁public ▁List ▁< ▁Route ▁> ▁routes ▁( ▁) ▁{ ▁return ▁List ▁. ▁of ▁( ▁Route ▁. ▁builder ▁( ▁PUT ▁, ▁BASE _ PATH ▁+ ▁STR ▁+ ▁TrainedModel Config ▁. ▁MODEL _ ID ▁+ ▁STR ▁) ▁. ▁replaces ▁( ▁PUT ▁, ▁BASE _ PATH ▁+ ▁STR ▁+ ▁TrainedModel Config ▁. ▁MODEL _ ID ▁+ ▁STR ▁, ▁RestApiVersion ▁. ▁V _8 ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁protected ▁RestChannel Consumer ▁prepareRequest ▁( ▁RestRequest ▁restRequest ▁, ▁NodeClient ▁client ▁) ▁throws ▁IOException ▁{ ▁String ▁id ▁= ▁restRequest ▁. ▁param ▁( ▁TrainedModel Config ▁. ▁MODEL _ ID ▁. ▁getPreferred Name ▁( ▁) ▁) ▁; ▁XContentParser ▁parser ▁= ▁restRequest ▁. ▁content Parser ▁( ▁) ▁; ▁Put TrainedModel Action ▁. ▁Request ▁put Request ▁= ▁Put TrainedModel Action ▁. ▁Request ▁. ▁parse Request ▁( ▁id ▁, ▁parser ▁) ▁; ▁put Request ▁. ▁timeout ▁( ▁restRequest ▁. ▁paramAsTime ▁( ▁STR ▁, ▁put Request ▁. ▁timeout ▁( ▁) ▁) ▁) ▁; ▁return ▁channel ▁-> ▁client ▁. ▁execute ▁( ▁Put TrainedModel Action ▁. ▁INSTANCE ▁, ▁put Request ▁, ▁new ▁RestToXContent Listener ▁< ▁> ▁( ▁channel ▁) ▁) ▁; ▁} ▁}
▁@ ▁RunWith ▁( ▁Parameterized R obolectric TestRunner ▁. ▁class ▁) ▁public ▁class ▁Flac Extractor Test ▁{ ▁@ ▁Parameters ▁( ▁name ▁= ▁STR ▁) ▁public ▁static ▁ImmutableList ▁< ▁Extractor Asserts ▁. ▁Sim ulation Config ▁> ▁params ▁( ▁) ▁{ ▁return ▁Extractor Asserts ▁. ▁configs ▁( ▁) ▁; ▁} ▁@ ▁Parameter ▁public ▁Extractor Asserts ▁. ▁Sim ulation Config ▁sim ulation Config ▁; ▁@ ▁Test ▁public ▁void ▁sample ▁( ▁) ▁throws ▁Exception ▁{ ▁Extractor Asserts ▁. ▁assert Behavior ▁( ▁Flac Extractor ▁:: ▁new ▁, ▁STR ▁, ▁new ▁Assertion Config ▁. ▁Builder ▁( ▁) ▁. ▁set Dump Files Prefix ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁, ▁sim ulation Config ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁sample With Id 3 Header And Id 3 Enabled ▁( ▁) ▁throws ▁Exception ▁{ ▁Extractor Asserts ▁. ▁assert Behavior ▁( ▁Flac Extractor ▁:: ▁new ▁, ▁STR ▁, ▁new ▁Assertion Config ▁. ▁Builder ▁( ▁) ▁. ▁set Dump Files Prefix ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁, ▁sim ulation Config ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁sample With Id 3 Header And Id 3 Disabled ▁( ▁) ▁throws ▁Exception ▁{ ▁Extractor Asserts ▁. ▁assert Behavior ▁( ▁( ▁) ▁-> ▁new ▁Flac Extractor ▁( ▁Flac Extractor ▁. ▁FLAG _ DIS ABLE _ ID 3_ METADATA ▁) ▁, ▁STR ▁, ▁new ▁Assertion Config ▁. ▁Builder ▁( ▁) ▁. ▁set Dump Files Prefix ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁, ▁sim ulation Config ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁sample Un se ek able ▁( ▁) ▁throws ▁Exception ▁{ ▁Extractor Asserts ▁. ▁assert Behavior ▁( ▁Flac Extractor ▁:: ▁new ▁, ▁STR ▁, ▁new ▁Assertion Config ▁. ▁Builder ▁( ▁) ▁. ▁set Dump Files Prefix ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁, ▁sim ulation Config ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁sample With V orb is Comments ▁( ▁) ▁throws ▁Exception ▁{ ▁Extractor Asserts ▁. ▁assert Behavior ▁( ▁Flac Extractor ▁:: ▁new ▁, ▁STR ▁, ▁new ▁Assertion Config ▁. ▁Builder ▁( ▁) ▁. ▁set Dump Files Prefix ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁, ▁sim ulation Config ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁sample With P icture ▁( ▁) ▁throws ▁Exception ▁{ ▁Extractor Asserts ▁. ▁assert Behavior ▁( ▁Flac Extractor ▁:: ▁new ▁, ▁STR ▁, ▁new ▁Assertion Config ▁. ▁Builder ▁( ▁) ▁. ▁set Dump Files Prefix ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁, ▁sim ulation Config ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁one Metadata Block ▁( ▁) ▁throws ▁Exception ▁{ ▁Extractor Asserts ▁. ▁assert Behavior ▁( ▁Flac Extractor ▁:: ▁new ▁, ▁STR ▁, ▁new ▁Assertion Config ▁. ▁Builder ▁( ▁) ▁. ▁set Dump Files Prefix ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁, ▁sim ulation Config ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁no MinMax FrameSize ▁( ▁) ▁throws ▁Exception ▁{ ▁Extractor Asserts ▁. ▁assert Behavior ▁( ▁Flac Extractor ▁:: ▁new ▁, ▁STR ▁, ▁new ▁Assertion Config ▁. ▁Builder ▁( ▁) ▁. ▁set Dump Files Prefix ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁, ▁sim ulation Config ▁) ▁; ▁}
▁public ▁class ▁Raptor Bucket Function ▁implements ▁Bucket Function ▁{ ▁private ▁final ▁Hash Function ▁[ ▁] ▁functions ▁; ▁private ▁final ▁int ▁bucketCount ▁; ▁public ▁Raptor Bucket Function ▁( ▁int ▁bucketCount ▁, ▁List ▁< ▁Type ▁> ▁types ▁) ▁{ ▁checkArgument ▁( ▁bucketCount ▁> ▁0 ▁, ▁STR ▁) ▁; ▁this ▁. ▁bucketCount ▁= ▁bucketCount ▁; ▁this ▁. ▁functions ▁= ▁types ▁. ▁stream ▁( ▁) ▁. ▁map ▁( ▁Raptor Bucket Function ▁:: ▁get HashFunction ▁) ▁. ▁toArray ▁( ▁Hash Function ▁[ ▁] ▁:: ▁new ▁) ▁; ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁@ ▁Override ▁public ▁int ▁getBucket ▁( ▁Page ▁page ▁, ▁int ▁position ▁) ▁{ ▁long ▁hash ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁page ▁. ▁getChannel Count ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁Block ▁block ▁= ▁page ▁. ▁getBlock ▁( ▁i ▁) ▁; ▁long ▁value ▁= ▁functions ▁[ ▁i ▁] ▁. ▁hash ▁( ▁block ▁, ▁position ▁) ▁; ▁hash ▁= ▁( ▁hash ▁ * ▁31 ▁) ▁+ ▁value ▁; ▁} ▁int ▁value ▁= ▁( ▁int ▁) ▁( ▁hash ▁& ▁Integer ▁. ▁MAX _ VALUE ▁) ▁; ▁return ▁value ▁ % ▁bucketCount ▁; ▁} ▁public ▁static ▁void ▁validate Bucket Type ▁( ▁Type ▁type ▁) ▁{ ▁get HashFunction ▁( ▁type ▁) ▁; ▁} ▁private ▁static ▁Hash Function ▁get HashFunction ▁( ▁Type ▁type ▁) ▁{ ▁if ▁( ▁type ▁. ▁equals ▁( ▁BIGINT ▁) ▁) ▁{ ▁return ▁big int HashFunction ▁( ▁) ▁; ▁} ▁if ▁( ▁type ▁. ▁equals ▁( ▁INTEGER ▁) ▁) ▁{ ▁return ▁int HashFunction ▁( ▁) ▁; ▁} ▁if ▁( ▁is VarcharType ▁( ▁type ▁) ▁) ▁{ ▁return ▁v archar HashFunction ▁( ▁) ▁; ▁} ▁throw ▁new ▁PrestoException ▁( ▁NOT _ SUPPORTED ▁, ▁STR ▁+ ▁type ▁. ▁getDisplayName ▁( ▁) ▁) ▁; ▁} ▁private ▁static ▁Hash Function ▁big int HashFunction ▁( ▁) ▁{ ▁return ▁( ▁block ▁, ▁position ▁) ▁-> ▁X x Hash 64 ▁. ▁hash ▁( ▁BIGINT ▁. ▁getLong ▁( ▁block ▁, ▁position ▁) ▁) ▁; ▁} ▁private ▁static ▁Hash Function ▁int HashFunction ▁( ▁) ▁{ ▁return ▁( ▁block ▁, ▁position ▁) ▁-> ▁X x Hash 64 ▁. ▁hash ▁( ▁INTEGER ▁. ▁getLong ▁( ▁block ▁, ▁position ▁) ▁) ▁; ▁} ▁private ▁static ▁Hash Function ▁v archar HashFunction ▁( ▁) ▁{ ▁return ▁( ▁block ▁, ▁position ▁) ▁-> ▁X x Hash 64 ▁. ▁hash ▁( ▁block ▁. ▁getSlice ▁( ▁position ▁, ▁0 ▁, ▁block ▁. ▁getSlice Length ▁( ▁position ▁) ▁) ▁) ▁; ▁} ▁private ▁interface ▁Hash Function ▁{ ▁long ▁hash ▁( ▁Block ▁block ▁, ▁int ▁position ▁) ▁; ▁} ▁}
▁layout ▁. ▁setH orizontal Group ▁( ▁layout ▁. ▁create Parallel Group ▁( ▁javax ▁. ▁sw ing ▁. ▁Group Layout ▁. ▁Al ignment ▁. ▁LE AD ING ▁) ▁. ▁add Group ▁( ▁layout ▁. ▁create Sequential Group ▁( ▁) ▁. ▁add Container Gap ▁( ▁) ▁. ▁add Group ▁( ▁layout ▁. ▁create Parallel Group ▁( ▁javax ▁. ▁sw ing ▁. ▁Group Layout ▁. ▁Al ignment ▁. ▁LE AD ING ▁) ▁. ▁add Group ▁( ▁layout ▁. ▁create Sequential Group ▁( ▁) ▁. ▁add Group ▁( ▁layout ▁. ▁create Parallel Group ▁( ▁javax ▁. ▁sw ing ▁. ▁Group Layout ▁. ▁Al ignment ▁. ▁TR AIL ING ▁) ▁. ▁add Component ▁( ▁replace Label ▁) ▁. ▁add Component ▁( ▁find Label ▁) ▁) ▁. ▁add Preferred Gap ▁( ▁javax ▁. ▁sw ing ▁. ▁Layout Style ▁. ▁Component Placement ▁. ▁RE L ATED ▁) ▁. ▁add Group ▁( ▁layout ▁. ▁create Parallel Group ▁( ▁javax ▁. ▁sw ing ▁. ▁Group Layout ▁. ▁Al ignment ▁. ▁LE AD ING ▁) ▁. ▁add Component ▁( ▁findField ▁) ▁. ▁add Component ▁( ▁replace Field ▁) ▁. ▁add Group ▁( ▁layout ▁. ▁create Sequential Group ▁( ▁) ▁. ▁add Group ▁( ▁layout ▁. ▁create Parallel Group ▁( ▁javax ▁. ▁sw ing ▁. ▁Group Layout ▁. ▁Al ignment ▁. ▁LE AD ING ▁) ▁. ▁add Component ▁( ▁search All Files Box ▁) ▁. ▁add Component ▁( ▁wrap Around Box ▁) ▁. ▁add Component ▁( ▁ignore Case Box ▁) ▁) ▁. ▁add Gap ▁( ▁0 ▁, ▁0 ▁, ▁Short ▁. ▁MAX _ VALUE ▁) ▁) ▁) ▁) ▁. ▁add Component ▁( ▁button s Container ▁, ▁javax ▁. ▁sw ing ▁. ▁Group Layout ▁. ▁DEFAULT _ SI Z E ▁, ▁javax ▁. ▁sw ing ▁. ▁Group Layout ▁. ▁DEFAULT _ SI Z E ▁, ▁Short ▁. ▁MAX _ VALUE ▁) ▁) ▁. ▁add Container Gap ▁( ▁) ▁) ▁) ▁;
▁else ▁{ ▁this ▁. ▁complete Exceptionally ▁( ▁new ▁Remoting Exception ▁( ▁channel ▁, ▁res ▁. ▁getError Message ▁( ▁) ▁) ▁) ▁; ▁} ▁if ▁( ▁executor ▁!= ▁null ▁&& ▁executor ▁instanceof ▁Thread less Executor ▁) ▁{ ▁Thread less Executor ▁thread less Executor ▁= ▁( ▁Thread less Executor ▁) ▁executor ▁; ▁if ▁( ▁thread less Executor ▁. ▁is Waiting ▁( ▁) ▁) ▁{ ▁thread less Executor ▁. ▁notify Return ▁( ▁new ▁Illegal StateException ▁( ▁STR ▁+ ▁STR ▁) ▁) ▁; ▁} ▁} ▁} ▁private ▁long ▁getId ▁( ▁) ▁{ ▁return ▁id ▁; ▁} ▁private ▁Channel ▁getChannel ▁( ▁) ▁{ ▁return ▁channel ▁; ▁} ▁private ▁boolean ▁isS ent ▁( ▁) ▁{ ▁return ▁sent ▁> ▁0 ▁; ▁} ▁public ▁Request ▁getRequest ▁( ▁) ▁{ ▁return ▁request ▁; ▁} ▁private ▁int ▁getTimeout ▁( ▁) ▁{ ▁return ▁timeout ▁; ▁} ▁private ▁void ▁do Sent ▁( ▁) ▁{ ▁sent ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁; ▁} ▁private ▁String ▁getTimeout Message ▁( ▁boolean ▁scan ▁) ▁{ ▁long ▁now Timestamp ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁; ▁return ▁( ▁sent ▁> ▁0 ▁? ▁STR ▁: ▁STR ▁) ▁+ ▁( ▁scan ▁? ▁STR ▁: ▁STR ▁) ▁+ ▁STR ▁+ ▁( ▁new ▁Simple DateFormat ▁( ▁STR ▁) ▁. ▁format ▁( ▁new ▁Date ▁( ▁start ▁) ▁) ▁) ▁+ ▁STR ▁+ ▁( ▁new ▁Simple DateFormat ▁( ▁STR ▁) ▁. ▁format ▁( ▁new ▁Date ▁( ▁now Timestamp ▁) ▁) ▁) ▁+ ▁STR ▁+ ▁( ▁sent ▁> ▁0 ▁? ▁STR ▁+ ▁( ▁sent ▁- ▁start ▁) ▁+ ▁STR ▁+ ▁( ▁now Timestamp ▁- ▁sent ▁) ▁: ▁STR ▁+ ▁( ▁now Timestamp ▁- ▁start ▁) ▁) ▁+ ▁STR ▁+ ▁timeout ▁+ ▁STR ▁+ ▁( ▁logger ▁. ▁isDebugEnabled ▁( ▁) ▁? ▁request ▁: ▁getRequest Without Data ▁( ▁) ▁) ▁+ ▁STR ▁+ ▁channel ▁. ▁getLocal Address ▁( ▁) ▁+ ▁STR ▁+ ▁channel ▁. ▁getRemote Address ▁( ▁) ▁; ▁} ▁private ▁Request ▁getRequest Without Data ▁( ▁) ▁{ ▁Request ▁new Request ▁= ▁request ▁. ▁copy ▁( ▁) ▁; ▁new Request ▁. ▁setData ▁( ▁null ▁) ▁; ▁return ▁new Request ▁; ▁} ▁private ▁static ▁class ▁Timeout Check Task ▁implements ▁TimerTask ▁{ ▁private ▁final ▁Long ▁request ID ▁; ▁Timeout Check Task ▁( ▁Long ▁request ID ▁) ▁{ ▁this ▁. ▁request ID ▁= ▁request ID ▁; ▁} ▁@ ▁Override ▁public ▁void ▁run ▁( ▁Timeout ▁timeout ▁) ▁{ ▁Default Future ▁future ▁= ▁Default Future ▁. ▁get Future ▁( ▁request ID ▁) ▁; ▁if ▁( ▁future ▁== ▁null ▁|| ▁future ▁. ▁isDone ▁( ▁) ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁future ▁. ▁getExecutor ▁( ▁) ▁!= ▁null ▁) ▁{ ▁future ▁. ▁getExecutor ▁( ▁) ▁. ▁execute ▁( ▁( ▁) ▁-> ▁notify Timeout ▁( ▁future ▁) ▁) ▁; ▁} ▁else ▁{ ▁notify Timeout ▁( ▁future ▁) ▁; ▁} ▁} ▁private ▁void ▁notify Timeout ▁( ▁Default Future ▁future ▁) ▁{ ▁Response ▁timeout Response ▁= ▁new ▁Response ▁( ▁future ▁. ▁getId ▁( ▁) ▁) ▁; ▁timeout Response ▁. ▁setStatus ▁( ▁future ▁. ▁isS ent ▁( ▁) ▁? ▁Response ▁. ▁SERVER _ TIMEOUT ▁: ▁Response ▁. ▁CLIENT _ TIMEOUT ▁) ▁;
▁public ▁class ▁Word P iece V ocab ul ary ▁implements ▁ToXContent Object ▁{ ▁public ▁static ▁final ▁String ▁NAME ▁= ▁STR ▁; ▁public ▁static ▁final ▁ParseField ▁VO C AB ▁= ▁new ▁ParseField ▁( ▁NAME ▁) ▁; ▁public ▁static ▁final ▁ParseField ▁UNKNOWN _ TOKEN ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁Construct ingObjectParser ▁< ▁Word P iece V ocab ul ary ▁, ▁Void ▁> ▁STRICT _ PARSER ▁= ▁createParser ▁( ▁false ▁) ▁; ▁private ▁static ▁final ▁Construct ingObjectParser ▁< ▁Word P iece V ocab ul ary ▁, ▁Void ▁> ▁LEN IENT _ PARSER ▁= ▁createParser ▁( ▁true ▁) ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁private ▁static ▁Construct ingObjectParser ▁< ▁Word P iece V ocab ul ary ▁, ▁Void ▁> ▁createParser ▁( ▁boolean ▁ignore UnknownFields ▁) ▁{ ▁Construct ingObjectParser ▁< ▁Word P iece V ocab ul ary ▁, ▁Void ▁> ▁parser ▁= ▁new ▁Construct ingObjectParser ▁< ▁> ▁( ▁NAME ▁, ▁ignore UnknownFields ▁, ▁a ▁-> ▁new ▁Word P iece V ocab ul ary ▁( ▁( ▁List ▁< ▁String ▁> ▁) ▁a ▁[ ▁0 ▁] ▁, ▁( ▁Integer ▁) ▁a ▁[ ▁1 ▁] ▁) ▁) ▁; ▁parser ▁. ▁declareString Array ▁( ▁Construct ingObjectParser ▁. ▁constructorArg ▁( ▁) ▁, ▁VO C AB ▁) ▁; ▁parser ▁. ▁declare Int ▁( ▁Construct ingObjectParser ▁. ▁optional ConstructorArg ▁( ▁) ▁, ▁UNKNOWN _ TOKEN ▁) ▁; ▁return ▁parser ▁; ▁} ▁public ▁static ▁Word P iece V ocab ul ary ▁fromXContent ▁( ▁XContentParser ▁parser ▁, ▁boolean ▁lenient ▁) ▁{ ▁return ▁lenient ▁? ▁LEN IENT _ PARSER ▁. ▁apply ▁( ▁parser ▁, ▁null ▁) ▁: ▁STRICT _ PARSER ▁. ▁apply ▁( ▁parser ▁, ▁null ▁) ▁; ▁} ▁private ▁final ▁SortedMap ▁< ▁String ▁, ▁Integer ▁> ▁vocab ▁; ▁private ▁final ▁int ▁unknown Token ▁; ▁public ▁Word P iece V ocab ul ary ▁( ▁List ▁< ▁String ▁> ▁words ▁, ▁Integer ▁unknown Token ▁) ▁{ ▁this ▁. ▁unknown Token ▁= ▁unknown Token ▁== ▁null ▁? ▁- ▁1 ▁: ▁unknown Token ▁; ▁vocab ▁= ▁new ▁TreeMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁words ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁vocab ▁. ▁put ▁( ▁words ▁. ▁get ▁( ▁i ▁) ▁, ▁i ▁) ▁; ▁} ▁} ▁public ▁int ▁token ▁( ▁String ▁word ▁) ▁{ ▁Integer ▁token ▁= ▁vocab ▁. ▁get ▁( ▁word ▁) ▁; ▁if ▁( ▁token ▁== ▁null ▁) ▁{ ▁token ▁= ▁unknown Token ▁; ▁} ▁return ▁token ▁; ▁} ▁@ ▁Override ▁public ▁XContentBuilder ▁toXContent ▁( ▁XContentBuilder ▁builder ▁, ▁Params ▁params ▁) ▁throws ▁IOException ▁{ ▁return ▁builder ▁. ▁field ▁( ▁VO C AB ▁. ▁getPreferred Name ▁( ▁) ▁, ▁vocab ▁. ▁keySet ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁o ▁) ▁{ ▁if ▁( ▁this ▁== ▁o ▁) ▁return ▁true ▁; ▁if ▁( ▁o ▁== ▁null ▁|| ▁getClass ▁( ▁) ▁!= ▁o ▁. ▁getClass ▁( ▁) ▁) ▁return ▁false ▁; ▁Word P iece V ocab ul ary ▁that ▁= ▁( ▁Word P iece V ocab ul ary ▁) ▁o ▁;
▁@ ▁Override ▁public ▁int ▁getResult Set Hold ability ▁( ▁) ▁throws ▁SQLException ▁{ ▁return ▁real Statement ▁. ▁getResult Set Hold ability ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁isClosed ▁( ▁) ▁throws ▁SQLException ▁{ ▁return ▁real Statement ▁. ▁isClosed ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setPool able ▁( ▁boolean ▁pool able ▁) ▁throws ▁SQLException ▁{ ▁real Statement ▁. ▁setPool able ▁( ▁pool able ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is Pool able ▁( ▁) ▁throws ▁SQLException ▁{ ▁return ▁real Statement ▁. ▁is Pool able ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁close On Completion ▁( ▁) ▁throws ▁SQLException ▁{ ▁real Statement ▁. ▁close On Completion ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is Close On Completion ▁( ▁) ▁throws ▁SQLException ▁{ ▁return ▁real Statement ▁. ▁is Close On Completion ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁< ▁T ▁> ▁T ▁unwrap ▁( ▁Class ▁< ▁T ▁> ▁iface ▁) ▁throws ▁SQLException ▁{ ▁return ▁real Statement ▁. ▁unwrap ▁( ▁iface ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁isWrapper For ▁( ▁Class ▁< ▁? ▁> ▁iface ▁) ▁throws ▁SQLException ▁{ ▁return ▁real Statement ▁. ▁isWrapper For ▁( ▁iface ▁) ▁; ▁} ▁@ ▁Override ▁public ▁ResultSet ▁executeQuery ▁( ▁) ▁throws ▁SQLException ▁{ ▁return ▁Pre paredStatement Tracing ▁. ▁execute ▁( ▁real Statement ▁, ▁connect Info ▁, ▁STR ▁, ▁sql ▁, ▁new ▁Pre paredStatement Tracing ▁. ▁Executable ▁< ▁ResultSet ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁ResultSet ▁ex e ▁( ▁Pre paredStatement ▁real Statement ▁, ▁String ▁sql ▁) ▁throws ▁SQLException ▁{ ▁return ▁real Statement ▁. ▁executeQuery ▁( ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁executeUpdate ▁( ▁) ▁throws ▁SQLException ▁{ ▁return ▁Pre paredStatement Tracing ▁. ▁execute ▁( ▁real Statement ▁, ▁connect Info ▁, ▁STR ▁, ▁sql ▁, ▁new ▁Pre paredStatement Tracing ▁. ▁Executable ▁< ▁Integer ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Integer ▁ex e ▁( ▁Pre paredStatement ▁real Statement ▁, ▁String ▁sql ▁) ▁throws ▁SQLException ▁{ ▁return ▁real Statement ▁. ▁executeUpdate ▁( ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setNull ▁( ▁int ▁parameterIndex ▁, ▁int ▁sql Type ▁) ▁throws ▁SQLException ▁{ ▁real Statement ▁. ▁setNull ▁( ▁parameterIndex ▁, ▁sql Type ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setBoolean ▁( ▁int ▁parameterIndex ▁, ▁boolean ▁x ▁) ▁throws ▁SQLException ▁{ ▁real Statement ▁. ▁setBoolean ▁( ▁parameterIndex ▁, ▁x ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Byte ▁( ▁int ▁parameterIndex ▁, ▁byte ▁x ▁) ▁throws ▁SQLException ▁{ ▁real Statement ▁. ▁set Byte ▁( ▁parameterIndex ▁, ▁x ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Short ▁( ▁int ▁parameterIndex ▁, ▁short ▁x ▁) ▁throws ▁SQLException ▁{ ▁real Statement ▁. ▁set Short ▁( ▁parameterIndex ▁, ▁x ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setInt ▁( ▁int ▁parameterIndex ▁, ▁int ▁x ▁) ▁throws ▁SQLException ▁{ ▁real Statement ▁. ▁setInt ▁( ▁parameterIndex ▁, ▁x ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setLong ▁( ▁int ▁parameterIndex ▁, ▁long ▁x ▁) ▁throws ▁SQLException ▁{ ▁real Statement ▁. ▁setLong ▁( ▁parameterIndex ▁, ▁x ▁) ▁; ▁}
▁void ▁reset ▁( ▁) ▁{ ▁is Show ing ▁= ▁false ▁; ▁invalidate ▁( ▁) ▁; ▁} ▁void ▁show ▁( ▁boolean ▁do Show ▁) ▁{ ▁if ▁( ▁do Show ▁== ▁is Show ing ▁) ▁{ ▁return ▁; ▁} ▁is Show ing ▁= ▁do Show ▁; ▁invalidate ▁( ▁) ▁; ▁} ▁private ▁void ▁invalidate ▁( ▁) ▁{ ▁invalidate Component Node ▁( ▁) ▁; ▁dispose Component ▁( ▁) ▁; ▁if ▁( ▁component Provider ▁!= ▁null ▁) ▁{ ▁if ▁( ▁is Show ing ▁) ▁{ ▁component Provider ▁. ▁component Shown ▁( ▁) ▁; ▁} ▁else ▁{ ▁component Provider ▁. ▁component Hidden ▁( ▁) ▁; ▁} ▁} ▁} ▁public ▁boolean ▁isDisposed ▁( ▁) ▁{ ▁return ▁disposed ▁; ▁} ▁void ▁dispose ▁( ▁) ▁{ ▁disposed ▁= ▁true ▁; ▁if ▁( ▁comp ▁!= ▁null ▁) ▁{ ▁comp ▁. ▁dispose ▁( ▁) ▁; ▁comp ▁= ▁null ▁; ▁} ▁if ▁( ▁comp Node ▁== ▁null ▁) ▁{ ▁return ▁; ▁} ▁Window Node ▁window Node ▁= ▁comp Node ▁. ▁getTop Level Node ▁( ▁) ▁; ▁if ▁( ▁window Node ▁!= ▁null ▁) ▁{ ▁window Node ▁. ▁component Removed ▁( ▁this ▁) ▁; ▁} ▁comp Node ▁. ▁remove ▁( ▁this ▁) ▁; ▁comp Node ▁= ▁null ▁; ▁} ▁private ▁void ▁dispose Component ▁( ▁) ▁{ ▁if ▁( ▁comp ▁== ▁null ▁) ▁{ ▁return ▁; ▁} ▁comp ▁. ▁dispose ▁( ▁) ▁; ▁comp ▁= ▁null ▁; ▁} ▁void ▁to Front ▁( ▁) ▁{ ▁if ▁( ▁comp ▁!= ▁null ▁) ▁{ ▁comp Node ▁. ▁make Selected Tab ▁( ▁this ▁) ▁; ▁} ▁} ▁void ▁request Focus ▁( ▁) ▁{ ▁Component ▁tmp ▁= ▁comp ▁; ▁if ▁( ▁tmp ▁== ▁null ▁) ▁{ ▁return ▁; ▁} ▁comp Node ▁. ▁make Selected Tab ▁( ▁this ▁) ▁; ▁activate Window ▁( ▁) ▁; ▁tmp ▁. ▁request Focus ▁( ▁) ▁; ▁Swing ▁. ▁run Later ▁( ▁( ▁) ▁-> ▁{ ▁tmp ▁. ▁request Focus ▁( ▁) ▁; ▁context Changed ▁( ▁) ▁; ▁} ▁) ▁; ▁} ▁private ▁void ▁activate Window ▁( ▁) ▁{ ▁Det ached Window Node ▁window Node ▁= ▁getWindow Node ▁( ▁) ▁; ▁if ▁( ▁window Node ▁!= ▁null ▁) ▁{ ▁Window ▁window ▁= ▁getWindow Node ▁( ▁) ▁. ▁getWindow ▁( ▁) ▁; ▁if ▁( ▁window ▁instanceof ▁Frame ▁) ▁{ ▁Frame ▁frame ▁= ▁( ▁Frame ▁) ▁window ▁; ▁frame ▁. ▁setState ▁( ▁Frame ▁. ▁NORMAL ▁) ▁; ▁} ▁} ▁} ▁void ▁close ▁( ▁) ▁{ ▁if ▁( ▁component Provider ▁!= ▁null ▁) ▁{ ▁component Provider ▁. ▁close Component ▁( ▁) ▁; ▁} ▁} ▁public ▁Dock able Component ▁getComponent ▁( ▁) ▁{ ▁if ▁( ▁disposed ▁) ▁{ ▁throw ▁new ▁AssertException ▁( ▁STR ▁+ ▁this ▁) ▁; ▁} ▁boolean ▁isD ock ing ▁= ▁true ▁; ▁if ▁( ▁comp Node ▁!= ▁null ▁) ▁{ ▁isD ock ing ▁= ▁comp Node ▁. ▁win Mgr ▁. ▁isD ock ing ▁( ▁) ▁; ▁} ▁if ▁( ▁comp ▁== ▁null ▁&& ▁is Show ing ▁) ▁{ ▁comp ▁= ▁new ▁Dock able Component ▁( ▁this ▁, ▁isD ock ing ▁) ▁; ▁} ▁return ▁comp ▁; ▁}
▁public ▁class ▁EnvVars ▁extends ▁TreeMap ▁< ▁String ▁, ▁String ▁> ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁4 32 03 3 16 6 19 8 72 59 02 2 L ▁; ▁private ▁static ▁Logger ▁LOGGER ▁= ▁Logger ▁. ▁getLogger ▁( ▁EnvVars ▁. ▁class ▁. ▁getName ▁( ▁) ▁) ▁; ▁private ▁Platform ▁platform ▁; ▁public ▁@ ▁CheckForNull ▁Platform ▁getPlatform ▁( ▁) ▁{ ▁return ▁platform ▁; ▁} ▁public ▁void ▁set Platform ▁( ▁@ ▁NonNull ▁Platform ▁platform ▁) ▁{ ▁this ▁. ▁platform ▁= ▁platform ▁; ▁} ▁public ▁EnvVars ▁( ▁) ▁{ ▁super ▁( ▁Case Insensitive Comparator ▁. ▁INSTANCE ▁) ▁; ▁} ▁public ▁EnvVars ▁( ▁@ ▁NonNull ▁Map ▁< ▁String ▁, ▁String ▁> ▁m ▁) ▁{ ▁this ▁( ▁) ▁; ▁putAll ▁( ▁m ▁) ▁; ▁if ▁( ▁m ▁instanceof ▁EnvVars ▁) ▁{ ▁EnvVars ▁lhs ▁= ▁( ▁EnvVars ▁) ▁m ▁; ▁this ▁. ▁platform ▁= ▁lhs ▁. ▁platform ▁; ▁} ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁EnvVars ▁( ▁@ ▁NonNull ▁EnvVars ▁m ▁) ▁{ ▁this ▁( ▁( ▁Map ▁) ▁m ▁) ▁; ▁} ▁public ▁EnvVars ▁( ▁String ▁... ▁keyValue Pairs ▁) ▁{ ▁this ▁( ▁) ▁; ▁if ▁( ▁keyValue Pairs ▁. ▁length ▁ % ▁2 ▁!= ▁0 ▁) ▁throw ▁new ▁IllegalArgument Exception ▁( ▁Arrays ▁. ▁asList ▁( ▁keyValue Pairs ▁) ▁. ▁toString ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁keyValue Pairs ▁. ▁length ▁; ▁i ▁+= ▁2 ▁) ▁put ▁( ▁keyValue Pairs ▁[ ▁i ▁] ▁, ▁keyValue Pairs ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁} ▁public ▁void ▁override ▁( ▁String ▁key ▁, ▁String ▁value ▁) ▁{ ▁if ▁( ▁value ▁== ▁null ▁|| ▁value ▁. ▁length ▁( ▁) ▁== ▁0 ▁) ▁{ ▁remove ▁( ▁key ▁) ▁; ▁return ▁; ▁} ▁int ▁idx ▁= ▁key ▁. ▁indexOf ▁( ▁CHAR ▁) ▁; ▁if ▁( ▁idx ▁> ▁0 ▁) ▁{ ▁String ▁real Key ▁= ▁key ▁. ▁substring ▁( ▁0 ▁, ▁idx ▁) ▁; ▁String ▁v ▁= ▁get ▁( ▁real Key ▁) ▁; ▁if ▁( ▁v ▁== ▁null ▁) ▁v ▁= ▁value ▁; ▁else ▁{ ▁char ▁ch ▁= ▁platform ▁== ▁null ▁? ▁File ▁. ▁path Separator Char ▁: ▁platform ▁. ▁path Separator ▁; ▁v ▁= ▁value ▁+ ▁ch ▁+ ▁v ▁; ▁} ▁put ▁( ▁real Key ▁, ▁v ▁) ▁; ▁return ▁; ▁} ▁put ▁( ▁key ▁, ▁value ▁) ▁; ▁} ▁public ▁EnvVars ▁override All ▁( ▁Map ▁< ▁String ▁, ▁String ▁> ▁all ▁) ▁{ ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁String ▁> ▁e ▁: ▁all ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁override ▁( ▁e ▁. ▁getKey ▁( ▁) ▁, ▁e ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁return ▁this ▁; ▁} ▁static ▁class ▁Override Order Calculator ▁{ ▁private ▁static ▁class ▁Trace Resolver ▁implements ▁Variable Resolver ▁< ▁String ▁> ▁{ ▁private ▁final ▁Comparator ▁< ▁? ▁super ▁String ▁> ▁comparator ▁; ▁public ▁Set ▁< ▁String ▁> ▁re ferred Variables ▁; ▁Trace Resolver ▁( ▁Comparator ▁< ▁? ▁super ▁String ▁> ▁comparator ▁) ▁{ ▁this ▁. ▁comparator ▁= ▁comparator ▁; ▁clear ▁( ▁) ▁; ▁}
▁@ ▁Interface Audience ▁. ▁LimitedPrivate ▁( ▁{ ▁STR ▁} ▁) ▁@ ▁Interface Stability ▁. ▁Unstable ▁public ▁class ▁Map Task ▁extends ▁Task ▁{ ▁public ▁static ▁final ▁int ▁MAP _ OUTPUT _ INDEX _ RECORD _ LENGTH ▁= ▁24 ▁; ▁private ▁static ▁final ▁FsPermission ▁SH U FF LE _ OUTPUT _ PER M ▁= ▁new ▁FsPermission ▁( ▁( ▁short ▁) ▁0 64 0 ▁) ▁; ▁private ▁Task Split Index ▁split MetaInfo ▁= ▁new ▁Task Split Index ▁( ▁) ▁; ▁private ▁final ▁static ▁int ▁APP RO X _ HEADER _ LENGTH ▁= ▁150 ▁; ▁private ▁static ▁final ▁Logger ▁LOG ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Map Task ▁. ▁class ▁. ▁getName ▁( ▁) ▁) ▁; ▁private ▁Progress ▁map Phase ▁; ▁private ▁Progress ▁sort Phase ▁; ▁{ ▁set Phase ▁( ▁Task Status ▁. ▁Phase ▁. ▁MAP ▁) ▁; ▁getProgress ▁( ▁) ▁. ▁setStatus ▁( ▁STR ▁) ▁; ▁} ▁public ▁Map Task ▁( ▁) ▁{ ▁super ▁( ▁) ▁; ▁} ▁public ▁Map Task ▁( ▁String ▁job File ▁, ▁TaskAttemptID ▁taskId ▁, ▁int ▁partition ▁, ▁Task Split Index ▁split Index ▁, ▁int ▁num Slots Required ▁) ▁{ ▁super ▁( ▁job File ▁, ▁taskId ▁, ▁partition ▁, ▁num Slots Required ▁) ▁; ▁this ▁. ▁split MetaInfo ▁= ▁split Index ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is Map Task ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁void ▁local ize Configuration ▁( ▁JobConf ▁conf ▁) ▁throws ▁IOException ▁{ ▁super ▁. ▁local ize Configuration ▁( ▁conf ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁write ▁( ▁DataOutput ▁out ▁) ▁throws ▁IOException ▁{ ▁super ▁. ▁write ▁( ▁out ▁) ▁; ▁if ▁( ▁is Map Or Reduce ▁( ▁) ▁) ▁{ ▁split MetaInfo ▁. ▁write ▁( ▁out ▁) ▁; ▁split MetaInfo ▁= ▁null ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁readFields ▁( ▁DataInput ▁in ▁) ▁throws ▁IOException ▁{ ▁super ▁. ▁readFields ▁( ▁in ▁) ▁; ▁if ▁( ▁is Map Or Reduce ▁( ▁) ▁) ▁{ ▁split MetaInfo ▁. ▁readFields ▁( ▁in ▁) ▁; ▁} ▁} ▁class ▁Track ed RecordReader ▁< ▁K ▁, ▁V ▁> ▁implements ▁RecordReader ▁< ▁K ▁, ▁V ▁> ▁{ ▁private ▁RecordReader ▁< ▁K ▁, ▁V ▁> ▁raw In ▁; ▁private ▁Counters ▁. ▁Counter ▁file Input Byte Counter ▁; ▁private ▁Counters ▁. ▁Counter ▁input Record Counter ▁; ▁private ▁Task Reporter ▁reporter ▁; ▁private ▁long ▁bytes In Pre v ▁= ▁- ▁1 ▁; ▁private ▁long ▁bytes In C urr ▁= ▁- ▁1 ▁; ▁private ▁final ▁List ▁< ▁Statistics ▁> ▁fs Stats ▁; ▁Track ed RecordReader ▁( ▁Task Reporter ▁reporter ▁, ▁JobConf ▁job ▁) ▁throws ▁IOException ▁{ ▁input Record Counter ▁= ▁reporter ▁. ▁getCounter ▁( ▁Task Counter ▁. ▁MAP _ INPUT _ REC ORDS ▁) ▁; ▁file Input Byte Counter ▁= ▁reporter ▁. ▁getCounter ▁( ▁FileInputFormat Counter ▁. ▁BYTES _ READ ▁) ▁; ▁this ▁. ▁reporter ▁= ▁reporter ▁; ▁List ▁< ▁Statistics ▁> ▁matched Stats ▁= ▁null ▁; ▁if ▁( ▁this ▁. ▁reporter ▁. ▁getInput Split ▁( ▁) ▁instanceof ▁FileSplit ▁) ▁{ ▁matched Stats ▁= ▁getF s Statistics ▁( ▁( ▁( ▁FileSplit ▁) ▁this ▁. ▁reporter ▁. ▁getInput Split ▁( ▁) ▁) ▁. ▁getPath ▁( ▁) ▁, ▁job ▁) ▁; ▁}
▁public ▁abstract ▁class ▁Template Script ▁{ ▁private ▁final ▁Map ▁< ▁String ▁, ▁Object ▁> ▁params ▁; ▁public ▁Template Script ▁( ▁Map ▁< ▁String ▁, ▁Object ▁> ▁params ▁) ▁{ ▁this ▁. ▁params ▁= ▁params ▁; ▁} ▁public ▁Map ▁< ▁String ▁, ▁Object ▁> ▁getParams ▁( ▁) ▁{ ▁return ▁params ▁; ▁} ▁public ▁static ▁final ▁String ▁[ ▁] ▁PARAMETER S ▁= ▁{ ▁} ▁; ▁public ▁abstract ▁String ▁execute ▁( ▁) ▁; ▁public ▁interface ▁Factory ▁{ ▁Template Script ▁newInstance ▁( ▁Map ▁< ▁String ▁, ▁Object ▁> ▁params ▁) ▁; ▁} ▁public ▁static ▁final ▁ScriptContext ▁< ▁Factory ▁> ▁CONTEXT ▁= ▁new ▁ScriptContext ▁< ▁> ▁( ▁STR ▁, ▁Factory ▁. ▁class ▁) ▁; ▁public ▁static ▁final ▁ScriptContext ▁< ▁Factory ▁> ▁IN G EST _ CONTEXT ▁= ▁new ▁ScriptContext ▁< ▁> ▁( ▁STR ▁, ▁Factory ▁. ▁class ▁, ▁200 ▁, ▁TimeValue ▁. ▁timeValueMillis ▁( ▁0 ▁) ▁, ▁Script Cache ▁. ▁UN LIMIT ED _ COMP IL ATION _ RATE ▁. ▁as Tuple ▁( ▁) ▁, ▁true ▁) ▁; ▁}
▁class ▁B zip 2 Bit Reader ▁{ ▁private ▁static ▁final ▁int ▁MAX _ COUNT _ OF _ READ ABLE _ BYTES ▁= ▁Integer ▁. ▁MAX _ VALUE ▁>>> ▁3 ▁; ▁private ▁ByteBuf ▁in ▁; ▁private ▁long ▁bit Buffer ▁; ▁private ▁int ▁bit Count ▁; ▁void ▁set ByteBuf ▁( ▁ByteBuf ▁in ▁) ▁{ ▁this ▁. ▁in ▁= ▁in ▁; ▁} ▁int ▁read Bits ▁( ▁final ▁int ▁count ▁) ▁{ ▁if ▁( ▁count ▁< ▁0 ▁|| ▁count ▁> ▁32 ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁count ▁+ ▁STR ▁) ▁; ▁} ▁int ▁bit Count ▁= ▁this ▁. ▁bit Count ▁; ▁long ▁bit Buffer ▁= ▁this ▁. ▁bit Buffer ▁; ▁if ▁( ▁bit Count ▁< ▁count ▁) ▁{ ▁long ▁read Data ▁; ▁int ▁offset ▁; ▁switch ▁( ▁in ▁. ▁readableBytes ▁( ▁) ▁) ▁{ ▁case ▁1 ▁: ▁{ ▁read Data ▁= ▁in ▁. ▁readUnsigned Byte ▁( ▁) ▁; ▁offset ▁= ▁8 ▁; ▁break ▁; ▁} ▁case ▁2 ▁: ▁{ ▁read Data ▁= ▁in ▁. ▁readUnsigned Short ▁( ▁) ▁; ▁offset ▁= ▁16 ▁; ▁break ▁; ▁} ▁case ▁3 ▁: ▁{ ▁read Data ▁= ▁in ▁. ▁readUnsigned M edium ▁( ▁) ▁; ▁offset ▁= ▁24 ▁; ▁break ▁; ▁} ▁default ▁: ▁{ ▁read Data ▁= ▁in ▁. ▁readUnsigned Int ▁( ▁) ▁; ▁offset ▁= ▁32 ▁; ▁break ▁; ▁} ▁} ▁bit Buffer ▁= ▁bit Buffer ▁<< ▁offset ▁| ▁read Data ▁; ▁bit Count ▁+= ▁offset ▁; ▁this ▁. ▁bit Buffer ▁= ▁bit Buffer ▁; ▁} ▁this ▁. ▁bit Count ▁= ▁bit Count ▁-= ▁count ▁; ▁return ▁( ▁int ▁) ▁( ▁bit Buffer ▁>>> ▁bit Count ▁& ▁( ▁count ▁!= ▁32 ▁? ▁( ▁1 ▁<< ▁count ▁) ▁- ▁1 ▁: ▁0 xFF FFFF FF L ▁) ▁) ▁; ▁} ▁boolean ▁readBoolean ▁( ▁) ▁{ ▁return ▁read Bits ▁( ▁1 ▁) ▁!= ▁0 ▁; ▁} ▁int ▁readInt ▁( ▁) ▁{ ▁return ▁read Bits ▁( ▁32 ▁) ▁; ▁} ▁void ▁ref ill ▁( ▁) ▁{ ▁int ▁read Data ▁= ▁in ▁. ▁readUnsigned Byte ▁( ▁) ▁; ▁bit Buffer ▁= ▁bit Buffer ▁<< ▁8 ▁| ▁read Data ▁; ▁bit Count ▁+= ▁8 ▁; ▁} ▁boolean ▁isReadable ▁( ▁) ▁{ ▁return ▁bit Count ▁> ▁0 ▁|| ▁in ▁. ▁isReadable ▁( ▁) ▁; ▁} ▁boolean ▁has Readable Bits ▁( ▁int ▁count ▁) ▁{ ▁if ▁( ▁count ▁< ▁0 ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁count ▁+ ▁STR ▁) ▁; ▁} ▁return ▁bit Count ▁>= ▁count ▁|| ▁( ▁in ▁. ▁readableBytes ▁( ▁) ▁<< ▁3 ▁& ▁Integer ▁. ▁MAX _ VALUE ▁) ▁>= ▁count ▁- ▁bit Count ▁; ▁} ▁boolean ▁has Readable Bytes ▁( ▁int ▁count ▁) ▁{ ▁if ▁( ▁count ▁< ▁0 ▁|| ▁count ▁> ▁MAX _ COUNT _ OF _ READ ABLE _ BYTES ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁count ▁+ ▁STR ▁+ ▁MAX _ COUNT _ OF _ READ ABLE _ BYTES ▁+ ▁CHAR ▁) ▁; ▁} ▁return ▁has Readable Bits ▁( ▁count ▁<< ▁3 ▁) ▁; ▁} ▁}
▁public ▁class ▁Test Disable ▁extends ▁TestCase ▁{ ▁private ▁MockDriver ▁driver ▁; ▁private ▁DruidDataSource ▁dataSource ▁; ▁protected ▁void ▁setUp ▁( ▁) ▁throws ▁Exception ▁{ ▁DruidDataSource StatManager ▁. ▁clear ▁( ▁) ▁; ▁driver ▁= ▁new ▁MockDriver ▁( ▁) ▁; ▁dataSource ▁= ▁new ▁DruidDataSource ▁( ▁) ▁; ▁dataSource ▁. ▁setUrl ▁( ▁STR ▁) ▁; ▁dataSource ▁. ▁setDriver ▁( ▁driver ▁) ▁; ▁dataSource ▁. ▁setInitial Size ▁( ▁1 ▁) ▁; ▁dataSource ▁. ▁setMax Active ▁( ▁2 ▁) ▁; ▁dataSource ▁. ▁setMax Idle ▁( ▁2 ▁) ▁; ▁dataSource ▁. ▁setMin Idle ▁( ▁1 ▁) ▁; ▁dataSource ▁. ▁setMin Ev ic table Idle TimeMillis ▁( ▁300 ▁ * ▁1000 ▁) ▁; ▁dataSource ▁. ▁setTime Between Eviction Runs Millis ▁( ▁180 ▁ * ▁1000 ▁) ▁; ▁dataSource ▁. ▁setTest While Idle ▁( ▁true ▁) ▁; ▁dataSource ▁. ▁setTestOnBorrow ▁( ▁false ▁) ▁; ▁dataSource ▁. ▁set Validation Query ▁( ▁STR ▁) ▁; ▁dataSource ▁. ▁setFilters ▁( ▁STR ▁) ▁; ▁} ▁protected ▁void ▁tearDown ▁( ▁) ▁throws ▁Exception ▁{ ▁dataSource ▁. ▁close ▁( ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁0 ▁, ▁DruidDataSource StatManager ▁. ▁getInstance ▁( ▁) ▁. ▁getDataSource List ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁test _ close ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁int ▁threadCount ▁= ▁100 ▁; ▁Thread ▁[ ▁] ▁threads ▁= ▁new ▁Thread ▁[ ▁threadCount ▁] ▁; ▁final ▁CountDownLatch ▁start Latch ▁= ▁new ▁CountDownLatch ▁( ▁1 ▁) ▁; ▁final ▁CountDownLatch ▁end Latch ▁= ▁new ▁CountDownLatch ▁( ▁threadCount ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁threadCount ▁; ▁++ ▁i ▁) ▁{ ▁threads ▁[ ▁i ▁] ▁= ▁new ▁Thread ▁( ▁STR ▁+ ▁i ▁) ▁{ ▁public ▁void ▁run ▁( ▁) ▁{ ▁try ▁{ ▁start Latch ▁. ▁await ▁( ▁) ▁; ▁Connection ▁conn ▁= ▁dataSource ▁. ▁getConnection ▁( ▁) ▁; ▁} ▁catch ▁( ▁DataSource Disable Exception ▁e ▁) ▁{ ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁e ▁. ▁printStackTrace ▁( ▁) ▁; ▁} ▁finally ▁{ ▁end Latch ▁. ▁countDown ▁( ▁) ▁; ▁} ▁} ▁} ▁; ▁} ▁start Latch ▁. ▁countDown ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁threadCount ▁; ▁++ ▁i ▁) ▁{ ▁threads ▁[ ▁i ▁] ▁. ▁start ▁( ▁) ▁; ▁} ▁Thread ▁. ▁sleep ▁( ▁1000 ▁) ▁; ▁new ▁Thread ▁( ▁STR ▁) ▁{ ▁public ▁void ▁run ▁( ▁) ▁{ ▁dataSource ▁. ▁set Enable ▁( ▁false ▁) ▁; ▁} ▁} ▁. ▁start ▁( ▁) ▁; ▁end Latch ▁. ▁await ▁( ▁) ▁; ▁} ▁}
▁final ▁class ▁D ar w in AMD 64 Platform Capability ▁extends ▁Basic Platform Capability ▁< ▁D ar w in AMD 64 Sy scall ▁> ▁{ ▁public ▁static ▁final ▁int ▁RT LD _ G LOBAL _ D AR W IN ▁= ▁8 ▁; ▁public ▁static ▁final ▁int ▁RT LD _ FIRST _ D AR W IN ▁= ▁100 ▁; ▁public ▁static ▁final ▁long ▁RT LD _ DEFAULT _ D AR W IN ▁= ▁- ▁2 ▁; ▁D ar w in AMD 64 Platform Capability ▁( ▁boolean ▁load C xx Libraries ▁) ▁{ ▁super ▁( ▁D ar w in AMD 64 Sy scall ▁. ▁class ▁, ▁load C xx Libraries ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is Global DL Open Flag Set ▁( ▁int ▁flag ▁) ▁{ ▁return ▁( ▁flag ▁& ▁RT LD _ G LOBAL _ D AR W IN ▁) ▁== ▁RT LD _ G LOBAL _ D AR W IN ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁isFirst DL Open Flag Set ▁( ▁int ▁flag ▁) ▁{ ▁return ▁( ▁flag ▁& ▁RT LD _ FIRST _ D AR W IN ▁) ▁== ▁RT LD _ FIRST _ D AR W IN ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁isDefault D LS ym Flag Set ▁( ▁long ▁flag ▁) ▁{ ▁return ▁flag ▁== ▁RT LD _ DEFAULT _ D AR W IN ▁; ▁} ▁@ ▁Override ▁protected ▁LLVM Sy scall Operation Node ▁create Sy scall Node ▁( ▁D ar w in AMD 64 Sy scall ▁sy scall ▁) ▁{ ▁switch ▁( ▁sy scall ▁) ▁{ ▁case ▁SY S _ mm ap ▁: ▁return ▁LLVMAMD 64 Sy scall M map NodeGen ▁. ▁create ▁( ▁) ▁; ▁case ▁SY S _ ex it ▁: ▁return ▁new ▁LLVM Sy scall Exit Node ▁( ▁) ▁; ▁default ▁: ▁return ▁new ▁LLVMNative Sy scall Node ▁( ▁sy scall ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁Object ▁create VA List Storage ▁( ▁RootNode ▁rootNode ▁) ▁{ ▁return ▁new ▁LLVM X 86 _64 V a List Storage ▁( ▁rootNode ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Type ▁getV A List Type ▁( ▁) ▁{ ▁return ▁LLVM X 86 _64 V a List Storage ▁. ▁V A _ LIST _ TYPE ▁; ▁} ▁@ ▁Override ▁public ▁V A List Pointer Wrapper Factory ▁create Native VA List Wrapper ▁( ▁boolean ▁cached ▁) ▁{ ▁return ▁cached ▁? ▁X 86 _64 VA List Pointer Wrapper Factory NodeGen ▁. ▁create ▁( ▁) ▁: ▁X 86 _64 VA List Pointer Wrapper Factory NodeGen ▁. ▁getUncached ▁( ▁) ▁; ▁} ▁}
▁check Sh a 1 ▁( ▁STR ▁, ▁key ▁, ▁data ▁) ▁; ▁} ▁public ▁void ▁test R fc 2 20 2_ h mac Sh a 1_ case 3 ▁( ▁) ▁{ ▁byte ▁[ ▁] ▁key ▁= ▁fill ByteArray ▁( ▁20 ▁, ▁0 x aa ▁) ▁; ▁byte ▁[ ▁] ▁data ▁= ▁fill ByteArray ▁( ▁50 ▁, ▁0 x dd ▁) ▁; ▁check Sh a 1 ▁( ▁STR ▁, ▁key ▁, ▁data ▁) ▁; ▁} ▁public ▁void ▁test R fc 2 20 2_ h mac Sh a 1_ case 4 ▁( ▁) ▁{ ▁byte ▁[ ▁] ▁key ▁= ▁base 16 ▁( ▁) ▁. ▁lower Case ▁( ▁) ▁. ▁decode ▁( ▁STR ▁) ▁; ▁byte ▁[ ▁] ▁data ▁= ▁fill ByteArray ▁( ▁50 ▁, ▁0 x cd ▁) ▁; ▁check Sh a 1 ▁( ▁STR ▁, ▁key ▁, ▁data ▁) ▁; ▁} ▁public ▁void ▁test R fc 2 20 2_ h mac Sh a 1_ case 5 ▁( ▁) ▁{ ▁byte ▁[ ▁] ▁key ▁= ▁fill ByteArray ▁( ▁20 ▁, ▁0 x 0 c ▁) ▁; ▁String ▁data ▁= ▁STR ▁; ▁check Sh a 1 ▁( ▁STR ▁, ▁key ▁, ▁data ▁) ▁; ▁} ▁public ▁void ▁test R fc 2 20 2_ h mac Sh a 1_ case 6 ▁( ▁) ▁{ ▁byte ▁[ ▁] ▁key ▁= ▁fill ByteArray ▁( ▁80 ▁, ▁0 x aa ▁) ▁; ▁String ▁data ▁= ▁STR ▁; ▁check Sh a 1 ▁( ▁STR ▁, ▁key ▁, ▁data ▁) ▁; ▁} ▁public ▁void ▁test R fc 2 20 2_ h mac Sh a 1_ case 7 ▁( ▁) ▁{ ▁byte ▁[ ▁] ▁key ▁= ▁fill ByteArray ▁( ▁80 ▁, ▁0 x aa ▁) ▁; ▁String ▁data ▁= ▁STR ▁; ▁check Sh a 1 ▁( ▁STR ▁, ▁key ▁, ▁data ▁) ▁; ▁} ▁public ▁void ▁test R fc 2 20 2_ h mac Md 5_ case 1 ▁( ▁) ▁{ ▁byte ▁[ ▁] ▁key ▁= ▁fill ByteArray ▁( ▁16 ▁, ▁0 x 0 b ▁) ▁; ▁String ▁data ▁= ▁STR ▁; ▁check Md 5 ▁( ▁STR ▁, ▁key ▁, ▁data ▁) ▁; ▁} ▁public ▁void ▁test R fc 2 20 2_ h mac Md 5_ case 2 ▁( ▁) ▁{ ▁byte ▁[ ▁] ▁key ▁= ▁STR ▁. ▁getBytes ▁( ▁UTF _8 ▁) ▁; ▁String ▁data ▁= ▁STR ▁; ▁check Md 5 ▁( ▁STR ▁, ▁key ▁, ▁data ▁) ▁; ▁} ▁public ▁void ▁test R fc 2 20 2_ h mac Md 5_ case 3 ▁( ▁) ▁{ ▁byte ▁[ ▁] ▁key ▁= ▁fill ByteArray ▁( ▁16 ▁, ▁0 x aa ▁) ▁; ▁byte ▁[ ▁] ▁data ▁= ▁fill ByteArray ▁( ▁50 ▁, ▁0 x dd ▁) ▁; ▁check Md 5 ▁( ▁STR ▁, ▁key ▁, ▁data ▁) ▁; ▁} ▁public ▁void ▁test R fc 2 20 2_ h mac Md 5_ case 4 ▁( ▁) ▁{ ▁byte ▁[ ▁] ▁key ▁= ▁base 16 ▁( ▁) ▁. ▁lower Case ▁( ▁) ▁. ▁decode ▁( ▁STR ▁) ▁; ▁byte ▁[ ▁] ▁data ▁= ▁fill ByteArray ▁( ▁50 ▁, ▁0 x cd ▁) ▁;
▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁@ ▁GwtCompatible ▁public ▁enum ▁MapFeature ▁implements ▁Feature ▁< ▁Map ▁> ▁{ ▁ALLOWS _ NULL _ KEY _ QUERIES ▁, ▁ALLOWS _ NULL _ KEYS ▁( ▁ALLOWS _ NULL _ KEY _ QUERIES ▁) ▁, ▁ALLOWS _ NULL _ VALUE _ QUERIES ▁, ▁ALLOWS _ NULL _ VALUES ▁( ▁ALLOWS _ NULL _ VALUE _ QUERIES ▁) ▁, ▁ALLOWS _ NULL _ ENTRY _ QUERIES ▁, ▁ALLOWS _ AN Y _ NULL _ QUERIES ▁( ▁ALLOWS _ NULL _ ENTRY _ QUERIES ▁, ▁ALLOWS _ NULL _ KEY _ QUERIES ▁, ▁ALLOWS _ NULL _ VALUE _ QUERIES ▁) ▁, ▁RE STR ICT S _ KEYS ▁, ▁RE STR ICT S _ VALUES ▁, ▁SUPPORTS _ PUT ▁, ▁SUPPORTS _ REMOVE ▁, ▁FAIL S _ FA ST _ ON _ CON CURRENT _ MODIFI CATION ▁, ▁REJECT S _ D UP LIC ATE S _ AT _ CRE ATION ▁, ▁GENER AL _ P UR PO SE ▁( ▁SUPPORTS _ PUT ▁, ▁SUPPORTS _ REMOVE ▁) ▁; ▁private ▁final ▁Set ▁< ▁Feature ▁< ▁? ▁super ▁Map ▁> ▁> ▁imp lied ▁; ▁MapFeature ▁( ▁Feature ▁< ▁? ▁super ▁Map ▁> ▁... ▁imp lied ▁) ▁{ ▁this ▁. ▁imp lied ▁= ▁Helpers ▁. ▁copyTo Set ▁( ▁imp lied ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Set ▁< ▁Feature ▁< ▁? ▁super ▁Map ▁> ▁> ▁get Imp lied Features ▁( ▁) ▁{ ▁return ▁imp lied ▁; ▁} ▁@ ▁Retention ▁( ▁RetentionPolicy ▁. ▁RUNTIME ▁) ▁@ ▁In herited ▁@ ▁Test er Annotation ▁public ▁@ interface ▁Require ▁{ ▁public ▁abstract ▁MapFeature ▁[ ▁] ▁value ▁( ▁) ▁default ▁{ ▁} ▁; ▁public ▁abstract ▁MapFeature ▁[ ▁] ▁absent ▁( ▁) ▁default ▁{ ▁} ▁; ▁} ▁}
▁for ▁( ▁Training Listener ▁il ▁: ▁listeners ▁) ▁{ ▁log ▁. ▁info ▁( ▁STR ▁) ▁; ▁log ▁. ▁info ▁( ▁STR ▁, ▁il ▁) ▁; ▁ByteArray OutputStream ▁baos ▁= ▁new ▁ByteArray OutputStream ▁( ▁) ▁; ▁Object OutputStream ▁ oos ▁= ▁new ▁Object OutputStream ▁( ▁baos ▁) ▁; ▁ oos ▁. ▁writeObject ▁( ▁il ▁) ▁; ▁byte ▁[ ▁] ▁bytes ▁= ▁baos ▁. ▁toByteArray ▁( ▁) ▁; ▁Object InputStream ▁o is ▁= ▁new ▁Object InputStream ▁( ▁new ▁ByteArray InputStream ▁( ▁bytes ▁) ▁) ▁; ▁Training Listener ▁il 2 ▁= ▁( ▁Training Listener ▁) ▁o is ▁. ▁readObject ▁( ▁) ▁; ▁listeners 2 ▁. ▁add ▁( ▁il 2 ▁) ▁; ▁} ▁net ▁. ▁set Listeners ▁( ▁listeners 2 ▁) ▁; ▁net ▁. ▁fit ▁( ▁iter ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Listener Calls ▁( ▁) ▁{ ▁MultiLayer Configuration ▁conf ▁= ▁new ▁NeuralNet Configuration ▁. ▁Builder ▁( ▁) ▁. ▁list ▁( ▁) ▁. ▁layer ▁( ▁new ▁Output Layer ▁. ▁Builder ▁( ▁) ▁. ▁nIn ▁( ▁4 ▁) ▁. ▁nOut ▁( ▁3 ▁) ▁. ▁activation ▁( ▁Activation ▁. ▁S OFT MAX ▁) ▁. ▁loss Function ▁( ▁Loss Functions ▁. ▁LossFunction ▁. ▁M C X ENT ▁) ▁. ▁build ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁MultiLayer Network ▁net ▁= ▁new ▁MultiLayer Network ▁( ▁conf ▁) ▁; ▁net ▁. ▁init ▁( ▁) ▁; ▁Test Listener ▁t l ▁= ▁new ▁Test Listener ▁( ▁) ▁; ▁net ▁. ▁set Listeners ▁( ▁t l ▁) ▁; ▁DataSetIterator ▁i ri s Iter ▁= ▁new ▁I ri s DataSetIterator ▁( ▁50 ▁, ▁150 ▁) ▁; ▁net ▁. ▁fit ▁( ▁i ri s Iter ▁, ▁2 ▁) ▁; ▁List ▁< ▁T riple ▁< ▁Call ▁, ▁Integer ▁, ▁Integer ▁> ▁> ▁exp ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁exp ▁. ▁add ▁( ▁new ▁T riple ▁< ▁> ▁( ▁Call ▁. ▁E POCH _ START ▁, ▁0 ▁, ▁0 ▁) ▁) ▁; ▁exp ▁. ▁add ▁( ▁new ▁T riple ▁< ▁> ▁( ▁Call ▁. ▁ON _ FW D ▁, ▁0 ▁, ▁0 ▁) ▁) ▁; ▁exp ▁. ▁add ▁( ▁new ▁T riple ▁< ▁> ▁( ▁Call ▁. ▁ON _ B W D ▁, ▁0 ▁, ▁0 ▁) ▁) ▁; ▁exp ▁. ▁add ▁( ▁new ▁T riple ▁< ▁> ▁( ▁Call ▁. ▁ON _ GR AD ▁, ▁0 ▁, ▁0 ▁) ▁) ▁; ▁exp ▁. ▁add ▁( ▁new ▁T riple ▁< ▁> ▁( ▁Call ▁. ▁ITER _ DONE ▁, ▁0 ▁, ▁0 ▁) ▁) ▁; ▁exp ▁. ▁add ▁( ▁new ▁T riple ▁< ▁> ▁( ▁Call ▁. ▁ON _ FW D ▁, ▁1 ▁, ▁0 ▁) ▁) ▁; ▁exp ▁. ▁add ▁( ▁new ▁T riple ▁< ▁> ▁( ▁Call ▁. ▁ON _ B W D ▁, ▁1 ▁, ▁0 ▁) ▁) ▁; ▁exp ▁. ▁add ▁( ▁new ▁T riple ▁< ▁> ▁( ▁Call ▁. ▁ON _ GR AD ▁, ▁1 ▁, ▁0 ▁) ▁) ▁; ▁exp ▁. ▁add ▁( ▁new ▁T riple ▁< ▁> ▁( ▁Call ▁. ▁ITER _ DONE ▁, ▁1 ▁, ▁0 ▁) ▁) ▁;
▁Annotation Bo ▁sql ▁= ▁new ▁Annotation Bo ▁( ▁AnnotationKey ▁. ▁SQL ▁. ▁getCode ▁( ▁) ▁, ▁StringUtils ▁. ▁trim ▁( ▁original Sql ▁) ▁) ▁; ▁annotation BoList ▁. ▁add ▁( ▁sql ▁) ▁; ▁} ▁} ▁else ▁{ ▁String ▁collision Sql Id Code Message ▁= ▁collision Sql Id Code Message ▁( ▁sql Id ▁, ▁sql MetaData List ▁) ▁; ▁Annotation Bo ▁api ▁= ▁new ▁Annotation Bo ▁( ▁AnnotationKey ▁. ▁SQL ▁. ▁getCode ▁( ▁) ▁, ▁collision Sql Id Code Message ▁) ▁; ▁annotation BoList ▁. ▁add ▁( ▁api ▁) ▁; ▁} ▁final ▁String ▁bind Value ▁= ▁sql Value ▁. ▁getString Value 2 ▁( ▁) ▁; ▁if ▁( ▁StringUtils ▁. ▁isNotEmpty ▁( ▁bind Value ▁) ▁) ▁{ ▁Annotation Bo ▁bind Value Annotation ▁= ▁new ▁Annotation Bo ▁( ▁AnnotationKey ▁. ▁SQL _ BIND VALUE ▁. ▁getCode ▁( ▁) ▁, ▁bind Value ▁) ▁; ▁annotation BoList ▁. ▁add ▁( ▁bind Value Annotation ▁) ▁; ▁} ▁} ▁} ▁) ▁; ▁} ▁private ▁void ▁transition Mongo Json ▁( ▁final ▁List ▁< ▁Align ▁> ▁spans ▁) ▁{ ▁this ▁. ▁transition Annotation ▁( ▁spans ▁, ▁new ▁Annotation Replacement Callback ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁replacement ▁( ▁Align ▁align ▁, ▁List ▁< ▁Annotation Bo ▁> ▁annotation BoList ▁) ▁{ ▁Annotation Bo ▁collection Info ▁= ▁find Annotation ▁( ▁annotation BoList ▁, ▁Mongo Constants ▁. ▁M ONG O _ COLLE CTION _ INFO ▁. ▁getCode ▁( ▁) ▁) ▁; ▁Annotation Bo ▁collection Option ▁= ▁find Annotation ▁( ▁annotation BoList ▁, ▁Mongo Constants ▁. ▁M ONG O _ COLLE CTION _ OPTION ▁. ▁getCode ▁( ▁) ▁) ▁; ▁if ▁( ▁collection Info ▁!= ▁null ▁) ▁{ ▁StringBuilder ▁stringBuilder ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁stringBuilder ▁. ▁append ▁( ▁align ▁. ▁getDestination Id ▁( ▁) ▁) ▁. ▁append ▁( ▁STR ▁) ▁. ▁append ▁( ▁( ▁String ▁) ▁collection Info ▁. ▁getValue ▁( ▁) ▁) ▁; ▁if ▁( ▁collection Option ▁!= ▁null ▁) ▁{ ▁stringBuilder ▁. ▁append ▁( ▁STR ▁) ▁. ▁append ▁( ▁( ▁( ▁String ▁) ▁collection Option ▁. ▁getValue ▁( ▁) ▁) ▁. ▁toUpperCase ▁( ▁) ▁) ▁; ▁} ▁collection Info ▁. ▁setValue ▁( ▁stringBuilder ▁) ▁; ▁} ▁Annotation Bo ▁json Annotation ▁= ▁find Annotation ▁( ▁annotation BoList ▁, ▁Mongo Constants ▁. ▁M ONG O _ JSON _ DATA ▁. ▁getCode ▁( ▁) ▁) ▁; ▁if ▁( ▁json Annotation ▁== ▁null ▁) ▁{ ▁return ▁; ▁} ▁final ▁String StringValue ▁json Value ▁= ▁( ▁String StringValue ▁) ▁json Annotation ▁. ▁getValue ▁( ▁) ▁; ▁final ▁String ▁json ▁= ▁json Value ▁. ▁getString Value 1 ▁( ▁) ▁; ▁final ▁String ▁json bind Value ▁= ▁json Value ▁. ▁getString Value 2 ▁( ▁) ▁; ▁if ▁( ▁StringUtils ▁. ▁isEmpty ▁( ▁json ▁) ▁) ▁{ ▁logger ▁. ▁debug ▁( ▁STR ▁) ▁; ▁} ▁else ▁{ ▁Annotation Bo ▁json Meta ▁= ▁new ▁Annotation Bo ▁( ▁Mongo Constants ▁. ▁M ONG O _ JSON ▁. ▁getCode ▁( ▁) ▁, ▁json ▁) ▁; ▁annotation BoList ▁. ▁add ▁( ▁json Meta ▁) ▁; ▁}
▁public ▁class ▁JSONField Test 2 ▁extends ▁TestCase ▁{ ▁public ▁void ▁test _ json Field ▁( ▁) ▁throws ▁Exception ▁{ ▁VO ▁vo ▁= ▁new ▁VO ▁( ▁) ▁; ▁vo ▁. ▁setId ▁( ▁123 ▁) ▁; ▁vo ▁. ▁set Flag ▁( ▁true ▁) ▁; ▁String ▁text ▁= ▁JSON ▁. ▁toJSONString ▁( ▁vo ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁text ▁) ▁; ▁} ▁public ▁static ▁class ▁VO ▁{ ▁private ▁int ▁id ▁; ▁@ ▁JSONField ▁( ▁serialize ▁= ▁false ▁) ▁private ▁boolean ▁flag ▁; ▁public ▁int ▁getId ▁( ▁) ▁{ ▁return ▁id ▁; ▁} ▁public ▁void ▁setId ▁( ▁int ▁id ▁) ▁{ ▁this ▁. ▁id ▁= ▁id ▁; ▁} ▁public ▁boolean ▁is Flag ▁( ▁) ▁{ ▁return ▁flag ▁; ▁} ▁public ▁void ▁set Flag ▁( ▁boolean ▁flag ▁) ▁{ ▁this ▁. ▁flag ▁= ▁flag ▁; ▁} ▁} ▁}
▁if ▁( ▁current Account ▁== ▁0 ▁) ▁{ ▁selected Account ▁= ▁preferences ▁. ▁getInt ▁( ▁STR ▁, ▁0 ▁) ▁; ▁} ▁registered For Push ▁= ▁preferences ▁. ▁getBoolean ▁( ▁STR ▁, ▁false ▁) ▁; ▁last Send MessageId ▁= ▁preferences ▁. ▁getInt ▁( ▁STR ▁, ▁- ▁21 0000 ▁) ▁; ▁contacts Saved Count ▁= ▁preferences ▁. ▁getInt ▁( ▁STR ▁, ▁0 ▁) ▁; ▁last Broadcast Id ▁= ▁preferences ▁. ▁getInt ▁( ▁STR ▁, ▁- ▁1 ▁) ▁; ▁last Contact s Sync Time ▁= ▁preferences ▁. ▁getInt ▁( ▁STR ▁, ▁( ▁int ▁) ▁( ▁System ▁. ▁current TimeMillis ▁( ▁) ▁ / ▁1000 ▁) ▁- ▁23 ▁ * ▁60 ▁ * ▁60 ▁) ▁; ▁last Hints Sync Time ▁= ▁preferences ▁. ▁getInt ▁( ▁STR ▁, ▁( ▁int ▁) ▁( ▁System ▁. ▁current TimeMillis ▁( ▁) ▁ / ▁1000 ▁) ▁- ▁25 ▁ * ▁60 ▁ * ▁60 ▁) ▁; ▁d ra ft s Loaded ▁= ▁preferences ▁. ▁getBoolean ▁( ▁STR ▁, ▁false ▁) ▁; ▁unread Dialog s Loaded ▁= ▁preferences ▁. ▁getBoolean ▁( ▁STR ▁, ▁false ▁) ▁; ▁contacts Re imp orted ▁= ▁preferences ▁. ▁getBoolean ▁( ▁STR ▁, ▁false ▁) ▁; ▁r ating Load Time ▁= ▁preferences ▁. ▁getInt ▁( ▁STR ▁, ▁0 ▁) ▁; ▁b ot Rating Load Time ▁= ▁preferences ▁. ▁getInt ▁( ▁STR ▁, ▁0 ▁) ▁; ▁login Time ▁= ▁preferences ▁. ▁getInt ▁( ▁STR ▁, ▁current Account ▁) ▁; ▁sync Contact s ▁= ▁preferences ▁. ▁getBoolean ▁( ▁STR ▁, ▁true ▁) ▁; ▁s uggest Contact s ▁= ▁preferences ▁. ▁getBoolean ▁( ▁STR ▁, ▁true ▁) ▁; ▁has Secure Data ▁= ▁preferences ▁. ▁getBoolean ▁( ▁STR ▁, ▁false ▁) ▁; ▁notification s Settings Loaded ▁= ▁preferences ▁. ▁getBoolean ▁( ▁STR ▁, ▁false ▁) ▁; ▁notification s Sign Up Settings Loaded ▁= ▁preferences ▁. ▁getBoolean ▁( ▁STR ▁, ▁false ▁) ▁; ▁auto Download Config Load Time ▁= ▁preferences ▁. ▁getLong ▁( ▁STR ▁, ▁0 ▁) ▁; ▁has Valid Dialog Load Ids ▁= ▁preferences ▁. ▁contains ▁( ▁STR ▁) ▁|| ▁preferences ▁. ▁getBoolean ▁( ▁STR ▁, ▁false ▁) ▁; ▁sh aring My Location Until ▁= ▁preferences ▁. ▁getInt ▁( ▁STR ▁, ▁0 ▁) ▁; ▁last My Location Share Time ▁= ▁preferences ▁. ▁getInt ▁( ▁STR ▁, ▁0 ▁) ▁; ▁filters Loaded ▁= ▁preferences ▁. ▁getBoolean ▁( ▁STR ▁, ▁false ▁) ▁; ▁try ▁{ ▁String ▁terms ▁= ▁preferences ▁. ▁getString ▁( ▁STR ▁, ▁null ▁) ▁; ▁if ▁( ▁terms ▁!= ▁null ▁) ▁{ ▁byte ▁[ ▁] ▁arr ▁= ▁Base 64 ▁. ▁decode ▁( ▁terms ▁, ▁Base 64 ▁. ▁DEFAULT ▁) ▁; ▁if ▁( ▁arr ▁!= ▁null ▁) ▁{ ▁Serialized Data ▁data ▁= ▁new ▁Serialized Data ▁( ▁arr ▁) ▁; ▁un ac cepted Terms Of Service ▁= ▁TLRPC ▁. ▁TL _ h elp _ ter ms Of Service ▁. ▁TL de ser ialize ▁( ▁data ▁, ▁data ▁. ▁readInt 32 ▁( ▁false ▁) ▁, ▁false ▁) ▁; ▁data ▁. ▁cleanup ▁( ▁) ▁; ▁} ▁} ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁File Log ▁. ▁e ▁( ▁e ▁) ▁; ▁}
▁if ▁( ▁fil ler Value ▁. ▁equals IgnoreCase ▁( ▁DEFAULT _ FI LL _ VALUE ▁) ▁) ▁{ ▁String ▁fil ler Bytes ▁= ▁determine F iller Value ▁( ▁listing ▁) ▁; ▁if ▁( ▁fil ler Bytes ▁== ▁null ▁) ▁{ ▁return ▁false ▁; ▁} ▁fil ler ▁= ▁STR ▁+ ▁fil ler Bytes ▁; ▁} ▁byte ▁[ ▁] ▁test Bytes ▁= ▁new ▁byte ▁[ ▁min Bytes ▁] ▁; ▁byte ▁fil ler Byte ▁= ▁Integer ▁. ▁decode ▁( ▁fil ler ▁) ▁. ▁byteValue ▁( ▁) ▁; ▁Arrays ▁. ▁fill ▁( ▁test Bytes ▁, ▁fil ler Byte ▁) ▁; ▁byte ▁[ ▁] ▁program Bytes ▁= ▁new ▁byte ▁[ ▁min Bytes ▁] ▁; ▁Function Iterator ▁iterator ▁= ▁listing ▁. ▁getFunctions ▁( ▁true ▁) ▁; ▁while ▁( ▁iterator ▁. ▁hasNext ▁( ▁) ▁&& ▁! ▁monitor ▁. ▁isCancelled ▁( ▁) ▁) ▁{ ▁Function ▁f un ct i oin ▁= ▁iterator ▁. ▁next ▁( ▁) ▁; ▁Address ▁fil ler Address ▁= ▁f un ct i oin ▁. ▁getBody ▁( ▁) ▁. ▁getMaxAddress ▁( ▁) ▁. ▁next ▁( ▁) ▁; ▁Data ▁un defined ▁= ▁listing ▁. ▁getUn defined Data At ▁( ▁fil ler Address ▁) ▁; ▁if ▁( ▁un defined ▁== ▁null ▁) ▁{ ▁continue ▁; ▁} ▁String ▁un defined Representation ▁= ▁un defined ▁. ▁getDefaultValue Representation ▁( ▁) ▁; ▁if ▁( ▁! ▁getBytes ▁( ▁program ▁. ▁getMemory ▁( ▁) ▁, ▁fil ler Address ▁, ▁program Bytes ▁) ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁! ▁Arrays ▁. ▁equals ▁( ▁program Bytes ▁, ▁test Bytes ▁) ▁) ▁{ ▁continue ▁; ▁} ▁int ▁fil ler Length ▁= ▁count Un defined s ▁( ▁program ▁, ▁fil ler Address ▁, ▁un defined Representation ▁) ▁; ▁replace F iller Bytes ▁( ▁listing ▁, ▁fil ler Address ▁, ▁fil ler Length ▁) ▁; ▁} ▁return ▁true ▁; ▁} ▁private ▁boolean ▁getBytes ▁( ▁Memory ▁memory ▁, ▁Address ▁fil ler Address ▁, ▁byte ▁[ ▁] ▁program Bytes ▁) ▁{ ▁try ▁{ ▁memory ▁. ▁getBytes ▁( ▁fil ler Address ▁, ▁program Bytes ▁) ▁; ▁return ▁true ▁; ▁} ▁catch ▁( ▁Memory AccessException ▁e ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁private ▁int ▁count Un defined s ▁( ▁Program ▁p ▁, ▁Address ▁address ▁, ▁String ▁un defined String ▁) ▁{ ▁int ▁un defined Count ▁= ▁1 ▁; ▁Listing ▁listing ▁= ▁p ▁. ▁getListing ▁( ▁) ▁; ▁AddressSet ▁all Address After ▁= ▁new ▁AddressSet ▁( ▁p ▁, ▁address ▁, ▁p ▁. ▁getMaxAddress ▁( ▁) ▁) ▁; ▁Address Iterator ▁iterator ▁= ▁all Address After ▁. ▁getAddress es ▁( ▁address ▁. ▁next ▁( ▁) ▁, ▁true ▁) ▁; ▁while ▁( ▁iterator ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁Address ▁next ▁= ▁iterator ▁. ▁next ▁( ▁) ▁; ▁Data ▁un defined ▁= ▁listing ▁. ▁getUn defined Data At ▁( ▁next ▁) ▁; ▁if ▁( ▁un defined ▁== ▁null ▁) ▁{ ▁break ▁; ▁} ▁String ▁current String ▁= ▁un defined ▁. ▁getDefaultValue Representation ▁( ▁) ▁; ▁if ▁( ▁! ▁un defined String ▁. ▁equals IgnoreCase ▁( ▁current String ▁) ▁) ▁{ ▁break ▁; ▁} ▁++ ▁un defined Count ▁; ▁} ▁return ▁un defined Count ▁; ▁}
▁Test File Utils ▁. ▁createTempFile In Directory ▁( ▁nested Dir ▁. ▁getAbsolutePath ▁( ▁) ▁, ▁STR ▁) ▁; ▁Test File Utils ▁. ▁createTempFile In Directory ▁( ▁ins ide Nested Dir ▁. ▁getAbsolutePath ▁( ▁) ▁, ▁STR ▁) ▁; ▁Test File Utils ▁. ▁createTempFile In Directory ▁( ▁ins ide Nested Dir ▁. ▁getAbsolutePath ▁( ▁) ▁, ▁STR ▁) ▁; ▁this ▁. ▁format ▁. ▁set FilePath ▁( ▁new ▁Path ▁( ▁nested Dir ▁. ▁toURI ▁( ▁) ▁. ▁toString ▁( ▁) ▁) ▁) ▁; ▁this ▁. ▁config ▁. ▁setBoolean ▁( ▁STR ▁, ▁false ▁) ▁; ▁format ▁. ▁configure ▁( ▁this ▁. ▁config ▁) ▁; ▁File InputSplit ▁[ ▁] ▁splits ▁= ▁format ▁. ▁createInput Splits ▁( ▁1 ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁1 ▁, ▁splits ▁. ▁length ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁ex ▁) ▁{ ▁ex ▁. ▁printStackTrace ▁( ▁) ▁; ▁Assert ▁. ▁fail ▁( ▁ex ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Two Nested Directories True ▁( ▁) ▁{ ▁try ▁{ ▁String ▁first Level Dir ▁= ▁Test File Utils ▁. ▁random FileName ▁( ▁) ▁; ▁String ▁second Level Dir ▁= ▁Test File Utils ▁. ▁random FileName ▁( ▁) ▁; ▁String ▁third Level Dir ▁= ▁Test File Utils ▁. ▁random FileName ▁( ▁) ▁; ▁File ▁nested Nested Dir ▁= ▁tempFolder ▁. ▁newFolder ▁( ▁first Level Dir ▁, ▁second Level Dir ▁, ▁third Level Dir ▁) ▁; ▁File ▁ins ide Nested Dir ▁= ▁nested Nested Dir ▁. ▁getParentFile ▁( ▁) ▁; ▁File ▁nested Dir ▁= ▁ins ide Nested Dir ▁. ▁getParentFile ▁( ▁) ▁; ▁Test File Utils ▁. ▁createTempFile In Directory ▁( ▁nested Dir ▁. ▁getAbsolutePath ▁( ▁) ▁, ▁STR ▁) ▁; ▁Test File Utils ▁. ▁createTempFile In Directory ▁( ▁ins ide Nested Dir ▁. ▁getAbsolutePath ▁( ▁) ▁, ▁STR ▁) ▁; ▁Test File Utils ▁. ▁createTempFile In Directory ▁( ▁ins ide Nested Dir ▁. ▁getAbsolutePath ▁( ▁) ▁, ▁STR ▁) ▁; ▁Test File Utils ▁. ▁createTempFile In Directory ▁( ▁nested Nested Dir ▁. ▁getAbsolutePath ▁( ▁) ▁, ▁STR ▁) ▁; ▁this ▁. ▁format ▁. ▁set FilePath ▁( ▁new ▁Path ▁( ▁nested Dir ▁. ▁toURI ▁( ▁) ▁. ▁toString ▁( ▁) ▁) ▁) ▁; ▁this ▁. ▁config ▁. ▁setBoolean ▁( ▁STR ▁, ▁true ▁) ▁; ▁format ▁. ▁configure ▁( ▁this ▁. ▁config ▁) ▁; ▁File InputSplit ▁[ ▁] ▁splits ▁= ▁format ▁. ▁createInput Splits ▁( ▁1 ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁4 ▁, ▁splits ▁. ▁length ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁ex ▁) ▁{ ▁ex ▁. ▁printStackTrace ▁( ▁) ▁; ▁Assert ▁. ▁fail ▁( ▁ex ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Only Level 2 Nested Directories ▁( ▁) ▁{ ▁try ▁{ ▁String ▁rootDir ▁= ▁Test File Utils ▁. ▁random FileName ▁( ▁) ▁; ▁String ▁nested Dir ▁= ▁Test File Utils ▁. ▁random FileName ▁( ▁) ▁; ▁String ▁first Nested Nested Dir ▁= ▁Test File Utils ▁. ▁random FileName ▁( ▁) ▁; ▁String ▁second Nested Nested Dir ▁= ▁Test File Utils ▁. ▁random FileName ▁( ▁) ▁; ▁File ▁testDir ▁= ▁tempFolder ▁. ▁newFolder ▁( ▁rootDir ▁) ▁;
▁public ▁class ▁Group Key 2 ▁{ ▁public ▁static ▁String ▁getKey ▁( ▁String ▁dataId ▁, ▁String ▁group ▁) ▁{ ▁StringBuilder ▁sb ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁url Encode ▁( ▁dataId ▁, ▁sb ▁) ▁; ▁sb ▁. ▁append ▁( ▁CHAR ▁) ▁; ▁url Encode ▁( ▁group ▁, ▁sb ▁) ▁; ▁return ▁sb ▁. ▁toString ▁( ▁) ▁; ▁} ▁public ▁static ▁String ▁getKey ▁( ▁String ▁dataId ▁, ▁String ▁group ▁, ▁String ▁tenant ▁) ▁{ ▁StringBuilder ▁sb ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁url Encode ▁( ▁dataId ▁, ▁sb ▁) ▁; ▁sb ▁. ▁append ▁( ▁CHAR ▁) ▁; ▁url Encode ▁( ▁group ▁, ▁sb ▁) ▁; ▁if ▁( ▁StringUtils ▁. ▁isNotEmpty ▁( ▁tenant ▁) ▁) ▁{ ▁sb ▁. ▁append ▁( ▁CHAR ▁) ▁; ▁url Encode ▁( ▁tenant ▁, ▁sb ▁) ▁; ▁} ▁return ▁sb ▁. ▁toString ▁( ▁) ▁; ▁} ▁public ▁static ▁String ▁[ ▁] ▁parse Key ▁( ▁String ▁group Key ▁) ▁{ ▁StringBuilder ▁sb ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁String ▁dataId ▁= ▁null ▁; ▁String ▁group ▁= ▁null ▁; ▁String ▁tenant ▁= ▁null ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁group Key ▁. ▁length ▁( ▁) ▁; ▁++ ▁i ▁) ▁{ ▁char ▁c ▁= ▁group Key ▁. ▁charAt ▁( ▁i ▁) ▁; ▁if ▁( ▁CHAR ▁== ▁c ▁) ▁{ ▁if ▁( ▁null ▁== ▁dataId ▁) ▁{ ▁dataId ▁= ▁sb ▁. ▁toString ▁( ▁) ▁; ▁sb ▁. ▁setLength ▁( ▁0 ▁) ▁; ▁} ▁else ▁if ▁( ▁null ▁== ▁group ▁) ▁{ ▁group ▁= ▁sb ▁. ▁toString ▁( ▁) ▁; ▁sb ▁. ▁setLength ▁( ▁0 ▁) ▁; ▁} ▁else ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁group Key ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁CHAR ▁== ▁c ▁) ▁{ ▁char ▁next ▁= ▁group Key ▁. ▁charAt ▁( ▁++ ▁i ▁) ▁; ▁char ▁next n ext ▁= ▁group Key ▁. ▁charAt ▁( ▁++ ▁i ▁) ▁; ▁if ▁( ▁CHAR ▁== ▁next ▁&& ▁CHAR ▁== ▁next n ext ▁) ▁{ ▁sb ▁. ▁append ▁( ▁CHAR ▁) ▁; ▁} ▁else ▁if ▁( ▁CHAR ▁== ▁next ▁&& ▁CHAR ▁== ▁next n ext ▁) ▁{ ▁sb ▁. ▁append ▁( ▁CHAR ▁) ▁; ▁} ▁else ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁group Key ▁) ▁; ▁} ▁} ▁else ▁{ ▁sb ▁. ▁append ▁( ▁c ▁) ▁; ▁} ▁} ▁if ▁( ▁StringUtils ▁. ▁isBlank ▁( ▁group ▁) ▁) ▁{ ▁group ▁= ▁sb ▁. ▁toString ▁( ▁) ▁; ▁} ▁else ▁{ ▁tenant ▁= ▁sb ▁. ▁toString ▁( ▁) ▁; ▁} ▁if ▁( ▁group ▁. ▁length ▁( ▁) ▁== ▁0 ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁group Key ▁) ▁; ▁} ▁return ▁new ▁String ▁[ ▁] ▁{ ▁dataId ▁, ▁group ▁, ▁tenant ▁} ▁; ▁} ▁static ▁void ▁url Encode ▁( ▁String ▁str ▁, ▁StringBuilder ▁sb ▁) ▁{ ▁for ▁( ▁int ▁idx ▁= ▁0 ▁; ▁idx ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁++ ▁idx ▁) ▁{ ▁char ▁c ▁= ▁str ▁. ▁charAt ▁( ▁idx ▁) ▁; ▁if ▁( ▁CHAR ▁== ▁c ▁) ▁{ ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁}
▁public ▁class ▁SWIGTYPE _ p _ p _ bt MultiBody Constraint ▁{ ▁private ▁transient ▁long ▁swigCPtr ▁; ▁protected ▁SWIGTYPE _ p _ p _ bt MultiBody Constraint ▁( ▁long ▁cPtr ▁, ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁boolean ▁future Use ▁) ▁{ ▁swigCPtr ▁= ▁cPtr ▁; ▁} ▁protected ▁SWIGTYPE _ p _ p _ bt MultiBody Constraint ▁( ▁) ▁{ ▁swigCPtr ▁= ▁0 ▁; ▁} ▁protected ▁static ▁long ▁getCPtr ▁( ▁SWIGTYPE _ p _ p _ bt MultiBody Constraint ▁obj ▁) ▁{ ▁return ▁( ▁obj ▁== ▁null ▁) ▁? ▁0 ▁: ▁obj ▁. ▁swigCPtr ▁; ▁} ▁}
▁public ▁class ▁Bar Line Chart Touch Listener ▁extends ▁Chart Touch Listener ▁< ▁Bar Line Chart Base ▁< ▁? ▁extends ▁Bar Line Scatter C and le B ubble Data ▁< ▁? ▁extends ▁I Bar Line Scatter C and le B ubble DataSet ▁< ▁? ▁extends ▁Entry ▁> ▁> ▁> ▁> ▁{ ▁private ▁Matrix ▁m Matrix ▁= ▁new ▁Matrix ▁( ▁) ▁; ▁private ▁Matrix ▁m Saved Matrix ▁= ▁new ▁Matrix ▁( ▁) ▁; ▁private ▁MP Point F ▁m Touch Start Point ▁= ▁MP Point F ▁. ▁getInstance ▁( ▁0 ▁, ▁0 ▁) ▁; ▁private ▁MP Point F ▁m Touch Point Center ▁= ▁MP Point F ▁. ▁getInstance ▁( ▁0 ▁, ▁0 ▁) ▁; ▁private ▁float ▁m Saved X Dist ▁= ▁1 f ▁; ▁private ▁float ▁m Saved Y Dist ▁= ▁1 f ▁; ▁private ▁float ▁m Saved Dist ▁= ▁1 f ▁; ▁private ▁I DataSet ▁m Close st DataSet To Touch ▁; ▁private ▁V elocity Tracker ▁m V elocity Tracker ▁; ▁private ▁long ▁m De celer ation Last Time ▁= ▁0 ▁; ▁private ▁MP Point F ▁m De celer ation Current Point ▁= ▁MP Point F ▁. ▁getInstance ▁( ▁0 ▁, ▁0 ▁) ▁; ▁private ▁MP Point F ▁m De celer ation V elocity ▁= ▁MP Point F ▁. ▁getInstance ▁( ▁0 ▁, ▁0 ▁) ▁; ▁private ▁float ▁m Drag Trigger Dist ▁; ▁private ▁float ▁m Min Scale Pointer Distance ▁; ▁public ▁Bar Line Chart Touch Listener ▁( ▁Bar Line Chart Base ▁< ▁? ▁extends ▁Bar Line Scatter C and le B ubble Data ▁< ▁? ▁extends ▁I Bar Line Scatter C and le B ubble DataSet ▁< ▁? ▁extends ▁Entry ▁> ▁> ▁> ▁chart ▁, ▁Matrix ▁touch Matrix ▁, ▁float ▁drag Trigger Distance ▁) ▁{ ▁super ▁( ▁chart ▁) ▁; ▁this ▁. ▁m Matrix ▁= ▁touch Matrix ▁; ▁this ▁. ▁m Drag Trigger Dist ▁= ▁Utils ▁. ▁convert D p To Pixel ▁( ▁drag Trigger Distance ▁) ▁; ▁this ▁. ▁m Min Scale Pointer Distance ▁= ▁Utils ▁. ▁convert D p To Pixel ▁( ▁3. 5 f ▁) ▁; ▁} ▁@ ▁SuppressLint ▁( ▁STR ▁) ▁@ ▁Override ▁public ▁boolean ▁on Touch ▁( ▁View ▁v ▁, ▁MotionEvent ▁event ▁) ▁{ ▁if ▁( ▁m V elocity Tracker ▁== ▁null ▁) ▁{ ▁m V elocity Tracker ▁= ▁V elocity Tracker ▁. ▁obtain ▁( ▁) ▁; ▁} ▁m V elocity Tracker ▁. ▁add Move ment ▁( ▁event ▁) ▁; ▁if ▁( ▁event ▁. ▁getAction Mask ed ▁( ▁) ▁== ▁MotionEvent ▁. ▁ACTION _ C ANCE L ▁) ▁{ ▁if ▁( ▁m V elocity Tracker ▁!= ▁null ▁) ▁{ ▁m V elocity Tracker ▁. ▁recycle ▁( ▁) ▁; ▁m V elocity Tracker ▁= ▁null ▁; ▁} ▁} ▁if ▁( ▁m Touch Mode ▁== ▁NONE ▁) ▁{ ▁m Gesture Detector ▁. ▁on Touch Event ▁( ▁event ▁) ▁; ▁} ▁if ▁( ▁! ▁m Chart ▁. ▁isD rag Enabled ▁( ▁) ▁&& ▁( ▁! ▁m Chart ▁. ▁is Scale X Enabled ▁( ▁) ▁&& ▁! ▁m Chart ▁. ▁is Scale Y Enabled ▁( ▁) ▁) ▁) ▁return ▁true ▁;
▁public ▁class ▁Th reshold Re lu Bp ▁extends ▁DynamicCustomOp ▁{ ▁@ ▁Getter ▁private ▁double ▁c utoff ▁= ▁0 ▁; ▁public ▁Th reshold Re lu Bp ▁( ▁) ▁{ ▁} ▁public ▁Th reshold Re lu Bp ▁( ▁SameDiff ▁sd ▁, ▁SDVariable ▁input ▁, ▁SDVariable ▁gradient ▁, ▁double ▁c utoff ▁) ▁{ ▁super ▁( ▁sd ▁, ▁new ▁SDVariable ▁[ ▁] ▁{ ▁input ▁, ▁gradient ▁} ▁) ▁; ▁this ▁. ▁c utoff ▁= ▁c utoff ▁; ▁add T Argument ▁( ▁c utoff ▁) ▁; ▁} ▁public ▁Th reshold Re lu Bp ▁( ▁@ ▁NonNull ▁INDArray ▁input ▁, ▁@ ▁NonNull ▁INDArray ▁gradient ▁, ▁INDArray ▁output ▁, ▁double ▁c utoff ▁) ▁{ ▁super ▁( ▁new ▁INDArray ▁[ ▁] ▁{ ▁input ▁, ▁gradient ▁} ▁, ▁wrap OrNull ▁( ▁output ▁) ▁) ▁; ▁this ▁. ▁c utoff ▁= ▁c utoff ▁; ▁add T Argument ▁( ▁c utoff ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁opName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁DataType ▁> ▁calculateOutput DataTypes ▁( ▁List ▁< ▁DataType ▁> ▁dataTypes ▁) ▁{ ▁Preconditions ▁. ▁checkArgument ▁( ▁dataTypes ▁!= ▁null ▁&& ▁dataTypes ▁. ▁size ▁( ▁) ▁== ▁2 ▁, ▁STR ▁, ▁dataTypes ▁) ▁; ▁Preconditions ▁. ▁checkArgument ▁( ▁dataTypes ▁. ▁get ▁( ▁0 ▁) ▁. ▁isF P Type ▁( ▁) ▁&& ▁dataTypes ▁. ▁get ▁( ▁1 ▁) ▁. ▁isF P Type ▁( ▁) ▁, ▁STR ▁, ▁dataTypes ▁) ▁; ▁return ▁Collections ▁. ▁singletonList ▁( ▁dataTypes ▁. ▁get ▁( ▁0 ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁SDVariable ▁> ▁doDiff ▁( ▁List ▁< ▁SDVariable ▁> ▁f 1 ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁STR ▁) ▁; ▁} ▁}
▁@ ▁Override ▁public ▁void ▁run ▁( ▁Source Context ▁< ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁out ▁) ▁throws ▁Exception ▁{ ▁Random ▁random ▁= ▁new ▁Random ▁( ▁42 ▁) ▁; ▁while ▁( ▁remaining Events ▁> ▁0 ▁) ▁{ ▁synchronized ▁( ▁out ▁. ▁getCheckpoint Lock ▁( ▁) ▁) ▁{ ▁out ▁. ▁collect ▁( ▁new ▁Tuple 2 ▁< ▁> ▁( ▁random ▁. ▁nextInt ▁( ▁num Keys ▁) ▁, ▁1 ▁) ▁) ▁; ▁-- ▁remaining Events ▁; ▁} ▁} ▁} ▁@ ▁Override ▁public ▁void ▁cancel ▁( ▁) ▁{ ▁this ▁. ▁remaining Events ▁= ▁0 ▁; ▁} ▁} ▁private ▁static ▁class ▁To Partition File Sink ▁extends ▁Rich SinkFunction ▁< ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁private ▁final ▁List ▁< ▁File ▁> ▁all Partitions ▁; ▁private ▁Data OutputStream ▁dos ▁; ▁To Partition File Sink ▁( ▁List ▁< ▁File ▁> ▁all Partitions ▁) ▁{ ▁this ▁. ▁all Partitions ▁= ▁all Partitions ▁; ▁} ▁@ ▁Override ▁public ▁void ▁open ▁( ▁Configuration ▁parameters ▁) ▁throws ▁Exception ▁{ ▁super ▁. ▁open ▁( ▁parameters ▁) ▁; ▁int ▁subtask Idx ▁= ▁getRuntime Context ▁( ▁) ▁. ▁getIndex Of This Subtask ▁( ▁) ▁; ▁dos ▁= ▁new ▁Data OutputStream ▁( ▁new ▁Buffered OutputStream ▁( ▁new ▁File OutputStream ▁( ▁all Partitions ▁. ▁get ▁( ▁subtask Idx ▁) ▁) ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁close ▁( ▁) ▁throws ▁Exception ▁{ ▁super ▁. ▁close ▁( ▁) ▁; ▁dos ▁. ▁close ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁invoke ▁( ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁value ▁, ▁Context ▁context ▁) ▁throws ▁Exception ▁{ ▁dos ▁. ▁writeInt ▁( ▁value ▁. ▁f 0 ▁) ▁; ▁dos ▁. ▁writeInt ▁( ▁value ▁. ▁f 1 ▁) ▁; ▁} ▁} ▁private ▁static ▁class ▁From Partition File Source ▁extends ▁Rich Parallel Source Function ▁< ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁implements ▁Check pointed Function ▁, ▁Checkpoint Listener ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁private ▁final ▁List ▁< ▁File ▁> ▁all Partitions ▁; ▁private ▁DataInputStream ▁d in ▁; ▁private ▁volatile ▁boolean ▁running ▁; ▁private ▁long ▁file Length ▁; ▁private ▁long ▁waitFor Failure Pos ▁; ▁private ▁long ▁position ▁; ▁private ▁transient ▁List State ▁< ▁Long ▁> ▁position State ▁; ▁private ▁transient ▁boolean ▁is Restored ▁; ▁private ▁transient ▁volatile ▁boolean ▁can Fail ▁; ▁From Partition File Source ▁( ▁List ▁< ▁File ▁> ▁all Partitions ▁) ▁{ ▁this ▁. ▁all Partitions ▁= ▁all Partitions ▁; ▁} ▁@ ▁Override ▁public ▁void ▁open ▁( ▁Configuration ▁parameters ▁) ▁throws ▁Exception ▁{ ▁super ▁. ▁open ▁( ▁parameters ▁) ▁; ▁int ▁subtask Idx ▁= ▁getRuntime Context ▁( ▁) ▁. ▁getIndex Of This Subtask ▁( ▁) ▁; ▁File ▁partition File ▁= ▁all Partitions ▁. ▁get ▁( ▁subtask Idx ▁) ▁; ▁file Length ▁= ▁partition File ▁. ▁length ▁( ▁) ▁; ▁waitFor Failure Pos ▁= ▁file Length ▁ * ▁3 ▁ / ▁4 ▁; ▁d in ▁= ▁new ▁DataInputStream ▁( ▁new ▁Buffered InputStream ▁( ▁new ▁FileInputStream ▁( ▁partition File ▁) ▁) ▁) ▁; ▁long ▁to Skip ▁= ▁position ▁;
▁@ ▁ComponentScan ▁( ▁STR ▁) ▁@ ▁Entity Scan ▁( ▁basePackages ▁= ▁STR ▁) ▁@ ▁SpringBoot Application ▁( ▁exclude ▁= ▁J ta Auto Configuration ▁. ▁class ▁) ▁public ▁class ▁Sharding SpringBoot Jpa Example ▁{ ▁public ▁static ▁void ▁main ▁( ▁final ▁String ▁[ ▁] ▁args ▁) ▁throws ▁SQLException ▁{ ▁try ▁( ▁Configurable Application Context ▁application Context ▁= ▁Spring Application ▁. ▁run ▁( ▁Sharding SpringBoot Jpa Example ▁. ▁class ▁, ▁args ▁) ▁) ▁{ ▁Example Execute Template ▁. ▁run ▁( ▁application Context ▁. ▁getBean ▁( ▁ExampleService ▁. ▁class ▁) ▁) ▁; ▁} ▁} ▁}
▁{ ▁DruidDataSource Stat Value ▁stat Value ▁= ▁dataSource ▁. ▁get Stat Value And Reset ▁( ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁2000 ▁, ▁stat Value ▁. ▁getSql List ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁0 ▁, ▁stat Value ▁. ▁getSql Skip Count ▁( ▁) ▁) ▁; ▁} ▁dataSource ▁. ▁setConnection Properties ▁( ▁STR ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁2000 ▁; ▁++ ▁i ▁) ▁{ ▁Connection ▁conn ▁= ▁dataSource ▁. ▁getConnection ▁( ▁) ▁; ▁Pre paredStatement ▁stmt ▁= ▁conn ▁. ▁prepare Statement ▁( ▁STR ▁+ ▁i ▁) ▁; ▁stmt ▁. ▁execute ▁( ▁) ▁; ▁stmt ▁. ▁close ▁( ▁) ▁; ▁conn ▁. ▁close ▁( ▁) ▁; ▁} ▁{ ▁DruidDataSource Stat Value ▁stat Value ▁= ▁dataSource ▁. ▁get Stat Value And Reset ▁( ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁100 ▁, ▁stat Value ▁. ▁getSql List ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁19 00 ▁, ▁stat Value ▁. ▁getSql Skip Count ▁( ▁) ▁) ▁; ▁} ▁{ ▁DruidDataSource Stat Value ▁stat Value ▁= ▁dataSource ▁. ▁get Stat Value And Reset ▁( ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁0 ▁, ▁stat Value ▁. ▁getSql List ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁0 ▁, ▁stat Value ▁. ▁getSql Skip Count ▁( ▁) ▁) ▁; ▁} ▁} ▁}
▁public ▁class ▁Mqtt Message FactoryTest ▁{ ▁private ▁static ▁final ▁String ▁SAMPLE _ TOPIC ▁= ▁STR ▁; ▁private ▁static ▁final ▁int ▁SAMPLE _ MESSAGE _ ID ▁= ▁123 ▁; ▁@ ▁Test ▁public ▁void ▁create Unsub Ack V 3 ▁( ▁) ▁{ ▁Mqtt Fixed Header ▁fixed Header ▁= ▁new ▁Mqtt Fixed Header ▁( ▁Mqtt MessageType ▁. ▁UN SU BACK ▁, ▁false ▁, ▁Mqtt Q o S ▁. ▁AT _ MO ST _ ON CE ▁, ▁false ▁, ▁0 ▁) ▁; ▁Mqtt MessageId Variable Header ▁variable Header ▁= ▁Mqtt MessageId Variable Header ▁. ▁from ▁( ▁SAMPLE _ MESSAGE _ ID ▁) ▁; ▁Mqtt Message ▁unsub ack ▁= ▁Mqtt Message Factory ▁. ▁new Message ▁( ▁fixed Header ▁, ▁variable Header ▁, ▁null ▁) ▁; ▁assertEquals ▁( ▁Mqtt MessageType ▁. ▁UN SU BACK ▁, ▁unsub ack ▁. ▁fixed Header ▁( ▁) ▁. ▁messageType ▁( ▁) ▁) ▁; ▁Mqtt MessageId And Properties Variable Header ▁actual Variable Header ▁= ▁( ▁Mqtt MessageId And Properties Variable Header ▁) ▁unsub ack ▁. ▁variable Header ▁( ▁) ▁; ▁assertEquals ▁( ▁SAMPLE _ MESSAGE _ ID ▁, ▁actual Variable Header ▁. ▁messageId ▁( ▁) ▁) ▁; ▁validate Properties ▁( ▁Mqtt Properties ▁. ▁NO _ PROPERTIES ▁, ▁actual Variable Header ▁. ▁properties ▁( ▁) ▁) ▁; ▁Mqtt Unsub Ack Payload ▁actual Payload ▁= ▁( ▁Mqtt Unsub Ack Payload ▁) ▁unsub ack ▁. ▁payload ▁( ▁) ▁; ▁assertNotNull ▁( ▁actual Payload ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁actual Payload ▁. ▁unsubscribe Reason Codes ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁create Unsub Ack V 5 ▁( ▁) ▁{ ▁Mqtt Fixed Header ▁fixed Header ▁= ▁new ▁Mqtt Fixed Header ▁( ▁Mqtt MessageType ▁. ▁UN SU BACK ▁, ▁false ▁, ▁Mqtt Q o S ▁. ▁AT _ MO ST _ ON CE ▁, ▁false ▁, ▁0 ▁) ▁; ▁Mqtt Properties ▁properties ▁= ▁new ▁Mqtt Properties ▁( ▁) ▁; ▁String ▁reason String ▁= ▁STR ▁; ▁properties ▁. ▁add ▁( ▁new ▁Mqtt Properties ▁. ▁String Property ▁( ▁Mqtt Properties ▁. ▁Mqtt Property Type ▁. ▁RE A SON _ STRING ▁. ▁value ▁( ▁) ▁, ▁reason String ▁) ▁) ▁; ▁Mqtt MessageId And Properties Variable Header ▁variable Header ▁= ▁new ▁Mqtt MessageId And Properties Variable Header ▁( ▁SAMPLE _ MESSAGE _ ID ▁, ▁properties ▁) ▁; ▁Mqtt Unsub Ack Payload ▁payload ▁= ▁new ▁Mqtt Unsub Ack Payload ▁( ▁( ▁short ▁) ▁0 x 80 ▁) ▁; ▁Mqtt Message ▁unsub ack ▁= ▁Mqtt Message Factory ▁. ▁new Message ▁( ▁fixed Header ▁, ▁variable Header ▁, ▁payload ▁) ▁; ▁assertEquals ▁( ▁Mqtt MessageType ▁. ▁UN SU BACK ▁, ▁unsub ack ▁. ▁fixed Header ▁( ▁) ▁. ▁messageType ▁( ▁) ▁) ▁; ▁Mqtt MessageId And Properties Variable Header ▁actual Variable Header ▁= ▁( ▁Mqtt MessageId And Properties Variable Header ▁) ▁unsub ack ▁. ▁variable Header ▁( ▁) ▁; ▁assertEquals ▁( ▁SAMPLE _ MESSAGE _ ID ▁, ▁actual Variable Header ▁. ▁messageId ▁( ▁) ▁) ▁; ▁validate Properties ▁( ▁properties ▁, ▁actual Variable Header ▁. ▁properties ▁( ▁) ▁) ▁;
▁if ▁( ▁y ▁instanceof ▁Starlark Int ▁) ▁{ ▁return ▁Starlark Int ▁. ▁multiply ▁( ▁x i ▁, ▁( ▁Starlark Int ▁) ▁y ▁) ▁; ▁} ▁else ▁if ▁( ▁y ▁instanceof ▁String ▁) ▁{ ▁return ▁repeat String ▁( ▁( ▁String ▁) ▁y ▁, ▁x i ▁) ▁; ▁} ▁else ▁if ▁( ▁y ▁instanceof ▁Tuple ▁) ▁{ ▁return ▁( ▁( ▁Tuple ▁) ▁y ▁) ▁. ▁repeat ▁( ▁x i ▁) ▁; ▁} ▁else ▁if ▁( ▁y ▁instanceof ▁Starlark List ▁) ▁{ ▁return ▁( ▁( ▁Starlark List ▁< ▁? ▁> ▁) ▁y ▁) ▁. ▁repeat ▁( ▁x i ▁, ▁m u ▁) ▁; ▁} ▁else ▁if ▁( ▁y ▁instanceof ▁Starlark Float ▁) ▁{ ▁double ▁z ▁= ▁x i ▁. ▁to F inite Double ▁( ▁) ▁ * ▁( ▁( ▁Starlark Float ▁) ▁y ▁) ▁. ▁toDouble ▁( ▁) ▁; ▁return ▁Starlark Float ▁. ▁of ▁( ▁z ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁x ▁instanceof ▁String ▁) ▁{ ▁if ▁( ▁y ▁instanceof ▁Starlark Int ▁) ▁{ ▁return ▁repeat String ▁( ▁( ▁String ▁) ▁x ▁, ▁( ▁Starlark Int ▁) ▁y ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁x ▁instanceof ▁Tuple ▁) ▁{ ▁if ▁( ▁y ▁instanceof ▁Starlark Int ▁) ▁{ ▁return ▁( ▁( ▁Tuple ▁) ▁x ▁) ▁. ▁repeat ▁( ▁( ▁Starlark Int ▁) ▁y ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁x ▁instanceof ▁Starlark List ▁) ▁{ ▁if ▁( ▁y ▁instanceof ▁Starlark Int ▁) ▁{ ▁return ▁( ▁( ▁Starlark List ▁< ▁? ▁> ▁) ▁x ▁) ▁. ▁repeat ▁( ▁( ▁Starlark Int ▁) ▁y ▁, ▁m u ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁x ▁instanceof ▁Starlark Float ▁) ▁{ ▁double ▁x f ▁= ▁( ▁( ▁Starlark Float ▁) ▁x ▁) ▁. ▁toDouble ▁( ▁) ▁; ▁if ▁( ▁y ▁instanceof ▁Starlark Float ▁) ▁{ ▁return ▁Starlark Float ▁. ▁of ▁( ▁x f ▁ * ▁( ▁( ▁Starlark Float ▁) ▁y ▁) ▁. ▁toDouble ▁( ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁y ▁instanceof ▁Starlark Int ▁) ▁{ ▁return ▁Starlark Float ▁. ▁of ▁( ▁x f ▁ * ▁( ▁( ▁Starlark Int ▁) ▁y ▁) ▁. ▁to F inite Double ▁( ▁) ▁) ▁; ▁} ▁} ▁break ▁; ▁case ▁S LA SH ▁: ▁if ▁( ▁x ▁instanceof ▁Starlark Int ▁) ▁{ ▁double ▁x f ▁= ▁( ▁( ▁Starlark Int ▁) ▁x ▁) ▁. ▁to F inite Double ▁( ▁) ▁; ▁if ▁( ▁y ▁instanceof ▁Starlark Int ▁) ▁{ ▁return ▁Starlark Float ▁. ▁div ▁( ▁x f ▁, ▁( ▁( ▁Starlark Int ▁) ▁y ▁) ▁. ▁to F inite Double ▁( ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁y ▁instanceof ▁Starlark Float ▁) ▁{ ▁return ▁Starlark Float ▁. ▁div ▁( ▁x f ▁, ▁( ▁( ▁Starlark Float ▁) ▁y ▁) ▁. ▁toDouble ▁( ▁) ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁x ▁instanceof ▁Starlark Float ▁) ▁{ ▁double ▁x f ▁= ▁( ▁( ▁Starlark Float ▁) ▁x ▁) ▁. ▁toDouble ▁( ▁) ▁; ▁if ▁( ▁y ▁instanceof ▁Starlark Float ▁) ▁{ ▁return ▁Starlark Float ▁. ▁div ▁( ▁x f ▁, ▁( ▁( ▁Starlark Float ▁) ▁y ▁) ▁. ▁toDouble ▁( ▁) ▁) ▁; ▁}
▁public ▁class ▁Stream Exec Group Table Aggregate ▁extends ▁ExecNode Base ▁< ▁RowData ▁> ▁implements ▁Stream Exec Node ▁< ▁RowData ▁> ▁, ▁Single Transformation Translator ▁< ▁RowData ▁> ▁{ ▁private ▁static ▁final ▁Logger ▁LOG ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Stream Exec Group Table Aggregate ▁. ▁class ▁) ▁; ▁private ▁final ▁int ▁[ ▁] ▁grouping ▁; ▁private ▁final ▁Aggregate Call ▁[ ▁] ▁agg Calls ▁; ▁private ▁final ▁boolean ▁[ ▁] ▁agg Call Need Ret raction s ▁; ▁private ▁final ▁boolean ▁generate Update Before ▁; ▁private ▁final ▁boolean ▁need Ret raction ▁; ▁public ▁Stream Exec Group Table Aggregate ▁( ▁int ▁[ ▁] ▁grouping ▁, ▁Aggregate Call ▁[ ▁] ▁agg Calls ▁, ▁boolean ▁[ ▁] ▁agg Call Need Ret raction s ▁, ▁boolean ▁generate Update Before ▁, ▁boolean ▁need Ret raction ▁, ▁InputProperty ▁input Property ▁, ▁RowType ▁outputType ▁, ▁String ▁description ▁) ▁{ ▁super ▁( ▁Collections ▁. ▁singletonList ▁( ▁input Property ▁) ▁, ▁outputType ▁, ▁description ▁) ▁; ▁Preconditions ▁. ▁checkArgument ▁( ▁agg Calls ▁. ▁length ▁== ▁agg Call Need Ret raction s ▁. ▁length ▁) ▁; ▁this ▁. ▁grouping ▁= ▁grouping ▁; ▁this ▁. ▁agg Calls ▁= ▁agg Calls ▁; ▁this ▁. ▁agg Call Need Ret raction s ▁= ▁agg Call Need Ret raction s ▁; ▁this ▁. ▁generate Update Before ▁= ▁generate Update Before ▁; ▁this ▁. ▁need Ret raction ▁= ▁need Ret raction ▁; ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁@ ▁Override ▁protected ▁Transformation ▁< ▁RowData ▁> ▁translate To Plan Internal ▁( ▁Planner Base ▁planner ▁) ▁{ ▁final ▁Table Config ▁table Config ▁= ▁planner ▁. ▁getTable Config ▁( ▁) ▁; ▁if ▁( ▁grouping ▁. ▁length ▁> ▁0 ▁&& ▁table Config ▁. ▁getMin Idle State Retention Time ▁( ▁) ▁< ▁0 ▁) ▁{ ▁LOG ▁. ▁warn ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁; ▁} ▁final ▁Exec Edge ▁input Edge ▁= ▁getInput Edges ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁; ▁final ▁Transformation ▁< ▁RowData ▁> ▁input Transform ▁= ▁( ▁Transformation ▁< ▁RowData ▁> ▁) ▁input Edge ▁. ▁translate To Plan ▁( ▁planner ▁) ▁; ▁final ▁RowType ▁input RowType ▁= ▁( ▁RowType ▁) ▁input Edge ▁. ▁getOutputType ▁( ▁) ▁; ▁final ▁Agg s Handler Code Generator ▁generator ▁= ▁new ▁Agg s Handler Code Generator ▁( ▁new ▁Code Generator Context ▁( ▁table Config ▁) ▁, ▁planner ▁. ▁getRe l Builder ▁( ▁) ▁, ▁Java Sc ala Conversion Util ▁. ▁to Sc ala ▁( ▁input RowType ▁. ▁getChildren ▁( ▁) ▁) ▁, ▁true ▁) ▁. ▁need Accum ulate ▁( ▁) ▁; ▁if ▁( ▁need Ret raction ▁) ▁{ ▁generator ▁. ▁need Ret ract ▁( ▁) ▁; ▁} ▁final ▁Aggregate InfoList ▁agg InfoList ▁= ▁Aggregate Util ▁. ▁transform To Stream Aggregate InfoList ▁( ▁input RowType ▁, ▁Java Sc ala Conversion Util ▁. ▁to Sc ala ▁( ▁Arrays ▁. ▁asList ▁( ▁agg Calls ▁) ▁) ▁, ▁agg Call Need Ret raction s ▁, ▁need Ret raction ▁, ▁true ▁, ▁true ▁) ▁; ▁final ▁Generated Table Aggs HandleFunction ▁aggs Handler ▁= ▁generator ▁. ▁generate Table Aggs Handler ▁( ▁STR ▁, ▁agg InfoList ▁) ▁;
▁if ▁( ▁head Arg ▁. ▁startsWith ▁( ▁NativeImage ▁. ▁o R ▁) ▁) ▁{ ▁args ▁. ▁poll ▁( ▁) ▁; ▁native Image ▁. ▁add Custom Image Builder Args ▁( ▁head Arg ▁) ▁; ▁return ▁true ▁; ▁} ▁String ▁java Args Prefix ▁= ▁STR ▁; ▁if ▁( ▁head Arg ▁. ▁startsWith ▁( ▁java Args Prefix ▁) ▁) ▁{ ▁args ▁. ▁poll ▁( ▁) ▁; ▁native Image ▁. ▁add Custom Java Args ▁( ▁head Arg ▁) ▁; ▁return ▁true ▁; ▁} ▁String ▁option Key Prefix ▁= ▁STR ▁; ▁if ▁( ▁head Arg ▁. ▁startsWith ▁( ▁option Key Prefix ▁) ▁) ▁{ ▁args ▁. ▁poll ▁( ▁) ▁; ▁String ▁keyValue Str ▁= ▁head Arg ▁. ▁substring ▁( ▁option Key Prefix ▁. ▁length ▁( ▁) ▁) ▁; ▁String ▁[ ▁] ▁keyValue ▁= ▁keyValue Str ▁. ▁split ▁( ▁STR ▁) ▁; ▁if ▁( ▁keyValue ▁. ▁length ▁!= ▁2 ▁) ▁{ ▁throw ▁NativeImage ▁. ▁showError ▁( ▁STR ▁+ ▁option Key Prefix ▁+ ▁STR ▁) ▁; ▁} ▁native Image ▁. ▁addOption KeyValue ▁( ▁keyValue ▁[ ▁0 ▁] ▁, ▁keyValue ▁[ ▁1 ▁] ▁) ▁; ▁return ▁true ▁; ▁} ▁if ▁( ▁head Arg ▁. ▁startsWith ▁( ▁STR ▁) ▁) ▁{ ▁args ▁. ▁poll ▁( ▁) ▁; ▁if ▁( ▁head Arg ▁. ▁equals ▁( ▁STR ▁) ▁) ▁{ ▁NativeImage ▁. ▁showError ▁( ▁STR ▁) ▁; ▁} ▁else ▁{ ▁native Image ▁. ▁add Custom Java Args ▁( ▁head Arg ▁. ▁substring ▁( ▁2 ▁) ▁) ▁; ▁} ▁return ▁true ▁; ▁} ▁String ▁optim ize Option ▁= ▁STR ▁; ▁if ▁( ▁head Arg ▁. ▁startsWith ▁( ▁optim ize Option ▁) ▁) ▁{ ▁args ▁. ▁poll ▁( ▁) ▁; ▁if ▁( ▁head Arg ▁. ▁equals ▁( ▁optim ize Option ▁) ▁) ▁{ ▁NativeImage ▁. ▁showError ▁( ▁STR ▁+ ▁optim ize Option ▁+ ▁STR ▁) ▁; ▁} ▁else ▁{ ▁native Image ▁. ▁add Plain Image Builder Arg ▁( ▁native Image ▁. ▁o H Optim ize ▁+ ▁head Arg ▁. ▁substring ▁( ▁2 ▁) ▁) ▁; ▁} ▁return ▁true ▁; ▁} ▁if ▁( ▁head Arg ▁. ▁startsWith ▁( ▁server Option Prefix ▁) ▁) ▁{ ▁args ▁. ▁poll ▁( ▁) ▁; ▁NativeImage ▁. ▁show Warning ▁( ▁STR ▁+ ▁head Arg ▁+ ▁STR ▁) ▁; ▁String ▁server Option Command ▁= ▁head Arg ▁. ▁substring ▁( ▁server Option Prefix ▁. ▁length ▁( ▁) ▁) ▁; ▁if ▁( ▁! ▁server Option Command ▁. ▁startsWith ▁( ▁STR ▁) ▁) ▁{ ▁System ▁. ▁exit ▁( ▁0 ▁) ▁; ▁} ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁private ▁void ▁process Classpath Args ▁( ▁String ▁cp Args ▁) ▁{ ▁for ▁( ▁String ▁cp ▁: ▁cp Args ▁. ▁split ▁( ▁File ▁. ▁path Separator ▁, ▁Integer ▁. ▁MAX _ VALUE ▁) ▁) ▁{ ▁String ▁cp Entry ▁= ▁cp ▁. ▁isEmpty ▁( ▁) ▁? ▁STR ▁: ▁cp ▁; ▁native Image ▁. ▁add Custom Image Classpath ▁( ▁cp Entry ▁) ▁; ▁} ▁}
▁@ ▁Service ▁public ▁class ▁Loop Condition ▁{ ▁public ▁boolean ▁evaluate Loop ▁( ▁final ▁int ▁n Current Number ▁, ▁final ▁int ▁n Total Count ▁) ▁{ ▁final ▁Th ree W ay Integer Comparison Result ▁comp arison Result ▁= ▁Th ree W ay Integer Comparator ▁. ▁Compare ▁( ▁n Current Number ▁, ▁n Total Count ▁) ▁; ▁if ▁( ▁Th ree W ay Integer Comparison Result ▁. ▁First Is LessThan Second ▁== ▁comp arison Result ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁if ▁( ▁Th ree W ay Integer Comparison Result ▁. ▁First Equals Second ▁== ▁comp arison Result ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁{ ▁return ▁false ▁; ▁} ▁} ▁}
▁assertThat ▁( ▁c 1 ▁. ▁socket ▁( ▁) ▁. ▁isClosed ▁( ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁assertThat ▁( ▁c 2 ▁. ▁socket ▁( ▁) ▁. ▁isClosed ▁( ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁ol dest Connections Ev icted If Idle Limit Exceeded ▁( ▁) ▁throws ▁Exception ▁{ ▁Real Connection Pool ▁pool ▁= ▁new ▁Real Connection Pool ▁( ▁task Runner ▁, ▁2 ▁, ▁100 L ▁, ▁TimeUnit ▁. ▁NANOSECONDS ▁) ▁; ▁Real Connection ▁c 1 ▁= ▁new Connection ▁( ▁pool ▁, ▁route A 1 ▁, ▁50 L ▁) ▁; ▁Real Connection ▁c 2 ▁= ▁new Connection ▁( ▁pool ▁, ▁route B 1 ▁, ▁75 L ▁) ▁; ▁assertThat ▁( ▁pool ▁. ▁cleanup ▁( ▁100 L ▁) ▁) ▁. ▁isEqualTo ▁( ▁50 L ▁) ▁; ▁assertThat ▁( ▁pool ▁. ▁connection Count ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁2 ▁) ▁; ▁assertThat ▁( ▁c 1 ▁. ▁socket ▁( ▁) ▁. ▁isClosed ▁( ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁assertThat ▁( ▁c 2 ▁. ▁socket ▁( ▁) ▁. ▁isClosed ▁( ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁Real Connection ▁c 3 ▁= ▁new Connection ▁( ▁pool ▁, ▁route C 1 ▁, ▁75 L ▁) ▁; ▁assertThat ▁( ▁pool ▁. ▁cleanup ▁( ▁100 L ▁) ▁) ▁. ▁isEqualTo ▁( ▁0 L ▁) ▁; ▁assertThat ▁( ▁pool ▁. ▁connection Count ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁2 ▁) ▁; ▁assertThat ▁( ▁c 1 ▁. ▁socket ▁( ▁) ▁. ▁isClosed ▁( ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁assertThat ▁( ▁c 2 ▁. ▁socket ▁( ▁) ▁. ▁isClosed ▁( ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁assertThat ▁( ▁c 3 ▁. ▁socket ▁( ▁) ▁. ▁isClosed ▁( ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁le ak ed Allocation ▁( ▁) ▁throws ▁Exception ▁{ ▁Real Connection Pool ▁pool ▁= ▁new ▁Real Connection Pool ▁( ▁task Runner ▁, ▁Integer ▁. ▁MAX _ VALUE ▁, ▁100 L ▁, ▁TimeUnit ▁. ▁NANOSECONDS ▁) ▁; ▁Connection Pool ▁pool Api ▁= ▁new ▁Connection Pool ▁( ▁pool ▁) ▁; ▁Real Connection ▁c 1 ▁= ▁new Connection ▁( ▁pool ▁, ▁route A 1 ▁, ▁0 L ▁) ▁; ▁allocate And Leak Allocation ▁( ▁pool Api ▁, ▁c 1 ▁) ▁; ▁await G arbage Collection ▁( ▁) ▁; ▁assertThat ▁( ▁pool ▁. ▁cleanup ▁( ▁100 L ▁) ▁) ▁. ▁isEqualTo ▁( ▁0 L ▁) ▁; ▁assertThat ▁( ▁c 1 ▁. ▁get Calls ▁( ▁) ▁) ▁. ▁isEmpty ▁( ▁) ▁; ▁assertThat ▁( ▁c 1 ▁. ▁get No New Ex ch anges ▁( ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁interrupt St ops Thread ▁( ▁) ▁throws ▁Exception ▁{ ▁Task Runner ▁real Task Runner ▁= ▁Task Runner ▁. ▁INSTANCE ▁; ▁Real Connection Pool ▁pool ▁= ▁new ▁Real Connection Pool ▁( ▁real Task Runner ▁, ▁2 ▁, ▁100 L ▁, ▁TimeUnit ▁. ▁NANOSECONDS ▁) ▁; ▁new Connection ▁( ▁pool ▁, ▁route A 1 ▁, ▁Long ▁. ▁MAX _ VALUE ▁) ▁; ▁assertThat ▁( ▁real Task Runner ▁. ▁active Queues ▁( ▁) ▁) ▁. ▁isNotEmpty ▁( ▁) ▁;
▁public ▁class ▁Default Future ▁extends ▁Completable Future ▁< ▁Object ▁> ▁{ ▁private ▁static ▁final ▁Logger ▁logger ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Default Future ▁. ▁class ▁) ▁; ▁private ▁static ▁final ▁Map ▁< ▁Long ▁, ▁Channel ▁> ▁CHANNEL S ▁= ▁new ▁Concurrent HashMap ▁< ▁> ▁( ▁) ▁; ▁private ▁static ▁final ▁Map ▁< ▁Long ▁, ▁Default Future ▁> ▁F UT URE S ▁= ▁new ▁Concurrent HashMap ▁< ▁> ▁( ▁) ▁; ▁public ▁static ▁final ▁Timer ▁TIME _ OUT _ T IM ER ▁= ▁new ▁Hash ed Wheel Timer ▁( ▁new ▁Named ThreadFactory ▁( ▁STR ▁, ▁true ▁) ▁, ▁30 ▁, ▁TimeUnit ▁. ▁MILLISECONDS ▁) ▁; ▁private ▁final ▁Long ▁id ▁; ▁private ▁final ▁Channel ▁channel ▁; ▁private ▁final ▁Request ▁request ▁; ▁private ▁final ▁int ▁timeout ▁; ▁private ▁final ▁long ▁start ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁; ▁private ▁volatile ▁long ▁sent ▁; ▁private ▁Timeout ▁timeout Check Task ▁; ▁private ▁ExecutorService ▁executor ▁; ▁public ▁ExecutorService ▁getExecutor ▁( ▁) ▁{ ▁return ▁executor ▁; ▁} ▁public ▁void ▁set Executor ▁( ▁ExecutorService ▁executor ▁) ▁{ ▁this ▁. ▁executor ▁= ▁executor ▁; ▁} ▁private ▁Default Future ▁( ▁Channel ▁channel ▁, ▁Request ▁request ▁, ▁int ▁timeout ▁) ▁{ ▁this ▁. ▁channel ▁= ▁channel ▁; ▁this ▁. ▁request ▁= ▁request ▁; ▁this ▁. ▁id ▁= ▁request ▁. ▁getId ▁( ▁) ▁; ▁this ▁. ▁timeout ▁= ▁timeout ▁> ▁0 ▁? ▁timeout ▁: ▁channel ▁. ▁getUrl ▁( ▁) ▁. ▁getPos itive Parameter ▁( ▁TIMEOUT _ KEY ▁, ▁DEFAULT _ TIMEOUT ▁) ▁; ▁F UT URE S ▁. ▁put ▁( ▁id ▁, ▁this ▁) ▁; ▁CHANNEL S ▁. ▁put ▁( ▁id ▁, ▁channel ▁) ▁; ▁} ▁private ▁static ▁void ▁timeout Check ▁( ▁Default Future ▁future ▁) ▁{ ▁Timeout Check Task ▁task ▁= ▁new ▁Timeout Check Task ▁( ▁future ▁. ▁getId ▁( ▁) ▁) ▁; ▁future ▁. ▁timeout Check Task ▁= ▁TIME _ OUT _ T IM ER ▁. ▁new Timeout ▁( ▁task ▁, ▁future ▁. ▁getTimeout ▁( ▁) ▁, ▁TimeUnit ▁. ▁MILLISECONDS ▁) ▁; ▁} ▁public ▁static ▁Default Future ▁new Future ▁( ▁Channel ▁channel ▁, ▁Request ▁request ▁, ▁int ▁timeout ▁, ▁ExecutorService ▁executor ▁) ▁{ ▁final ▁Default Future ▁future ▁= ▁new ▁Default Future ▁( ▁channel ▁, ▁request ▁, ▁timeout ▁) ▁; ▁future ▁. ▁set Executor ▁( ▁executor ▁) ▁; ▁if ▁( ▁executor ▁instanceof ▁Thread less Executor ▁) ▁{ ▁( ▁( ▁Thread less Executor ▁) ▁executor ▁) ▁. ▁set Waiting Future ▁( ▁future ▁) ▁; ▁} ▁timeout Check ▁( ▁future ▁) ▁; ▁return ▁future ▁; ▁} ▁public ▁static ▁Default Future ▁get Future ▁( ▁long ▁id ▁) ▁{ ▁return ▁F UT URE S ▁. ▁get ▁( ▁id ▁) ▁; ▁} ▁public ▁static ▁boolean ▁has Future ▁( ▁Channel ▁channel ▁) ▁{ ▁return ▁CHANNEL S ▁. ▁containsValue ▁( ▁channel ▁) ▁; ▁} ▁public ▁static ▁void ▁sent ▁( ▁Channel ▁channel ▁, ▁Request ▁request ▁) ▁{ ▁Default Future ▁future ▁= ▁F UT URE S ▁. ▁get ▁( ▁request ▁. ▁getId ▁( ▁) ▁) ▁; ▁if ▁( ▁future ▁!= ▁null ▁) ▁{ ▁future ▁. ▁do Sent ▁( ▁) ▁; ▁} ▁}
▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁class ▁S 3 A Op Context ▁extends ▁Active Operation Context ▁{ ▁final ▁boolean ▁isS 3 Guard Enabled ▁; ▁final ▁Invoker ▁invoker ▁; ▁@ ▁Nullable ▁final ▁FileSystem ▁. ▁Statistics ▁stats ▁; ▁@ ▁Nullable ▁final ▁Invoker ▁s 3 g uard Invoker ▁; ▁protected ▁final ▁FileStatus ▁dst FileStatus ▁; ▁public ▁S 3 A Op Context ▁( ▁boolean ▁isS 3 Guard Enabled ▁, ▁Invoker ▁invoker ▁, ▁@ ▁Nullable ▁Invoker ▁s 3 g uard Invoker ▁, ▁@ ▁Nullable ▁FileSystem ▁. ▁Statistics ▁stats ▁, ▁S 3 A Statistics Context ▁instrumentation ▁, ▁FileStatus ▁dst FileStatus ▁) ▁{ ▁super ▁( ▁new Operation Id ▁( ▁) ▁, ▁instrumentation ▁, ▁null ▁) ▁; ▁Preconditions ▁. ▁checkNotNull ▁( ▁invoker ▁, ▁STR ▁) ▁; ▁Preconditions ▁. ▁checkNotNull ▁( ▁instrumentation ▁, ▁STR ▁) ▁; ▁Preconditions ▁. ▁checkNotNull ▁( ▁dst FileStatus ▁, ▁STR ▁) ▁; ▁this ▁. ▁isS 3 Guard Enabled ▁= ▁isS 3 Guard Enabled ▁; ▁Preconditions ▁. ▁checkArgument ▁( ▁! ▁isS 3 Guard Enabled ▁|| ▁s 3 g uard Invoker ▁!= ▁null ▁, ▁STR ▁) ▁; ▁this ▁. ▁invoker ▁= ▁invoker ▁; ▁this ▁. ▁s 3 g uard Invoker ▁= ▁s 3 g uard Invoker ▁; ▁this ▁. ▁stats ▁= ▁stats ▁; ▁this ▁. ▁dst FileStatus ▁= ▁dst FileStatus ▁; ▁} ▁public ▁S 3 A Op Context ▁( ▁boolean ▁isS 3 Guard Enabled ▁, ▁Invoker ▁invoker ▁, ▁@ ▁Nullable ▁FileSystem ▁. ▁Statistics ▁stats ▁, ▁S 3 A Statistics Context ▁instrumentation ▁, ▁FileStatus ▁dst FileStatus ▁) ▁{ ▁this ▁( ▁isS 3 Guard Enabled ▁, ▁invoker ▁, ▁null ▁, ▁stats ▁, ▁instrumentation ▁, ▁dst FileStatus ▁) ▁; ▁} ▁public ▁boolean ▁isS 3 Guard Enabled ▁( ▁) ▁{ ▁return ▁isS 3 Guard Enabled ▁; ▁} ▁public ▁Invoker ▁getIn voker ▁( ▁) ▁{ ▁return ▁invoker ▁; ▁} ▁@ ▁Nullable ▁public ▁FileSystem ▁. ▁Statistics ▁getStats ▁( ▁) ▁{ ▁return ▁stats ▁; ▁} ▁@ ▁Nullable ▁public ▁Invoker ▁getS 3 g uard Invoker ▁( ▁) ▁{ ▁return ▁s 3 g uard Invoker ▁; ▁} ▁public ▁FileStatus ▁getD st FileStatus ▁( ▁) ▁{ ▁return ▁dst FileStatus ▁; ▁} ▁}
▁@ ▁RunWith ▁( ▁EasyMock Runner ▁. ▁class ▁) ▁public ▁class ▁Session Store Builder Test ▁{ ▁@ ▁Mock ▁( ▁type ▁= ▁Mock Type ▁. ▁N I CE ▁) ▁private ▁Session Bytes Store Supplier ▁supplier ▁; ▁@ ▁Mock ▁( ▁type ▁= ▁Mock Type ▁. ▁N I CE ▁) ▁private ▁Session Store ▁< ▁Bytes ▁, ▁byte ▁[ ▁] ▁> ▁inner ▁; ▁private ▁Session Store Builder ▁< ▁String ▁, ▁String ▁> ▁builder ▁; ▁@ ▁Before ▁public ▁void ▁setUp ▁( ▁) ▁{ ▁expect ▁( ▁supplier ▁. ▁get ▁( ▁) ▁) ▁. ▁andReturn ▁( ▁inner ▁) ▁; ▁expect ▁( ▁supplier ▁. ▁name ▁( ▁) ▁) ▁. ▁andReturn ▁( ▁STR ▁) ▁; ▁expect ▁( ▁supplier ▁. ▁metrics Scope ▁( ▁) ▁) ▁. ▁andReturn ▁( ▁STR ▁) ▁; ▁replay ▁( ▁supplier ▁) ▁; ▁builder ▁= ▁new ▁Session Store Builder ▁< ▁> ▁( ▁supplier ▁, ▁Serdes ▁. ▁String ▁( ▁) ▁, ▁Serdes ▁. ▁String ▁( ▁) ▁, ▁new ▁Mock Time ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁should Have Meter ed Store As Outer Store ▁( ▁) ▁{ ▁final ▁Session Store ▁< ▁String ▁, ▁String ▁> ▁store ▁= ▁builder ▁. ▁build ▁( ▁) ▁; ▁assertThat ▁( ▁store ▁, ▁instanceOf ▁( ▁Meter ed Session Store ▁. ▁class ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁should Have Change Logging Store ByDefault ▁( ▁) ▁{ ▁final ▁Session Store ▁< ▁String ▁, ▁String ▁> ▁store ▁= ▁builder ▁. ▁build ▁( ▁) ▁; ▁final ▁StateStore ▁next ▁= ▁( ▁( ▁Wrapped StateStore ▁) ▁store ▁) ▁. ▁wrapped ▁( ▁) ▁; ▁assertThat ▁( ▁next ▁, ▁instanceOf ▁( ▁Change Logging Session Bytes Store ▁. ▁class ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁shouldNot Have Change Logging Store When Disabled ▁( ▁) ▁{ ▁final ▁Session Store ▁< ▁String ▁, ▁String ▁> ▁store ▁= ▁builder ▁. ▁with Logging Disabled ▁( ▁) ▁. ▁build ▁( ▁) ▁; ▁final ▁StateStore ▁next ▁= ▁( ▁( ▁Wrapped StateStore ▁) ▁store ▁) ▁. ▁wrapped ▁( ▁) ▁; ▁assertThat ▁( ▁next ▁, ▁Core Matchers ▁. ▁< ▁StateStore ▁> ▁equalTo ▁( ▁inner ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁should Have Caching Store When Enabled ▁( ▁) ▁{ ▁final ▁Session Store ▁< ▁String ▁, ▁String ▁> ▁store ▁= ▁builder ▁. ▁with Caching Enabled ▁( ▁) ▁. ▁build ▁( ▁) ▁; ▁final ▁StateStore ▁wrapped ▁= ▁( ▁( ▁Wrapped StateStore ▁) ▁store ▁) ▁. ▁wrapped ▁( ▁) ▁; ▁assertThat ▁( ▁store ▁, ▁instanceOf ▁( ▁Meter ed Session Store ▁. ▁class ▁) ▁) ▁; ▁assertThat ▁( ▁wrapped ▁, ▁instanceOf ▁( ▁Caching Session Store ▁. ▁class ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁should Have Change Logging Store When Logging Enabled ▁( ▁) ▁{ ▁final ▁Session Store ▁< ▁String ▁, ▁String ▁> ▁store ▁= ▁builder ▁. ▁with Logging Enabled ▁( ▁Collections ▁. ▁< ▁String ▁, ▁String ▁> ▁emptyMap ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁final ▁StateStore ▁wrapped ▁= ▁( ▁( ▁Wrapped StateStore ▁) ▁store ▁) ▁. ▁wrapped ▁( ▁) ▁; ▁assertThat ▁( ▁store ▁, ▁instanceOf ▁( ▁Meter ed Session Store ▁. ▁class ▁) ▁) ▁; ▁assertThat ▁( ▁wrapped ▁, ▁instanceOf ▁( ▁Change Logging Session Bytes Store ▁. ▁class ▁) ▁) ▁;
▁@ ▁RestController ▁public ▁class ▁Back Controller ▁{ ▁private ▁static ▁final ▁Map ▁< ▁Integer ▁, ▁User ▁> ▁USER S ▁= ▁new ▁Concurrent HashMap ▁< ▁> ▁( ▁) ▁; ▁@ ▁GetMapping ▁( ▁STR ▁) ▁public ▁ResponseEntity ▁< ▁User ▁> ▁getUser ▁( ▁@ ▁PathVariable ▁( ▁STR ▁) ▁int ▁id ▁) ▁{ ▁User ▁current User ▁= ▁USER S ▁. ▁get ▁( ▁id ▁) ▁; ▁return ▁ResponseEntity ▁. ▁ok ▁( ▁current User ▁) ▁; ▁} ▁@ ▁PostMapping ▁( ▁value ▁= ▁STR ▁) ▁public ▁ResponseEntity ▁< ▁Void ▁> ▁createUser ▁( ▁@ ▁RequestBody ▁User ▁user ▁, ▁UriComponents Builder ▁u c Builder ▁) ▁{ ▁USER S ▁. ▁put ▁( ▁user ▁. ▁getId ▁( ▁) ▁, ▁user ▁) ▁; ▁HttpHeaders ▁headers ▁= ▁new ▁HttpHeaders ▁( ▁) ▁; ▁headers ▁. ▁setLocation ▁( ▁u c Builder ▁. ▁path ▁( ▁STR ▁) ▁. ▁build And Expand ▁( ▁user ▁. ▁getId ▁( ▁) ▁) ▁. ▁toUri ▁( ▁) ▁) ▁; ▁return ▁new ▁ResponseEntity ▁< ▁> ▁( ▁headers ▁, ▁HttpStatus ▁. ▁CREATED ▁) ▁; ▁} ▁@ ▁PutMapping ▁( ▁value ▁= ▁STR ▁) ▁public ▁ResponseEntity ▁< ▁User ▁> ▁update User ▁( ▁@ ▁PathVariable ▁( ▁STR ▁) ▁int ▁id ▁, ▁@ ▁RequestBody ▁User ▁user ▁) ▁{ ▁User ▁current User ▁= ▁new ▁User ▁( ▁id ▁, ▁user ▁. ▁getUserName ▁( ▁) ▁) ▁; ▁return ▁ResponseEntity ▁. ▁ok ▁( ▁current User ▁) ▁; ▁} ▁@ ▁Delete Mapping ▁( ▁value ▁= ▁STR ▁) ▁public ▁ResponseEntity ▁< ▁User ▁> ▁delete User ▁( ▁@ ▁PathVariable ▁( ▁STR ▁) ▁int ▁id ▁) ▁{ ▁User ▁current User ▁= ▁USER S ▁. ▁get ▁( ▁id ▁) ▁; ▁if ▁( ▁current User ▁== ▁null ▁) ▁{ ▁return ▁ResponseEntity ▁. ▁no Content ▁( ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁USER S ▁. ▁remove ▁( ▁id ▁) ▁; ▁return ▁ResponseEntity ▁. ▁no Content ▁( ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁}
▁ap f ▁. ▁setRe member Me Services ▁( ▁sc ▁. ▁re member Me 2 ▁) ▁; ▁final ▁Authentication Success Handler ▁success Handler ▁= ▁new ▁Authentication Success Handler ▁( ▁) ▁; ▁success Handler ▁. ▁setTarget Url Parameter ▁( ▁STR ▁) ▁; ▁ap f ▁. ▁set Authentication Success Handler ▁( ▁success Handler ▁) ▁; ▁ap f ▁. ▁set Authentication Failure Handler ▁( ▁new ▁Simple Url Authentication Failure Handler ▁( ▁STR ▁) ▁) ▁; ▁filters ▁. ▁add ▁( ▁ap f ▁) ▁; ▁} ▁filters ▁. ▁add ▁( ▁new ▁Re member Me Authentication Filter ▁( ▁sc ▁. ▁manager 2 ▁, ▁sc ▁. ▁re member Me 2 ▁) ▁) ▁; ▁filters ▁. ▁addAll ▁( ▁common Filters ▁( ▁) ▁) ▁; ▁return ▁new ▁Chain ed Servlet Filter ▁( ▁filters ▁) ▁; ▁} ▁protected ▁final ▁List ▁< ▁Filter ▁> ▁common Filters ▁( ▁) ▁{ ▁An onymous Authentication Filter ▁ap f ▁= ▁new ▁An onymous Authentication Filter ▁( ▁STR ▁, ▁STR ▁, ▁Collections ▁. ▁singletonList ▁( ▁new ▁Simple G rantedAuthority ▁( ▁STR ▁) ▁) ▁) ▁; ▁Exception Translation Filter ▁et f ▁= ▁new ▁Exception Translation Filter ▁( ▁new ▁H udson Authentication EntryPoint ▁( ▁STR ▁+ ▁getLogin Url ▁( ▁) ▁+ ▁STR ▁) ▁) ▁; ▁et f ▁. ▁set Access Denied Handler ▁( ▁new ▁Access Denied Handler Impl ▁( ▁) ▁) ▁; ▁Un w rap Security Exception Filter ▁use f ▁= ▁new ▁Un w rap Security Exception Filter ▁( ▁) ▁; ▁A ce gi Security Exception Filter ▁ ase f ▁= ▁new ▁A ce gi Security Exception Filter ▁( ▁) ▁; ▁return ▁Arrays ▁. ▁asList ▁( ▁ap f ▁, ▁et f ▁, ▁use f ▁, ▁ ase f ▁) ▁; ▁} ▁public ▁static ▁final ▁Security Realm ▁NO _ AUTH ENTIC ATION ▁= ▁new ▁None ▁( ▁) ▁; ▁@ ▁Restricted ▁( ▁DoNot Use ▁. ▁class ▁) ▁public ▁static ▁String ▁getFrom ▁( ▁) ▁{ ▁String ▁from ▁= ▁null ▁, ▁returnValue ▁= ▁null ▁; ▁final ▁StaplerRequest ▁request ▁= ▁Stapler ▁. ▁getCurrent Request ▁( ▁) ▁; ▁if ▁( ▁request ▁!= ▁null ▁) ▁{ ▁from ▁= ▁request ▁. ▁getParameter ▁( ▁STR ▁) ▁; ▁} ▁if ▁( ▁from ▁== ▁null ▁&& ▁request ▁!= ▁null ▁&& ▁request ▁. ▁getRequest URI ▁( ▁) ▁!= ▁null ▁&& ▁! ▁request ▁. ▁getRequest URI ▁( ▁) ▁. ▁equals ▁( ▁STR ▁) ▁&& ▁! ▁request ▁. ▁getRequest URI ▁( ▁) ▁. ▁equals ▁( ▁STR ▁) ▁) ▁{ ▁from ▁= ▁request ▁. ▁getRequest URI ▁( ▁) ▁; ▁} ▁from ▁= ▁StringUtils ▁. ▁default If Blank ▁( ▁from ▁, ▁STR ▁) ▁. ▁trim ▁( ▁) ▁; ▁try ▁{ ▁returnValue ▁= ▁java ▁. ▁net ▁. ▁URL Encoder ▁. ▁encode ▁( ▁from ▁, ▁STR ▁) ▁; ▁} ▁catch ▁( ▁Unsupported Encoding Exception ▁e ▁) ▁{ ▁} ▁return ▁StringUtils ▁. ▁isBlank ▁( ▁returnValue ▁) ▁? ▁STR ▁: ▁returnValue ▁; ▁} ▁private ▁static ▁class ▁None ▁extends ▁Security Realm ▁{ ▁@ ▁Override ▁public ▁Security Components ▁create Security Components ▁( ▁) ▁{ ▁return ▁new ▁Security Components ▁( ▁new ▁Authentication Manager ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Authentication ▁authenticate ▁( ▁Authentication ▁authentication ▁) ▁{ ▁return ▁authentication ▁; ▁} ▁}
▁@ ▁Override ▁public ▁Search Context ▁parsed Query ▁( ▁Parsed Query ▁query ▁) ▁{ ▁return ▁in ▁. ▁parsed Query ▁( ▁query ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Parsed Query ▁parsed Query ▁( ▁) ▁{ ▁return ▁in ▁. ▁parsed Query ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Query ▁query ▁( ▁) ▁{ ▁return ▁in ▁. ▁query ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁from ▁( ▁) ▁{ ▁return ▁in ▁. ▁from ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Search Context ▁from ▁( ▁int ▁from ▁) ▁{ ▁return ▁in ▁. ▁from ▁( ▁from ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁size ▁( ▁) ▁{ ▁return ▁in ▁. ▁size ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Search Context ▁size ▁( ▁int ▁size ▁) ▁{ ▁return ▁in ▁. ▁size ▁( ▁size ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁explain ▁( ▁) ▁{ ▁return ▁in ▁. ▁explain ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁explain ▁( ▁boolean ▁explain ▁) ▁{ ▁in ▁. ▁explain ▁( ▁explain ▁) ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁String ▁> ▁group Stats ▁( ▁) ▁{ ▁return ▁in ▁. ▁group Stats ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁group Stats ▁( ▁List ▁< ▁String ▁> ▁group Stats ▁) ▁{ ▁in ▁. ▁group Stats ▁( ▁group Stats ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁version ▁( ▁) ▁{ ▁return ▁in ▁. ▁version ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁version ▁( ▁boolean ▁version ▁) ▁{ ▁in ▁. ▁version ▁( ▁version ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁seqNo And Primary Term ▁( ▁) ▁{ ▁return ▁in ▁. ▁seqNo And Primary Term ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁seqNo And Primary Term ▁( ▁boolean ▁seqNo And Primary Term ▁) ▁{ ▁in ▁. ▁seqNo And Primary Term ▁( ▁seqNo And Primary Term ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁[ ▁] ▁doc Ids To Load ▁( ▁) ▁{ ▁return ▁in ▁. ▁doc Ids To Load ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Search Context ▁doc Ids To Load ▁( ▁int ▁[ ▁] ▁doc Ids To Load ▁, ▁int ▁docs Ids To Load Size ▁) ▁{ ▁return ▁in ▁. ▁doc Ids To Load ▁( ▁doc Ids To Load ▁, ▁docs Ids To Load Size ▁) ▁; ▁} ▁@ ▁Override ▁public ▁D fs SearchResult ▁dfs Result ▁( ▁) ▁{ ▁return ▁in ▁. ▁dfs Result ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Query SearchResult ▁queryResult ▁( ▁) ▁{ ▁return ▁in ▁. ▁queryResult ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Fetch SearchResult ▁fetch Result ▁( ▁) ▁{ ▁return ▁in ▁. ▁fetch Result ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Fetch Phase ▁fetch Phase ▁( ▁) ▁{ ▁return ▁in ▁. ▁fetch Phase ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁long ▁getRelative Time InMillis ▁( ▁) ▁{ ▁return ▁in ▁. ▁getRelative Time InMillis ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁add Search Ext ▁( ▁Search Ext Builder ▁search Ext Builder ▁) ▁{ ▁in ▁. ▁add Search Ext ▁( ▁search Ext Builder ▁) ▁; ▁}
▁public ▁class ▁Asynchronous Block Writer With Callback ▁extends ▁Asynchronous File IO Channel ▁< ▁MemorySegment ▁, ▁WriteRequest ▁> ▁implements ▁Block Channel Writer With Callback ▁< ▁MemorySegment ▁> ▁{ ▁protected ▁Asynchronous Block Writer With Callback ▁( ▁File IO Channel ▁. ▁ID ▁channel ID ▁, ▁Request Queue ▁< ▁WriteRequest ▁> ▁request Queue ▁, ▁Request Done Callback ▁< ▁MemorySegment ▁> ▁callback ▁) ▁throws ▁IOException ▁{ ▁super ▁( ▁channel ID ▁, ▁request Queue ▁, ▁callback ▁, ▁true ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁write Block ▁( ▁MemorySegment ▁segment ▁) ▁throws ▁IOException ▁{ ▁add Request ▁( ▁new ▁Segment WriteRequest ▁( ▁this ▁, ▁segment ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁OAuthBearer Un sec ured Validator Callback Handler Test ▁{ ▁private ▁static ▁final ▁String ▁UN SECURE D _ J WT _ HEADER _ JSON ▁= ▁STR ▁+ ▁claim Or Header Text ▁( ▁STR ▁, ▁STR ▁) ▁+ ▁STR ▁; ▁private ▁static ▁final ▁Time ▁MOCK _ TIME ▁= ▁new ▁Mock Time ▁( ▁) ▁; ▁private ▁static ▁final ▁String ▁ QUOTE ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁PR INC IP AL _ C LA IM _ VALUE ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁PR INC IP AL _ C LA IM _ TEXT ▁= ▁claim Or Header Text ▁( ▁STR ▁, ▁PR INC IP AL _ C LA IM _ VALUE ▁) ▁; ▁private ▁static ▁final ▁String ▁SUB _ C LA IM _ TEXT ▁= ▁claim Or Header Text ▁( ▁STR ▁, ▁PR INC IP AL _ C LA IM _ VALUE ▁) ▁; ▁private ▁static ▁final ▁String ▁BAD _ PR INC IP AL _ C LA IM _ TEXT ▁= ▁claim Or Header Text ▁( ▁STR ▁, ▁1 ▁) ▁; ▁private ▁static ▁final ▁long ▁LI F ET IME _ SECONDS _ TO _ USE ▁= ▁1000 ▁ * ▁60 ▁ * ▁60 ▁; ▁private ▁static ▁final ▁String ▁EX PI R ATION _ TIME _ C LA IM _ TEXT ▁= ▁exp Cl aim Text ▁( ▁LI F ET IME _ SECONDS _ TO _ USE ▁) ▁; ▁private ▁static ▁final ▁String ▁TO O _ EAR LY _ EX PI R ATION _ TIME _ C LA IM _ TEXT ▁= ▁exp Cl aim Text ▁( ▁0 ▁) ▁; ▁private ▁static ▁final ▁String ▁I SS UE D _ AT _ C LA IM _ TEXT ▁= ▁claim Or Header Text ▁( ▁STR ▁, ▁MOCK _ TIME ▁. ▁milliseconds ▁( ▁) ▁ / ▁1000 .0 ▁) ▁; ▁private ▁static ▁final ▁String ▁SCOPE _ C LA IM _ TEXT ▁= ▁claim Or Header Text ▁( ▁STR ▁, ▁STR ▁) ▁; ▁private ▁static ▁final ▁Map ▁< ▁String ▁, ▁String ▁> ▁MOD ULE _ OPTIONS _ MAP _ NO _ SCOPE _ RE QUIRED ▁; ▁static ▁{ ▁Map ▁< ▁String ▁, ▁String ▁> ▁tmp ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁tmp ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁; ▁tmp ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁; ▁MOD ULE _ OPTIONS _ MAP _ NO _ SCOPE _ RE QUIRED ▁= ▁Collections ▁. ▁unmodifiableMap ▁( ▁tmp ▁) ▁; ▁} ▁private ▁static ▁final ▁Map ▁< ▁String ▁, ▁String ▁> ▁MOD ULE _ OPTIONS _ MAP _ RE QUI RE _ EXISTING _ SCOPE ▁; ▁static ▁{ ▁Map ▁< ▁String ▁, ▁String ▁> ▁tmp ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁tmp ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁; ▁MOD ULE _ OPTIONS _ MAP _ RE QUI RE _ EXISTING _ SCOPE ▁= ▁Collections ▁. ▁unmodifiableMap ▁( ▁tmp ▁) ▁; ▁} ▁private ▁static ▁final ▁Map ▁< ▁String ▁, ▁String ▁> ▁MOD ULE _ OPTIONS _ MAP _ RE QUI RE _ ADD ITION AL _ SCOPE ▁;
▁public ▁class ▁Odps Grant Test ▁extends ▁TestCase ▁{ ▁public ▁void ▁test _0 ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁Odps StatementParser ▁parser ▁= ▁new ▁Odps StatementParser ▁( ▁sql ▁) ▁; ▁SQLStatement ▁stmt ▁= ▁parser ▁. ▁parseStatement List ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁; ▁parser ▁. ▁match ▁( ▁Token ▁. ▁EOF ▁) ▁; ▁String ▁output ▁= ▁SQLUtils ▁. ▁to Odps String ▁( ▁stmt ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁output ▁) ▁; ▁} ▁public ▁void ▁test _1 ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁Odps StatementParser ▁parser ▁= ▁new ▁Odps StatementParser ▁( ▁sql ▁) ▁; ▁SQLStatement ▁stmt ▁= ▁parser ▁. ▁parseStatement List ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁; ▁parser ▁. ▁match ▁( ▁Token ▁. ▁EOF ▁) ▁; ▁String ▁output ▁= ▁SQLUtils ▁. ▁to Odps String ▁( ▁stmt ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁output ▁) ▁; ▁} ▁public ▁void ▁test _2 ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁Odps StatementParser ▁parser ▁= ▁new ▁Odps StatementParser ▁( ▁sql ▁) ▁; ▁SQLStatement ▁stmt ▁= ▁parser ▁. ▁parseStatement List ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁; ▁parser ▁. ▁match ▁( ▁Token ▁. ▁EOF ▁) ▁; ▁String ▁output ▁= ▁SQLUtils ▁. ▁to Odps String ▁( ▁stmt ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁output ▁) ▁; ▁} ▁public ▁void ▁test _3 ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁Odps StatementParser ▁parser ▁= ▁new ▁Odps StatementParser ▁( ▁sql ▁) ▁; ▁SQLStatement ▁stmt ▁= ▁parser ▁. ▁parseStatement List ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁; ▁parser ▁. ▁match ▁( ▁Token ▁. ▁EOF ▁) ▁; ▁String ▁output ▁= ▁SQLUtils ▁. ▁to Odps String ▁( ▁stmt ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁output ▁) ▁; ▁} ▁public ▁void ▁test _4 ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁Odps StatementParser ▁parser ▁= ▁new ▁Odps StatementParser ▁( ▁sql ▁) ▁; ▁SQLStatement ▁stmt ▁= ▁parser ▁. ▁parseStatement List ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁; ▁parser ▁. ▁match ▁( ▁Token ▁. ▁EOF ▁) ▁; ▁String ▁output ▁= ▁SQLUtils ▁. ▁to Odps String ▁( ▁stmt ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁output ▁) ▁; ▁} ▁}
▁public ▁class ▁Memory Address UnitTest ▁{ ▁@ ▁Test ▁public ▁void ▁print The Memory Address ▁( ▁) ▁{ ▁String ▁answer ▁= ▁STR ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁VM ▁. ▁current ▁( ▁) ▁. ▁address Of ▁( ▁answer ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁identity HashCode And Memory Address ▁( ▁) ▁{ ▁Object ▁obj ▁= ▁new ▁Object ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁VM ▁. ▁current ▁( ▁) ▁. ▁address Of ▁( ▁obj ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁obj ▁. ▁hashCode ▁( ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁System ▁. ▁identity HashCode ▁( ▁obj ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁obj ▁) ▁; ▁} ▁}
▁public ▁class ▁Oracle Procedure St andalone ▁extends ▁Oracle Procedure Base ▁< ▁OracleSchema ▁> ▁implements ▁Oracle Source Object ▁, ▁DBP Refresh ableObject ▁{ ▁private ▁boolean ▁valid ▁; ▁private ▁String ▁source Declaration ▁; ▁public ▁Oracle Procedure St andalone ▁( ▁OracleSchema ▁schema ▁, ▁ResultSet ▁dbResult ▁) ▁{ ▁super ▁( ▁schema ▁, ▁JDBCUtils ▁. ▁safeGetString ▁( ▁dbResult ▁, ▁STR ▁) ▁, ▁JDBCUtils ▁. ▁safeGet Long ▁( ▁dbResult ▁, ▁STR ▁) ▁, ▁DBSProcedure Type ▁. ▁valueOf ▁( ▁JDBCUtils ▁. ▁safeGetString ▁( ▁dbResult ▁, ▁STR ▁) ▁) ▁) ▁; ▁this ▁. ▁valid ▁= ▁STR ▁. ▁equals ▁( ▁JDBCUtils ▁. ▁safeGetString ▁( ▁dbResult ▁, ▁STR ▁) ▁) ▁; ▁} ▁public ▁Oracle Procedure St andalone ▁( ▁OracleSchema ▁oracle Schema ▁, ▁String ▁name ▁, ▁DBSProcedure Type ▁procedure Type ▁) ▁{ ▁super ▁( ▁oracle Schema ▁, ▁name ▁, ▁0 l ▁, ▁procedure Type ▁) ▁; ▁source Declaration ▁= ▁procedure Type ▁. ▁name ▁( ▁) ▁+ ▁STR ▁+ ▁name ▁+ ▁GeneralUtils ▁. ▁getDefault Line Separator ▁( ▁) ▁+ ▁STR ▁+ ▁GeneralUtils ▁. ▁getDefault Line Separator ▁( ▁) ▁+ ▁STR ▁+ ▁GeneralUtils ▁. ▁getDefault Line Separator ▁( ▁) ▁+ ▁STR ▁+ ▁name ▁+ ▁STR ▁+ ▁GeneralUtils ▁. ▁getDefault Line Separator ▁( ▁) ▁; ▁} ▁@ ▁Property ▁( ▁viewable ▁= ▁true ▁, ▁order ▁= ▁3 ▁) ▁public ▁boolean ▁isValid ▁( ▁) ▁{ ▁return ▁valid ▁; ▁} ▁@ ▁NotNull ▁@ ▁Override ▁public ▁OracleSchema ▁getSchema ▁( ▁) ▁{ ▁return ▁getParentObject ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Oracle SourceType ▁getSource Type ▁( ▁) ▁{ ▁return ▁get Procedure Type ▁( ▁) ▁== ▁DBSProcedure Type ▁. ▁PRO CED URE ▁? ▁Oracle SourceType ▁. ▁PRO CED URE ▁: ▁Oracle SourceType ▁. ▁FUNCTION ▁; ▁} ▁@ ▁Override ▁public ▁Integer ▁get Over load Number ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁NotNull ▁@ ▁Override ▁public ▁String ▁getFull yQualifiedName ▁( ▁DBPE valuationContext ▁context ▁) ▁{ ▁return ▁DBUtils ▁. ▁getFull QualifiedName ▁( ▁getDataSource ▁( ▁) ▁, ▁getSchema ▁( ▁) ▁, ▁this ▁) ▁; ▁} ▁@ ▁Override ▁@ ▁Property ▁( ▁hidden ▁= ▁true ▁, ▁editable ▁= ▁true ▁, ▁updatable ▁= ▁true ▁, ▁order ▁= ▁- ▁1 ▁) ▁public ▁String ▁getObject Definition Text ▁( ▁DBR ProgressMonitor ▁monitor ▁, ▁Map ▁< ▁String ▁, ▁Object ▁> ▁options ▁) ▁throws ▁DBCException ▁{ ▁if ▁( ▁source Declaration ▁== ▁null ▁&& ▁monitor ▁!= ▁null ▁) ▁{ ▁source Declaration ▁= ▁Oracle Utils ▁. ▁getSource ▁( ▁monitor ▁, ▁this ▁, ▁false ▁, ▁true ▁) ▁; ▁} ▁return ▁source Declaration ▁; ▁} ▁public ▁void ▁setObject Definition Text ▁( ▁String ▁source Declaration ▁) ▁{ ▁this ▁. ▁source Declaration ▁= ▁source Declaration ▁; ▁} ▁@ ▁Override ▁public ▁DBE PersistAction ▁[ ▁] ▁get Compile Actions ▁( ▁DBR ProgressMonitor ▁monitor ▁) ▁{ ▁return ▁new ▁DBE PersistAction ▁[ ▁] ▁{ ▁new ▁Oracle Object PersistAction ▁( ▁get Procedure Type ▁( ▁) ▁== ▁DBSProcedure Type ▁. ▁PRO CED URE ▁? ▁Oracle ObjectType ▁. ▁PRO CED URE ▁: ▁Oracle ObjectType ▁. ▁FUNCTION ▁, ▁STR ▁, ▁STR ▁+ ▁getSource Type ▁( ▁) ▁. ▁name ▁( ▁) ▁+ ▁STR ▁+ ▁getFull yQualifiedName ▁( ▁DBPE valuationContext ▁. ▁DDL ▁) ▁+ ▁STR ▁) ▁} ▁; ▁}
▁public ▁class ▁Mock ServletContext ▁implements ▁ServletContext ▁{ ▁private ▁static ▁final ▁String ▁COMMON _ DEFAULT _ SERV LET _ NAME ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁TEMP _ DIR _ SYSTEM _ PROPERTY ▁= ▁STR ▁; ▁private ▁static ▁final ▁Set ▁< ▁Session Tracking Mode ▁> ▁DEFAULT _ SESSION _ TR ACK ING _ MODE S ▁= ▁new ▁LinkedHashSet ▁< ▁> ▁( ▁4 ▁) ▁; ▁static ▁{ ▁DEFAULT _ SESSION _ TR ACK ING _ MODE S ▁. ▁add ▁( ▁Session Tracking Mode ▁. ▁CO OK IE ▁) ▁; ▁DEFAULT _ SESSION _ TR ACK ING _ MODE S ▁. ▁add ▁( ▁Session Tracking Mode ▁. ▁URL ▁) ▁; ▁DEFAULT _ SESSION _ TR ACK ING _ MODE S ▁. ▁add ▁( ▁Session Tracking Mode ▁. ▁SSL ▁) ▁; ▁} ▁private ▁final ▁Log ▁logger ▁= ▁LogFactory ▁. ▁getLog ▁( ▁getClass ▁( ▁) ▁) ▁; ▁private ▁final ▁ResourceLoader ▁resourceLoader ▁; ▁private ▁final ▁String ▁resource BasePath ▁; ▁private ▁String ▁contextPath ▁= ▁STR ▁; ▁private ▁final ▁Map ▁< ▁String ▁, ▁ServletContext ▁> ▁contexts ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁private ▁int ▁majorVersion ▁= ▁3 ▁; ▁private ▁int ▁minor Version ▁= ▁1 ▁; ▁private ▁int ▁effective Major Version ▁= ▁3 ▁; ▁private ▁int ▁effective Min or Version ▁= ▁1 ▁; ▁private ▁final ▁Map ▁< ▁String ▁, ▁Request Dispatcher ▁> ▁named Request Dispatch ers ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁private ▁String ▁default Servlet Name ▁= ▁COMMON _ DEFAULT _ SERV LET _ NAME ▁; ▁private ▁final ▁Map ▁< ▁String ▁, ▁String ▁> ▁init Parameters ▁= ▁new ▁LinkedHashMap ▁< ▁> ▁( ▁) ▁; ▁private ▁final ▁Map ▁< ▁String ▁, ▁Object ▁> ▁attributes ▁= ▁new ▁LinkedHashMap ▁< ▁> ▁( ▁) ▁; ▁private ▁String ▁servletContext Name ▁= ▁STR ▁; ▁private ▁final ▁Set ▁< ▁String ▁> ▁declared Roles ▁= ▁new ▁LinkedHashSet ▁< ▁> ▁( ▁) ▁; ▁@ ▁Nullable ▁private ▁Set ▁< ▁Session Tracking Mode ▁> ▁session Tracking Mode s ▁; ▁private ▁final ▁Session Cookie Config ▁session Cookie Config ▁= ▁new ▁Mock Session Cookie Config ▁( ▁) ▁; ▁private ▁int ▁session Timeout ▁; ▁@ ▁Nullable ▁private ▁String ▁request Character Encoding ▁; ▁@ ▁Nullable ▁private ▁String ▁response Character Encoding ▁; ▁private ▁final ▁Map ▁< ▁String ▁, ▁MediaType ▁> ▁m ime Types ▁= ▁new ▁LinkedHashMap ▁< ▁> ▁( ▁) ▁; ▁public ▁Mock ServletContext ▁( ▁) ▁{ ▁this ▁( ▁STR ▁, ▁null ▁) ▁; ▁} ▁public ▁Mock ServletContext ▁( ▁String ▁resource BasePath ▁) ▁{ ▁this ▁( ▁resource BasePath ▁, ▁null ▁) ▁; ▁} ▁public ▁Mock ServletContext ▁( ▁@ ▁Nullable ▁ResourceLoader ▁resourceLoader ▁) ▁{ ▁this ▁( ▁STR ▁, ▁resourceLoader ▁) ▁; ▁} ▁public ▁Mock ServletContext ▁( ▁String ▁resource BasePath ▁, ▁@ ▁Nullable ▁ResourceLoader ▁resourceLoader ▁) ▁{ ▁this ▁. ▁resourceLoader ▁= ▁( ▁resourceLoader ▁!= ▁null ▁? ▁resourceLoader ▁: ▁new ▁Default Resource Loader ▁( ▁) ▁) ▁; ▁this ▁. ▁resource BasePath ▁= ▁resource BasePath ▁; ▁String ▁tempDir ▁= ▁System ▁. ▁getProperty ▁( ▁TEMP _ DIR _ SYSTEM _ PROPERTY ▁) ▁; ▁if ▁( ▁tempDir ▁!= ▁null ▁) ▁{ ▁this ▁. ▁attributes ▁. ▁put ▁( ▁Web Utils ▁. ▁TEMP _ DIR _ CONTEXT _ ATTRIBUTE ▁, ▁new ▁File ▁( ▁tempDir ▁) ▁) ▁;
▁De ad Node Detector ▁. ▁Unique Queue ▁< ▁Datanode Info ▁> ▁s us pect Spy ▁= ▁Mockito ▁. ▁spy ▁( ▁queue ▁) ▁; ▁de ad Node Detector ▁. ▁setS us pect Queue ▁( ▁s us pect Spy ▁) ▁; ▁queue ▁= ▁de ad Node Detector ▁. ▁get De ad Nodes Probe Queue ▁( ▁) ▁; ▁De ad Node Detector ▁. ▁Unique Queue ▁< ▁Datanode Info ▁> ▁de ad Spy ▁= ▁Mockito ▁. ▁spy ▁( ▁queue ▁) ▁; ▁de ad Node Detector ▁. ▁set De ad Queue ▁( ▁de ad Spy ▁) ▁; ▁try ▁{ ▁in ▁. ▁read ▁( ▁) ▁; ▁} ▁catch ▁( ▁Block Missing Exception ▁e ▁) ▁{ ▁} ▁Thread ▁. ▁sleep ▁( ▁15 00 ▁) ▁; ▁Collection ▁< ▁Datanode Info ▁> ▁de ad Nodes ▁= ▁dfs Client ▁. ▁get De ad Node Detector ▁( ▁) ▁. ▁clear AndGet Detected De ad Nodes ▁( ▁) ▁; ▁assertEquals ▁( ▁3 ▁, ▁de ad Nodes ▁. ▁size ▁( ▁) ▁) ▁; ▁for ▁( ▁Datanode Info ▁de ad ▁: ▁de ad Nodes ▁) ▁{ ▁Mockito ▁. ▁verify ▁( ▁s us pect Spy ▁, ▁Mockito ▁. ▁times ▁( ▁1 ▁) ▁) ▁. ▁offer ▁( ▁de ad ▁) ▁; ▁Mockito ▁. ▁verify ▁( ▁de ad Spy ▁, ▁Mockito ▁. ▁atLeast Once ▁( ▁) ▁) ▁. ▁offer ▁( ▁de ad ▁) ▁; ▁Mockito ▁. ▁verify ▁( ▁de ad Spy ▁, ▁Mockito ▁. ▁atLeast Once ▁( ▁) ▁) ▁. ▁poll ▁( ▁) ▁; ▁} ▁} ▁finally ▁{ ▁if ▁( ▁in ▁!= ▁null ▁) ▁{ ▁in ▁. ▁close ▁( ▁) ▁; ▁} ▁delete File ▁( ▁fs ▁, ▁filePath ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test De ad Node Detection S us pect Node ▁( ▁) ▁throws ▁Exception ▁{ ▁De ad Node Detector ▁. ▁set Disabled Probe Thread ForTest ▁( ▁true ▁) ▁; ▁cluster ▁= ▁new ▁MiniDFSCluster ▁. ▁Builder ▁( ▁conf ▁) ▁. ▁numDataNodes ▁( ▁1 ▁) ▁. ▁build ▁( ▁) ▁; ▁cluster ▁. ▁waitActive ▁( ▁) ▁; ▁FileSystem ▁fs ▁= ▁cluster ▁. ▁getFileSystem ▁( ▁) ▁; ▁Path ▁filePath ▁= ▁new ▁Path ▁( ▁STR ▁) ▁; ▁createFile ▁( ▁fs ▁, ▁filePath ▁) ▁; ▁MiniDFSCluster ▁. ▁DataNode Properties ▁one ▁= ▁cluster ▁. ▁stop DataNode ▁( ▁0 ▁) ▁; ▁FSData InputStream ▁in ▁= ▁fs ▁. ▁open ▁( ▁filePath ▁) ▁; ▁DFS InputStream ▁d in ▁= ▁( ▁DFS InputStream ▁) ▁in ▁. ▁getWrapped Stream ▁( ▁) ▁; ▁DFS Client ▁dfs Client ▁= ▁d in ▁. ▁getD FS Client ▁( ▁) ▁; ▁De ad Node Detector ▁de ad Node Detector ▁= ▁dfs Client ▁. ▁getClient Context ▁( ▁) ▁. ▁get De ad Node Detector ▁( ▁) ▁; ▁try ▁{ ▁try ▁{ ▁in ▁. ▁read ▁( ▁) ▁; ▁} ▁catch ▁( ▁Block Missing Exception ▁e ▁) ▁{ ▁} ▁waitFor S us pect Node ▁( ▁d in ▁. ▁getD FS Client ▁( ▁) ▁) ▁; ▁cluster ▁. ▁restart DataNode ▁( ▁one ▁, ▁true ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁1 ▁, ▁de ad Node Detector ▁. ▁getS us pect Nodes Probe Queue ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁;
▁@ ▁Override ▁protected ▁Optional ▁< ▁HttpRequest ▁> ▁create HttpRequest ▁( ▁Request Pause d ▁pause d Request ▁) ▁{ ▁if ▁( ▁pause d Request ▁. ▁getResponse Error Reason ▁( ▁) ▁. ▁isPresent ▁( ▁) ▁|| ▁pause d Request ▁. ▁getResponse StatusCode ▁( ▁) ▁. ▁isPresent ▁( ▁) ▁) ▁{ ▁return ▁Optional ▁. ▁empty ▁( ▁) ▁; ▁} ▁Request ▁c dp Request ▁= ▁pause d Request ▁. ▁getRequest ▁( ▁) ▁; ▁return ▁Optional ▁. ▁of ▁( ▁create HttpRequest ▁( ▁c dp Request ▁. ▁getMethod ▁( ▁) ▁, ▁c dp Request ▁. ▁getUrl ▁( ▁) ▁, ▁c dp Request ▁. ▁getHeaders ▁( ▁) ▁, ▁c dp Request ▁. ▁getPost Data ▁( ▁) ▁) ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Command ▁< ▁Void ▁> ▁continue Without Modification ▁( ▁Request Pause d ▁pause d Request ▁) ▁{ ▁return ▁Fetch ▁. ▁continue Request ▁( ▁pause d Request ▁. ▁getRequest Id ▁( ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Command ▁< ▁Void ▁> ▁create Response ▁( ▁Request Pause d ▁pause d Request ▁, ▁HttpResponse ▁response ▁) ▁{ ▁List ▁< ▁Header Entry ▁> ▁headers ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁response ▁. ▁getHeader Names ▁( ▁) ▁. ▁forEach ▁( ▁name ▁-> ▁response ▁. ▁getHeaders ▁( ▁name ▁) ▁. ▁forEach ▁( ▁value ▁-> ▁headers ▁. ▁add ▁( ▁new ▁Header Entry ▁( ▁name ▁, ▁value ▁) ▁) ▁) ▁) ▁; ▁byte ▁[ ▁] ▁bytes ▁= ▁ Contents ▁. ▁bytes ▁( ▁response ▁. ▁getContent ▁( ▁) ▁) ▁; ▁String ▁body ▁= ▁bytes ▁. ▁length ▁> ▁0 ▁? ▁Base 64 ▁. ▁getEncoder ▁( ▁) ▁. ▁encodeToString ▁( ▁bytes ▁) ▁: ▁null ▁; ▁return ▁Fetch ▁. ▁f ul fill Request ▁( ▁pause d Request ▁. ▁getRequest Id ▁( ▁) ▁, ▁response ▁. ▁getStatus ▁( ▁) ▁, ▁Optional ▁. ▁of ▁( ▁headers ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁, ▁Optional ▁. ▁ofNullable ▁( ▁body ▁) ▁, ▁Optional ▁. ▁empty ▁( ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁Hystrix Properties Chain ed Arch ai us Property Test ▁{ ▁@ ▁After ▁public ▁void ▁cleanUp ▁( ▁) ▁{ ▁Configuration Manager ▁. ▁getConfig Instance ▁( ▁) ▁. ▁clear ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testString ▁( ▁) ▁throws ▁Exception ▁{ ▁Dynamic String Property ▁p String ▁= ▁new ▁Dynamic String Property ▁( ▁STR ▁, ▁STR ▁) ▁; ▁Hystrix Properties Chain ed Arch ai us Property ▁. ▁String Property ▁f String ▁= ▁new ▁Hystrix Properties Chain ed Arch ai us Property ▁. ▁String Property ▁( ▁STR ▁, ▁p String ▁) ▁; ▁assertTrue ▁( ▁STR ▁. ▁equals ▁( ▁f String ▁. ▁get ▁( ▁) ▁) ▁) ▁; ▁Configuration Manager ▁. ▁getConfig Instance ▁( ▁) ▁. ▁setProperty ▁( ▁STR ▁, ▁STR ▁) ▁; ▁assertTrue ▁( ▁STR ▁. ▁equals ▁( ▁f String ▁. ▁get ▁( ▁) ▁) ▁) ▁; ▁Configuration Manager ▁. ▁getConfig Instance ▁( ▁) ▁. ▁setProperty ▁( ▁STR ▁, ▁STR ▁) ▁; ▁assertTrue ▁( ▁STR ▁. ▁equals ▁( ▁f String ▁. ▁get ▁( ▁) ▁) ▁) ▁; ▁Configuration Manager ▁. ▁getConfig Instance ▁( ▁) ▁. ▁clearProperty ▁( ▁STR ▁) ▁; ▁assertTrue ▁( ▁STR ▁. ▁equals ▁( ▁f String ▁. ▁get ▁( ▁) ▁) ▁) ▁; ▁Configuration Manager ▁. ▁getConfig Instance ▁( ▁) ▁. ▁clearProperty ▁( ▁STR ▁) ▁; ▁assertTrue ▁( ▁STR ▁. ▁equals ▁( ▁f String ▁. ▁get ▁( ▁) ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Integer ▁( ▁) ▁throws ▁Exception ▁{ ▁Dynamic Integer Property ▁p Int ▁= ▁new ▁Dynamic Integer Property ▁( ▁STR ▁, ▁- ▁1 ▁) ▁; ▁Hystrix Properties Chain ed Arch ai us Property ▁. ▁Integer Property ▁f Int ▁= ▁new ▁Hystrix Properties Chain ed Arch ai us Property ▁. ▁Integer Property ▁( ▁STR ▁, ▁p Int ▁) ▁; ▁assertTrue ▁( ▁- ▁1 ▁== ▁f Int ▁. ▁get ▁( ▁) ▁) ▁; ▁Configuration Manager ▁. ▁getConfig Instance ▁( ▁) ▁. ▁setProperty ▁( ▁STR ▁, ▁10 ▁) ▁; ▁assertTrue ▁( ▁10 ▁== ▁f Int ▁. ▁get ▁( ▁) ▁) ▁; ▁Configuration Manager ▁. ▁getConfig Instance ▁( ▁) ▁. ▁setProperty ▁( ▁STR ▁, ▁11 ▁) ▁; ▁assertTrue ▁( ▁11 ▁== ▁f Int ▁. ▁get ▁( ▁) ▁) ▁; ▁Configuration Manager ▁. ▁getConfig Instance ▁( ▁) ▁. ▁clearProperty ▁( ▁STR ▁) ▁; ▁assertTrue ▁( ▁10 ▁== ▁f Int ▁. ▁get ▁( ▁) ▁) ▁; ▁Configuration Manager ▁. ▁getConfig Instance ▁( ▁) ▁. ▁clearProperty ▁( ▁STR ▁) ▁; ▁assertTrue ▁( ▁- ▁1 ▁== ▁f Int ▁. ▁get ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Boolean ▁( ▁) ▁throws ▁Exception ▁{ ▁Dynamic Boolean Property ▁p Boolean ▁= ▁new ▁Dynamic Boolean Property ▁( ▁STR ▁, ▁true ▁) ▁; ▁Hystrix Properties Chain ed Arch ai us Property ▁. ▁Boolean Property ▁f Boolean ▁= ▁new ▁Hystrix Properties Chain ed Arch ai us Property ▁. ▁Boolean Property ▁( ▁STR ▁, ▁p Boolean ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁p Boolean ▁. ▁get ▁( ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁f Boolean ▁. ▁get ▁( ▁) ▁) ▁; ▁assertTrue ▁( ▁f Boolean ▁. ▁get ▁( ▁) ▁) ▁;
▁public ▁class ▁Tinker ▁{ ▁private ▁static ▁final ▁String ▁TAG ▁= ▁STR ▁; ▁private ▁static ▁Tinker ▁s Instance ▁; ▁private ▁static ▁boolean ▁s Installed ▁= ▁false ▁; ▁final ▁Context ▁context ▁; ▁final ▁File ▁patch Directory ▁; ▁final ▁P atch Listener ▁listener ▁; ▁final ▁Load Reporter ▁load Reporter ▁; ▁final ▁P atch Reporter ▁patch Reporter ▁; ▁final ▁File ▁patch Info File ▁; ▁final ▁File ▁patch Info Lock File ▁; ▁final ▁boolean ▁is Main Process ▁; ▁final ▁boolean ▁is Patch Process ▁; ▁final ▁boolean ▁t inker Load Verify Flag ▁; ▁int ▁t inker Flags ▁; ▁Tinker Load Result ▁t inker Load Result ▁; ▁private ▁boolean ▁loaded ▁= ▁false ▁; ▁private ▁Tinker ▁( ▁Context ▁context ▁, ▁int ▁t inker Flags ▁, ▁Load Reporter ▁load Reporter ▁, ▁P atch Reporter ▁patch Reporter ▁, ▁P atch Listener ▁listener ▁, ▁File ▁patch Directory ▁, ▁File ▁patch Info File ▁, ▁File ▁patch Info Lock File ▁, ▁boolean ▁isIn Main Proc ▁, ▁boolean ▁is Patch Process ▁, ▁boolean ▁t inker Load Verify Flag ▁) ▁{ ▁this ▁. ▁context ▁= ▁context ▁; ▁this ▁. ▁listener ▁= ▁listener ▁; ▁this ▁. ▁load Reporter ▁= ▁load Reporter ▁; ▁this ▁. ▁patch Reporter ▁= ▁patch Reporter ▁; ▁this ▁. ▁t inker Flags ▁= ▁t inker Flags ▁; ▁this ▁. ▁patch Directory ▁= ▁patch Directory ▁; ▁this ▁. ▁patch Info File ▁= ▁patch Info File ▁; ▁this ▁. ▁patch Info Lock File ▁= ▁patch Info Lock File ▁; ▁this ▁. ▁is Main Process ▁= ▁isIn Main Proc ▁; ▁this ▁. ▁t inker Load Verify Flag ▁= ▁t inker Load Verify Flag ▁; ▁this ▁. ▁is Patch Process ▁= ▁is Patch Process ▁; ▁} ▁public ▁static ▁Tinker ▁with ▁( ▁Context ▁context ▁) ▁{ ▁if ▁( ▁! ▁s Installed ▁) ▁{ ▁throw ▁new ▁Tinker RuntimeException ▁( ▁STR ▁) ▁; ▁} ▁synchronized ▁( ▁Tinker ▁. ▁class ▁) ▁{ ▁if ▁( ▁s Instance ▁== ▁null ▁) ▁{ ▁s Instance ▁= ▁new ▁Builder ▁( ▁context ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁} ▁return ▁s Instance ▁; ▁} ▁public ▁static ▁void ▁create ▁( ▁Tinker ▁t inker ▁) ▁{ ▁if ▁( ▁s Instance ▁!= ▁null ▁) ▁{ ▁throw ▁new ▁Tinker RuntimeException ▁( ▁STR ▁) ▁; ▁} ▁s Instance ▁= ▁t inker ▁; ▁} ▁public ▁static ▁boolean ▁is Tinker Installed ▁( ▁) ▁{ ▁return ▁s Installed ▁; ▁} ▁public ▁void ▁install ▁( ▁Intent ▁intent Result ▁, ▁Class ▁< ▁? ▁extends ▁Abstract Result Service ▁> ▁service Class ▁, ▁Abstract Patch ▁upgrade Patch ▁) ▁{ ▁s Installed ▁= ▁true ▁; ▁Tinker Patch Service ▁. ▁set Patch Processor ▁( ▁upgrade Patch ▁, ▁service Class ▁) ▁; ▁ShareTinkerLog ▁. ▁i ▁( ▁TAG ▁, ▁STR ▁, ▁is Tinker Enabled ▁( ▁) ▁, ▁Share Constants ▁. ▁TIN KER _ VERSION ▁) ▁; ▁if ▁( ▁! ▁is Tinker Enabled ▁( ▁) ▁) ▁{ ▁ShareTinkerLog ▁. ▁e ▁( ▁TAG ▁, ▁STR ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁intent Result ▁== ▁null ▁) ▁{ ▁throw ▁new ▁Tinker RuntimeException ▁( ▁STR ▁) ▁; ▁} ▁t inker Load Result ▁= ▁new ▁Tinker Load Result ▁( ▁) ▁;
▁public ▁class ▁Remote Host Header ▁{ ▁static ▁final ▁String ▁KEY ▁= ▁STR ▁; ▁public ▁static ▁void ▁process ▁( ▁RestRequest ▁request ▁, ▁ThreadContext ▁threadContext ▁) ▁{ ▁threadContext ▁. ▁put Transient ▁( ▁KEY ▁, ▁request ▁. ▁getHttp Channel ▁( ▁) ▁. ▁getRemote Address ▁( ▁) ▁) ▁; ▁} ▁public ▁static ▁Inet SocketAddress ▁rest Remote Address ▁( ▁ThreadContext ▁threadContext ▁) ▁{ ▁SocketAddress ▁address ▁= ▁threadContext ▁. ▁get Transient ▁( ▁KEY ▁) ▁; ▁if ▁( ▁address ▁!= ▁null ▁&& ▁address ▁instanceof ▁Inet SocketAddress ▁) ▁{ ▁return ▁( ▁Inet SocketAddress ▁) ▁address ▁; ▁} ▁return ▁null ▁; ▁} ▁public ▁static ▁void ▁put Rest Remote Address ▁( ▁ThreadContext ▁threadContext ▁, ▁SocketAddress ▁address ▁) ▁{ ▁threadContext ▁. ▁put Transient ▁( ▁KEY ▁, ▁address ▁) ▁; ▁} ▁}
▁else ▁if ▁( ▁Watch Field ▁. ▁TRANS FORM ▁. ▁match ▁( ▁current FieldName ▁, ▁parser ▁. ▁get Deprecation Handler ▁( ▁) ▁) ▁) ▁{ ▁transform ▁= ▁action Registry ▁. ▁get Transform Registry ▁( ▁) ▁. ▁parse ▁( ▁id ▁, ▁parser ▁) ▁; ▁} ▁else ▁if ▁( ▁Watch Field ▁. ▁TH RO TT LE _ PERIOD ▁. ▁match ▁( ▁current FieldName ▁, ▁parser ▁. ▁get Deprecation Handler ▁( ▁) ▁) ▁) ▁{ ▁throttle Period ▁= ▁timeValueMillis ▁( ▁parser ▁. ▁longValue ▁( ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁Watch Field ▁. ▁TH RO TT LE _ PERIOD _ H UM AN ▁. ▁match ▁( ▁current FieldName ▁, ▁parser ▁. ▁get Deprecation Handler ▁( ▁) ▁) ▁) ▁{ ▁try ▁{ ▁throttle Period ▁= ▁Watcher DateTime Utils ▁. ▁parse TimeValue ▁( ▁parser ▁, ▁Watch Field ▁. ▁TH RO TT LE _ PERIOD _ H UM AN ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁Elasticsearch ParseException ▁pe ▁) ▁{ ▁throw ▁new ▁Elasticsearch ParseException ▁( ▁STR ▁, ▁pe ▁, ▁id ▁, ▁current FieldName ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁Watch Field ▁. ▁ACTION S ▁. ▁match ▁( ▁current FieldName ▁, ▁parser ▁. ▁get Deprecation Handler ▁( ▁) ▁) ▁) ▁{ ▁actions ▁= ▁action Registry ▁. ▁parse Actions ▁( ▁id ▁, ▁parser ▁) ▁; ▁} ▁else ▁if ▁( ▁Watch Field ▁. ▁METADATA ▁. ▁match ▁( ▁current FieldName ▁, ▁parser ▁. ▁get Deprecation Handler ▁( ▁) ▁) ▁) ▁{ ▁met at data ▁= ▁parser ▁. ▁map ▁( ▁) ▁; ▁} ▁else ▁if ▁( ▁Watch Field ▁. ▁STATUS ▁. ▁match ▁( ▁current FieldName ▁, ▁parser ▁. ▁get Deprecation Handler ▁( ▁) ▁) ▁) ▁{ ▁if ▁( ▁include Status ▁) ▁{ ▁status ▁= ▁Watch Status ▁. ▁parse ▁( ▁id ▁, ▁parser ▁) ▁; ▁} ▁else ▁{ ▁parser ▁. ▁skip Children ▁( ▁) ▁; ▁} ▁} ▁else ▁{ ▁throw ▁new ▁Elasticsearch ParseException ▁( ▁STR ▁, ▁id ▁, ▁current FieldName ▁) ▁; ▁} ▁} ▁if ▁( ▁trigger ▁== ▁null ▁) ▁{ ▁throw ▁new ▁Elasticsearch ParseException ▁( ▁STR ▁, ▁id ▁, ▁Watch Field ▁. ▁TR IG GER ▁. ▁getPreferred Name ▁( ▁) ▁) ▁; ▁} ▁if ▁( ▁status ▁!= ▁null ▁) ▁{ ▁for ▁( ▁Action Wrapper ▁action ▁: ▁actions ▁) ▁{ ▁if ▁( ▁status ▁. ▁action Status ▁( ▁action ▁. ▁id ▁( ▁) ▁) ▁== ▁null ▁) ▁{ ▁throw ▁new ▁Elasticsearch ParseException ▁( ▁STR ▁+ ▁STR ▁, ▁id ▁, ▁action ▁. ▁id ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁else ▁{ ▁Map ▁< ▁String ▁, ▁Action Status ▁> ▁actions Statuses ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁Action Wrapper ▁action ▁: ▁actions ▁) ▁{ ▁actions Statuses ▁. ▁put ▁( ▁action ▁. ▁id ▁( ▁) ▁, ▁new ▁Action Status ▁( ▁parser ▁. ▁get Parse DateTime ▁( ▁) ▁) ▁) ▁; ▁} ▁status ▁= ▁new ▁Watch Status ▁( ▁parser ▁. ▁get Parse DateTime ▁( ▁) ▁, ▁unmodifiableMap ▁( ▁actions Statuses ▁) ▁) ▁; ▁} ▁return ▁new ▁Watch ▁( ▁id ▁, ▁trigger ▁, ▁input ▁, ▁condition ▁, ▁transform ▁, ▁throttle Period ▁, ▁actions ▁, ▁met at data ▁, ▁status ▁, ▁source SeqNo ▁, ▁source Primary Term ▁) ▁; ▁}
▁public ▁class ▁Add Partition sTo Txn Request Test ▁{ ▁private ▁static ▁String ▁transactional Id ▁= ▁STR ▁; ▁private ▁static ▁int ▁producer Id ▁= ▁10 ▁; ▁private ▁static ▁short ▁producer Epoch ▁= ▁1 ▁; ▁private ▁static ▁int ▁throttleTimeMs ▁= ▁10 ▁; ▁@ ▁Test ▁public ▁void ▁test Constructor ▁( ▁) ▁{ ▁List ▁< ▁TopicPartition ▁> ▁partitions ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁partitions ▁. ▁add ▁( ▁new ▁TopicPartition ▁( ▁STR ▁, ▁0 ▁) ▁) ▁; ▁partitions ▁. ▁add ▁( ▁new ▁TopicPartition ▁( ▁STR ▁, ▁1 ▁) ▁) ▁; ▁Add Partition sTo Txn Request ▁. ▁Builder ▁builder ▁= ▁new ▁Add Partition sTo Txn Request ▁. ▁Builder ▁( ▁transactional Id ▁, ▁producer Id ▁, ▁producer Epoch ▁, ▁partitions ▁) ▁; ▁for ▁( ▁short ▁version ▁: ▁ApiKeys ▁. ▁ADD _ PARTITION S _ TO _ TX N ▁. ▁all Versions ▁( ▁) ▁) ▁{ ▁Add Partition sTo Txn Request ▁request ▁= ▁builder ▁. ▁build ▁( ▁version ▁) ▁; ▁assertEquals ▁( ▁transactional Id ▁, ▁request ▁. ▁data ▁( ▁) ▁. ▁transactional Id ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁producer Id ▁, ▁request ▁. ▁data ▁( ▁) ▁. ▁producer Id ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁producer Epoch ▁, ▁request ▁. ▁data ▁( ▁) ▁. ▁producer Epoch ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁partitions ▁, ▁request ▁. ▁partitions ▁( ▁) ▁) ▁; ▁Add Partition sTo Txn Response ▁response ▁= ▁request ▁. ▁getError Response ▁( ▁throttleTimeMs ▁, ▁Errors ▁. ▁UNKNOWN _ TOPIC _ OR _ PARTITION ▁. ▁exception ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁Collections ▁. ▁singletonMap ▁( ▁Errors ▁. ▁UNKNOWN _ TOPIC _ OR _ PARTITION ▁, ▁2 ▁) ▁, ▁response ▁. ▁error Counts ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁throttleTimeMs ▁, ▁response ▁. ▁throttleTimeMs ▁( ▁) ▁) ▁; ▁} ▁} ▁}
▁abstract ▁class ▁B ipart ite Visitor ▁< ▁BLACK ▁, ▁WHITE ▁> ▁{ ▁protected ▁B ipart ite Visitor ▁( ▁) ▁{ ▁} ▁private ▁int ▁next NodeId ▁= ▁0 ▁; ▁protected ▁final ▁Map ▁< ▁BLACK ▁, ▁Integer ▁> ▁visited Black Nodes ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁protected ▁final ▁Map ▁< ▁WHITE ▁, ▁Integer ▁> ▁visited White Nodes ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁protected ▁final ▁boolean ▁visit Black Node ▁( ▁BLACK ▁black Node ▁) ▁throws ▁Interrupted Exception ▁{ ▁if ▁( ▁black Node ▁== ▁null ▁) ▁{ ▁throw ▁new ▁NullPointer Exception ▁( ▁) ▁; ▁} ▁if ▁( ▁! ▁visited Black Nodes ▁. ▁containsKey ▁( ▁black Node ▁) ▁) ▁{ ▁visited Black Nodes ▁. ▁put ▁( ▁black Node ▁, ▁next NodeId ▁++ ▁) ▁; ▁black ▁( ▁black Node ▁) ▁; ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁protected ▁final ▁void ▁visit Black Nodes ▁( ▁Iterable ▁< ▁BLACK ▁> ▁black Nodes ▁) ▁throws ▁Interrupted Exception ▁{ ▁for ▁( ▁BLACK ▁black Node ▁: ▁black Nodes ▁) ▁{ ▁visit Black Node ▁( ▁black Node ▁) ▁; ▁} ▁} ▁protected ▁final ▁boolean ▁visit White Node ▁( ▁WHITE ▁white Node ▁) ▁throws ▁Interrupted Exception ▁{ ▁if ▁( ▁white Node ▁== ▁null ▁) ▁{ ▁throw ▁new ▁NullPointer Exception ▁( ▁) ▁; ▁} ▁if ▁( ▁! ▁visited White Nodes ▁. ▁containsKey ▁( ▁white Node ▁) ▁) ▁{ ▁visited White Nodes ▁. ▁put ▁( ▁white Node ▁, ▁next NodeId ▁++ ▁) ▁; ▁white ▁( ▁white Node ▁) ▁; ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁public ▁final ▁void ▁visit White Nodes ▁( ▁Iterable ▁< ▁WHITE ▁> ▁white Nodes ▁) ▁throws ▁Interrupted Exception ▁{ ▁for ▁( ▁WHITE ▁white Node ▁: ▁white Nodes ▁) ▁{ ▁visit White Node ▁( ▁white Node ▁) ▁; ▁} ▁} ▁protected ▁abstract ▁void ▁white ▁( ▁WHITE ▁white Node ▁) ▁throws ▁Interrupted Exception ▁; ▁protected ▁abstract ▁void ▁black ▁( ▁BLACK ▁black Node ▁) ▁throws ▁Interrupted Exception ▁; ▁}
▁public ▁abstract ▁class ▁Abstract Http S ending Transport Handler ▁extends ▁Abstract Transport Handler ▁implements ▁SockJs SessionFactory ▁{ ▁private ▁static ▁final ▁Pattern ▁CALL BACK _ PARAM _ PATTERN ▁= ▁Pattern ▁. ▁compile ▁( ▁STR ▁) ▁; ▁@ ▁Override ▁public ▁final ▁void ▁handleRequest ▁( ▁Server HttpRequest ▁request ▁, ▁Server HttpResponse ▁response ▁, ▁WebSocket Handler ▁ws Handler ▁, ▁SockJs Session ▁ws Session ▁) ▁throws ▁SockJs Exception ▁{ ▁Abstract Http S ockJs Session ▁s ockJs Session ▁= ▁( ▁Abstract Http S ockJs Session ▁) ▁ws Session ▁; ▁response ▁. ▁getHeaders ▁( ▁) ▁. ▁setContentType ▁( ▁getContentType ▁( ▁) ▁) ▁; ▁handleRequest Internal ▁( ▁request ▁, ▁response ▁, ▁s ockJs Session ▁) ▁; ▁} ▁protected ▁void ▁handleRequest Internal ▁( ▁Server HttpRequest ▁request ▁, ▁Server HttpResponse ▁response ▁, ▁Abstract Http S ockJs Session ▁s ockJs Session ▁) ▁throws ▁SockJs Exception ▁{ ▁if ▁( ▁s ockJs Session ▁. ▁is New ▁( ▁) ▁) ▁{ ▁if ▁( ▁logger ▁. ▁isDebugEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁debug ▁( ▁request ▁. ▁getMethod ▁( ▁) ▁+ ▁STR ▁+ ▁request ▁. ▁getURI ▁( ▁) ▁) ▁; ▁} ▁s ockJs Session ▁. ▁handle Initial Request ▁( ▁request ▁, ▁response ▁, ▁getFrame Format ▁( ▁request ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁s ockJs Session ▁. ▁isClosed ▁( ▁) ▁) ▁{ ▁if ▁( ▁logger ▁. ▁isDebugEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁debug ▁( ▁STR ▁+ ▁s ockJs Session ▁) ▁; ▁} ▁SockJs Frame ▁frame ▁= ▁SockJs Frame ▁. ▁close Frame Go A way ▁( ▁) ▁; ▁try ▁{ ▁response ▁. ▁getBody ▁( ▁) ▁. ▁write ▁( ▁frame ▁. ▁getContent Bytes ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁ex ▁) ▁{ ▁throw ▁new ▁SockJs Exception ▁( ▁STR ▁+ ▁frame ▁, ▁s ockJs Session ▁. ▁getId ▁( ▁) ▁, ▁ex ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁! ▁s ockJs Session ▁. ▁isActive ▁( ▁) ▁) ▁{ ▁if ▁( ▁logger ▁. ▁isTraceEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁trace ▁( ▁STR ▁+ ▁get Transport Type ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁s ockJs Session ▁. ▁handle Success ive Request ▁( ▁request ▁, ▁response ▁, ▁getFrame Format ▁( ▁request ▁) ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁logger ▁. ▁isDebugEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁debug ▁( ▁STR ▁+ ▁get Transport Type ▁( ▁) ▁+ ▁STR ▁+ ▁s ockJs Session ▁) ▁; ▁} ▁String ▁formatted Frame ▁= ▁getFrame Format ▁( ▁request ▁) ▁. ▁format ▁( ▁SockJs Frame ▁. ▁close Frame Another Connection Open ▁( ▁) ▁) ▁; ▁try ▁{ ▁response ▁. ▁getBody ▁( ▁) ▁. ▁write ▁( ▁formatted Frame ▁. ▁getBytes ▁( ▁SockJs Frame ▁. ▁CHARSET ▁) ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁ex ▁) ▁{ ▁throw ▁new ▁SockJs Exception ▁( ▁STR ▁+ ▁formatted Frame ▁, ▁s ockJs Session ▁. ▁getId ▁( ▁) ▁, ▁ex ▁) ▁; ▁} ▁} ▁} ▁protected ▁abstract ▁MediaType ▁getContentType ▁( ▁) ▁; ▁protected ▁abstract ▁SockJs Frame Format ▁getFrame Format ▁( ▁Server HttpRequest ▁request ▁) ▁; ▁@ ▁Nullable ▁protected ▁final ▁String ▁get Callback Param ▁( ▁Server HttpRequest ▁request ▁) ▁{ ▁String ▁query ▁= ▁request ▁. ▁getURI ▁( ▁) ▁. ▁getQuery ▁( ▁) ▁;
▁public ▁abstract ▁class ▁Abstract Client Stream ▁extends ▁Abstract Stream ▁implements ▁Stream ▁{ ▁private ▁Consumer Model ▁consumer Model ▁; ▁private ▁Connection ▁connection ▁; ▁protected ▁Abstract Client Stream ▁( ▁URL ▁url ▁) ▁{ ▁super ▁( ▁url ▁) ▁; ▁} ▁protected ▁Abstract Client Stream ▁( ▁URL ▁url ▁, ▁Executor ▁executor ▁) ▁{ ▁super ▁( ▁url ▁, ▁executor ▁) ▁; ▁} ▁public ▁static ▁Unary Client Stream ▁un ary ▁( ▁URL ▁url ▁, ▁Executor ▁executor ▁) ▁{ ▁return ▁new ▁Unary Client Stream ▁( ▁url ▁, ▁executor ▁) ▁; ▁} ▁public ▁static ▁Abstract Client Stream ▁stream ▁( ▁URL ▁url ▁) ▁{ ▁return ▁new ▁Client Stream ▁( ▁url ▁) ▁; ▁} ▁public ▁Abstract Client Stream ▁service ▁( ▁Consumer Model ▁model ▁) ▁{ ▁this ▁. ▁consumer Model ▁= ▁model ▁; ▁return ▁this ▁; ▁} ▁public ▁Consumer Model ▁getConsumer Model ▁( ▁) ▁{ ▁return ▁consumer Model ▁; ▁} ▁public ▁Abstract Client Stream ▁connection ▁( ▁Connection ▁connection ▁) ▁{ ▁this ▁. ▁connection ▁= ▁connection ▁; ▁return ▁this ▁; ▁} ▁public ▁Connection ▁getConnection ▁( ▁) ▁{ ▁return ▁connection ▁; ▁} ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁Runnable ▁runnable ▁) ▁{ ▁try ▁{ ▁super ▁. ▁execute ▁( ▁runnable ▁) ▁; ▁} ▁catch ▁( ▁Re jectedExecution Exception ▁e ▁) ▁{ ▁LOGGER ▁. ▁error ▁( ▁STR ▁, ▁e ▁) ▁; ▁getStream Subscriber ▁( ▁) ▁. ▁onError ▁( ▁Grpc Status ▁. ▁from Code ▁( ▁Grpc Status ▁. ▁Code ▁. ▁RESOURCE _ EX HA UST ED ▁) ▁. ▁withDescription ▁( ▁STR ▁) ▁. ▁as Exception ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁LOGGER ▁. ▁error ▁( ▁STR ▁, ▁t ▁) ▁; ▁getStream Subscriber ▁( ▁) ▁. ▁onError ▁( ▁Grpc Status ▁. ▁from Code ▁( ▁Grpc Status ▁. ▁Code ▁. ▁INTERNAL ▁) ▁. ▁with Cause ▁( ▁t ▁) ▁. ▁withDescription ▁( ▁STR ▁) ▁. ▁as Exception ▁( ▁) ▁) ▁; ▁} ▁} ▁protected ▁byte ▁[ ▁] ▁encode Request ▁( ▁Object ▁value ▁) ▁{ ▁final ▁byte ▁[ ▁] ▁out ▁; ▁final ▁Object ▁obj ▁; ▁if ▁( ▁getMethod Descriptor ▁( ▁) ▁. ▁isN eed Wrap ▁( ▁) ▁) ▁{ ▁obj ▁= ▁getRequest Wrapper ▁( ▁value ▁) ▁; ▁} ▁else ▁{ ▁obj ▁= ▁getRequest Value ▁( ▁value ▁) ▁; ▁} ▁out ▁= ▁T riple Util ▁. ▁pack ▁( ▁obj ▁) ▁; ▁return ▁out ▁; ▁} ▁private ▁T riple Wrapper ▁. ▁T riple RequestWrapper ▁getRequest Wrapper ▁( ▁Object ▁value ▁) ▁{ ▁if ▁( ▁getMethod Descriptor ▁( ▁) ▁. ▁is Stream ▁( ▁) ▁) ▁{ ▁String ▁type ▁= ▁getMethod Descriptor ▁( ▁) ▁. ▁getParameter Classes ▁( ▁) ▁[ ▁0 ▁] ▁. ▁getName ▁( ▁) ▁; ▁return ▁T riple Util ▁. ▁wrap Req ▁( ▁getUrl ▁( ▁) ▁, ▁get Serialize Type ▁( ▁) ▁, ▁value ▁, ▁type ▁, ▁getMult iple Serialization ▁( ▁) ▁) ▁; ▁} ▁else ▁{ ▁RpcInvocation ▁invocation ▁= ▁( ▁RpcInvocation ▁) ▁value ▁; ▁return ▁T riple Util ▁. ▁wrap Req ▁( ▁getUrl ▁( ▁) ▁, ▁invocation ▁, ▁getMult iple Serialization ▁( ▁) ▁) ▁; ▁} ▁} ▁private ▁Object ▁getRequest Value ▁( ▁Object ▁value ▁) ▁{ ▁if ▁( ▁getMethod Descriptor ▁( ▁) ▁. ▁isUn ary ▁( ▁) ▁) ▁{ ▁RpcInvocation ▁invocation ▁= ▁( ▁RpcInvocation ▁) ▁value ▁;
▁@ ▁Data ▁@ ▁All ArgsConstructor ▁public ▁class ▁My Class With Annotated Fields ▁{ ▁@ ▁Ex pose ▁private ▁long ▁id ▁; ▁@ ▁Ex pose ▁private ▁String ▁name ▁; ▁private ▁String ▁other ▁; ▁@ ▁Ex pose ▁private ▁My Sub Class With Annotated Fields ▁sub class ▁; ▁}
▁public ▁Cell ▁< ▁Label ▁> ▁add ▁( ▁@ ▁Null ▁CharSequence ▁text ▁) ▁{ ▁if ▁( ▁skin ▁== ▁null ▁) ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁return ▁add ▁( ▁new ▁Label ▁( ▁text ▁, ▁skin ▁) ▁) ▁; ▁} ▁public ▁Cell ▁< ▁Label ▁> ▁add ▁( ▁@ ▁Null ▁CharSequence ▁text ▁, ▁String ▁label Style Name ▁) ▁{ ▁if ▁( ▁skin ▁== ▁null ▁) ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁return ▁add ▁( ▁new ▁Label ▁( ▁text ▁, ▁skin ▁. ▁get ▁( ▁label Style Name ▁, ▁Label Style ▁. ▁class ▁) ▁) ▁) ▁; ▁} ▁public ▁Cell ▁< ▁Label ▁> ▁add ▁( ▁@ ▁Null ▁CharSequence ▁text ▁, ▁String ▁font Name ▁, ▁@ ▁Null ▁Color ▁color ▁) ▁{ ▁if ▁( ▁skin ▁== ▁null ▁) ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁return ▁add ▁( ▁new ▁Label ▁( ▁text ▁, ▁new ▁Label Style ▁( ▁skin ▁. ▁getFont ▁( ▁font Name ▁) ▁, ▁color ▁) ▁) ▁) ▁; ▁} ▁public ▁Cell ▁< ▁Label ▁> ▁add ▁( ▁@ ▁Null ▁CharSequence ▁text ▁, ▁String ▁font Name ▁, ▁String ▁color Name ▁) ▁{ ▁if ▁( ▁skin ▁== ▁null ▁) ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁return ▁add ▁( ▁new ▁Label ▁( ▁text ▁, ▁new ▁Label Style ▁( ▁skin ▁. ▁getFont ▁( ▁font Name ▁) ▁, ▁skin ▁. ▁getColor ▁( ▁color Name ▁) ▁) ▁) ▁) ▁; ▁} ▁public ▁Cell ▁add ▁( ▁) ▁{ ▁return ▁add ▁( ▁( ▁Actor ▁) ▁null ▁) ▁; ▁} ▁public ▁Cell ▁< ▁Stack ▁> ▁stack ▁( ▁@ ▁Null ▁Actor ▁... ▁act ors ▁) ▁{ ▁Stack ▁stack ▁= ▁new ▁Stack ▁( ▁) ▁; ▁if ▁( ▁act ors ▁!= ▁null ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁, ▁n ▁= ▁act ors ▁. ▁length ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁stack ▁. ▁add Actor ▁( ▁act ors ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁add ▁( ▁stack ▁) ▁; ▁} ▁public ▁boolean ▁remove Actor ▁( ▁Actor ▁actor ▁) ▁{ ▁return ▁remove Actor ▁( ▁actor ▁, ▁true ▁) ▁; ▁} ▁public ▁boolean ▁remove Actor ▁( ▁Actor ▁actor ▁, ▁boolean ▁un fo c us ▁) ▁{ ▁if ▁( ▁! ▁super ▁. ▁remove Actor ▁( ▁actor ▁, ▁un fo c us ▁) ▁) ▁return ▁false ▁; ▁Cell ▁cell ▁= ▁getCell ▁( ▁actor ▁) ▁; ▁if ▁( ▁cell ▁!= ▁null ▁) ▁cell ▁. ▁actor ▁= ▁null ▁; ▁return ▁true ▁; ▁} ▁public ▁Actor ▁remove Actor At ▁( ▁int ▁index ▁, ▁boolean ▁un fo c us ▁) ▁{ ▁Actor ▁actor ▁= ▁super ▁. ▁remove Actor At ▁( ▁index ▁, ▁un fo c us ▁) ▁; ▁Cell ▁cell ▁= ▁getCell ▁( ▁actor ▁) ▁; ▁if ▁( ▁cell ▁!= ▁null ▁) ▁cell ▁. ▁actor ▁= ▁null ▁; ▁return ▁actor ▁; ▁} ▁public ▁void ▁clear Children ▁( ▁boolean ▁un fo c us ▁) ▁{ ▁Object ▁[ ▁] ▁cell s ▁= ▁this ▁. ▁cell s ▁. ▁items ▁; ▁for ▁( ▁int ▁i ▁= ▁this ▁. ▁cell s ▁. ▁size ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁Cell ▁cell ▁= ▁( ▁Cell ▁) ▁cell s ▁[ ▁i ▁] ▁;
▁@ ▁GwtCompatible ▁( ▁emulated ▁= ▁true ▁) ▁class ▁Testing Removal Listeners ▁{ ▁static ▁< ▁K ▁, ▁V ▁> ▁Null Removal Listener ▁< ▁K ▁, ▁V ▁> ▁null Removal Listener ▁( ▁) ▁{ ▁return ▁new ▁Null Removal Listener ▁< ▁> ▁( ▁) ▁; ▁} ▁@ ▁GwtIncompatible ▁static ▁< ▁K ▁, ▁V ▁> ▁ Que u ing Removal Listener ▁< ▁K ▁, ▁V ▁> ▁que u ing Removal Listener ▁( ▁) ▁{ ▁return ▁new ▁ Que u ing Removal Listener ▁< ▁> ▁( ▁) ▁; ▁} ▁static ▁< ▁K ▁, ▁V ▁> ▁Counting Removal Listener ▁< ▁K ▁, ▁V ▁> ▁count ing Removal Listener ▁( ▁) ▁{ ▁return ▁new ▁Counting Removal Listener ▁< ▁> ▁( ▁) ▁; ▁} ▁@ ▁GwtIncompatible ▁static ▁class ▁ Que u ing Removal Listener ▁< ▁K ▁, ▁V ▁> ▁extends ▁Concurrent LinkedQueue ▁< ▁Re mo val Notification ▁< ▁K ▁, ▁V ▁> ▁> ▁implements ▁Re mo val Listener ▁< ▁K ▁, ▁V ▁> ▁{ ▁@ ▁Override ▁public ▁void ▁on Removal ▁( ▁Re mo val Notification ▁< ▁K ▁, ▁V ▁> ▁notification ▁) ▁{ ▁add ▁( ▁notification ▁) ▁; ▁} ▁} ▁static ▁class ▁Counting Removal Listener ▁< ▁K ▁, ▁V ▁> ▁implements ▁Re mo val Listener ▁< ▁K ▁, ▁V ▁> ▁{ ▁private ▁final ▁AtomicInteger ▁count ▁= ▁new ▁AtomicInteger ▁( ▁) ▁; ▁private ▁volatile ▁Re mo val Notification ▁< ▁K ▁, ▁V ▁> ▁last Notification ▁; ▁@ ▁Override ▁public ▁void ▁on Removal ▁( ▁Re mo val Notification ▁< ▁K ▁, ▁V ▁> ▁notification ▁) ▁{ ▁count ▁. ▁incrementAndGet ▁( ▁) ▁; ▁last Notification ▁= ▁notification ▁; ▁} ▁public ▁int ▁getCount ▁( ▁) ▁{ ▁return ▁count ▁. ▁get ▁( ▁) ▁; ▁} ▁public ▁K ▁getLast Ev icted Key ▁( ▁) ▁{ ▁return ▁last Notification ▁. ▁getKey ▁( ▁) ▁; ▁} ▁public ▁V ▁getLast Ev icted Value ▁( ▁) ▁{ ▁return ▁last Notification ▁. ▁getValue ▁( ▁) ▁; ▁} ▁public ▁Re mo val Notification ▁< ▁K ▁, ▁V ▁> ▁getLast Notification ▁( ▁) ▁{ ▁return ▁last Notification ▁; ▁} ▁} ▁static ▁class ▁Null Removal Listener ▁< ▁K ▁, ▁V ▁> ▁implements ▁Re mo val Listener ▁< ▁K ▁, ▁V ▁> ▁{ ▁@ ▁Override ▁public ▁void ▁on Removal ▁( ▁Re mo val Notification ▁< ▁K ▁, ▁V ▁> ▁notification ▁) ▁{ ▁} ▁} ▁}
▁for ▁( ▁var ▁entry ▁: ▁code base s Props ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁addClass Code base ▁( ▁policy Code base s ▁, ▁entry ▁. ▁getKey ▁( ▁) ▁, ▁entry ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁p olicies ▁. ▁add ▁( ▁Policy Util ▁. ▁read Policy ▁( ▁policy File ▁, ▁policy Code base s ▁) ▁) ▁; ▁} ▁Map ▁< ▁String ▁, ▁Policy ▁> ▁map ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁URL ▁url ▁: ▁code base s ▁) ▁{ ▁map ▁. ▁put ▁( ▁url ▁. ▁getFile ▁( ▁) ▁, ▁new ▁Policy ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁boolean ▁imp li es ▁( ▁Pro tectionDomain ▁domain ▁, ▁Permission ▁permission ▁) ▁{ ▁for ▁( ▁Policy ▁p ▁: ▁p olicies ▁) ▁{ ▁if ▁( ▁p ▁. ▁imp li es ▁( ▁domain ▁, ▁permission ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁return ▁false ▁; ▁} ▁} ▁) ▁; ▁} ▁return ▁Collections ▁. ▁unmodifiableMap ▁( ▁map ▁) ▁; ▁} ▁static ▁Map ▁< ▁String ▁, ▁String ▁> ▁parse Properties File ▁( ▁Path ▁properties File ▁) ▁throws ▁Exception ▁{ ▁Properties ▁props ▁= ▁new ▁Properties ▁( ▁) ▁; ▁try ▁( ▁InputStream ▁is ▁= ▁Files ▁. ▁new InputStream ▁( ▁properties File ▁) ▁) ▁{ ▁props ▁. ▁load ▁( ▁is ▁) ▁; ▁} ▁return ▁props ▁. ▁entrySet ▁( ▁) ▁. ▁stream ▁( ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toMap ▁( ▁e ▁-> ▁e ▁. ▁getKey ▁( ▁) ▁. ▁toString ▁( ▁) ▁, ▁e ▁-> ▁e ▁. ▁getValue ▁( ▁) ▁. ▁toString ▁( ▁) ▁) ▁) ▁; ▁} ▁@ ▁Suppress Forbidden ▁( ▁reason ▁= ▁STR ▁) ▁static ▁Set ▁< ▁URL ▁> ▁parse ClassPath With Symlink s ▁( ▁) ▁throws ▁Exception ▁{ ▁Set ▁< ▁URL ▁> ▁raw ▁= ▁Jar Hel l ▁. ▁parse ClassPath ▁( ▁) ▁; ▁Set ▁< ▁URL ▁> ▁cook ed ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁raw ▁. ▁size ▁( ▁) ▁) ▁; ▁for ▁( ▁URL ▁url ▁: ▁raw ▁) ▁{ ▁Path ▁path ▁= ▁PathUtils ▁. ▁get ▁( ▁url ▁. ▁toURI ▁( ▁) ▁) ▁; ▁if ▁( ▁Files ▁. ▁exists ▁( ▁path ▁) ▁) ▁{ ▁boolean ▁added ▁= ▁cook ed ▁. ▁add ▁( ▁path ▁. ▁to Real Path ▁( ▁) ▁. ▁toUri ▁( ▁) ▁. ▁toURL ▁( ▁) ▁) ▁; ▁if ▁( ▁added ▁== ▁false ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁+ ▁url ▁) ▁; ▁} ▁} ▁} ▁return ▁raw ▁; ▁} ▁public ▁static ▁void ▁ensure Initialized ▁( ▁) ▁{ ▁} ▁}
▁public ▁class ▁Serializable Hadoop Config ▁implements ▁Serializable ▁{ ▁private ▁Map ▁< ▁String ▁, ▁String ▁> ▁content ▁; ▁private ▁transient ▁Configuration ▁configuration ▁; ▁public ▁Serializable Hadoop Config ▁( ▁@ ▁NonNull ▁Configuration ▁configuration ▁) ▁{ ▁this ▁. ▁configuration ▁= ▁configuration ▁; ▁content ▁= ▁new ▁LinkedHashMap ▁< ▁> ▁( ▁) ▁; ▁Iterator ▁< ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁String ▁> ▁> ▁iter ▁= ▁configuration ▁. ▁iterator ▁( ▁) ▁; ▁while ▁( ▁iter ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁String ▁> ▁next ▁= ▁iter ▁. ▁next ▁( ▁) ▁; ▁content ▁. ▁put ▁( ▁next ▁. ▁getKey ▁( ▁) ▁, ▁next ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁} ▁public ▁synchronized ▁Configuration ▁get Configuration ▁( ▁) ▁{ ▁if ▁( ▁configuration ▁== ▁null ▁) ▁{ ▁configuration ▁= ▁new ▁Configuration ▁( ▁) ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁String ▁> ▁e ▁: ▁content ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁configuration ▁. ▁set ▁( ▁e ▁. ▁getKey ▁( ▁) ▁, ▁e ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁} ▁return ▁configuration ▁; ▁} ▁}
▁class ▁Dat ad og Metrics Export Auto Configuration Tests ▁{ ▁private ▁final ▁Application ContextRunner ▁contextRunner ▁= ▁new ▁Application ContextRunner ▁( ▁) ▁. ▁with Configuration ▁( ▁Auto Configurations ▁. ▁of ▁( ▁Dat ad og Metrics Export Auto Configuration ▁. ▁class ▁) ▁) ▁; ▁@ ▁Test ▁void ▁back s Off Without AC lock ▁( ▁) ▁{ ▁this ▁. ▁contextRunner ▁. ▁run ▁( ▁( ▁context ▁) ▁-> ▁assertThat ▁( ▁context ▁) ▁. ▁doesNotHaveBean ▁( ▁Dat ad og MeterRegistry ▁. ▁class ▁) ▁) ▁; ▁} ▁@ ▁Test ▁void ▁fail sWith out An ApiKey ▁( ▁) ▁{ ▁this ▁. ▁contextRunner ▁. ▁withUser Configuration ▁( ▁Base Configuration ▁. ▁class ▁) ▁. ▁run ▁( ▁( ▁context ▁) ▁-> ▁assertThat ▁( ▁context ▁) ▁. ▁has Failed ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁void ▁auto Configure sConfig And MeterRegistry ▁( ▁) ▁{ ▁this ▁. ▁contextRunner ▁. ▁withUser Configuration ▁( ▁Base Configuration ▁. ▁class ▁) ▁. ▁with PropertyValues ▁( ▁STR ▁) ▁. ▁run ▁( ▁( ▁context ▁) ▁-> ▁assertThat ▁( ▁context ▁) ▁. ▁hasSingleBean ▁( ▁Dat ad og MeterRegistry ▁. ▁class ▁) ▁. ▁hasSingleBean ▁( ▁Dat ad og Config ▁. ▁class ▁) ▁) ▁; ▁} ▁@ ▁Test ▁void ▁auto Configuration CanBe Disabled With Defaults Enabled Property ▁( ▁) ▁{ ▁this ▁. ▁contextRunner ▁. ▁withUser Configuration ▁( ▁Base Configuration ▁. ▁class ▁) ▁. ▁with PropertyValues ▁( ▁STR ▁) ▁. ▁run ▁( ▁( ▁context ▁) ▁-> ▁assertThat ▁( ▁context ▁) ▁. ▁doesNotHaveBean ▁( ▁Dat ad og MeterRegistry ▁. ▁class ▁) ▁. ▁doesNotHaveBean ▁( ▁Dat ad og Config ▁. ▁class ▁) ▁) ▁; ▁} ▁@ ▁Test ▁void ▁auto Configuration CanBe Disabled With Specific Enabled Property ▁( ▁) ▁{ ▁this ▁. ▁contextRunner ▁. ▁withUser Configuration ▁( ▁Base Configuration ▁. ▁class ▁) ▁. ▁with PropertyValues ▁( ▁STR ▁) ▁. ▁run ▁( ▁( ▁context ▁) ▁-> ▁assertThat ▁( ▁context ▁) ▁. ▁doesNotHaveBean ▁( ▁Dat ad og MeterRegistry ▁. ▁class ▁) ▁. ▁doesNotHaveBean ▁( ▁Dat ad og Config ▁. ▁class ▁) ▁) ▁; ▁} ▁@ ▁Test ▁void ▁allows Custom Config ToBe Used ▁( ▁) ▁{ ▁this ▁. ▁contextRunner ▁. ▁withUser Configuration ▁( ▁Custom Config Configuration ▁. ▁class ▁) ▁. ▁run ▁( ▁( ▁context ▁) ▁-> ▁assertThat ▁( ▁context ▁) ▁. ▁hasSingleBean ▁( ▁Dat ad og MeterRegistry ▁. ▁class ▁) ▁. ▁hasSingleBean ▁( ▁Dat ad og Config ▁. ▁class ▁) ▁. ▁has Bean ▁( ▁STR ▁) ▁) ▁; ▁} ▁@ ▁Test ▁void ▁allows Custom Registry ToBe Used ▁( ▁) ▁{ ▁this ▁. ▁contextRunner ▁. ▁withUser Configuration ▁( ▁Custom Registry Configuration ▁. ▁class ▁) ▁. ▁with PropertyValues ▁( ▁STR ▁) ▁. ▁run ▁( ▁( ▁context ▁) ▁-> ▁assertThat ▁( ▁context ▁) ▁. ▁hasSingleBean ▁( ▁Dat ad og MeterRegistry ▁. ▁class ▁) ▁. ▁has Bean ▁( ▁STR ▁) ▁. ▁hasSingleBean ▁( ▁Dat ad og Config ▁. ▁class ▁) ▁) ▁; ▁} ▁@ ▁Test ▁void ▁st ops MeterRegistry When Context Is Closed ▁( ▁) ▁{ ▁this ▁. ▁contextRunner ▁. ▁withUser Configuration ▁( ▁Base Configuration ▁. ▁class ▁) ▁. ▁with PropertyValues ▁( ▁STR ▁) ▁. ▁run ▁( ▁( ▁context ▁) ▁-> ▁{ ▁Dat ad og MeterRegistry ▁registry ▁= ▁context ▁. ▁getBean ▁( ▁Dat ad og MeterRegistry ▁. ▁class ▁) ▁;
▁@ ▁Test ▁public ▁void ▁qu ick Memory Check Returns Null IfNot In Cache ▁( ▁) ▁{ ▁Bitmap ▁cached ▁= ▁pic ass o ▁. ▁qu ick MemoryCache Check ▁( ▁URI _ KEY _1 ▁) ▁; ▁assertThat ▁( ▁cached ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁event Recorder ▁. ▁cache Miss es ▁) ▁. ▁isGreaterThan ▁( ▁0 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁complete Invok es Success On All Successful Requests ▁( ▁) ▁{ ▁Action ▁action 1 ▁= ▁mock Action ▁( ▁URI _ KEY _1 ▁, ▁URI _1 ▁, ▁mock ImageView Target ▁( ▁) ▁) ▁; ▁Action ▁action 2 ▁= ▁mock Canceled Action ▁( ▁) ▁; ▁Bitmap H unter ▁h unter ▁= ▁mock H unter ▁( ▁URI _ KEY _1 ▁, ▁new ▁Request Handler ▁. ▁Result ▁( ▁bitmap ▁, ▁MEMORY ▁) ▁) ▁; ▁when ▁( ▁h unter ▁. ▁get Actions ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁Arrays ▁. ▁asList ▁( ▁action 1 ▁, ▁action 2 ▁) ▁) ▁; ▁pic ass o ▁. ▁complete ▁( ▁h unter ▁) ▁; ▁verify Action Complete ▁( ▁action 1 ▁) ▁; ▁verify ▁( ▁action 2 ▁, ▁never ▁( ▁) ▁) ▁. ▁complete ▁( ▁any ▁( ▁Request Handler ▁. ▁Result ▁. ▁class ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁complete Invok es Error On All Failed Requests ▁( ▁) ▁{ ▁Action ▁action 1 ▁= ▁mock Action ▁( ▁URI _ KEY _1 ▁, ▁URI _1 ▁, ▁mock ImageView Target ▁( ▁) ▁) ▁; ▁Action ▁action 2 ▁= ▁mock Canceled Action ▁( ▁) ▁; ▁Exception ▁exception ▁= ▁mock ▁( ▁Exception ▁. ▁class ▁) ▁; ▁Bitmap H unter ▁h unter ▁= ▁mock H unter ▁( ▁URI _ KEY _1 ▁, ▁null ▁) ▁; ▁when ▁( ▁h unter ▁. ▁getException ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁exception ▁) ▁; ▁when ▁( ▁h unter ▁. ▁get Actions ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁Arrays ▁. ▁asList ▁( ▁action 1 ▁, ▁action 2 ▁) ▁) ▁; ▁pic ass o ▁. ▁complete ▁( ▁h unter ▁) ▁; ▁verify ▁( ▁action 1 ▁) ▁. ▁error ▁( ▁exception ▁) ▁; ▁verify ▁( ▁action 2 ▁, ▁never ▁( ▁) ▁) ▁. ▁error ▁( ▁exception ▁) ▁; ▁verify ▁( ▁listener ▁) ▁. ▁on Image Load Failed ▁( ▁pic ass o ▁, ▁URI _1 ▁, ▁exception ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁complete Del iver sTo Single ▁( ▁) ▁{ ▁Action ▁action ▁= ▁mock Action ▁( ▁URI _ KEY _1 ▁, ▁URI _1 ▁, ▁mock ImageView Target ▁( ▁) ▁) ▁; ▁Bitmap H unter ▁h unter ▁= ▁mock H unter ▁( ▁URI _ KEY _1 ▁, ▁new ▁Request Handler ▁. ▁Result ▁( ▁bitmap ▁, ▁MEMORY ▁) ▁) ▁; ▁when ▁( ▁h unter ▁. ▁getAction ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁action ▁) ▁; ▁when ▁( ▁h unter ▁. ▁get Actions ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁Collections ▁. ▁< ▁Action ▁> ▁emptyList ▁( ▁) ▁) ▁; ▁pic ass o ▁. ▁complete ▁( ▁h unter ▁) ▁; ▁verify Action Complete ▁( ▁action ▁) ▁; ▁}
▁public ▁class ▁Test D ont Inline This ▁extends ▁IntegrationTest ▁{ ▁public ▁static ▁class ▁TestCls ▁{ ▁public ▁int ▁field ▁= ▁new ▁Random ▁( ▁) ▁. ▁nextInt ▁( ▁) ▁; ▁public ▁TestCls ▁test ▁( ▁) ▁{ ▁TestCls ▁res ▁; ▁if ▁( ▁field ▁== ▁7 ▁) ▁{ ▁res ▁= ▁this ▁; ▁} ▁else ▁{ ▁res ▁= ▁new ▁TestCls ▁( ▁) ▁; ▁} ▁res ▁. ▁method ▁( ▁) ▁; ▁return ▁res ▁; ▁} ▁private ▁void ▁method ▁( ▁) ▁{ ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test ▁( ▁) ▁{ ▁ClassNode ▁cls ▁= ▁getClassNode ▁( ▁TestCls ▁. ▁class ▁) ▁; ▁String ▁code ▁= ▁cls ▁. ▁getCode ▁( ▁) ▁. ▁toString ▁( ▁) ▁; ▁assertThat ▁( ▁code ▁, ▁containsOne ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁code ▁, ▁containsOne ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁code ▁, ▁containsOne ▁( ▁STR ▁) ▁) ▁; ▁} ▁}
▁@ ▁Override ▁public ▁int ▁compareTo ▁( ▁Member Info ▁other Member Info ▁) ▁{ ▁if ▁( ▁this ▁. ▁group InstanceId ▁. ▁isPresent ▁( ▁) ▁&& ▁other Member Info ▁. ▁group InstanceId ▁. ▁isPresent ▁( ▁) ▁) ▁{ ▁return ▁this ▁. ▁group InstanceId ▁. ▁get ▁( ▁) ▁. ▁compareTo ▁( ▁other Member Info ▁. ▁group InstanceId ▁. ▁get ▁( ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁this ▁. ▁group InstanceId ▁. ▁isPresent ▁( ▁) ▁) ▁{ ▁return ▁- ▁1 ▁; ▁} ▁else ▁if ▁( ▁other Member Info ▁. ▁group InstanceId ▁. ▁isPresent ▁( ▁) ▁) ▁{ ▁return ▁1 ▁; ▁} ▁else ▁{ ▁return ▁this ▁. ▁member Id ▁. ▁compareTo ▁( ▁other Member Info ▁. ▁member Id ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁o ▁) ▁{ ▁return ▁o ▁instanceof ▁Member Info ▁&& ▁this ▁. ▁member Id ▁. ▁equals ▁( ▁( ▁( ▁Member Info ▁) ▁o ▁) ▁. ▁member Id ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁member Id ▁. ▁hashCode ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁member Id ▁+ ▁STR ▁+ ▁group InstanceId ▁. ▁orElse ▁( ▁STR ▁) ▁+ ▁STR ▁; ▁} ▁} ▁}
▁public ▁class ▁Array Map Bytecode Expression ▁extends ▁Bytecode Expression ▁{ ▁private ▁static ▁final ▁AtomicLong ▁N EXT _ VARIABLE _ ID ▁= ▁new ▁AtomicLong ▁( ▁) ▁; ▁private ▁final ▁BytecodeBlock ▁body ▁; ▁private ▁final ▁String ▁one Line Description ▁; ▁public ▁Array Map Bytecode Expression ▁( ▁Scope ▁scope ▁, ▁Call Site Binder ▁binder ▁, ▁Bytecode Expression ▁array ▁, ▁Type ▁from Type ▁, ▁Type ▁to Type ▁, ▁Function ▁< ▁Bytecode Expression ▁, ▁Bytecode Expression ▁> ▁mapper ▁) ▁{ ▁super ▁( ▁type ▁( ▁Block ▁. ▁class ▁) ▁) ▁; ▁body ▁= ▁new ▁BytecodeBlock ▁( ▁) ▁; ▁Variable ▁blockBuilder ▁= ▁scope ▁. ▁declare Variable ▁( ▁BlockBuilder ▁. ▁class ▁, ▁STR ▁+ ▁N EXT _ VARIABLE _ ID ▁. ▁getAndIncrement ▁( ▁) ▁) ▁; ▁body ▁. ▁append ▁( ▁blockBuilder ▁. ▁set ▁( ▁constant Type ▁( ▁binder ▁, ▁to Type ▁) ▁. ▁invoke ▁( ▁STR ▁, ▁BlockBuilder ▁. ▁class ▁, ▁constant Null ▁( ▁BlockBuilder Status ▁. ▁class ▁) ▁, ▁array ▁. ▁invoke ▁( ▁STR ▁, ▁int ▁. ▁class ▁) ▁) ▁) ▁) ▁; ▁Variable ▁position ▁= ▁scope ▁. ▁declare Variable ▁( ▁int ▁. ▁class ▁, ▁STR ▁+ ▁N EXT _ VARIABLE _ ID ▁. ▁getAndIncrement ▁( ▁) ▁) ▁; ▁BytecodeBlock ▁map Element ▁; ▁String ▁mapper Description ▁; ▁if ▁( ▁from Type ▁instanceof ▁Unknown Type ▁) ▁{ ▁map Element ▁= ▁new ▁BytecodeBlock ▁( ▁) ▁. ▁comment ▁( ▁STR ▁) ▁; ▁mapper Description ▁= ▁STR ▁; ▁} ▁else ▁{ ▁Variable ▁element ▁= ▁scope ▁. ▁declare Variable ▁( ▁from Type ▁. ▁getJava Type ▁( ▁) ▁, ▁STR ▁+ ▁N EXT _ VARIABLE _ ID ▁. ▁getAndIncrement ▁( ▁) ▁) ▁; ▁Variable ▁new Element ▁= ▁scope ▁. ▁declare Variable ▁( ▁to Type ▁. ▁getJava Type ▁( ▁) ▁, ▁STR ▁+ ▁N EXT _ VARIABLE _ ID ▁. ▁getAndIncrement ▁( ▁) ▁) ▁; ▁SqlType Bytecode Expression ▁elementType Constant ▁= ▁constant Type ▁( ▁binder ▁, ▁from Type ▁) ▁; ▁SqlType Bytecode Expression ▁new ElementType Constant ▁= ▁constant Type ▁( ▁binder ▁, ▁to Type ▁) ▁; ▁map Element ▁= ▁new ▁BytecodeBlock ▁( ▁) ▁. ▁append ▁( ▁element ▁. ▁set ▁( ▁elementType Constant ▁. ▁getValue ▁( ▁array ▁, ▁position ▁) ▁) ▁) ▁. ▁append ▁( ▁new Element ▁. ▁set ▁( ▁mapper ▁. ▁apply ▁( ▁element ▁) ▁) ▁) ▁. ▁append ▁( ▁new ElementType Constant ▁. ▁writeValue ▁( ▁blockBuilder ▁, ▁new Element ▁) ▁) ▁; ▁mapper Description ▁= ▁mapper ▁. ▁apply ▁( ▁element ▁) ▁. ▁toString ▁( ▁) ▁; ▁} ▁body ▁. ▁append ▁( ▁new ▁For Loop ▁( ▁) ▁. ▁initialize ▁( ▁position ▁. ▁set ▁( ▁constant Int ▁( ▁0 ▁) ▁) ▁) ▁. ▁condition ▁( ▁lessThan ▁( ▁position ▁, ▁array ▁. ▁invoke ▁( ▁STR ▁, ▁int ▁. ▁class ▁) ▁) ▁) ▁. ▁update ▁( ▁increment Variable ▁( ▁position ▁, ▁( ▁byte ▁) ▁1 ▁) ▁) ▁. ▁body ▁( ▁new ▁If Statement ▁( ▁) ▁. ▁condition ▁( ▁array ▁. ▁invoke ▁( ▁STR ▁, ▁boolean ▁. ▁class ▁, ▁position ▁) ▁) ▁. ▁if True ▁( ▁blockBuilder ▁. ▁invoke ▁( ▁STR ▁, ▁BlockBuilder ▁. ▁class ▁) ▁. ▁pop ▁( ▁) ▁) ▁. ▁if False ▁( ▁map Element ▁) ▁) ▁) ▁;
▁Java Info ▁java InfoProvider ▁= ▁fetch Java Info ▁( ▁) ▁; ▁NestedSet ▁< ▁Library To Link ▁> ▁lib raries For Top Target ▁= ▁java InfoProvider ▁. ▁get Transitive Native Libraries ▁( ▁) ▁; ▁assertThat ▁( ▁lib raries For Top Target ▁. ▁toList ▁( ▁) ▁. ▁stream ▁( ▁) ▁. ▁map ▁( ▁Library To Link ▁:: ▁getL ibrary Identifier ▁) ▁) ▁. ▁contains ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁build Helper Create Java Info With Deps And Ne ver Link ▁( ▁) ▁throws ▁Exception ▁{ ▁rule Builder ▁( ▁) ▁. ▁with Ne ver Link ▁( ▁) ▁. ▁build ▁( ▁) ▁; ▁scratch ▁. ▁file ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁assertNo Events ▁( ▁) ▁; ▁Java Compilation Args Provider ▁java Compilation Args Provider ▁= ▁fetch Java Info ▁( ▁) ▁. ▁getProvider ▁( ▁Java Compilation Args Provider ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁pretty Artifact Names ▁( ▁java Compilation Args Provider ▁. ▁get Direct Compile Time Jars ▁( ▁) ▁) ▁) ▁. ▁containsExactly ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁pretty Artifact Names ▁( ▁java Compilation Args Provider ▁. ▁get Direct Full Compile Time Jars ▁( ▁) ▁) ▁) ▁. ▁containsExactly ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁pretty Artifact Names ▁( ▁java Compilation Args Provider ▁. ▁getRuntime Jars ▁( ▁) ▁) ▁) ▁. ▁isEmpty ▁( ▁) ▁; ▁assertThat ▁( ▁pretty Artifact Names ▁( ▁java Compilation Args Provider ▁. ▁get Transitive Compile Time Jars ▁( ▁) ▁) ▁) ▁. ▁containsExactly ▁( ▁STR ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁build Helper Create Java Info Source Jars Provider With Source Jars ▁( ▁) ▁throws ▁Exception ▁{ ▁rule Builder ▁( ▁) ▁. ▁build ▁( ▁) ▁; ▁scratch ▁. ▁file ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁assertNo Events ▁( ▁) ▁; ▁Java Source Jars Provider ▁source Jars Provider ▁= ▁fetch Java Info ▁( ▁) ▁. ▁getProvider ▁( ▁Java Source Jars Provider ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁pretty Artifact Names ▁( ▁source Jars Provider ▁. ▁getSource Jars ▁( ▁) ▁) ▁) ▁. ▁containsExactly ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁pretty Artifact Names ▁( ▁source Jars Provider ▁. ▁get Transitive Source Jars ▁( ▁) ▁) ▁) ▁. ▁containsExactly ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁build Helper Pack Sources _ re pack Single Jar ▁( ▁) ▁throws ▁Exception ▁{ ▁rule Builder ▁( ▁) ▁. ▁with Source Files ▁( ▁) ▁. ▁build ▁( ▁) ▁; ▁scratch ▁. ▁file ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁assertNo Events ▁( ▁) ▁; ▁Java Source Jars Provider ▁source Jars Provider ▁= ▁fetch Java Info ▁( ▁) ▁. ▁getProvider ▁( ▁Java Source Jars Provider ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁pretty Artifact Names ▁( ▁source Jars Provider ▁. ▁getSource Jars ▁( ▁) ▁) ▁) ▁. ▁containsExactly ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁pretty Artifact Names ▁( ▁source Jars Provider ▁. ▁get Transitive Source Jars ▁( ▁) ▁) ▁) ▁. ▁containsExactly ▁( ▁STR ▁) ▁; ▁}
▁Schema ▁new Schema ▁= ▁reflect Data ▁. ▁getSchema ▁( ▁type ▁) ▁; ▁return ▁new ▁Avro Factory ▁< ▁> ▁( ▁reflect Data ▁, ▁new Schema ▁, ▁new ▁Reflect Dat um Reader ▁< ▁> ▁( ▁previous Schema ▁. ▁orElse ▁( ▁new Schema ▁) ▁, ▁new Schema ▁, ▁reflect Data ▁) ▁, ▁new ▁Reflect Dat um Writer ▁< ▁> ▁( ▁new Schema ▁, ▁reflect Data ▁) ▁) ▁; ▁} ▁public ▁static ▁< ▁T ▁> ▁Schema ▁extract Avro Specific Schema ▁( ▁Class ▁< ▁T ▁> ▁type ▁, ▁Specific Data ▁specific Data ▁) ▁{ ▁Optional ▁< ▁Schema ▁> ▁new Schema Optional ▁= ▁try Extract Avro Schema Via Instance ▁( ▁type ▁) ▁; ▁return ▁new Schema Optional ▁. ▁orElseGet ▁( ▁( ▁) ▁-> ▁specific Data ▁. ▁getSchema ▁( ▁type ▁) ▁) ▁; ▁} ▁public ▁static ▁< ▁T ▁extends ▁Specific Data ▁> ▁Specific Data ▁getSpec ific Data For Class ▁( ▁Class ▁< ▁T ▁> ▁type ▁, ▁ClassLoader ▁cl ▁) ▁{ ▁try ▁{ ▁Field ▁specific Data Field ▁= ▁type ▁. ▁getDeclared Field ▁( ▁STR ▁) ▁; ▁specific Data Field ▁. ▁setAccessible ▁( ▁true ▁) ▁; ▁return ▁( ▁Specific Data ▁) ▁specific Data Field ▁. ▁get ▁( ▁( ▁Object ▁) ▁null ▁) ▁; ▁} ▁catch ▁( ▁Illegal AccessException ▁e ▁) ▁{ ▁throw ▁new ▁Flink RuntimeException ▁( ▁STR ▁, ▁e ▁) ▁; ▁} ▁catch ▁( ▁NoSuch FieldException ▁e ▁) ▁{ ▁return ▁new ▁Specific Data ▁( ▁cl ▁) ▁; ▁} ▁} ▁private ▁static ▁Optional ▁< ▁Schema ▁> ▁try Extract Avro Schema Via Instance ▁( ▁Class ▁< ▁? ▁> ▁type ▁) ▁{ ▁try ▁{ ▁Specific Record ▁instance ▁= ▁( ▁Specific Record ▁) ▁type ▁. ▁newInstance ▁( ▁) ▁; ▁return ▁Optional ▁. ▁ofNullable ▁( ▁instance ▁. ▁getSchema ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁Instant iationException ▁| ▁Illegal AccessException ▁e ▁) ▁{ ▁LOG ▁. ▁warn ▁( ▁STR ▁, ▁type ▁, ▁e ▁) ▁; ▁return ▁Optional ▁. ▁empty ▁( ▁) ▁; ▁} ▁} ▁private ▁Avro Factory ▁( ▁Generic Data ▁a vro Data ▁, ▁Schema ▁schema ▁, ▁Dat um Reader ▁< ▁T ▁> ▁reader ▁, ▁Dat um Writer ▁< ▁T ▁> ▁writer ▁) ▁{ ▁this ▁. ▁a vro Data ▁= ▁checkNotNull ▁( ▁a vro Data ▁) ▁; ▁this ▁. ▁schema ▁= ▁checkNotNull ▁( ▁schema ▁) ▁; ▁this ▁. ▁writer ▁= ▁checkNotNull ▁( ▁writer ▁) ▁; ▁this ▁. ▁reader ▁= ▁checkNotNull ▁( ▁reader ▁) ▁; ▁} ▁DataOutput Encoder ▁getEncoder ▁( ▁) ▁{ ▁return ▁encoder ▁; ▁} ▁DataInput Decoder ▁getDecoder ▁( ▁) ▁{ ▁return ▁decoder ▁; ▁} ▁Schema ▁getSchema ▁( ▁) ▁{ ▁return ▁schema ▁; ▁} ▁Dat um Writer ▁< ▁T ▁> ▁getWriter ▁( ▁) ▁{ ▁return ▁writer ▁; ▁} ▁Dat um Reader ▁< ▁T ▁> ▁getReader ▁( ▁) ▁{ ▁return ▁reader ▁; ▁} ▁Generic Data ▁getA vro Data ▁( ▁) ▁{ ▁return ▁a vro Data ▁; ▁} ▁}
▁public ▁class ▁RocksDB Key edStateBackend Builder ▁< ▁K ▁> ▁extends ▁Abstract Key edStateBackend Builder ▁< ▁K ▁> ▁{ ▁static ▁final ▁String ▁DB _ INSTANCE _ DIR _ STRING ▁= ▁STR ▁; ▁private ▁final ▁String ▁operator Identifier ▁; ▁private ▁final ▁Embedded R ocksDB StateBackend ▁. ▁PriorityQueue State Type ▁priority Queue State Type ▁; ▁private ▁final ▁Local Recovery Config ▁local Recovery Config ▁; ▁private ▁final ▁Function ▁< ▁String ▁, ▁ColumnFamily Options ▁> ▁columnFamily Options Factory ▁; ▁private ▁final ▁RocksDB Resource Container ▁options Container ▁; ▁private ▁final ▁File ▁instance BasePath ▁; ▁private ▁final ▁File ▁instance R ocksDB Path ▁; ▁private ▁final ▁MetricGroup ▁metric Group ▁; ▁private ▁boolean ▁enable Increment al Checkpointing ▁; ▁private ▁RocksDB Native Metric Options ▁native Metric Options ▁; ▁private ▁int ▁numberOf Transfer ing Threads ▁; ▁private ▁long ▁write BatchSize ▁= ▁RocksDB Configur able Options ▁. ▁WRITE _ B ATCH _ SI Z E ▁. ▁defaultValue ▁( ▁) ▁. ▁getBytes ▁( ▁) ▁; ▁private ▁RocksDB ▁inject ed Test DB ▁; ▁private ▁ColumnFamily Handle ▁inject ed Default ColumnFamily Handle ▁; ▁private ▁RocksDB State Uploader ▁inject R ocksDB State Uploader ▁; ▁public ▁RocksDB Key edStateBackend Builder ▁( ▁String ▁operator Identifier ▁, ▁ClassLoader ▁user CodeClassLoader ▁, ▁File ▁instance BasePath ▁, ▁RocksDB Resource Container ▁options Container ▁, ▁Function ▁< ▁String ▁, ▁ColumnFamily Options ▁> ▁columnFamily Options Factory ▁, ▁Task KvState Registry ▁kvState Registry ▁, ▁TypeSerializer ▁< ▁K ▁> ▁keySerializer ▁, ▁int ▁numberOf Key Groups ▁, ▁KeyGroupRange ▁keyGroupRange ▁, ▁ExecutionConfig ▁executionConfig ▁, ▁Local Recovery Config ▁local Recovery Config ▁, ▁Embedded R ocksDB StateBackend ▁. ▁PriorityQueue State Type ▁priority Queue State Type ▁, ▁Ttl TimeProvider ▁ttl TimeProvider ▁, ▁Latency TrackingState Config ▁latency TrackingState Config ▁, ▁MetricGroup ▁metric Group ▁, ▁@ ▁Nonnull ▁Collection ▁< ▁KeyedState Handle ▁> ▁state Handles ▁, ▁Stream Compression Decorator ▁key Group Compression Decorator ▁, ▁Closeable Registry ▁cancel Stream Registry ▁) ▁{ ▁super ▁( ▁kvState Registry ▁, ▁keySerializer ▁, ▁user CodeClassLoader ▁, ▁numberOf Key Groups ▁, ▁keyGroupRange ▁, ▁executionConfig ▁, ▁ttl TimeProvider ▁, ▁latency TrackingState Config ▁, ▁state Handles ▁, ▁key Group Compression Decorator ▁, ▁cancel Stream Registry ▁) ▁; ▁this ▁. ▁operator Identifier ▁= ▁operator Identifier ▁; ▁this ▁. ▁priority Queue State Type ▁= ▁priority Queue State Type ▁; ▁this ▁. ▁local Recovery Config ▁= ▁local Recovery Config ▁; ▁this ▁. ▁columnFamily Options Factory ▁= ▁Preconditions ▁. ▁checkNotNull ▁( ▁columnFamily Options Factory ▁) ▁; ▁this ▁. ▁options Container ▁= ▁options Container ▁; ▁this ▁. ▁instance BasePath ▁= ▁instance BasePath ▁; ▁this ▁. ▁instance R ocksDB Path ▁= ▁new ▁File ▁( ▁instance BasePath ▁, ▁DB _ INSTANCE _ DIR _ STRING ▁) ▁; ▁this ▁. ▁metric Group ▁= ▁metric Group ▁; ▁this ▁. ▁enable Increment al Checkpointing ▁= ▁false ▁; ▁this ▁. ▁native Metric Options ▁= ▁new ▁RocksDB Native Metric Options ▁( ▁) ▁; ▁this ▁. ▁numberOf Transfer ing Threads ▁= ▁RocksDB Options ▁. ▁CHECK POINT _ TRANS FER _ THREAD _ NUM ▁. ▁defaultValue ▁( ▁) ▁; ▁}
▁public ▁class ▁Serial ThreadLocal M arshalling Decoder Test ▁extends ▁Serial M arshalling Decoder Test ▁{ ▁@ ▁Override ▁protected ▁Unm arshaller Provider ▁create Provider ▁( ▁M arshaller Factory ▁factory ▁, ▁M arshalling Configuration ▁config ▁) ▁{ ▁return ▁new ▁ThreadLocal Unm arshaller Provider ▁( ▁factory ▁, ▁config ▁) ▁; ▁} ▁}
▁if ▁( ▁in ode ▁!= ▁null ▁) ▁{ ▁if ▁( ▁in ode ▁. ▁isDirectory ▁( ▁) ▁) ▁{ ▁throw ▁new ▁File Already ExistsException ▁( ▁i ip ▁. ▁getPath ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁INode File ▁. ▁valueOf ▁( ▁in ode ▁, ▁src ▁) ▁; ▁if ▁( ▁dir ▁. ▁is Permission Enabled ▁( ▁) ▁&& ▁flag ▁. ▁contains ▁( ▁Create Flag ▁. ▁OVER WRITE ▁) ▁) ▁{ ▁dir ▁. ▁check Path Access ▁( ▁pc ▁, ▁i ip ▁, ▁Fs Action ▁. ▁WRITE ▁) ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁! ▁create Parent ▁) ▁{ ▁dir ▁. ▁verify Parent Dir ▁( ▁i ip ▁) ▁; ▁} ▁if ▁( ▁! ▁flag ▁. ▁contains ▁( ▁Create Flag ▁. ▁CREATE ▁) ▁) ▁{ ▁throw ▁new ▁FileNot FoundException ▁( ▁STR ▁+ ▁src ▁) ▁; ▁} ▁} ▁return ▁i ip ▁; ▁} ▁static ▁Hdfs FileStatus ▁start File ▁( ▁FS Names ystem ▁fs n ▁, ▁I Nodes In Path ▁i ip ▁, ▁Permission Status ▁permissions ▁, ▁String ▁holder ▁, ▁String ▁client Machine ▁, ▁EnumSet ▁< ▁Create Flag ▁> ▁flag ▁, ▁boolean ▁create Parent ▁, ▁short ▁replication ▁, ▁long ▁blockSize ▁, ▁File Encryption Info ▁f e Info ▁, ▁INode ▁. ▁Block s Map Update Info ▁to Remove Blocks ▁, ▁boolean ▁should Repl icate ▁, ▁String ▁ec Policy Name ▁, ▁String ▁storage Policy ▁, ▁boolean ▁log Retry Entry ▁) ▁throws ▁IOException ▁{ ▁assert ▁fs n ▁. ▁has WriteLock ▁( ▁) ▁; ▁boolean ▁overwrite ▁= ▁flag ▁. ▁contains ▁( ▁Create Flag ▁. ▁OVER WRITE ▁) ▁; ▁boolean ▁is Lazy Persist ▁= ▁flag ▁. ▁contains ▁( ▁Create Flag ▁. ▁L A Z Y _ PER SIST ▁) ▁; ▁final ▁String ▁src ▁= ▁i ip ▁. ▁getPath ▁( ▁) ▁; ▁FS Directory ▁fs d ▁= ▁fs n ▁. ▁getFS Directory ▁( ▁) ▁; ▁if ▁( ▁i ip ▁. ▁getLast I Node ▁( ▁) ▁!= ▁null ▁) ▁{ ▁if ▁( ▁overwrite ▁) ▁{ ▁List ▁< ▁INode ▁> ▁to Remove I Nodes ▁= ▁new ▁Chunked ArrayList ▁< ▁> ▁( ▁) ▁; ▁List ▁< ▁Long ▁> ▁to Remove U C Files ▁= ▁new ▁Chunked ArrayList ▁< ▁> ▁( ▁) ▁; ▁long ▁ret ▁= ▁FS Dir Delete Op ▁. ▁delete ▁( ▁fs d ▁, ▁i ip ▁, ▁to Remove Blocks ▁, ▁to Remove I Nodes ▁, ▁to Remove U C Files ▁, ▁now ▁( ▁) ▁) ▁; ▁if ▁( ▁ret ▁>= ▁0 ▁) ▁{ ▁i ip ▁= ▁I Nodes In Path ▁. ▁replace ▁( ▁i ip ▁, ▁i ip ▁. ▁length ▁( ▁) ▁- ▁1 ▁, ▁null ▁) ▁; ▁FS Dir Delete Op ▁. ▁incr Deleted File Count ▁( ▁ret ▁) ▁; ▁fs n ▁. ▁remove Le ases And I Nodes ▁( ▁to Remove U C Files ▁, ▁to Remove I Nodes ▁, ▁true ▁) ▁; ▁} ▁} ▁else ▁{ ▁fs n ▁. ▁recover Lease Internal ▁( ▁FS Names ystem ▁. ▁Re cover Lease Op ▁. ▁CREATE _ FILE ▁, ▁i ip ▁, ▁src ▁, ▁holder ▁, ▁client Machine ▁, ▁false ▁) ▁; ▁throw ▁new ▁File Already ExistsException ▁( ▁src ▁+ ▁STR ▁+ ▁client Machine ▁+ ▁STR ▁) ▁; ▁} ▁}
▁public ▁abstract ▁class ▁A ether G rap e Engine Factory ▁{ ▁public ▁static ▁A ether G rap e Engine ▁create ▁( ▁Groovy ClassLoader ▁classLoader ▁, ▁List ▁< ▁Repository Configuration ▁> ▁repository Configurations ▁, ▁Dependency Resolution Context ▁dependency Resolution Context ▁, ▁boolean ▁qu iet ▁) ▁{ ▁Repository System ▁repository System ▁= ▁create Service Locator ▁( ▁) ▁. ▁getService ▁( ▁Repository System ▁. ▁class ▁) ▁; ▁Default Repository System Session ▁repository System Session ▁= ▁Maven Repository System Utils ▁. ▁new Session ▁( ▁) ▁; ▁ServiceLoader ▁< ▁Repository System Session Auto Configuration ▁> ▁auto Configurations ▁= ▁ServiceLoader ▁. ▁load ▁( ▁Repository System Session Auto Configuration ▁. ▁class ▁) ▁; ▁for ▁( ▁Repository System Session Auto Configuration ▁auto Configuration ▁: ▁auto Configurations ▁) ▁{ ▁auto Configuration ▁. ▁apply ▁( ▁repository System Session ▁, ▁repository System ▁) ▁; ▁} ▁new ▁Default Repository System Session Auto Configuration ▁( ▁) ▁. ▁apply ▁( ▁repository System Session ▁, ▁repository System ▁) ▁; ▁return ▁new ▁A ether G rap e Engine ▁( ▁classLoader ▁, ▁repository System ▁, ▁repository System Session ▁, ▁create Repositories ▁( ▁repository Configurations ▁) ▁, ▁dependency Resolution Context ▁, ▁qu iet ▁) ▁; ▁} ▁private ▁static ▁Service Locator ▁create Service Locator ▁( ▁) ▁{ ▁Default Service Locator ▁locator ▁= ▁Maven Repository System Utils ▁. ▁new Service Locator ▁( ▁) ▁; ▁locator ▁. ▁add Service ▁( ▁Repository System ▁. ▁class ▁, ▁Default Repository System ▁. ▁class ▁) ▁; ▁locator ▁. ▁add Service ▁( ▁Repository Connector Factory ▁. ▁class ▁, ▁Basic Repository Connector Factory ▁. ▁class ▁) ▁; ▁locator ▁. ▁add Service ▁( ▁Trans porter Factory ▁. ▁class ▁, ▁Http Trans porter Factory ▁. ▁class ▁) ▁; ▁locator ▁. ▁add Service ▁( ▁Trans porter Factory ▁. ▁class ▁, ▁File Trans porter Factory ▁. ▁class ▁) ▁; ▁return ▁locator ▁; ▁} ▁private ▁static ▁List ▁< ▁Remote Repository ▁> ▁create Repositories ▁( ▁List ▁< ▁Repository Configuration ▁> ▁repository Configurations ▁) ▁{ ▁List ▁< ▁Remote Repository ▁> ▁repositories ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁repository Configurations ▁. ▁size ▁( ▁) ▁) ▁; ▁for ▁( ▁Repository Configuration ▁repository Configuration ▁: ▁repository Configurations ▁) ▁{ ▁Remote Repository ▁. ▁Builder ▁builder ▁= ▁new ▁Remote Repository ▁. ▁Builder ▁( ▁repository Configuration ▁. ▁getName ▁( ▁) ▁, ▁STR ▁, ▁repository Configuration ▁. ▁getUri ▁( ▁) ▁. ▁to ASCII String ▁( ▁) ▁) ▁; ▁if ▁( ▁! ▁repository Configuration ▁. ▁getSnapshot s Enabled ▁( ▁) ▁) ▁{ ▁builder ▁. ▁set Snapshot Policy ▁( ▁new ▁Repository Policy ▁( ▁false ▁, ▁Repository Policy ▁. ▁UPDATE _ POLICY _ NE VER ▁, ▁Repository Policy ▁. ▁CHECK SUM _ POLICY _ IG NORE ▁) ▁) ▁; ▁} ▁repositories ▁. ▁add ▁( ▁builder ▁. ▁build ▁( ▁) ▁) ▁; ▁} ▁return ▁repositories ▁; ▁} ▁}
▁private ▁static ▁XContentBuilder ▁create Mappings ▁( ▁Rollup JobConfig ▁config ▁) ▁throws ▁IOException ▁{ ▁return ▁XContentBuilder ▁. ▁builder ▁( ▁XContentType ▁. ▁JSON ▁. ▁xContent ▁( ▁) ▁) ▁. ▁startObject ▁( ▁) ▁. ▁startObject ▁( ▁STR ▁) ▁. ▁startObject ▁( ▁STR ▁) ▁. ▁startObject ▁( ▁STR ▁) ▁. ▁field ▁( ▁Rollup ▁. ▁R OL LU P _ TEMPLATE _ VERSION _ FIELD ▁, ▁Version ▁. ▁CURRENT ▁. ▁toString ▁( ▁) ▁) ▁. ▁startObject ▁( ▁STR ▁) ▁. ▁field ▁( ▁config ▁. ▁getId ▁( ▁) ▁, ▁config ▁) ▁. ▁endObject ▁( ▁) ▁. ▁endObject ▁( ▁) ▁. ▁startArray ▁( ▁STR ▁) ▁. ▁startObject ▁( ▁) ▁. ▁startObject ▁( ▁STR ▁) ▁. ▁field ▁( ▁STR ▁, ▁STR ▁) ▁. ▁startObject ▁( ▁STR ▁) ▁. ▁field ▁( ▁STR ▁, ▁STR ▁) ▁. ▁endObject ▁( ▁) ▁. ▁endObject ▁( ▁) ▁. ▁endObject ▁( ▁) ▁. ▁startObject ▁( ▁) ▁. ▁startObject ▁( ▁STR ▁) ▁. ▁field ▁( ▁STR ▁, ▁STR ▁) ▁. ▁startObject ▁( ▁STR ▁) ▁. ▁field ▁( ▁STR ▁, ▁STR ▁) ▁. ▁endObject ▁( ▁) ▁. ▁endObject ▁( ▁) ▁. ▁endObject ▁( ▁) ▁. ▁endArray ▁( ▁) ▁. ▁endObject ▁( ▁) ▁. ▁endObject ▁( ▁) ▁. ▁endObject ▁( ▁) ▁; ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁static ▁void ▁update Mapping ▁( ▁Rollup Job ▁job ▁, ▁ActionListener ▁< ▁Acknowledged Response ▁> ▁listener ▁, ▁PersistentTasks Service ▁persistent Tasks Service ▁, ▁Client ▁client ▁, ▁Logger ▁logger ▁) ▁{ ▁final ▁String ▁indexName ▁= ▁job ▁. ▁getConfig ▁( ▁) ▁. ▁getR oll up Index ▁( ▁) ▁; ▁Checked Consumer ▁< ▁Get Mappings Response ▁, ▁Exception ▁> ▁getM apping ResponseHandler ▁= ▁getM apping Response ▁-> ▁{ ▁Mapping Metadata ▁mappings ▁= ▁getM apping Response ▁. ▁getM appings ▁( ▁) ▁. ▁get ▁( ▁indexName ▁) ▁; ▁Object ▁m ▁= ▁mappings ▁. ▁getSource AsMap ▁( ▁) ▁. ▁get ▁( ▁STR ▁) ▁; ▁if ▁( ▁m ▁== ▁null ▁) ▁{ ▁String ▁msg ▁= ▁STR ▁+ ▁STR ▁+ ▁indexName ▁+ ▁STR ▁; ▁logger ▁. ▁error ▁( ▁msg ▁) ▁; ▁listener ▁. ▁onFailure ▁( ▁new ▁Runtime Exception ▁( ▁msg ▁) ▁) ▁; ▁return ▁; ▁} ▁Map ▁< ▁String ▁, ▁Object ▁> ▁metadata ▁= ▁( ▁Map ▁< ▁String ▁, ▁Object ▁> ▁) ▁m ▁; ▁if ▁( ▁metadata ▁. ▁get ▁( ▁Rollup Field ▁. ▁R OL LU P _ META ▁) ▁== ▁null ▁) ▁{ ▁String ▁msg ▁= ▁STR ▁+ ▁STR ▁+ ▁Rollup Field ▁. ▁R OL LU P _ META ▁+ ▁STR ▁+ ▁indexName ▁+ ▁STR ▁; ▁logger ▁. ▁error ▁( ▁msg ▁) ▁; ▁listener ▁. ▁onFailure ▁( ▁new ▁Runtime Exception ▁( ▁msg ▁) ▁) ▁; ▁return ▁; ▁} ▁Map ▁< ▁String ▁, ▁Object ▁> ▁roll up Meta ▁= ▁( ▁Map ▁< ▁String ▁, ▁Object ▁> ▁) ▁( ▁( ▁Map ▁< ▁String ▁, ▁Object ▁> ▁) ▁m ▁) ▁. ▁get ▁( ▁Rollup Field ▁. ▁R OL LU P _ META ▁) ▁; ▁String ▁string Version ▁= ▁( ▁String ▁) ▁( ▁( ▁Map ▁< ▁String ▁, ▁Object ▁> ▁) ▁m ▁) ▁. ▁get ▁( ▁Rollup ▁. ▁R OL LU P _ TEMPLATE _ VERSION _ FIELD ▁) ▁;
▁public ▁class ▁By Chain ed ▁extends ▁By ▁implements ▁Serializable ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 56 3 76 90 5 1 17 0 17 24 5 1 L ▁; ▁private ▁By ▁[ ▁] ▁b ys ▁; ▁public ▁By Chain ed ▁( ▁By ▁... ▁b ys ▁) ▁{ ▁this ▁. ▁b ys ▁= ▁b ys ▁; ▁} ▁@ ▁Override ▁public ▁WebElement ▁findElement ▁( ▁Search Context ▁context ▁) ▁{ ▁List ▁< ▁WebElement ▁> ▁elements ▁= ▁find Elements ▁( ▁context ▁) ▁; ▁if ▁( ▁elements ▁. ▁isEmpty ▁( ▁) ▁) ▁throw ▁new ▁NoSuch ElementException ▁( ▁STR ▁+ ▁toString ▁( ▁) ▁) ▁; ▁return ▁elements ▁. ▁get ▁( ▁0 ▁) ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁WebElement ▁> ▁find Elements ▁( ▁Search Context ▁context ▁) ▁{ ▁if ▁( ▁b ys ▁. ▁length ▁== ▁0 ▁) ▁{ ▁return ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁} ▁List ▁< ▁WebElement ▁> ▁e le ms ▁= ▁b ys ▁[ ▁0 ▁] ▁. ▁find Elements ▁( ▁context ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁b ys ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁e le ms ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁break ▁; ▁} ▁final ▁By ▁by ▁= ▁b ys ▁[ ▁i ▁] ▁; ▁e le ms ▁= ▁e le ms ▁. ▁stream ▁( ▁) ▁. ▁map ▁( ▁elem ▁-> ▁elem ▁. ▁find Elements ▁( ▁by ▁) ▁) ▁. ▁flatMap ▁( ▁List ▁:: ▁stream ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toList ▁( ▁) ▁) ▁; ▁} ▁return ▁e le ms ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁String ▁. ▁format ▁( ▁STR ▁, ▁Stream ▁. ▁of ▁( ▁b ys ▁) ▁. ▁map ▁( ▁By ▁:: ▁toString ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁joining ▁( ▁STR ▁) ▁) ▁) ▁; ▁} ▁}
▁final ▁long ▁new Term ▁= ▁randomLong Between ▁( ▁current Term ▁+ ▁1 ▁, ▁Long ▁. ▁MAX _ VALUE ▁) ▁; ▁co ord ination State ▁. ▁handle Start Join ▁( ▁new ▁Start Join Request ▁( ▁local Node ▁, ▁new Term ▁) ▁) ▁; ▁responses By Node ▁. ▁forEach ▁( ▁( ▁other Node ▁, ▁pre V ote Response ▁) ▁-> ▁{ ▁if ▁( ▁pre V ote Response ▁!= ▁null ▁) ▁{ ▁try ▁{ ▁co ord ination State ▁. ▁handle Join ▁( ▁new ▁Join ▁( ▁other Node ▁, ▁local Node ▁, ▁new Term ▁, ▁pre V ote Response ▁. ▁getLast Accepted Term ▁( ▁) ▁, ▁pre V ote Response ▁. ▁getLast Accepted Version ▁( ▁) ▁) ▁) ▁; ▁} ▁catch ▁( ▁Co ord ination State Rejected Exception ▁ignored ▁) ▁{ ▁} ▁} ▁} ▁) ▁; ▁assertThat ▁( ▁co ord ination State ▁. ▁e lection W on ▁( ▁) ▁, ▁equalTo ▁( ▁e lection Occurred ▁) ▁) ▁; ▁} ▁private ▁Pre V ote Response ▁handle Pre V ote Request Via Transport Service ▁( ▁Pre V ote Request ▁pre V ote Request ▁) ▁{ ▁final ▁AtomicReference ▁< ▁Pre V ote Response ▁> ▁response Ref ▁= ▁new ▁AtomicReference ▁< ▁> ▁( ▁) ▁; ▁final ▁AtomicReference ▁< ▁Transport Exception ▁> ▁exception Ref ▁= ▁new ▁AtomicReference ▁< ▁> ▁( ▁) ▁; ▁transport Service ▁. ▁send Request ▁( ▁local Node ▁, ▁REQUEST _ PRE _ VO TE _ ACTION _ NAME ▁, ▁pre V ote Request ▁, ▁new ▁Transport ResponseHandler ▁< ▁Pre V ote Response ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Pre V ote Response ▁read ▁( ▁StreamInput ▁in ▁) ▁throws ▁IOException ▁{ ▁return ▁new ▁Pre V ote Response ▁( ▁in ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁handle Response ▁( ▁Pre V ote Response ▁response ▁) ▁{ ▁response Ref ▁. ▁set ▁( ▁response ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁handleException ▁( ▁Transport Exception ▁exp ▁) ▁{ ▁exception Ref ▁. ▁set ▁( ▁exp ▁) ▁; ▁} ▁} ▁) ▁; ▁determ in istic Task Queue ▁. ▁run All Runnable Tasks ▁( ▁) ▁; ▁assertFalse ▁( ▁determ in istic Task Queue ▁. ▁has De ferred Tasks ▁( ▁) ▁) ▁; ▁final ▁Pre V ote Response ▁response ▁= ▁response Ref ▁. ▁get ▁( ▁) ▁; ▁final ▁Transport Exception ▁transport Exception ▁= ▁exception Ref ▁. ▁get ▁( ▁) ▁; ▁if ▁( ▁transport Exception ▁!= ▁null ▁) ▁{ ▁assertThat ▁( ▁response ▁, ▁nullValue ▁( ▁) ▁) ▁; ▁throw ▁transport Exception ▁; ▁} ▁assertThat ▁( ▁response ▁, ▁not ▁( ▁nullValue ▁( ▁) ▁) ▁) ▁; ▁return ▁response ▁; ▁} ▁public ▁void ▁test Response If Candidate ▁( ▁) ▁{ ▁final ▁long ▁term ▁= ▁random NonNegativeLong ▁( ▁) ▁; ▁final ▁DiscoveryNode ▁other Node ▁= ▁new ▁DiscoveryNode ▁( ▁STR ▁, ▁build New Fake TransportAddress ▁( ▁) ▁, ▁Version ▁. ▁CURRENT ▁) ▁; ▁Pre V ote Response ▁new Pre V ote Response ▁= ▁new ▁Pre V ote Response ▁( ▁current Term ▁, ▁last Accepted Term ▁, ▁last Accepted Version ▁) ▁; ▁pre V ote Collector ▁. ▁update ▁( ▁new Pre V ote Response ▁, ▁null ▁) ▁;
▁@ ▁Sh ould Update ▁( ▁on Mount ▁= ▁true ▁) ▁static ▁boolean ▁should Update ▁( ▁@ ▁Pro p ▁( ▁optional ▁= ▁true ▁) ▁Diff ▁< ▁Uri ▁> ▁uri ▁, ▁@ ▁Pro p ▁( ▁optional ▁= ▁true ▁) ▁Diff ▁< ▁Image Source ▁> ▁image Source ▁, ▁@ ▁Pro p ▁( ▁optional ▁= ▁true ▁) ▁Diff ▁< ▁Image Options ▁> ▁image Options ▁, ▁@ ▁Pro p ▁( ▁optional ▁= ▁true ▁, ▁res Type ▁= ▁Res Type ▁. ▁FLOAT ▁) ▁Diff ▁< ▁Float ▁> ▁image Aspect Ratio ▁, ▁@ ▁Pro p ▁( ▁optional ▁= ▁true ▁) ▁Diff ▁< ▁Image Listener ▁> ▁image Listener ▁) ▁{ ▁return ▁! ▁Objects Compat ▁. ▁equals ▁( ▁uri ▁. ▁getPrevious ▁( ▁) ▁, ▁uri ▁. ▁getNext ▁( ▁) ▁) ▁|| ▁! ▁Objects Compat ▁. ▁equals ▁( ▁image Source ▁. ▁getPrevious ▁( ▁) ▁, ▁image Source ▁. ▁getNext ▁( ▁) ▁) ▁|| ▁! ▁Objects Compat ▁. ▁equals ▁( ▁image Options ▁. ▁getPrevious ▁( ▁) ▁, ▁image Options ▁. ▁getNext ▁( ▁) ▁) ▁|| ▁! ▁Objects Compat ▁. ▁equals ▁( ▁image Aspect Ratio ▁. ▁getPrevious ▁( ▁) ▁, ▁image Aspect Ratio ▁. ▁getNext ▁( ▁) ▁) ▁|| ▁! ▁Objects Compat ▁. ▁equals ▁( ▁image Listener ▁. ▁getPrevious ▁( ▁) ▁, ▁image Listener ▁. ▁getNext ▁( ▁) ▁) ▁; ▁} ▁@ ▁On Pop ulate Access ibility Node ▁static ▁void ▁on Pop ulate Access ibility Node ▁( ▁Component Context ▁c ▁, ▁View ▁host ▁, ▁Access ibility NodeInfo Compat ▁node ▁) ▁{ ▁node ▁. ▁set ClassName ▁( ▁Access ibility Role ▁. ▁IMAGE ▁) ▁; ▁} ▁@ ▁On Bounds Defined ▁static ▁void ▁on Bounds Defined ▁( ▁Component Context ▁c ▁, ▁Component Layout ▁layout ▁, ▁Output ▁< ▁Rect ▁> ▁viewport Dimensions ▁) ▁{ ▁final ▁int ▁width ▁= ▁layout ▁. ▁getWidth ▁( ▁) ▁; ▁final ▁int ▁height ▁= ▁layout ▁. ▁getHeight ▁( ▁) ▁; ▁int ▁padding X ▁= ▁0 ▁, ▁padding Y ▁= ▁0 ▁; ▁if ▁( ▁layout ▁. ▁is Padding Set ▁( ▁) ▁) ▁{ ▁padding X ▁= ▁layout ▁. ▁getPadding Left ▁( ▁) ▁+ ▁layout ▁. ▁getPadding Right ▁( ▁) ▁; ▁padding Y ▁= ▁layout ▁. ▁getPadding Top ▁( ▁) ▁+ ▁layout ▁. ▁getPadding Bottom ▁( ▁) ▁; ▁} ▁viewport Dimensions ▁. ▁set ▁( ▁new ▁Rect ▁( ▁0 ▁, ▁0 ▁, ▁width ▁- ▁padding X ▁, ▁height ▁- ▁padding Y ▁) ▁) ▁; ▁} ▁@ ▁On Enter ed Range ▁( ▁name ▁= ▁STR ▁) ▁static ▁void ▁on Enter ed Work ing Range ▁( ▁Component Context ▁c ▁, ▁@ ▁Pro p ▁( ▁optional ▁= ▁true ▁) ▁final ▁@ ▁Nullable ▁Pref etch ▁prefetch ▁, ▁@ ▁Pro p ▁( ▁optional ▁= ▁true ▁) ▁final ▁@ ▁Nullable ▁Object ▁caller Context ▁, ▁@ ▁Cached Value ▁V ito Image Request ▁image Request ▁, ▁@ ▁From Prepare ▁@ ▁Nullable ▁DataSource ▁< ▁Void ▁> ▁prefetch DataSource ▁, ▁@ ▁State ▁final ▁@ ▁Nullable ▁AtomicReference ▁< ▁DataSource ▁< ▁Void ▁> ▁> ▁working Range Prefetch Data ▁) ▁{ ▁if ▁( ▁working Range Prefetch Data ▁== ▁null ▁) ▁{ ▁return ▁; ▁} ▁cancel Work ing Range Prefetch ▁( ▁working Range Prefetch Data ▁) ▁;
▁case ▁REPLACE _ DEFAULT _ ONLY ▁: ▁options ▁. ▁set Enum ▁( ▁VT Option Defin es ▁. ▁DATA _ MATCH _ DATA _ TYPE ▁, ▁Replace Data Choices ▁. ▁REPLACE _ UN DEFINED _ DATA _ ONLY ▁) ▁; ▁break ▁; ▁case ▁REPLACE _ FIRST _ ONLY ▁: ▁options ▁. ▁set Enum ▁( ▁VT Option Defin es ▁. ▁DATA _ MATCH _ DATA _ TYPE ▁, ▁Replace Data Choices ▁. ▁REPLACE _ FIRST _ DATA _ ONLY ▁) ▁; ▁break ▁; ▁case ▁REPLACE ▁: ▁options ▁. ▁set Enum ▁( ▁VT Option Defin es ▁. ▁DATA _ MATCH _ DATA _ TYPE ▁, ▁Replace Data Choices ▁. ▁REPLACE _ ALL _ DATA ▁) ▁; ▁break ▁; ▁} ▁return ▁options ▁; ▁} ▁private ▁boolean ▁set DataType ▁( ▁Program ▁program ▁, ▁Address ▁start Address ▁, ▁DataType ▁dataType ▁, ▁int ▁data Length ▁, ▁VTMatch Apply Choices ▁. ▁Replace Data Choices ▁replace Choice ▁) ▁throws ▁CodeUnit Insert ion Exception ▁, ▁DataType Conflict Exception ▁, ▁Version Tracking Apply Exception ▁{ ▁Listing ▁listing ▁= ▁program ▁. ▁getListing ▁( ▁) ▁; ▁Data ▁original Data ▁= ▁listing ▁. ▁getData At ▁( ▁start Address ▁) ▁; ▁if ▁( ▁original Data ▁== ▁null ▁) ▁{ ▁throw ▁new ▁Version Tracking Apply Exception ▁( ▁STR ▁) ▁; ▁} ▁DataType ▁original DataType ▁= ▁original Data ▁. ▁getDataType ▁( ▁) ▁; ▁int ▁original Data Length ▁= ▁original Data ▁. ▁getLength ▁( ▁) ▁; ▁Address ▁end Address ▁; ▁try ▁{ ▁end Address ▁= ▁start Address ▁. ▁add ▁( ▁data Length ▁- ▁1 ▁) ▁; ▁} ▁catch ▁( ▁Address OutOfBounds Exception ▁e ▁) ▁{ ▁end Address ▁= ▁null ▁; ▁} ▁if ▁( ▁end Address ▁== ▁null ▁|| ▁! ▁start Address ▁. ▁has Same AddressSpace ▁( ▁end Address ▁) ▁) ▁{ ▁throw ▁new ▁Version Tracking Apply Exception ▁( ▁STR ▁+ ▁STR ▁) ▁; ▁} ▁AddressSet ▁address Set ▁= ▁new ▁AddressSet ▁( ▁start Address ▁, ▁end Address ▁) ▁; ▁Instruction Iterator ▁instructions ▁= ▁listing ▁. ▁getInstruction s ▁( ▁address Set ▁, ▁true ▁) ▁; ▁boolean ▁has Instructions ▁= ▁instructions ▁. ▁hasNext ▁( ▁) ▁; ▁if ▁( ▁has Instructions ▁) ▁{ ▁String ▁message ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁start Address ▁. ▁toString ▁( ▁) ▁+ ▁STR ▁+ ▁end Address ▁. ▁toString ▁( ▁) ▁+ ▁STR ▁; ▁throw ▁new ▁Version Tracking Apply Exception ▁( ▁message ▁) ▁; ▁} ▁boolean ▁replace Un defined Data Only ▁= ▁( ▁replace Choice ▁== ▁Replace Data Choices ▁. ▁REPLACE _ UN DEFINED _ DATA _ ONLY ▁) ▁; ▁boolean ▁replace First Only ▁= ▁( ▁replace Choice ▁== ▁Replace Data Choices ▁. ▁REPLACE _ FIRST _ DATA _ ONLY ▁) ▁; ▁Data Iterator ▁defined Data ▁= ▁listing ▁. ▁get Defined Data ▁( ▁address Set ▁, ▁true ▁) ▁; ▁boolean ▁has Defined Data ▁= ▁defined Data ▁. ▁hasNext ▁( ▁) ▁; ▁Data ▁next Non Un defined Data After ▁= ▁Data Utilities ▁. ▁getNext Non Un defined Data After ▁( ▁program ▁, ▁start Address ▁, ▁end Address ▁) ▁; ▁boolean ▁has Other Defined Data ▁= ▁next Non Un defined Data After ▁!= ▁null ▁;
▁public ▁class ▁Doc Count FieldMapper Tests ▁extends ▁Mapper Service TestCase ▁{ ▁private ▁static ▁final ▁String ▁CONTENT _ TYPE ▁= ▁Doc Count FieldMapper ▁. ▁CONTENT _ TYPE ▁; ▁private ▁static ▁final ▁String ▁DO C _ COUNT _ FIELD ▁= ▁Doc Count FieldMapper ▁. ▁NAME ▁; ▁public ▁void ▁testParse Value ▁( ▁) ▁throws ▁Exception ▁{ ▁Document Mapper ▁mapper ▁= ▁create Document Mapper ▁( ▁mapping ▁( ▁b ▁-> ▁{ ▁} ▁) ▁) ▁; ▁Parsed Document ▁doc ▁= ▁mapper ▁. ▁parse ▁( ▁source ▁( ▁b ▁-> ▁b ▁. ▁field ▁( ▁STR ▁, ▁500 ▁) ▁. ▁field ▁( ▁CONTENT _ TYPE ▁, ▁100 ▁) ▁) ▁) ▁; ▁Index able Field ▁field ▁= ▁doc ▁. ▁root Doc ▁( ▁) ▁. ▁getField ▁( ▁DO C _ COUNT _ FIELD ▁) ▁; ▁assertEquals ▁( ▁DO C _ COUNT _ FIELD ▁, ▁field ▁. ▁stringValue ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁doc ▁. ▁root Doc ▁( ▁) ▁. ▁getFields ▁( ▁DO C _ COUNT _ FIELD ▁) ▁. ▁length ▁) ▁; ▁} ▁public ▁void ▁testInvalid Document _ Negative DocCount ▁( ▁) ▁throws ▁Exception ▁{ ▁Document Mapper ▁mapper ▁= ▁create Document Mapper ▁( ▁mapping ▁( ▁b ▁-> ▁{ ▁} ▁) ▁) ▁; ▁Exception ▁e ▁= ▁expectThrows ▁( ▁Mapper ParsingException ▁. ▁class ▁, ▁( ▁) ▁-> ▁mapper ▁. ▁parse ▁( ▁source ▁( ▁b ▁-> ▁b ▁. ▁field ▁( ▁CONTENT _ TYPE ▁, ▁- ▁100 ▁) ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁e ▁. ▁getCause ▁( ▁) ▁. ▁getMessage ▁( ▁) ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁} ▁public ▁void ▁testInvalid Document _ Z ero DocCount ▁( ▁) ▁throws ▁Exception ▁{ ▁Document Mapper ▁mapper ▁= ▁create Document Mapper ▁( ▁mapping ▁( ▁b ▁-> ▁{ ▁} ▁) ▁) ▁; ▁Exception ▁e ▁= ▁expectThrows ▁( ▁Mapper ParsingException ▁. ▁class ▁, ▁( ▁) ▁-> ▁mapper ▁. ▁parse ▁( ▁source ▁( ▁b ▁-> ▁b ▁. ▁field ▁( ▁CONTENT _ TYPE ▁, ▁0 ▁) ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁e ▁. ▁getCause ▁( ▁) ▁. ▁getMessage ▁( ▁) ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁} ▁public ▁void ▁testInvalid Document _ Non Numeric DocCount ▁( ▁) ▁throws ▁Exception ▁{ ▁Document Mapper ▁mapper ▁= ▁create Document Mapper ▁( ▁mapping ▁( ▁b ▁-> ▁{ ▁} ▁) ▁) ▁; ▁Exception ▁e ▁= ▁expectThrows ▁( ▁Mapper ParsingException ▁. ▁class ▁, ▁( ▁) ▁-> ▁mapper ▁. ▁parse ▁( ▁source ▁( ▁b ▁-> ▁b ▁. ▁field ▁( ▁CONTENT _ TYPE ▁, ▁STR ▁) ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁e ▁. ▁getCause ▁( ▁) ▁. ▁getMessage ▁( ▁) ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁} ▁public ▁void ▁testInvalid Document _ Fraction al DocCount ▁( ▁) ▁throws ▁Exception ▁{ ▁Document Mapper ▁mapper ▁= ▁create Document Mapper ▁( ▁mapping ▁( ▁b ▁-> ▁{ ▁} ▁) ▁) ▁; ▁Exception ▁e ▁= ▁expectThrows ▁( ▁Mapper ParsingException ▁. ▁class ▁, ▁( ▁) ▁-> ▁mapper ▁. ▁parse ▁( ▁source ▁( ▁b ▁-> ▁b ▁. ▁field ▁( ▁CONTENT _ TYPE ▁, ▁100 . 23 ▁) ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁e ▁. ▁getCause ▁( ▁) ▁. ▁getMessage ▁( ▁) ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁}
▁public ▁class ▁VT D ual Listing Highlight Provider ▁implements ▁Highlight Provider ▁{ ▁private ▁static ▁Color ▁APP LI ED _ MARK UP _ COLOR ▁= ▁new ▁Color ▁( ▁150 ▁, ▁2 20 ▁, ▁150 ▁) ▁; ▁private ▁static ▁Color ▁UN APP LI ED _ MARK UP _ COLOR ▁= ▁new ▁Color ▁( ▁255 ▁, ▁17 0 ▁, ▁8 5 ▁) ▁; ▁private ▁static ▁Color ▁IG NO RED _ MARK UP _ COLOR ▁= ▁new ▁Color ▁( ▁2 20 ▁, ▁2 20 ▁, ▁2 20 ▁) ▁; ▁private ▁static ▁Color ▁RE JECTED _ MARK UP _ COLOR ▁= ▁new ▁Color ▁( ▁250 ▁, ▁200 ▁, ▁200 ▁) ▁; ▁private ▁static ▁Color ▁FAILED _ MARK UP _ COLOR ▁= ▁new ▁Color ▁( ▁255 ▁, ▁80 ▁, ▁80 ▁) ▁; ▁private ▁static ▁Color ▁NO _ ADDRESS _ MARK UP _ COLOR ▁= ▁new ▁Color ▁( ▁20 5 ▁, ▁18 5 ▁, ▁2 20 ▁) ▁; ▁private ▁static ▁Color ▁SAME _ MARK UP _ COLOR ▁= ▁new ▁Color ▁( ▁17 5 ▁, ▁2 25 ▁, ▁255 ▁) ▁; ▁private ▁static ▁Color ▁CONF LICT _ MARK UP _ COLOR ▁= ▁new ▁Color ▁( ▁255 ▁, ▁2 25 ▁, ▁10 5 ▁) ▁; ▁private ▁HashMap ▁< ▁Address ▁, ▁HashMap ▁< ▁VT Markup Type ▁, ▁VTMarkupItem ▁> ▁> ▁map ▁= ▁new ▁HashMap ▁< ▁Address ▁, ▁HashMap ▁< ▁VT Markup Type ▁, ▁VTMarkupItem ▁> ▁> ▁( ▁) ▁; ▁private ▁final ▁VTController ▁controller ▁; ▁private ▁Listing Panel ▁listing Panel ▁; ▁private ▁Listing Highlight Provider ▁listing High l ighter ▁; ▁private ▁VTMarkupItem ▁current MarkupItem ▁; ▁private ▁boolean ▁is Source ▁; ▁public ▁VT D ual Listing Highlight Provider ▁( ▁VTController ▁controller ▁, ▁boolean ▁is Source ▁) ▁{ ▁this ▁. ▁controller ▁= ▁controller ▁; ▁this ▁. ▁is Source ▁= ▁is Source ▁; ▁update Markup ▁( ▁) ▁; ▁} ▁public ▁void ▁set Listing Panel ▁( ▁Listing Panel ▁listing Panel ▁) ▁{ ▁if ▁( ▁this ▁. ▁listing Panel ▁!= ▁null ▁) ▁{ ▁this ▁. ▁listing Panel ▁. ▁remove Button Pressed Listener ▁( ▁listing High l ighter ▁) ▁; ▁} ▁this ▁. ▁listing Panel ▁= ▁listing Panel ▁; ▁if ▁( ▁listing Panel ▁!= ▁null ▁) ▁{ ▁this ▁. ▁listing High l ighter ▁= ▁new ▁Listing Highlight Provider ▁( ▁controller ▁. ▁getTool ▁( ▁) ▁, ▁listing Panel ▁) ▁; ▁listing Panel ▁. ▁remove Button Pressed Listener ▁( ▁listing High l ighter ▁) ▁; ▁listing Panel ▁. ▁add Button Pressed Listener ▁( ▁listing High l ighter ▁) ▁; ▁} ▁} ▁public ▁void ▁update Markup ▁( ▁) ▁{ ▁map ▁. ▁clear ▁( ▁) ▁; ▁VTSession ▁session ▁= ▁controller ▁. ▁getSession ▁( ▁) ▁; ▁if ▁( ▁session ▁== ▁null ▁) ▁{ ▁return ▁; ▁} ▁Match Info ▁match Info ▁= ▁controller ▁. ▁getMatch Info ▁( ▁) ▁; ▁if ▁( ▁match Info ▁!= ▁null ▁) ▁{ ▁Collection ▁< ▁VTMarkupItem ▁> ▁markup Items ▁= ▁match Info ▁. ▁get Ap pl i able Markup Items ▁( ▁null ▁) ▁; ▁for ▁( ▁VTMarkupItem ▁markup Item ▁: ▁markup Items ▁) ▁{ ▁update Map ▁( ▁markup Item ▁) ▁; ▁} ▁} ▁}
▁@ ▁RunWith ▁( ▁PowerMockRunner ▁. ▁class ▁) ▁@ ▁PowerMockRunner Delegate ▁( ▁Tracing Segment Runner ▁. ▁class ▁) ▁public ▁class ▁Generic Request or Interceptor Test ▁{ ▁@ ▁SegmentStorage Point ▁private ▁SegmentStorage ▁segmentStorage ▁; ▁@ ▁Rule ▁public ▁Agent ServiceRule ▁service Rule ▁= ▁new ▁Agent ServiceRule ▁( ▁) ▁; ▁public ▁Generic Request or Interceptor ▁interceptor ▁= ▁new ▁Generic Request or Interceptor ▁( ▁) ▁; ▁Object ▁[ ▁] ▁arguments ▁= ▁new ▁Object ▁[ ▁] ▁{ ▁STR ▁} ▁; ▁En hancedInstance ▁instance ▁; ▁@ ▁Before ▁public ▁void ▁setup ▁( ▁) ▁throws ▁IOException ▁{ ▁instance ▁= ▁new ▁En hance Instance ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Before ▁( ▁) ▁throws ▁Throwable ▁{ ▁interceptor ▁. ▁beforeMethod ▁( ▁instance ▁, ▁null ▁, ▁arguments ▁, ▁null ▁, ▁null ▁) ▁; ▁interceptor ▁. ▁afterMethod ▁( ▁instance ▁, ▁null ▁, ▁arguments ▁, ▁null ▁, ▁null ▁) ▁; ▁List ▁< ▁TraceSegment ▁> ▁segments ▁= ▁segmentStorage ▁. ▁getTrace Segments ▁( ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁segments ▁. ▁size ▁( ▁) ▁, ▁1 ▁) ▁; ▁List ▁< ▁Abstract TracingSpan ▁> ▁spans ▁= ▁SegmentHelper ▁. ▁getSpans ▁( ▁segments ▁. ▁get ▁( ▁0 ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁spans ▁. ▁size ▁( ▁) ▁, ▁1 ▁) ▁; ▁Abstract TracingSpan ▁span ▁= ▁spans ▁. ▁get ▁( ▁0 ▁) ▁; ▁span Common Assert ▁( ▁span ▁, ▁STR ▁) ▁; ▁} ▁private ▁void ▁span Common Assert ▁( ▁AbstractSpan ▁span ▁, ▁String ▁operationName ▁) ▁{ ▁SpanAssert ▁. ▁assert Component ▁( ▁span ▁, ▁Components Define ▁. ▁AV RO _ CLIENT ▁) ▁; ▁SpanAssert ▁. ▁assert Occur Exception ▁( ▁span ▁, ▁false ▁) ▁; ▁SpanAssert ▁. ▁assert Log Size ▁( ▁span ▁, ▁0 ▁) ▁; ▁SpanAssert ▁. ▁assert Layer ▁( ▁span ▁, ▁SpanLayer ▁. ▁RPC _ FRAME WORK ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁span ▁. ▁getOperation Name ▁( ▁) ▁, ▁operationName ▁) ▁; ▁} ▁@ ▁After ▁public ▁void ▁cleanup ▁( ▁) ▁{ ▁} ▁public ▁static ▁class ▁En hance Instance ▁implements ▁En hancedInstance ▁{ ▁@ ▁Override ▁public ▁Object ▁getSkyWalking DynamicField ▁( ▁) ▁{ ▁return ▁new ▁Avro Instance ▁( ▁STR ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setSkyWalking DynamicField ▁( ▁Object ▁value ▁) ▁{ ▁} ▁} ▁}
▁@ ▁Extension ▁( ▁value ▁= ▁STR ▁, ▁order ▁= ▁- ▁1000 ▁) ▁@ ▁Auto Active ▁( ▁consumer Side ▁= ▁true ▁) ▁public ▁class ▁Sentinel So fa Rpc Consumer Filter ▁extends ▁Abstract So fa Rpc Filter ▁{ ▁@ ▁Override ▁public ▁Sofa Response ▁invoke ▁( ▁Filter Invoker ▁invoker ▁, ▁Sofa Request ▁request ▁) ▁throws ▁Sofa Rpc Exception ▁{ ▁if ▁( ▁request ▁. ▁getIn voke Type ▁( ▁) ▁!= ▁null ▁&& ▁! ▁Rpc Constants ▁. ▁INVOK ER _ TYPE _ SYNC ▁. ▁equals ▁( ▁request ▁. ▁getIn voke Type ▁( ▁) ▁) ▁) ▁{ ▁return ▁invoker ▁. ▁invoke ▁( ▁request ▁) ▁; ▁} ▁String ▁interface ResourceName ▁= ▁getInterface ResourceName ▁( ▁request ▁) ▁; ▁String ▁method ResourceName ▁= ▁getMethod ResourceName ▁( ▁request ▁) ▁; ▁Entry ▁interface Entry ▁= ▁null ▁; ▁Entry ▁method Entry ▁= ▁null ▁; ▁try ▁{ ▁interface Entry ▁= ▁Sph U ▁. ▁entry ▁( ▁interface ResourceName ▁, ▁ResourceType Constants ▁. ▁COMMON _ RPC ▁, ▁EntryType ▁. ▁OUT ▁) ▁; ▁method Entry ▁= ▁Sph U ▁. ▁entry ▁( ▁method ResourceName ▁, ▁ResourceType Constants ▁. ▁COMMON _ RPC ▁, ▁EntryType ▁. ▁OUT ▁, ▁getMethod Arguments ▁( ▁request ▁) ▁) ▁; ▁Sofa Response ▁response ▁= ▁invoker ▁. ▁invoke ▁( ▁request ▁) ▁; ▁trace Response Exception ▁( ▁response ▁, ▁interface Entry ▁, ▁method Entry ▁) ▁; ▁return ▁response ▁; ▁} ▁catch ▁( ▁BlockException ▁e ▁) ▁{ ▁return ▁Sofa Rpc Fallback Registry ▁. ▁getConsumer Fallback ▁( ▁) ▁. ▁handle ▁( ▁invoker ▁, ▁request ▁, ▁e ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁trace Other Exception ▁( ▁t ▁, ▁interface Entry ▁, ▁method Entry ▁) ▁; ▁} ▁finally ▁{ ▁if ▁( ▁method Entry ▁!= ▁null ▁) ▁{ ▁method Entry ▁. ▁exit ▁( ▁1 ▁, ▁getMethod Arguments ▁( ▁request ▁) ▁) ▁; ▁} ▁if ▁( ▁interface Entry ▁!= ▁null ▁) ▁{ ▁interface Entry ▁. ▁exit ▁( ▁) ▁; ▁} ▁} ▁} ▁}
▁@ ▁RunWith ▁( ▁Parameterized ▁. ▁class ▁) ▁public ▁class ▁Realm Schema Tests ▁{ ▁private ▁enum ▁Schema Type ▁{ ▁M UT ABLE ▁( ▁Mutable Realm Object Schema ▁. ▁class ▁) ▁, ▁IM M UT ABLE ▁( ▁Immutable Realm Object Schema ▁. ▁class ▁) ▁; ▁final ▁Class ▁< ▁? ▁extends ▁Realm Object Schema ▁> ▁object Schema Class ▁; ▁Schema Type ▁( ▁Class ▁< ▁? ▁extends ▁Realm Object Schema ▁> ▁object Schema Class ▁) ▁{ ▁this ▁. ▁object Schema Class ▁= ▁object Schema Class ▁; ▁} ▁} ▁@ ▁Rule ▁public ▁final ▁Test Realm Configuration Factory ▁config Factory ▁= ▁new ▁Test Realm Configuration Factory ▁( ▁) ▁; ▁@ ▁Rule ▁public ▁final ▁Expected Exception ▁thrown ▁= ▁Expected Exception ▁. ▁none ▁( ▁) ▁; ▁private ▁Base Realm ▁realm ▁; ▁private ▁Realm Schema ▁realm Schema ▁; ▁private ▁Schema Type ▁type ▁; ▁@ ▁Parameterized ▁. ▁Parameters ▁( ▁name ▁= ▁STR ▁) ▁public ▁static ▁List ▁< ▁Schema Type ▁> ▁data ▁( ▁) ▁{ ▁return ▁Arrays ▁. ▁asList ▁( ▁Schema Type ▁. ▁values ▁( ▁) ▁) ▁; ▁} ▁public ▁Realm Schema Tests ▁( ▁Schema Type ▁type ▁) ▁{ ▁this ▁. ▁type ▁= ▁type ▁; ▁} ▁@ ▁Before ▁public ▁void ▁setUp ▁( ▁) ▁{ ▁Realm Configuration ▁realm Config ▁= ▁config Factory ▁. ▁create Configuration Builder ▁( ▁) ▁. ▁schema ▁( ▁All Java Types ▁. ▁class ▁, ▁Owner ▁. ▁class ▁, ▁Primary Key AsString ▁. ▁class ▁, ▁Cat ▁. ▁class ▁, ▁Dog ▁. ▁class ▁, ▁Dog PrimaryKey ▁. ▁class ▁, ▁Null Types ▁. ▁class ▁) ▁. ▁build ▁( ▁) ▁; ▁Realm ▁. ▁getInstance ▁( ▁realm Config ▁) ▁. ▁close ▁( ▁) ▁; ▁if ▁( ▁type ▁== ▁Schema Type ▁. ▁M UT ABLE ▁) ▁{ ▁realm ▁= ▁Dynamic Realm ▁. ▁getInstance ▁( ▁realm Config ▁) ▁; ▁} ▁else ▁{ ▁realm ▁= ▁Realm ▁. ▁getInstance ▁( ▁realm Config ▁) ▁; ▁} ▁realm Schema ▁= ▁this ▁. ▁realm ▁. ▁getSchema ▁( ▁) ▁; ▁realm ▁. ▁begin Transaction ▁( ▁) ▁; ▁} ▁@ ▁After ▁public ▁void ▁tearDown ▁( ▁) ▁{ ▁realm ▁. ▁close ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁getAll ▁( ▁) ▁{ ▁Set ▁< ▁Realm Object Schema ▁> ▁object S chemas ▁= ▁realm Schema ▁. ▁getAll ▁( ▁) ▁; ▁assertEquals ▁( ▁7 ▁, ▁object S chemas ▁. ▁size ▁( ▁) ▁) ▁; ▁List ▁< ▁String ▁> ▁expected Tables ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁All Java Types ▁. ▁CLASS _ NAME ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁Null Types ▁. ▁CLASS _ NAME ▁) ▁) ▁; ▁for ▁( ▁Realm Object Schema ▁object Schema ▁: ▁object S chemas ▁) ▁{ ▁assertThat ▁( ▁object Schema ▁, ▁Core Matchers ▁. ▁instanceOf ▁( ▁type ▁. ▁object Schema Class ▁) ▁) ▁; ▁if ▁( ▁! ▁expected Tables ▁. ▁remove ▁( ▁object Schema ▁. ▁getClassName ▁( ▁) ▁) ▁) ▁{ ▁fail ▁( ▁object Schema ▁. ▁getClassName ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁} ▁assertTrue ▁( ▁STR ▁+ ▁( ▁expected Tables ▁. ▁isEmpty ▁( ▁) ▁? ▁STR ▁: ▁expected Tables ▁. ▁get ▁( ▁0 ▁) ▁) ▁, ▁expected Tables ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁}
▁public ▁class ▁Object J _ B ▁{ ▁private ▁long ▁a ▁; ▁private ▁int ▁b ▁; ▁private ▁long ▁c ▁; ▁private ▁int ▁d ▁; ▁private ▁int ▁e ▁; ▁private ▁int ▁f ▁; ▁private ▁int ▁g ▁; ▁private ▁int ▁h ▁; ▁private ▁int ▁i ▁; ▁public ▁long ▁getA ▁( ▁) ▁{ ▁return ▁a ▁; ▁} ▁public ▁void ▁setA ▁( ▁long ▁a ▁) ▁{ ▁this ▁. ▁a ▁= ▁a ▁; ▁} ▁public ▁int ▁getB ▁( ▁) ▁{ ▁return ▁b ▁; ▁} ▁public ▁void ▁setB ▁( ▁int ▁b ▁) ▁{ ▁this ▁. ▁b ▁= ▁b ▁; ▁} ▁public ▁long ▁getC ▁( ▁) ▁{ ▁return ▁c ▁; ▁} ▁public ▁void ▁setC ▁( ▁long ▁c ▁) ▁{ ▁this ▁. ▁c ▁= ▁c ▁; ▁} ▁public ▁int ▁getD ▁( ▁) ▁{ ▁return ▁d ▁; ▁} ▁public ▁void ▁setD ▁( ▁int ▁d ▁) ▁{ ▁this ▁. ▁d ▁= ▁d ▁; ▁} ▁public ▁int ▁getE ▁( ▁) ▁{ ▁return ▁e ▁; ▁} ▁public ▁void ▁set E ▁( ▁int ▁e ▁) ▁{ ▁this ▁. ▁e ▁= ▁e ▁; ▁} ▁public ▁int ▁getF ▁( ▁) ▁{ ▁return ▁f ▁; ▁} ▁public ▁void ▁setF ▁( ▁int ▁f ▁) ▁{ ▁this ▁. ▁f ▁= ▁f ▁; ▁} ▁public ▁int ▁getG ▁( ▁) ▁{ ▁return ▁g ▁; ▁} ▁public ▁void ▁setG ▁( ▁int ▁g ▁) ▁{ ▁this ▁. ▁g ▁= ▁g ▁; ▁} ▁public ▁int ▁getH ▁( ▁) ▁{ ▁return ▁h ▁; ▁} ▁public ▁void ▁setH ▁( ▁int ▁h ▁) ▁{ ▁this ▁. ▁h ▁= ▁h ▁; ▁} ▁public ▁int ▁getI ▁( ▁) ▁{ ▁return ▁i ▁; ▁} ▁public ▁void ▁set I ▁( ▁int ▁i ▁) ▁{ ▁this ▁. ▁i ▁= ▁i ▁; ▁} ▁}
▁Insert FunctionPipe ▁new B ▁= ▁new ▁Insert FunctionPipe ▁( ▁b ▁. ▁source ▁( ▁) ▁, ▁b ▁. ▁expression ▁( ▁) ▁, ▁b ▁. ▁input ▁( ▁) ▁, ▁b ▁. ▁start ▁( ▁) ▁, ▁b ▁. ▁length ▁( ▁) ▁, ▁b ▁. ▁replacement ▁( ▁) ▁) ▁; ▁Insert FunctionPipe ▁transformed ▁= ▁null ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁5 ▁; ▁i ▁++ ▁) ▁{ ▁for ▁( ▁BitSet ▁comb ▁: ▁new ▁Comb inations ▁( ▁4 ▁, ▁i ▁) ▁) ▁{ ▁transformed ▁= ▁( ▁Insert FunctionPipe ▁) ▁new B ▁. ▁replaceChildren ▁( ▁comb ▁. ▁get ▁( ▁0 ▁) ▁? ▁new Input ▁: ▁b ▁. ▁input ▁( ▁) ▁, ▁comb ▁. ▁get ▁( ▁1 ▁) ▁? ▁new Start ▁: ▁b ▁. ▁start ▁( ▁) ▁, ▁comb ▁. ▁get ▁( ▁2 ▁) ▁? ▁new Length ▁: ▁b ▁. ▁length ▁( ▁) ▁, ▁comb ▁. ▁get ▁( ▁3 ▁) ▁? ▁new R ▁: ▁b ▁. ▁replacement ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁transformed ▁. ▁input ▁( ▁) ▁, ▁comb ▁. ▁get ▁( ▁0 ▁) ▁? ▁new Input ▁: ▁b ▁. ▁input ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁transformed ▁. ▁start ▁( ▁) ▁, ▁comb ▁. ▁get ▁( ▁1 ▁) ▁? ▁new Start ▁: ▁b ▁. ▁start ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁transformed ▁. ▁length ▁( ▁) ▁, ▁comb ▁. ▁get ▁( ▁2 ▁) ▁? ▁new Length ▁: ▁b ▁. ▁length ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁transformed ▁. ▁replacement ▁( ▁) ▁, ▁comb ▁. ▁get ▁( ▁3 ▁) ▁? ▁new R ▁: ▁b ▁. ▁replacement ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁transformed ▁. ▁expression ▁( ▁) ▁, ▁b ▁. ▁expression ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁transformed ▁. ▁source ▁( ▁) ▁, ▁b ▁. ▁source ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁@ ▁Override ▁protected ▁Insert FunctionPipe ▁mutate ▁( ▁Insert FunctionPipe ▁instance ▁) ▁{ ▁List ▁< ▁Function ▁< ▁Insert FunctionPipe ▁, ▁Insert FunctionPipe ▁> ▁> ▁random s ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁5 ▁;
▁case ▁STR ▁: ▁case ▁STR ▁: ▁case ▁new Style Classpath Option Name ▁: ▁args ▁. ▁poll ▁( ▁) ▁; ▁String ▁cp Args ▁= ▁args ▁. ▁poll ▁( ▁) ▁; ▁if ▁( ▁cp Args ▁== ▁null ▁) ▁{ ▁NativeImage ▁. ▁showError ▁( ▁head Arg ▁+ ▁STR ▁) ▁; ▁} ▁process Classpath Args ▁( ▁cp Args ▁) ▁; ▁return ▁true ▁; ▁case ▁STR ▁: ▁case ▁STR ▁: ▁args ▁. ▁poll ▁( ▁) ▁; ▁String ▁mp Args ▁= ▁args ▁. ▁poll ▁( ▁) ▁; ▁if ▁( ▁mp Args ▁== ▁null ▁) ▁{ ▁NativeImage ▁. ▁showError ▁( ▁head Arg ▁+ ▁STR ▁) ▁; ▁} ▁process Module Path Args ▁( ▁mp Args ▁) ▁; ▁return ▁true ▁; ▁case ▁STR ▁: ▁case ▁STR ▁: ▁args ▁. ▁poll ▁( ▁) ▁; ▁String ▁main Class Module Arg ▁= ▁args ▁. ▁poll ▁( ▁) ▁; ▁if ▁( ▁main Class Module Arg ▁== ▁null ▁) ▁{ ▁NativeImage ▁. ▁showError ▁( ▁head Arg ▁+ ▁STR ▁) ▁; ▁} ▁String ▁[ ▁] ▁main Class Module Arg Parts ▁= ▁main Class Module Arg ▁. ▁split ▁( ▁STR ▁, ▁2 ▁) ▁; ▁if ▁( ▁main Class Module Arg Parts ▁. ▁length ▁> ▁1 ▁) ▁{ ▁native Image ▁. ▁add Plain Image Builder Arg ▁( ▁native Image ▁. ▁o H Class ▁+ ▁main Class Module Arg Parts ▁[ ▁1 ▁] ▁) ▁; ▁} ▁native Image ▁. ▁add Plain Image Builder Arg ▁( ▁native Image ▁. ▁o H Module ▁+ ▁main Class Module Arg Parts ▁[ ▁0 ▁] ▁) ▁; ▁return ▁true ▁; ▁case ▁STR ▁: ▁args ▁. ▁poll ▁( ▁) ▁; ▁String ▁config Path ▁= ▁args ▁. ▁poll ▁( ▁) ▁; ▁if ▁( ▁config Path ▁== ▁null ▁) ▁{ ▁NativeImage ▁. ▁showError ▁( ▁head Arg ▁+ ▁STR ▁+ ▁File ▁. ▁path Separator ▁+ ▁STR ▁) ▁; ▁} ▁for ▁( ▁String ▁config Dir ▁: ▁config Path ▁. ▁split ▁( ▁File ▁. ▁path Separator ▁) ▁) ▁{ ▁native Image ▁. ▁add Macro Option Root ▁( ▁native Image ▁. ▁canonical ize ▁( ▁Paths ▁. ▁get ▁( ▁config Dir ▁) ▁) ▁) ▁; ▁} ▁return ▁true ▁; ▁case ▁STR ▁: ▁args ▁. ▁poll ▁( ▁) ▁; ▁String ▁jar FilePath Str ▁= ▁args ▁. ▁poll ▁( ▁) ▁; ▁if ▁( ▁jar FilePath Str ▁== ▁null ▁) ▁{ ▁NativeImage ▁. ▁showError ▁( ▁require Valid JarFile Message ▁) ▁; ▁} ▁handle JarFile Arg ▁( ▁native Image ▁. ▁canonical ize ▁( ▁Paths ▁. ▁get ▁( ▁jar FilePath Str ▁) ▁) ▁) ▁; ▁native Image ▁. ▁set Jar Option Mode ▁( ▁true ▁) ▁; ▁return ▁true ▁; ▁case ▁verbose Option ▁: ▁args ▁. ▁poll ▁( ▁) ▁; ▁native Image ▁. ▁set Verbose ▁( ▁true ▁) ▁; ▁return ▁true ▁; ▁case ▁STR ▁: ▁args ▁. ▁poll ▁( ▁) ▁; ▁native Image ▁. ▁setD ry Run ▁( ▁true ▁) ▁; ▁return ▁true ▁; ▁case ▁STR ▁: ▁args ▁. ▁poll ▁( ▁) ▁; ▁native Image ▁. ▁set Print Flags Option Query ▁( ▁OptionType ▁. ▁User ▁. ▁name ▁( ▁) ▁) ▁; ▁return ▁true ▁; ▁case ▁STR ▁: ▁args ▁. ▁poll ▁( ▁) ▁; ▁native Image ▁. ▁set Print Flags Option Query ▁( ▁STR ▁) ▁;
▁assert Fails ▁( ▁( ▁) ▁-> ▁invalid Iterable ▁. ▁get Iterator ▁( ▁) ▁, ▁Polyglot Exception ▁. ▁class ▁, ▁( ▁pe ▁) ▁-> ▁assertTrue ▁( ▁pe ▁. ▁as HostException ▁( ▁) ▁instanceof ▁Illegal StateException ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Proxy Iterable List ▁( ▁) ▁{ ▁String ▁[ ▁] ▁values ▁= ▁{ ▁STR ▁, ▁STR ▁} ▁; ▁List ▁< ▁Object ▁> ▁values List ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁Collections ▁. ▁addAll ▁( ▁values List ▁, ▁values ▁) ▁; ▁setup Env ▁( ▁Context ▁. ▁newBuilder ▁( ▁) ▁. ▁allow All Access ▁( ▁true ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁Value ▁iterable ▁= ▁context ▁. ▁as Value ▁( ▁Proxy Iterable ▁. ▁from ▁( ▁values List ▁) ▁) ▁; ▁verify Iterable ▁( ▁iterable ▁, ▁values ▁, ▁false ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Executable Proxy Iterable ▁( ▁) ▁{ ▁String ▁[ ▁] ▁values ▁= ▁{ ▁STR ▁, ▁STR ▁} ▁; ▁setup Env ▁( ▁Context ▁. ▁newBuilder ▁( ▁) ▁. ▁allow All Access ▁( ▁true ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁Value ▁iterable ▁= ▁context ▁. ▁as Value ▁( ▁new ▁Executable Proxy Iterable Impl ▁( ▁values ▁) ▁) ▁; ▁verify Iterable ▁( ▁iterable ▁, ▁values ▁, ▁false ▁) ▁; ▁assertTrue ▁( ▁iterable ▁. ▁can Execute ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁42 ▁, ▁iterable ▁. ▁execute ▁( ▁42 ▁) ▁. ▁asInt ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁42 ▁, ▁iterable ▁. ▁as ▁( ▁FUNCTION _ OBJECT _ OBJECT ▁) ▁. ▁apply ▁( ▁42 ▁) ▁) ▁; ▁verify Iterator ▁( ▁iterable ▁. ▁as ▁( ▁ITER ABLE _ VALUE ▁) ▁. ▁iterator ▁( ▁) ▁, ▁Arrays ▁. ▁stream ▁( ▁values ▁) ▁. ▁map ▁( ▁context ▁:: ▁as Value ▁) ▁. ▁toArray ▁( ▁) ▁, ▁false ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Proxy Iterable Iterator Has Members ▁( ▁) ▁{ ▁String ▁[ ▁] ▁values ▁= ▁{ ▁STR ▁, ▁STR ▁} ▁; ▁List ▁< ▁Object ▁> ▁values List ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁Collections ▁. ▁addAll ▁( ▁values List ▁, ▁values ▁) ▁; ▁setup Env ▁( ▁Context ▁. ▁newBuilder ▁( ▁) ▁. ▁allow All Access ▁( ▁true ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁Value ▁iterable ▁= ▁context ▁. ▁as Value ▁( ▁( ▁Proxy Iterable ▁) ▁( ▁) ▁-> ▁new ▁Proxy Iterator With Members Impl ▁( ▁values List ▁. ▁iterator ▁( ▁) ▁) ▁) ▁; ▁verify Iterable ▁( ▁iterable ▁, ▁values ▁, ▁false ▁) ▁; ▁verify Iterator ▁( ▁iterable ▁. ▁as ▁( ▁ITER ABLE _ VALUE ▁) ▁. ▁iterator ▁( ▁) ▁, ▁Arrays ▁. ▁stream ▁( ▁values ▁) ▁. ▁map ▁( ▁context ▁:: ▁as Value ▁) ▁. ▁toArray ▁( ▁) ▁, ▁false ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Iterator ▁( ▁) ▁{ ▁String ▁[ ▁] ▁values ▁= ▁{ ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁} ▁; ▁setup Env ▁( ▁Context ▁. ▁newBuilder ▁( ▁) ▁. ▁allow All Access ▁( ▁true ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁Value ▁iterator ▁= ▁context ▁. ▁as Value ▁( ▁new ▁G uest Language Iterator Impl ▁( ▁values ▁) ▁) ▁;
▁IOUtils ▁. ▁close ▁( ▁ir ▁, ▁iw ▁, ▁dir ▁) ▁; ▁} ▁public ▁void ▁test Stored Fields Int ▁( ▁) ▁throws ▁Exception ▁{ ▁Directory ▁dir ▁= ▁new Directory ▁( ▁) ▁; ▁Index Writer Config ▁iw c ▁= ▁new ▁Index Writer Config ▁( ▁null ▁) ▁; ▁Index Writer ▁iw ▁= ▁new ▁Index Writer ▁( ▁dir ▁, ▁iw c ▁) ▁; ▁Document ▁doc ▁= ▁new ▁Document ▁( ▁) ▁; ▁doc ▁. ▁add ▁( ▁new ▁Stored Field ▁( ▁STR ▁, ▁1 ▁) ▁) ▁; ▁doc ▁. ▁add ▁( ▁new ▁Stored Field ▁( ▁STR ▁, ▁2 ▁) ▁) ▁; ▁iw ▁. ▁addDocument ▁( ▁doc ▁) ▁; ▁DirectoryReader ▁ir ▁= ▁Field Subset Reader ▁. ▁wrap ▁( ▁DirectoryReader ▁. ▁open ▁( ▁iw ▁) ▁, ▁new ▁Character Run Aut omaton ▁( ▁Aut om ata ▁. ▁make String ▁( ▁STR ▁) ▁) ▁) ▁; ▁Document ▁d 2 ▁= ▁ir ▁. ▁document ▁( ▁0 ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁d 2 ▁. ▁getFields ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁d 2 ▁. ▁getField ▁( ▁STR ▁) ▁. ▁numeric Value ▁( ▁) ▁) ▁; ▁TestUtil ▁. ▁check Reader ▁( ▁ir ▁) ▁; ▁IOUtils ▁. ▁close ▁( ▁ir ▁, ▁iw ▁, ▁dir ▁) ▁; ▁} ▁public ▁void ▁test Stored Fields Long ▁( ▁) ▁throws ▁Exception ▁{ ▁Directory ▁dir ▁= ▁new Directory ▁( ▁) ▁; ▁Index Writer Config ▁iw c ▁= ▁new ▁Index Writer Config ▁( ▁null ▁) ▁; ▁Index Writer ▁iw ▁= ▁new ▁Index Writer ▁( ▁dir ▁, ▁iw c ▁) ▁; ▁Document ▁doc ▁= ▁new ▁Document ▁( ▁) ▁; ▁doc ▁. ▁add ▁( ▁new ▁Stored Field ▁( ▁STR ▁, ▁1 L ▁) ▁) ▁; ▁doc ▁. ▁add ▁( ▁new ▁Stored Field ▁( ▁STR ▁, ▁2 L ▁) ▁) ▁; ▁iw ▁. ▁addDocument ▁( ▁doc ▁) ▁; ▁DirectoryReader ▁ir ▁= ▁Field Subset Reader ▁. ▁wrap ▁( ▁DirectoryReader ▁. ▁open ▁( ▁iw ▁) ▁, ▁new ▁Character Run Aut omaton ▁( ▁Aut om ata ▁. ▁make String ▁( ▁STR ▁) ▁) ▁) ▁; ▁Document ▁d 2 ▁= ▁ir ▁. ▁document ▁( ▁0 ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁d 2 ▁. ▁getFields ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁1 L ▁, ▁d 2 ▁. ▁getField ▁( ▁STR ▁) ▁. ▁numeric Value ▁( ▁) ▁) ▁; ▁TestUtil ▁. ▁check Reader ▁( ▁ir ▁) ▁; ▁IOUtils ▁. ▁close ▁( ▁ir ▁, ▁iw ▁, ▁dir ▁) ▁; ▁} ▁public ▁void ▁test Stored Fields Float ▁( ▁) ▁throws ▁Exception ▁{ ▁Directory ▁dir ▁= ▁new Directory ▁( ▁) ▁; ▁Index Writer Config ▁iw c ▁= ▁new ▁Index Writer Config ▁( ▁null ▁) ▁; ▁Index Writer ▁iw ▁= ▁new ▁Index Writer ▁( ▁dir ▁, ▁iw c ▁) ▁; ▁Document ▁doc ▁= ▁new ▁Document ▁( ▁) ▁; ▁doc ▁. ▁add ▁( ▁new ▁Stored Field ▁( ▁STR ▁, ▁1 F ▁) ▁) ▁; ▁doc ▁. ▁add ▁( ▁new ▁Stored Field ▁( ▁STR ▁, ▁2 F ▁) ▁) ▁; ▁iw ▁. ▁addDocument ▁( ▁doc ▁) ▁;
▁public ▁final ▁class ▁String Literal ▁extends ▁Expression ▁{ ▁private ▁final ▁int ▁startOffset ▁; ▁private ▁final ▁String ▁value ▁; ▁private ▁final ▁int ▁endOffset ▁; ▁String Literal ▁( ▁File Locations ▁loc s ▁, ▁int ▁startOffset ▁, ▁String ▁value ▁, ▁int ▁endOffset ▁) ▁{ ▁super ▁( ▁loc s ▁) ▁; ▁this ▁. ▁startOffset ▁= ▁startOffset ▁; ▁this ▁. ▁value ▁= ▁value ▁; ▁this ▁. ▁endOffset ▁= ▁endOffset ▁; ▁} ▁public ▁String ▁getValue ▁( ▁) ▁{ ▁return ▁value ▁; ▁} ▁public ▁Location ▁getLocation ▁( ▁) ▁{ ▁return ▁loc s ▁. ▁getLocation ▁( ▁startOffset ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getStart Offset ▁( ▁) ▁{ ▁return ▁startOffset ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getEnd Offset ▁( ▁) ▁{ ▁return ▁endOffset ▁; ▁} ▁@ ▁Override ▁public ▁void ▁accept ▁( ▁Node Visitor ▁visitor ▁) ▁{ ▁visitor ▁. ▁visit ▁( ▁this ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Kind ▁kind ▁( ▁) ▁{ ▁return ▁Kind ▁. ▁STRING _ L ITERAL ▁; ▁} ▁public ▁Object ▁getFile Locations ▁( ▁) ▁{ ▁return ▁loc s ▁; ▁} ▁public ▁static ▁String ▁un qu ote ▁( ▁String ▁s ▁) ▁{ ▁ArrayList ▁< ▁Syn tax Error ▁> ▁errors ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁Le xer ▁lexer ▁= ▁new ▁Le xer ▁( ▁Parser Input ▁. ▁from Lines ▁( ▁s ▁) ▁, ▁File Options ▁. ▁DEFAULT ▁, ▁errors ▁) ▁; ▁lexer ▁. ▁nextToken ▁( ▁) ▁; ▁if ▁( ▁! ▁errors ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁errors ▁. ▁get ▁( ▁0 ▁) ▁. ▁message ▁( ▁) ▁) ▁; ▁} ▁if ▁( ▁lexer ▁. ▁start ▁!= ▁0 ▁|| ▁lexer ▁. ▁end ▁!= ▁s ▁. ▁length ▁( ▁) ▁|| ▁lexer ▁. ▁kind ▁!= ▁Token Kind ▁. ▁STRING ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁return ▁( ▁String ▁) ▁lexer ▁. ▁value ▁; ▁} ▁public ▁static ▁String Literal ▁from Serialization ▁( ▁Object ▁file Locations ▁, ▁int ▁startOffset ▁, ▁String ▁value ▁, ▁int ▁endOffset ▁) ▁{ ▁return ▁new ▁String Literal ▁( ▁( ▁File Locations ▁) ▁file Locations ▁, ▁startOffset ▁, ▁value ▁, ▁endOffset ▁) ▁; ▁} ▁}
▁@ ▁StarlarkBuiltin ▁( ▁name ▁= ▁STR ▁, ▁category ▁= ▁DocCategory ▁. ▁PROVIDER ▁, ▁doc ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁, ▁documented ▁= ▁false ▁) ▁public ▁interface ▁Android Starlark Api Provider Api ▁< ▁FileT ▁extends ▁FileApi ▁> ▁extends ▁StarlarkValue ▁{ ▁@ ▁StarlarkMethod ▁( ▁name ▁= ▁STR ▁, ▁structField ▁= ▁true ▁, ▁allow Return Non es ▁= ▁true ▁, ▁doc ▁= ▁STR ▁, ▁documented ▁= ▁false ▁) ▁@ ▁Nullable ▁FileT ▁get Apk ▁( ▁) ▁; ▁@ ▁StarlarkMethod ▁( ▁name ▁= ▁STR ▁, ▁structField ▁= ▁true ▁, ▁allow Return Non es ▁= ▁true ▁, ▁doc ▁= ▁STR ▁, ▁documented ▁= ▁false ▁) ▁@ ▁Nullable ▁String ▁getJava Package ▁( ▁) ▁; ▁@ ▁StarlarkMethod ▁( ▁name ▁= ▁STR ▁, ▁structField ▁= ▁true ▁, ▁allow Return Non es ▁= ▁true ▁, ▁doc ▁= ▁STR ▁, ▁documented ▁= ▁false ▁) ▁@ ▁Nullable ▁FileT ▁get Manifest ▁( ▁) ▁; ▁@ ▁StarlarkMethod ▁( ▁name ▁= ▁STR ▁, ▁structField ▁= ▁true ▁, ▁allow Return Non es ▁= ▁true ▁, ▁doc ▁= ▁STR ▁, ▁documented ▁= ▁false ▁) ▁@ ▁Nullable ▁FileT ▁getM erged Manifest ▁( ▁) ▁; ▁@ ▁StarlarkMethod ▁( ▁name ▁= ▁STR ▁, ▁structField ▁= ▁true ▁, ▁doc ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁, ▁documented ▁= ▁false ▁) ▁ImmutableMap ▁< ▁String ▁, ▁Depset ▁> ▁getNative Libs ▁( ▁) ▁; ▁@ ▁StarlarkMethod ▁( ▁name ▁= ▁STR ▁, ▁structField ▁= ▁true ▁, ▁doc ▁= ▁STR ▁, ▁documented ▁= ▁false ▁, ▁allow Return Non es ▁= ▁true ▁) ▁@ ▁Nullable ▁FileT ▁getResource Apk ▁( ▁) ▁; ▁@ ▁StarlarkMethod ▁( ▁name ▁= ▁STR ▁, ▁structField ▁= ▁true ▁, ▁allow Return Non es ▁= ▁true ▁, ▁doc ▁= ▁STR ▁, ▁documented ▁= ▁false ▁) ▁@ ▁Nullable ▁Immutable Collection ▁< ▁FileT ▁> ▁get Apk s UnderTest ▁( ▁) ▁; ▁@ ▁StarlarkMethod ▁( ▁name ▁= ▁STR ▁, ▁structField ▁= ▁true ▁, ▁doc ▁= ▁STR ▁, ▁documented ▁= ▁false ▁) ▁boolean ▁def ines Android Resources ▁( ▁) ▁; ▁@ ▁StarlarkMethod ▁( ▁name ▁= ▁STR ▁, ▁structField ▁= ▁true ▁, ▁doc ▁= ▁STR ▁, ▁documented ▁= ▁false ▁) ▁Id l InfoApi ▁< ▁FileT ▁> ▁getId l Info ▁( ▁) ▁; ▁@ ▁StarlarkMethod ▁( ▁name ▁= ▁STR ▁, ▁structField ▁= ▁true ▁, ▁doc ▁= ▁STR ▁, ▁documented ▁= ▁false ▁) ▁Depset ▁getResources ▁( ▁) ▁; ▁@ ▁StarlarkMethod ▁( ▁name ▁= ▁STR ▁, ▁structField ▁= ▁true ▁, ▁allow Return Non es ▁= ▁true ▁, ▁doc ▁= ▁STR ▁, ▁documented ▁= ▁false ▁) ▁@ ▁Nullable ▁Java Output Api ▁< ▁FileT ▁> ▁getResource Jar ▁( ▁) ▁; ▁@ ▁StarlarkMethod ▁( ▁name ▁= ▁STR ▁, ▁structField ▁= ▁true ▁, ▁allow Return Non es ▁= ▁true ▁, ▁doc ▁= ▁STR ▁, ▁documented ▁= ▁false ▁) ▁@ ▁Nullable ▁FileT ▁getA ar ▁( ▁) ▁;
▁public ▁class ▁Dist Cp ▁{ ▁private ▁static ▁final ▁Logger ▁LOGGER ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Dist Cp ▁. ▁class ▁) ▁; ▁public ▁static ▁final ▁String ▁BYTES _ CO PI ED _ C NT _ NAME ▁= ▁STR ▁; ▁public ▁static ▁final ▁String ▁FI LES _ CO PI ED _ C NT _ NAME ▁= ▁STR ▁; ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁throws ▁Exception ▁{ ▁final ▁Execution Environment ▁env ▁= ▁Execution Environment ▁. ▁getExecution Environment ▁( ▁) ▁; ▁ParameterTool ▁params ▁= ▁ParameterTool ▁. ▁from Args ▁( ▁args ▁) ▁; ▁if ▁( ▁! ▁params ▁. ▁has ▁( ▁STR ▁) ▁|| ▁! ▁params ▁. ▁has ▁( ▁STR ▁) ▁) ▁{ ▁System ▁. ▁err ▁. ▁println ▁( ▁STR ▁) ▁; ▁return ▁; ▁} ▁final ▁Path ▁source Path ▁= ▁new ▁Path ▁( ▁params ▁. ▁get ▁( ▁STR ▁) ▁) ▁; ▁final ▁Path ▁target Path ▁= ▁new ▁Path ▁( ▁params ▁. ▁get ▁( ▁STR ▁) ▁) ▁; ▁if ▁( ▁! ▁isLocal ▁( ▁env ▁) ▁&& ▁! ▁( ▁isOn Distributed FS ▁( ▁source Path ▁) ▁&& ▁isOn Distributed FS ▁( ▁target Path ▁) ▁) ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁) ▁; ▁return ▁; ▁} ▁final ▁int ▁parallelism ▁= ▁params ▁. ▁getInt ▁( ▁STR ▁, ▁10 ▁) ▁; ▁if ▁( ▁parallelism ▁<= ▁0 ▁) ▁{ ▁System ▁. ▁err ▁. ▁println ▁( ▁STR ▁) ▁; ▁return ▁; ▁} ▁env ▁. ▁getConfig ▁( ▁) ▁. ▁setGlobal Job Parameters ▁( ▁params ▁) ▁; ▁env ▁. ▁setParallelism ▁( ▁parallelism ▁) ▁; ▁long ▁startTime ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁; ▁LOGGER ▁. ▁info ▁( ▁STR ▁) ▁; ▁List ▁< ▁FileCopy Task ▁> ▁tasks ▁= ▁get Copy Tasks ▁( ▁source Path ▁) ▁; ▁LOGGER ▁. ▁info ▁( ▁STR ▁+ ▁( ▁System ▁. ▁current TimeMillis ▁( ▁) ▁- ▁startTime ▁) ▁+ ▁STR ▁) ▁; ▁DataSet ▁< ▁FileCopy Task ▁> ▁input Tasks ▁= ▁new ▁DataSource ▁< ▁> ▁( ▁env ▁, ▁new ▁FileCopy Task InputFormat ▁( ▁tasks ▁) ▁, ▁new ▁Generic TypeInfo ▁< ▁> ▁( ▁FileCopy Task ▁. ▁class ▁) ▁, ▁STR ▁) ▁; ▁FlatMap Operator ▁< ▁FileCopy Task ▁, ▁Object ▁> ▁res ▁= ▁input Tasks ▁. ▁flatMap ▁( ▁new ▁Rich FlatMap Function ▁< ▁FileCopy Task ▁, ▁Object ▁> ▁( ▁) ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁110 92 54 23 0 24 3 98 99 29 L ▁; ▁private ▁Long Counter ▁file Counter ▁; ▁private ▁Long Counter ▁bytes Counter ▁; ▁@ ▁Override ▁public ▁void ▁open ▁( ▁Configuration ▁parameters ▁) ▁throws ▁Exception ▁{ ▁bytes Counter ▁= ▁getRuntime Context ▁( ▁) ▁. ▁getLong Counter ▁( ▁BYTES _ CO PI ED _ C NT _ NAME ▁) ▁; ▁file Counter ▁= ▁getRuntime Context ▁( ▁) ▁. ▁getLong Counter ▁( ▁FI LES _ CO PI ED _ C NT _ NAME ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁flatMap ▁( ▁FileCopy Task ▁task ▁, ▁Collector ▁< ▁Object ▁> ▁out ▁) ▁throws ▁Exception ▁{ ▁LOGGER ▁. ▁info ▁( ▁STR ▁+ ▁task ▁) ▁; ▁Path ▁out Path ▁= ▁new ▁Path ▁( ▁target Path ▁, ▁task ▁. ▁getRelative Path ▁( ▁) ▁) ▁;
▁INode File ▁file 3 Node ▁= ▁fs dir ▁. ▁getI Node 4 Write ▁( ▁file 3 ▁. ▁toString ▁( ▁) ▁) ▁. ▁as File ▁( ▁) ▁; ▁BlockInfo ▁[ ▁] ▁file 3 Blocks ▁= ▁file 3 Node ▁. ▁getBlocks ▁( ▁) ▁; ▁assertEquals ▁( ▁2 ▁, ▁file 3 Blocks ▁. ▁length ▁) ▁; ▁assertEquals ▁( ▁BLOCK SI Z E ▁, ▁file 3 Blocks ▁[ ▁0 ▁] ▁. ▁getNum Bytes ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁Block U C State ▁. ▁COMPLETE ▁, ▁file 3 Blocks ▁[ ▁0 ▁] ▁. ▁getBlock U C State ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁BLOCK SI Z E ▁- ▁1 ▁, ▁file 3 Blocks ▁[ ▁1 ▁] ▁. ▁getNum Bytes ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁Block U C State ▁. ▁COMPLETE ▁, ▁file 3 Blocks ▁[ ▁1 ▁] ▁. ▁getBlock U C State ▁( ▁) ▁) ▁; ▁INode File ▁file 4 Node ▁= ▁fs dir ▁. ▁getI Node 4 Write ▁( ▁file 4 ▁. ▁toString ▁( ▁) ▁) ▁. ▁as File ▁( ▁) ▁; ▁BlockInfo ▁[ ▁] ▁file 4 Blocks ▁= ▁file 4 Node ▁. ▁getBlocks ▁( ▁) ▁; ▁assertEquals ▁( ▁2 ▁, ▁file 4 Blocks ▁. ▁length ▁) ▁; ▁assertEquals ▁( ▁BLOCK SI Z E ▁, ▁file 4 Blocks ▁[ ▁0 ▁] ▁. ▁getNum Bytes ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁Block U C State ▁. ▁COMPLETE ▁, ▁file 4 Blocks ▁[ ▁0 ▁] ▁. ▁getBlock U C State ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁BLOCK SI Z E ▁, ▁file 4 Blocks ▁[ ▁1 ▁] ▁. ▁getNum Bytes ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁Block U C State ▁. ▁COMPLETE ▁, ▁file 4 Blocks ▁[ ▁1 ▁] ▁. ▁getBlock U C State ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testAdd Block U C ▁( ▁) ▁throws ▁Exception ▁{ ▁Distributed FileSystem ▁fs ▁= ▁cluster ▁. ▁getFileSystem ▁( ▁) ▁; ▁final ▁Path ▁file 1 ▁= ▁new ▁Path ▁( ▁STR ▁) ▁; ▁DFSTestUtil ▁. ▁createFile ▁( ▁fs ▁, ▁file 1 ▁, ▁BLOCK SI Z E ▁- ▁1 ▁, ▁REP LICATION ▁, ▁0 L ▁) ▁; ▁FSData OutputStream ▁out ▁= ▁null ▁; ▁try ▁{ ▁out ▁= ▁fs ▁. ▁append ▁( ▁file 1 ▁) ▁; ▁String ▁append Content ▁= ▁STR ▁; ▁out ▁. ▁writeBytes ▁( ▁append Content ▁) ▁; ▁( ▁( ▁DFS OutputStream ▁) ▁out ▁. ▁getWrapped Stream ▁( ▁) ▁) ▁. ▁hsync ▁( ▁EnumSet ▁. ▁of ▁( ▁Sync Flag ▁. ▁UPDATE _ LENGTH ▁) ▁) ▁; ▁cluster ▁. ▁restart NameNode ▁( ▁true ▁) ▁; ▁FS Directory ▁fs dir ▁= ▁cluster ▁. ▁getName system ▁( ▁) ▁. ▁getFS Directory ▁( ▁) ▁; ▁INode File ▁file Node ▁= ▁fs dir ▁. ▁getI Node 4 Write ▁( ▁file 1 ▁. ▁toString ▁( ▁) ▁) ▁. ▁as File ▁( ▁) ▁; ▁BlockInfo ▁[ ▁] ▁file Blocks ▁= ▁file Node ▁. ▁getBlocks ▁( ▁) ▁; ▁assertEquals ▁( ▁2 ▁, ▁file Blocks ▁. ▁length ▁) ▁; ▁assertEquals ▁( ▁BLOCK SI Z E ▁, ▁file Blocks ▁[ ▁0 ▁] ▁. ▁getNum Bytes ▁( ▁) ▁) ▁;
▁public ▁static ▁final ▁long ▁B REG 20 ▁= ▁0 x 84 ▁; ▁public ▁static ▁final ▁long ▁B REG 21 ▁= ▁0 x 85 ▁; ▁public ▁static ▁final ▁long ▁B REG 22 ▁= ▁0 x 86 ▁; ▁public ▁static ▁final ▁long ▁B REG 23 ▁= ▁0 x 87 ▁; ▁public ▁static ▁final ▁long ▁B REG 24 ▁= ▁0 x 88 ▁; ▁public ▁static ▁final ▁long ▁B REG 25 ▁= ▁0 x 89 ▁; ▁public ▁static ▁final ▁long ▁B REG 26 ▁= ▁0 x 8 a ▁; ▁public ▁static ▁final ▁long ▁B REG 2 7 ▁= ▁0 x 8 b ▁; ▁public ▁static ▁final ▁long ▁B REG 28 ▁= ▁0 x 8 c ▁; ▁public ▁static ▁final ▁long ▁B REG 29 ▁= ▁0 x 8 d ▁; ▁public ▁static ▁final ▁long ▁B REG 30 ▁= ▁0 x 8 e ▁; ▁public ▁static ▁final ▁long ▁B REG 31 ▁= ▁0 x 8 f ▁; ▁public ▁static ▁final ▁long ▁REG X ▁= ▁0 x 90 ▁; ▁public ▁static ▁final ▁long ▁F B REG ▁= ▁0 x 9 1 ▁; ▁public ▁static ▁final ▁long ▁B REG X ▁= ▁0 x 92 ▁; ▁public ▁static ▁final ▁long ▁P IE CE ▁= ▁0 x 93 ▁; ▁public ▁static ▁final ▁long ▁D ER E F _ SI Z E ▁= ▁0 x 94 ▁; ▁public ▁static ▁final ▁long ▁X DER E F _ SI Z E ▁= ▁0 x 95 ▁; ▁public ▁static ▁final ▁long ▁NO P ▁= ▁0 x 96 ▁; ▁public ▁static ▁final ▁long ▁P U SH _ OBJECT _ ADDRESS ▁= ▁0 x 97 ▁; ▁public ▁static ▁final ▁long ▁CALL 2 ▁= ▁0 x 98 ▁; ▁public ▁static ▁final ▁long ▁CALL 4 ▁= ▁0 x 99 ▁; ▁public ▁static ▁final ▁long ▁CALL _ REF ▁= ▁0 x 9 a ▁; ▁public ▁static ▁final ▁long ▁FORM _ TLS _ ADDRESS ▁= ▁0 x 9 b ▁; ▁public ▁static ▁final ▁long ▁CALL _ FRAME _ C FA ▁= ▁0 x 9 c ▁; ▁public ▁static ▁final ▁long ▁B IT _ PI E CE ▁= ▁0 x 9 d ▁; ▁public ▁static ▁final ▁long ▁IMP LIC IT _ VALUE ▁= ▁0 x 9 e ▁; ▁public ▁static ▁final ▁long ▁STACK _ VALUE ▁= ▁0 x 9 f ▁; ▁public ▁static ▁final ▁long ▁IMP LIC IT _ PO long ER ▁= ▁0 xa 0 ▁; ▁public ▁static ▁final ▁long ▁ADD R X ▁= ▁0 xa 1 ▁; ▁public ▁static ▁final ▁long ▁CON ST X ▁= ▁0 xa 2 ▁; ▁public ▁static ▁final ▁long ▁EN TRY _ VALUE ▁= ▁0 xa 3 ▁; ▁public ▁static ▁final ▁long ▁CON ST _ TYPE ▁= ▁0 xa 4 ▁; ▁public ▁static ▁final ▁long ▁REG VAL _ TYPE ▁= ▁0 xa 5 ▁; ▁public ▁static ▁final ▁long ▁D ER E F _ TYPE ▁= ▁0 xa 6 ▁; ▁public ▁static ▁final ▁long ▁X DER E F _ TYPE ▁= ▁0 xa 7 ▁; ▁public ▁static ▁final ▁long ▁CON VER T ▁= ▁0 xa 8 ▁; ▁public ▁static ▁final ▁long ▁RE INTER PRE T ▁= ▁0 xa 9 ▁;
▁final ▁class ▁T s Binary Search Seek er ▁extends ▁Binary Search Seek er ▁{ ▁private ▁static ▁final ▁long ▁SE E K _ TO LER ANCE _ US ▁= ▁100 _000 ▁; ▁private ▁static ▁final ▁int ▁MIN IMUM _ SEARCH _ RANGE _ BYTES ▁= ▁5 ▁ * ▁T s Extractor ▁. ▁T S _ P ACKET _ SI Z E ▁; ▁public ▁T s Binary Search Seek er ▁( ▁Timestamp Adj uster ▁pcr Timestamp Adj uster ▁, ▁long ▁stream Duration Us ▁, ▁long ▁input Length ▁, ▁int ▁pcr Pid ▁, ▁int ▁timestamp Search Bytes ▁) ▁{ ▁super ▁( ▁new ▁Default Seek Timestamp Converter ▁( ▁) ▁, ▁new ▁T s P cr Seek er ▁( ▁pcr Pid ▁, ▁pcr Timestamp Adj uster ▁, ▁timestamp Search Bytes ▁) ▁, ▁stream Duration Us ▁, ▁0 ▁, ▁stream Duration Us ▁+ ▁1 ▁, ▁0 ▁, ▁input Length ▁, ▁T s Extractor ▁. ▁T S _ P ACKET _ SI Z E ▁, ▁MIN IMUM _ SEARCH _ RANGE _ BYTES ▁) ▁; ▁} ▁private ▁static ▁final ▁class ▁T s P cr Seek er ▁implements ▁Timestamp Seek er ▁{ ▁private ▁final ▁Timestamp Adj uster ▁pcr Timestamp Adj uster ▁; ▁private ▁final ▁Parsable ByteArray ▁packet Buffer ▁; ▁private ▁final ▁int ▁pcr Pid ▁; ▁private ▁final ▁int ▁timestamp Search Bytes ▁; ▁public ▁T s P cr Seek er ▁( ▁int ▁pcr Pid ▁, ▁Timestamp Adj uster ▁pcr Timestamp Adj uster ▁, ▁int ▁timestamp Search Bytes ▁) ▁{ ▁this ▁. ▁pcr Pid ▁= ▁pcr Pid ▁; ▁this ▁. ▁pcr Timestamp Adj uster ▁= ▁pcr Timestamp Adj uster ▁; ▁this ▁. ▁timestamp Search Bytes ▁= ▁timestamp Search Bytes ▁; ▁packet Buffer ▁= ▁new ▁Parsable ByteArray ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Timestamp SearchResult ▁search For Timestamp ▁( ▁Extractor Input ▁input ▁, ▁long ▁target Timestamp ▁) ▁throws ▁IOException ▁{ ▁long ▁input Position ▁= ▁input ▁. ▁getPosition ▁( ▁) ▁; ▁int ▁bytesTo Search ▁= ▁( ▁int ▁) ▁min ▁( ▁timestamp Search Bytes ▁, ▁input ▁. ▁getLength ▁( ▁) ▁- ▁input Position ▁) ▁; ▁packet Buffer ▁. ▁reset ▁( ▁bytesTo Search ▁) ▁; ▁input ▁. ▁peek Fully ▁( ▁packet Buffer ▁. ▁getData ▁( ▁) ▁, ▁0 ▁, ▁bytesTo Search ▁) ▁; ▁return ▁search For P cr Value In Buffer ▁( ▁packet Buffer ▁, ▁target Timestamp ▁, ▁input Position ▁) ▁; ▁} ▁private ▁Timestamp SearchResult ▁search For P cr Value In Buffer ▁( ▁Parsable ByteArray ▁packet Buffer ▁, ▁long ▁target P cr TimeUs ▁, ▁long ▁buffer Start Offset ▁) ▁{ ▁int ▁limit ▁= ▁packet Buffer ▁. ▁limit ▁( ▁) ▁; ▁long ▁start Of Last Packet Position ▁= ▁C ▁. ▁POSITION _ UNSET ▁; ▁long ▁endOf Last Packet Position ▁= ▁C ▁. ▁POSITION _ UNSET ▁; ▁long ▁last P cr TimeUs InRange ▁= ▁C ▁. ▁TIME _ UNSET ▁;
▁public ▁final ▁class ▁Edit Profile Name ViewModel ▁extends ▁ViewModel ▁{ ▁private ▁final ▁Man age Profile Repository ▁repository ▁; ▁private ▁final ▁MutableLiveData ▁< ▁SaveState ▁> ▁saveState ▁; ▁private ▁final ▁Single Live Event ▁< ▁Event ▁> ▁events ▁; ▁public ▁Edit Profile Name ViewModel ▁( ▁) ▁{ ▁this ▁. ▁repository ▁= ▁new ▁Man age Profile Repository ▁( ▁) ▁; ▁this ▁. ▁saveState ▁= ▁new ▁MutableLiveData ▁< ▁> ▁( ▁SaveState ▁. ▁ID LE ▁) ▁; ▁this ▁. ▁events ▁= ▁new ▁Single Live Event ▁< ▁> ▁( ▁) ▁; ▁} ▁void ▁on Given Name Length Changed ▁( ▁int ▁length ▁) ▁{ ▁if ▁( ▁length ▁<= ▁0 ▁) ▁{ ▁saveState ▁. ▁setValue ▁( ▁SaveState ▁. ▁DISABLED ▁) ▁; ▁} ▁else ▁{ ▁saveState ▁. ▁setValue ▁( ▁SaveState ▁. ▁ID LE ▁) ▁; ▁} ▁} ▁@ ▁NonNull ▁LiveData ▁< ▁SaveState ▁> ▁getS ave State ▁( ▁) ▁{ ▁return ▁saveState ▁; ▁} ▁@ ▁NonNull ▁LiveData ▁< ▁Event ▁> ▁get Events ▁( ▁) ▁{ ▁return ▁events ▁; ▁} ▁void ▁on Save Clicked ▁( ▁@ ▁NonNull ▁Context ▁context ▁, ▁@ ▁NonNull ▁String ▁given Name ▁, ▁@ ▁NonNull ▁String ▁family Name ▁) ▁{ ▁saveState ▁. ▁setValue ▁( ▁SaveState ▁. ▁IN _ PROGRESS ▁) ▁; ▁repository ▁. ▁setName ▁( ▁context ▁, ▁Profile Name ▁. ▁from Parts ▁( ▁given Name ▁, ▁family Name ▁) ▁, ▁result ▁-> ▁{ ▁switch ▁( ▁result ▁) ▁{ ▁case ▁SUCCESS ▁: ▁saveState ▁. ▁postValue ▁( ▁SaveState ▁. ▁D ONE ▁) ▁; ▁break ▁; ▁case ▁FAILURE _ NET WORK ▁: ▁saveState ▁. ▁postValue ▁( ▁SaveState ▁. ▁ID LE ▁) ▁; ▁events ▁. ▁postValue ▁( ▁Event ▁. ▁NETWORK _ FAILURE ▁) ▁; ▁break ▁; ▁} ▁} ▁) ▁; ▁} ▁enum ▁SaveState ▁{ ▁ID LE ▁, ▁IN _ PROGRESS ▁, ▁D ONE ▁, ▁DISABLED ▁} ▁enum ▁Event ▁{ ▁NETWORK _ FAILURE ▁} ▁}
▁@ ▁Interface Audience ▁. ▁Public ▁@ ▁Interface Stability ▁. ▁Evolving ▁public ▁final ▁class ▁Shutdown Hook Manager ▁{ ▁private ▁static ▁final ▁Shutdown Hook Manager ▁M GR ▁= ▁new ▁Shutdown Hook Manager ▁( ▁) ▁; ▁private ▁static ▁final ▁Logger ▁LOG ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Shutdown Hook Manager ▁. ▁class ▁) ▁; ▁public ▁static ▁final ▁long ▁TIMEOUT _ MINIMUM ▁= ▁1 ▁; ▁public ▁static ▁final ▁TimeUnit ▁TIME _ UNIT _ DEFAULT ▁= ▁TimeUnit ▁. ▁SECONDS ▁; ▁private ▁static ▁final ▁ExecutorService ▁EXEC UT OR ▁= ▁Hadoop Executors ▁. ▁newSingle ThreadExecutor ▁( ▁new ▁Thread FactoryBuilder ▁( ▁) ▁. ▁setDaemon ▁( ▁true ▁) ▁. ▁setName Format ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁static ▁{ ▁try ▁{ ▁Runtime ▁. ▁getRuntime ▁( ▁) ▁. ▁addShutdownHook ▁( ▁new ▁Thread ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁run ▁( ▁) ▁{ ▁if ▁( ▁M GR ▁. ▁shutdown InProgress ▁. ▁getAndSet ▁( ▁true ▁) ▁) ▁{ ▁LOG ▁. ▁info ▁( ▁STR ▁) ▁; ▁return ▁; ▁} ▁long ▁started ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁; ▁int ▁timeout Count ▁= ▁M GR ▁. ▁execute Shutdown ▁( ▁) ▁; ▁long ▁en ded ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁; ▁LOG ▁. ▁debug ▁( ▁String ▁. ▁format ▁( ▁STR ▁, ▁( ▁en ded ▁- ▁started ▁) ▁ / ▁1000 .0 ▁, ▁timeout Count ▁) ▁) ▁; ▁shutdown Executor ▁( ▁new ▁Configuration ▁( ▁) ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁catch ▁( ▁Illegal StateException ▁ex ▁) ▁{ ▁LOG ▁. ▁warn ▁( ▁STR ▁, ▁ex ▁) ▁; ▁} ▁} ▁@ ▁Interface Audience ▁. ▁Private ▁@ ▁Visible ForTesting ▁int ▁execute Shutdown ▁( ▁) ▁{ ▁int ▁timeout s ▁= ▁0 ▁; ▁for ▁( ▁H ook Entry ▁entry ▁: ▁get ShutdownHook sIn Order ▁( ▁) ▁) ▁{ ▁Future ▁< ▁? ▁> ▁future ▁= ▁EXEC UT OR ▁. ▁submit ▁( ▁entry ▁. ▁getH ook ▁( ▁) ▁) ▁; ▁try ▁{ ▁future ▁. ▁get ▁( ▁entry ▁. ▁getTimeout ▁( ▁) ▁, ▁entry ▁. ▁getTime Unit ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁Timeout Exception ▁ex ▁) ▁{ ▁timeout s ▁++ ▁; ▁future ▁. ▁cancel ▁( ▁true ▁) ▁; ▁LOG ▁. ▁warn ▁( ▁STR ▁+ ▁entry ▁. ▁getH ook ▁( ▁) ▁. ▁getClass ▁( ▁) ▁. ▁getSimpleName ▁( ▁) ▁+ ▁STR ▁+ ▁ex ▁. ▁toString ▁( ▁) ▁, ▁ex ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁ex ▁) ▁{ ▁LOG ▁. ▁warn ▁( ▁STR ▁+ ▁entry ▁. ▁getH ook ▁( ▁) ▁. ▁getClass ▁( ▁) ▁. ▁getSimpleName ▁( ▁) ▁+ ▁STR ▁+ ▁ex ▁. ▁toString ▁( ▁) ▁, ▁ex ▁) ▁; ▁} ▁} ▁return ▁timeout s ▁; ▁} ▁private ▁static ▁void ▁shutdown Executor ▁( ▁final ▁Configuration ▁conf ▁) ▁{ ▁try ▁{ ▁EXEC UT OR ▁. ▁shutdown ▁( ▁) ▁; ▁long ▁shutdown Timeout ▁= ▁get Shutdown Timeout ▁( ▁conf ▁) ▁; ▁if ▁( ▁! ▁EXEC UT OR ▁. ▁await Termination ▁( ▁shutdown Timeout ▁, ▁TIME _ UNIT _ DEFAULT ▁) ▁) ▁{ ▁LOG ▁. ▁error ▁( ▁STR ▁+ ▁STR ▁, ▁shutdown Timeout ▁) ▁; ▁EXEC UT OR ▁. ▁shutdownNow ▁( ▁) ▁; ▁} ▁LOG ▁. ▁debug ▁( ▁STR ▁) ▁; ▁}
▁public ▁class ▁DateTime Parse ▁extends ▁Base DateTime Parse Function ▁{ ▁public ▁DateTime Parse ▁( ▁Source ▁source ▁, ▁Expression ▁timestamp ▁, ▁Expression ▁pattern ▁, ▁ Z oneId ▁zoneId ▁) ▁{ ▁super ▁( ▁source ▁, ▁timestamp ▁, ▁pattern ▁, ▁zoneId ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Parser ▁parser ▁( ▁) ▁{ ▁return ▁DATE _ TIME ▁; ▁} ▁@ ▁Override ▁protected ▁NodeInfo ▁. ▁Node C t or 3 ▁< ▁Expression ▁, ▁Expression ▁, ▁ Z oneId ▁, ▁Base DateTime Parse Function ▁> ▁ct or For Info ▁( ▁) ▁{ ▁return ▁DateTime Parse ▁:: ▁new ▁; ▁} ▁@ ▁Override ▁public ▁DataType ▁dataType ▁( ▁) ▁{ ▁return ▁DataTypes ▁. ▁DATE TIME ▁; ▁} ▁@ ▁Override ▁protected ▁Binary ScalarFunction ▁replaceChildren ▁( ▁Expression ▁timestamp ▁, ▁Expression ▁pattern ▁) ▁{ ▁return ▁new ▁DateTime Parse ▁( ▁source ▁( ▁) ▁, ▁timestamp ▁, ▁pattern ▁, ▁zoneId ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁String ▁script MethodName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁}
▁@ ▁RunWith ▁( ▁MockitoJUnit Runner ▁. ▁class ▁) ▁public ▁final ▁class ▁Sharding Drop TableStatement Validator Test ▁{ ▁@ ▁Mock ▁private ▁ShardingRule ▁sharding Rule ▁; ▁@ ▁Mock ▁private ▁RouteContext ▁routeContext ▁; ▁@ ▁Before ▁public ▁void ▁init ▁( ▁) ▁{ ▁Collection ▁< ▁Table Rule ▁> ▁table Rules ▁= ▁new ▁LinkedList ▁< ▁> ▁( ▁) ▁; ▁table Rules ▁. ▁add ▁( ▁generate Sharding Rule ▁( ▁STR ▁) ▁) ▁; ▁table Rules ▁. ▁add ▁( ▁generate Sharding Rule ▁( ▁STR ▁) ▁) ▁; ▁when ▁( ▁sharding Rule ▁. ▁getTable Rules ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁table Rules ▁) ▁; ▁} ▁@ ▁Test ▁( ▁expected ▁= ▁ShardingSphere Exception ▁. ▁class ▁) ▁public ▁void ▁assert Validate Drop Table For My SQL ▁( ▁) ▁{ ▁MySQL Drop TableStatement ▁sqlStatement ▁= ▁new ▁MySQL Drop TableStatement ▁( ▁) ▁; ▁sqlStatement ▁. ▁getTables ▁( ▁) ▁. ▁add ▁( ▁new ▁Simple TableSegment ▁( ▁new ▁TableName Segment ▁( ▁0 ▁, ▁0 ▁, ▁new ▁IdentifierValue ▁( ▁STR ▁) ▁) ▁) ▁) ▁; ▁SQLStatement Context ▁< ▁Drop TableStatement ▁> ▁sql StatementContext ▁= ▁new ▁Common SQL StatementContext ▁< ▁> ▁( ▁sqlStatement ▁) ▁; ▁ShardingSphere Schema ▁schema ▁= ▁mock ▁( ▁ShardingSphere Schema ▁. ▁class ▁) ▁; ▁Sharding Drop TableStatement Validator ▁validator ▁= ▁new ▁Sharding Drop TableStatement Validator ▁( ▁) ▁; ▁validator ▁. ▁pre Validate ▁( ▁sharding Rule ▁, ▁sql StatementContext ▁, ▁Collections ▁. ▁emptyList ▁( ▁) ▁, ▁schema ▁) ▁; ▁Collection ▁< ▁RouteUnit ▁> ▁route Units ▁= ▁new ▁LinkedList ▁< ▁> ▁( ▁) ▁; ▁Route Mapper ▁dataSource Mapper ▁= ▁new ▁Route Mapper ▁( ▁STR ▁, ▁STR ▁) ▁; ▁Collection ▁< ▁Route Mapper ▁> ▁table Mapper ▁= ▁new ▁LinkedList ▁< ▁> ▁( ▁) ▁; ▁table Mapper ▁. ▁add ▁( ▁new ▁Route Mapper ▁( ▁STR ▁, ▁STR ▁) ▁) ▁; ▁table Mapper ▁. ▁add ▁( ▁new ▁Route Mapper ▁( ▁STR ▁, ▁STR ▁) ▁) ▁; ▁RouteUnit ▁route Unit ▁= ▁new ▁RouteUnit ▁( ▁dataSource Mapper ▁, ▁table Mapper ▁) ▁; ▁route Units ▁. ▁add ▁( ▁route Unit ▁) ▁; ▁RouteContext ▁routeContext ▁= ▁mock ▁( ▁RouteContext ▁. ▁class ▁) ▁; ▁when ▁( ▁routeContext ▁. ▁getRoute Units ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁route Units ▁) ▁; ▁validator ▁. ▁post Validate ▁( ▁sharding Rule ▁, ▁new ▁Drop Table StatementContext ▁( ▁sqlStatement ▁) ▁, ▁routeContext ▁, ▁schema ▁) ▁; ▁} ▁private ▁Table Rule ▁generate Sharding Rule ▁( ▁final ▁String ▁tableName ▁) ▁{ ▁Table Rule ▁result ▁= ▁mock ▁( ▁Table Rule ▁. ▁class ▁) ▁; ▁when ▁( ▁result ▁. ▁getLog ic Table ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁tableName ▁) ▁; ▁List ▁< ▁DataNode ▁> ▁data Nodes ▁= ▁new ▁LinkedList ▁< ▁> ▁( ▁) ▁; ▁DataNode ▁d 1 ▁= ▁mock ▁( ▁DataNode ▁. ▁class ▁) ▁; ▁when ▁( ▁d 1 ▁. ▁getTableName ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁STR ▁) ▁; ▁data Nodes ▁. ▁add ▁( ▁d 1 ▁) ▁; ▁DataNode ▁d 2 ▁= ▁mock ▁( ▁DataNode ▁. ▁class ▁) ▁; ▁when ▁( ▁d 2 ▁. ▁getTableName ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁STR ▁) ▁; ▁data Nodes ▁. ▁add ▁( ▁d 2 ▁) ▁; ▁when ▁( ▁result ▁. ▁getActual DataNodes ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁data Nodes ▁) ▁;
▁private ▁void ▁write Delta Values ▁( ▁) ▁{ ▁int ▁fixed Bits ▁= ▁getC lose st Aligned Fixed Bits ▁( ▁bits Delta Max ▁) ▁; ▁int ▁length ▁; ▁int ▁encode Bit Width ▁= ▁0 ▁; ▁if ▁( ▁is Fixed Delta ▁) ▁{ ▁if ▁( ▁fixed Run Length ▁> ▁MIN _ RE PEAT ▁) ▁{ ▁length ▁= ▁fixed Run Length ▁- ▁1 ▁; ▁fixed Run Length ▁= ▁0 ▁; ▁} ▁else ▁{ ▁length ▁= ▁variable Run Length ▁- ▁1 ▁; ▁variable Run Length ▁= ▁0 ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁fixed Bits ▁== ▁1 ▁) ▁{ ▁fixed Bits ▁= ▁2 ▁; ▁} ▁encode Bit Width ▁= ▁encode Bit Width ▁( ▁fixed Bits ▁) ▁<< ▁1 ▁; ▁length ▁= ▁variable Run Length ▁- ▁1 ▁; ▁variable Run Length ▁= ▁0 ▁; ▁} ▁final ▁int ▁tail Bits ▁= ▁( ▁length ▁& ▁0 x 100 ▁) ▁>>> ▁8 ▁; ▁final ▁int ▁header First Byte ▁= ▁Encoding Type ▁. ▁DE LTA ▁. ▁getOp Code ▁( ▁) ▁| ▁encode Bit Width ▁| ▁tail Bits ▁; ▁final ▁int ▁header Second Byte ▁= ▁length ▁& ▁0 xff ▁; ▁buffer ▁. ▁write ▁( ▁header First Byte ▁) ▁; ▁buffer ▁. ▁write ▁( ▁header Second Byte ▁) ▁; ▁if ▁( ▁signed ▁) ▁{ ▁write V sl ong ▁( ▁buffer ▁, ▁literal s ▁[ ▁0 ▁] ▁) ▁; ▁} ▁else ▁{ ▁write V ulong ▁( ▁buffer ▁, ▁literal s ▁[ ▁0 ▁] ▁) ▁; ▁} ▁if ▁( ▁is Fixed Delta ▁) ▁{ ▁write V sl ong ▁( ▁buffer ▁, ▁fixed Delta ▁) ▁; ▁} ▁else ▁{ ▁write V sl ong ▁( ▁buffer ▁, ▁adj Del tas ▁[ ▁0 ▁] ▁) ▁; ▁util s ▁. ▁writeInt s ▁( ▁adj Del tas ▁, ▁1 ▁, ▁num Literal s ▁- ▁2 ▁, ▁fixed Bits ▁, ▁buffer ▁) ▁; ▁} ▁} ▁private ▁void ▁write Patch ed Base Values ▁( ▁) ▁{ ▁prepare Patch ed Blob ▁( ▁) ▁; ▁final ▁int ▁fb ▁= ▁br Bits 95 p ▁; ▁final ▁int ▁e fb ▁= ▁encode Bit Width ▁( ▁fb ▁) ▁<< ▁1 ▁; ▁variable Run Length ▁-= ▁1 ▁; ▁final ▁int ▁tail Bits ▁= ▁( ▁variable Run Length ▁& ▁0 x 100 ▁) ▁>>> ▁8 ▁; ▁final ▁int ▁header First Byte ▁= ▁Encoding Type ▁. ▁P ATCH ED _ BASE ▁. ▁getOp Code ▁( ▁) ▁| ▁e fb ▁| ▁tail Bits ▁; ▁final ▁int ▁header Second Byte ▁= ▁variable Run Length ▁& ▁0 xff ▁; ▁final ▁boolean ▁is Negative ▁= ▁min ▁< ▁0 ▁; ▁if ▁( ▁is Negative ▁) ▁{ ▁min ▁= ▁- ▁min ▁; ▁} ▁final ▁int ▁base Width ▁= ▁find Close st Num Bits ▁( ▁min ▁) ▁+ ▁1 ▁; ▁final ▁int ▁base Bytes ▁= ▁base Width ▁ % ▁8 ▁== ▁0 ▁? ▁base Width ▁ / ▁8 ▁: ▁( ▁base Width ▁ / ▁8 ▁) ▁+ ▁1 ▁; ▁final ▁int ▁bb ▁= ▁( ▁base Bytes ▁- ▁1 ▁) ▁<< ▁5 ▁; ▁if ▁( ▁is Negative ▁) ▁{ ▁min ▁|= ▁( ▁1 L ▁<< ▁( ▁( ▁base Bytes ▁ * ▁8 ▁) ▁- ▁1 ▁) ▁) ▁; ▁}
▁public ▁static ▁void ▁serialize Properties ▁( ▁@ ▁NotNull ▁Json Writer ▁json ▁, ▁@ ▁NotNull ▁String ▁tag Name ▁, ▁@ ▁Nullable ▁Map ▁< ▁String ▁, ▁? ▁> ▁properties ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁! ▁CommonUtils ▁. ▁isEmpty ▁( ▁properties ▁) ▁) ▁{ ▁json ▁. ▁name ▁( ▁tag Name ▁) ▁; ▁serialize Map ▁( ▁json ▁, ▁properties ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁serialize Collection ▁( ▁@ ▁NotNull ▁Json Writer ▁json ▁, ▁@ ▁NotNull ▁Collection ▁< ▁? ▁> ▁list ▁) ▁throws ▁IOException ▁{ ▁json ▁. ▁begin Array ▁( ▁) ▁; ▁for ▁( ▁Object ▁value ▁: ▁CommonUtils ▁. ▁safe Collection ▁( ▁list ▁) ▁) ▁{ ▁if ▁( ▁value ▁== ▁null ▁) ▁{ ▁json ▁. ▁nullValue ▁( ▁) ▁; ▁} ▁else ▁if ▁( ▁value ▁instanceof ▁Number ▁) ▁{ ▁json ▁. ▁value ▁( ▁( ▁Number ▁) ▁value ▁) ▁; ▁} ▁else ▁if ▁( ▁value ▁instanceof ▁Boolean ▁) ▁{ ▁json ▁. ▁value ▁( ▁( ▁Boolean ▁) ▁value ▁) ▁; ▁} ▁else ▁if ▁( ▁value ▁instanceof ▁String ▁) ▁{ ▁json ▁. ▁value ▁( ▁value ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁value ▁instanceof ▁Map ▁) ▁{ ▁serialize Map ▁( ▁json ▁, ▁( ▁Map ▁< ▁String ▁, ▁? ▁> ▁) ▁value ▁) ▁; ▁} ▁else ▁if ▁( ▁value ▁instanceof ▁Collection ▁) ▁{ ▁serialize Collection ▁( ▁json ▁, ▁( ▁Collection ▁< ▁? ▁> ▁) ▁value ▁) ▁; ▁} ▁else ▁{ ▁json ▁. ▁value ▁( ▁value ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁} ▁json ▁. ▁endArray ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁serialize Map ▁( ▁@ ▁NotNull ▁Json Writer ▁json ▁, ▁@ ▁NotNull ▁Map ▁< ▁String ▁, ▁? ▁> ▁map ▁) ▁throws ▁IOException ▁{ ▁json ▁. ▁begin Object ▁( ▁) ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁? ▁> ▁entry ▁: ▁map ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁Object ▁prop Value ▁= ▁entry ▁. ▁getValue ▁( ▁) ▁; ▁String ▁fieldName ▁= ▁entry ▁. ▁getKey ▁( ▁) ▁; ▁if ▁( ▁prop Value ▁== ▁null ▁) ▁{ ▁} ▁else ▁if ▁( ▁prop Value ▁instanceof ▁Number ▁) ▁{ ▁field ▁( ▁json ▁, ▁fieldName ▁, ▁( ▁Number ▁) ▁prop Value ▁) ▁; ▁} ▁else ▁if ▁( ▁prop Value ▁instanceof ▁String ▁) ▁{ ▁String ▁str Value ▁= ▁( ▁String ▁) ▁prop Value ▁; ▁if ▁( ▁! ▁str Value ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁field ▁( ▁json ▁, ▁fieldName ▁, ▁str Value ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁prop Value ▁instanceof ▁Boolean ▁) ▁{ ▁field ▁( ▁json ▁, ▁fieldName ▁, ▁( ▁Boolean ▁) ▁prop Value ▁) ▁; ▁} ▁else ▁if ▁( ▁prop Value ▁instanceof ▁Collection ▁) ▁{ ▁serialize Object List ▁( ▁json ▁, ▁fieldName ▁, ▁( ▁Collection ▁< ▁? ▁> ▁) ▁prop Value ▁) ▁; ▁} ▁else ▁if ▁( ▁prop Value ▁instanceof ▁Map ▁) ▁{ ▁serialize Properties ▁( ▁json ▁, ▁fieldName ▁, ▁( ▁Map ▁< ▁String ▁, ▁? ▁> ▁) ▁prop Value ▁) ▁; ▁} ▁else ▁{ ▁log ▁. ▁debug ▁( ▁STR ▁+ ▁prop Value ▁. ▁getClass ▁( ▁) ▁. ▁getName ▁( ▁) ▁) ▁; ▁field ▁( ▁json ▁, ▁fieldName ▁, ▁prop Value ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁File Man ip ulation ▁{ ▁void ▁move ▁( ▁final ▁Path ▁origin ▁, ▁final ▁Path ▁destination ▁) ▁{ ▁try ▁{ ▁Files ▁. ▁create Directories ▁( ▁destination ▁) ▁; ▁Files ▁. ▁move ▁( ▁origin ▁, ▁destination ▁, ▁Standard Copy Option ▁. ▁REPLACE _ EXISTING ▁) ▁; ▁} ▁catch ▁( ▁final ▁IOException ▁ex ▁) ▁{ ▁throw ▁new ▁Unchecked IOException ▁( ▁ex ▁) ▁; ▁} ▁} ▁}
▁assertFalse ▁( ▁STR ▁, ▁user ▁. ▁getBuild s ▁( ▁) ▁. ▁contains ▁( ▁build 2 ▁) ▁) ▁; ▁assertFalse ▁( ▁STR ▁, ▁User ▁. ▁current ▁( ▁) ▁. ▁getBuild s ▁( ▁) ▁. ▁contains ▁( ▁build ▁) ▁) ▁; ▁assertTrue ▁( ▁STR ▁, ▁User ▁. ▁current ▁( ▁) ▁. ▁getBuild s ▁( ▁) ▁. ▁contains ▁( ▁build 2 ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Save ▁( ▁) ▁throws ▁Exception ▁{ ▁{ ▁User ▁user ▁= ▁User ▁. ▁get ▁( ▁STR ▁, ▁true ▁, ▁Collections ▁. ▁emptyMap ▁( ▁) ▁) ▁; ▁} ▁j ▁. ▁jenkins ▁. ▁reload ▁( ▁) ▁; ▁{ ▁User ▁user ▁= ▁User ▁. ▁get ▁( ▁STR ▁, ▁false ▁, ▁Collections ▁. ▁emptyMap ▁( ▁) ▁) ▁; ▁assertNull ▁( ▁STR ▁, ▁user ▁) ▁; ▁user ▁= ▁User ▁. ▁get ▁( ▁STR ▁, ▁true ▁, ▁Collections ▁. ▁emptyMap ▁( ▁) ▁) ▁; ▁user ▁. ▁addProperty ▁( ▁new ▁Some User Property ▁( ▁) ▁) ▁; ▁user ▁. ▁save ▁( ▁) ▁; ▁} ▁j ▁. ▁jenkins ▁. ▁reload ▁( ▁) ▁; ▁{ ▁User ▁user ▁= ▁User ▁. ▁get ▁( ▁STR ▁, ▁false ▁, ▁Collections ▁. ▁emptyMap ▁( ▁) ▁) ▁; ▁assertNotNull ▁( ▁STR ▁, ▁user ▁) ▁; ▁assertNotNull ▁( ▁STR ▁, ▁user ▁. ▁getProperty ▁( ▁Some User Property ▁. ▁class ▁) ▁) ▁; ▁} ▁} ▁@ ▁Issue ▁( ▁STR ▁) ▁@ ▁Test ▁public ▁void ▁unre coverable FullName ▁( ▁) ▁throws ▁Throwable ▁{ ▁String ▁id ▁; ▁{ ▁User ▁u ▁= ▁User ▁. ▁get ▁( ▁STR ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁Mail Address Resolver ▁. ▁resolve ▁( ▁u ▁) ▁) ▁; ▁id ▁= ▁u ▁. ▁getId ▁( ▁) ▁; ▁} ▁j ▁. ▁jenkins ▁. ▁reload ▁( ▁) ▁; ▁{ ▁User ▁u ▁= ▁User ▁. ▁get ▁( ▁id ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁Mail Address Resolver ▁. ▁resolve ▁( ▁u ▁) ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Delete ▁( ▁) ▁throws ▁Exception ▁{ ▁{ ▁User ▁user ▁= ▁User ▁. ▁get ▁( ▁STR ▁, ▁true ▁, ▁Collections ▁. ▁emptyMap ▁( ▁) ▁) ▁; ▁user ▁. ▁save ▁( ▁) ▁; ▁File ▁config Folder ▁= ▁user ▁. ▁getUser Folder ▁( ▁) ▁; ▁user ▁. ▁delete ▁( ▁) ▁; ▁assertFalse ▁( ▁STR ▁, ▁config Folder ▁. ▁exists ▁( ▁) ▁) ▁; ▁assertFalse ▁( ▁STR ▁, ▁User ▁. ▁getAll ▁( ▁) ▁. ▁contains ▁( ▁user ▁) ▁) ▁; ▁user ▁= ▁User ▁. ▁get ▁( ▁STR ▁, ▁false ▁, ▁Collections ▁. ▁emptyMap ▁( ▁) ▁) ▁; ▁assertNull ▁( ▁STR ▁, ▁user ▁) ▁; ▁} ▁j ▁. ▁jenkins ▁. ▁reload ▁( ▁) ▁; ▁{ ▁boolean ▁contain ed ▁= ▁false ▁; ▁for ▁( ▁User ▁u ▁: ▁User ▁. ▁getAll ▁( ▁) ▁) ▁{ ▁if ▁( ▁u ▁. ▁getId ▁( ▁) ▁. ▁equals ▁( ▁STR ▁) ▁) ▁{ ▁contain ed ▁= ▁true ▁; ▁break ▁; ▁} ▁} ▁assertFalse ▁( ▁STR ▁, ▁contain ed ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Do Config Submit ▁( ▁) ▁throws ▁Exception ▁{ ▁Global Matrix Authorization Strategy ▁auth ▁= ▁new ▁Global Matrix Authorization Strategy ▁( ▁) ▁; ▁j ▁. ▁jenkins ▁. ▁set Authorization Strategy ▁( ▁auth ▁) ▁;
47 ▁, ▁20 59 7 ▁, ▁20 5 34 ▁, ▁25 13 5 ▁, ▁35 36 ▁, ▁2 75 85 ▁, ▁22 7 39 ▁, ▁40 98 ▁, ▁33 9 31 ▁, ▁45 18 0 ▁, ▁25 37 7 ▁, ▁3 90 62 ▁, ▁2 40 85 ▁, ▁20 9 23 ▁, ▁37 78 2 ▁, ▁2 12 80 ▁, ▁34 3 84 ▁, ▁20 6 13 ▁, ▁25 24 3 ▁, ▁5 23 92 ▁} ▁; ▁System ▁. ▁arraycopy ▁( ▁temp ▁, ▁0 ▁, ▁chars ▁, ▁0 ▁, ▁temp ▁. ▁length ▁) ▁; ▁}
▁@ ▁ESIntegTestCase ▁. ▁S uite Scope TestCase ▁public ▁class ▁Long Terms IT ▁extends ▁Abstract Terms TestCase ▁{ ▁@ ▁Override ▁protected ▁Collection ▁< ▁Class ▁< ▁? ▁extends ▁Plugin ▁> ▁> ▁node Plugins ▁( ▁) ▁{ ▁return ▁Collections ▁. ▁singleton ▁( ▁Custom Script Plugin ▁. ▁class ▁) ▁; ▁} ▁public ▁static ▁class ▁Custom Script Plugin ▁extends ▁Aggregation Test Scripts Plugin ▁{ ▁@ ▁Override ▁protected ▁Map ▁< ▁String ▁, ▁Function ▁< ▁Map ▁< ▁String ▁, ▁Object ▁> ▁, ▁Object ▁> ▁> ▁plugin Scripts ▁( ▁) ▁{ ▁Map ▁< ▁String ▁, ▁Function ▁< ▁Map ▁< ▁String ▁, ▁Object ▁> ▁, ▁Object ▁> ▁> ▁scripts ▁= ▁super ▁. ▁plugin Scripts ▁( ▁) ▁; ▁scripts ▁. ▁put ▁( ▁STR ▁, ▁vars ▁-> ▁Math ▁. ▁floor ▁( ▁( ▁double ▁) ▁vars ▁. ▁get ▁( ▁STR ▁) ▁ / ▁1000 ▁+ ▁1 ▁) ▁) ▁; ▁scripts ▁. ▁put ▁( ▁STR ▁+ ▁MULTI _ VALUE D _ FIELD _ NAME ▁+ ▁STR ▁, ▁vars ▁-> ▁{ ▁Map ▁< ▁? ▁, ▁? ▁> ▁doc ▁= ▁( ▁Map ▁) ▁vars ▁. ▁get ▁( ▁STR ▁) ▁; ▁return ▁doc ▁. ▁get ▁( ▁MULTI _ VALUE D _ FIELD _ NAME ▁) ▁; ▁} ▁) ▁; ▁scripts ▁. ▁put ▁( ▁STR ▁+ ▁SINGLE _ VALUE D _ FIELD _ NAME ▁+ ▁STR ▁, ▁vars ▁-> ▁{ ▁Map ▁< ▁? ▁, ▁? ▁> ▁doc ▁= ▁( ▁Map ▁) ▁vars ▁. ▁get ▁( ▁STR ▁) ▁; ▁Script DocValues ▁. ▁Long s ▁value ▁= ▁( ▁Script DocValues ▁. ▁Long s ▁) ▁doc ▁. ▁get ▁( ▁SINGLE _ VALUE D _ FIELD _ NAME ▁) ▁; ▁return ▁value ▁. ▁getValue ▁( ▁) ▁; ▁} ▁) ▁; ▁return ▁scripts ▁; ▁} ▁@ ▁Override ▁protected ▁Map ▁< ▁String ▁, ▁Function ▁< ▁Map ▁< ▁String ▁, ▁Object ▁> ▁, ▁Object ▁> ▁> ▁non Deterministic Plugin Scripts ▁( ▁) ▁{ ▁Map ▁< ▁String ▁, ▁Function ▁< ▁Map ▁< ▁String ▁, ▁Object ▁> ▁, ▁Object ▁> ▁> ▁scripts ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁scripts ▁. ▁put ▁( ▁STR ▁, ▁vars ▁-> ▁Long Terms IT ▁. ▁randomDouble ▁( ▁) ▁) ▁; ▁return ▁scripts ▁; ▁} ▁} ▁private ▁static ▁final ▁int ▁NUM _ DO CS ▁= ▁5 ▁; ▁private ▁static ▁final ▁String ▁SINGLE _ VALUE D _ FIELD _ NAME ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁MULTI _ VALUE D _ FIELD _ NAME ▁= ▁STR ▁; ▁private ▁static ▁HashMap ▁< ▁Long ▁, ▁Map ▁< ▁String ▁, ▁Object ▁> ▁> ▁expected Multi Sort Buckets ▁; ▁@ ▁Override ▁public ▁void ▁setup Suite Scope Cluster ▁( ▁) ▁throws ▁Exception ▁{ ▁createIndex ▁( ▁STR ▁, ▁STR ▁) ▁; ▁Index RequestBuilder ▁[ ▁] ▁low Card Builders ▁= ▁new ▁Index RequestBuilder ▁[ ▁NUM _ DO CS ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁low Card Builders ▁. ▁length ▁;
▁DataSet ▁< ▁Custom Type ▁> ▁filter D s ▁= ▁ds ▁. ▁filter ▁( ▁new ▁Filter 6 ▁( ▁) ▁) ▁; ▁List ▁< ▁Custom Type ▁> ▁result ▁= ▁filter D s ▁. ▁collect ▁( ▁) ▁; ▁String ▁expected ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁; ▁compare Result AsText ▁( ▁result ▁, ▁expected ▁) ▁; ▁} ▁private ▁static ▁class ▁Filter 6 ▁implements ▁Filter Function ▁< ▁Custom Type ▁> ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁@ ▁Override ▁public ▁boolean ▁filter ▁( ▁Custom Type ▁value ▁) ▁throws ▁Exception ▁{ ▁return ▁value ▁. ▁my String ▁. ▁contains ▁( ▁STR ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test R ich Filter On String Tuple Field ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁Execution Environment ▁env ▁= ▁Execution Environment ▁. ▁getExecution Environment ▁( ▁) ▁; ▁DataSet ▁< ▁Integer ▁> ▁ints ▁= ▁Collection DataSet s ▁. ▁getInteger DataSet ▁( ▁env ▁) ▁; ▁DataSet ▁< ▁Tuple 3 ▁< ▁Integer ▁, ▁Long ▁, ▁String ▁> ▁> ▁ds ▁= ▁Collection DataSet s ▁. ▁get 3 Tuple DataSet ▁( ▁env ▁) ▁; ▁DataSet ▁< ▁Tuple 3 ▁< ▁Integer ▁, ▁Long ▁, ▁String ▁> ▁> ▁filter D s ▁= ▁ds ▁. ▁filter ▁( ▁new ▁Rich Filter 1 ▁( ▁) ▁) ▁. ▁with Broadcast Set ▁( ▁ints ▁, ▁STR ▁) ▁; ▁List ▁< ▁Tuple 3 ▁< ▁Integer ▁, ▁Long ▁, ▁String ▁> ▁> ▁result ▁= ▁filter D s ▁. ▁collect ▁( ▁) ▁; ▁String ▁expected ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁; ▁compare Result As Tuple s ▁( ▁result ▁, ▁expected ▁) ▁; ▁} ▁private ▁static ▁class ▁Rich Filter 1 ▁extends ▁Rich Filter Function ▁< ▁Tuple 3 ▁< ▁Integer ▁, ▁Long ▁, ▁String ▁> ▁> ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁int ▁literal ▁= ▁- ▁1 ▁; ▁@ ▁Override ▁public ▁void ▁open ▁( ▁Configuration ▁config ▁) ▁{ ▁Collection ▁< ▁Integer ▁> ▁ints ▁= ▁this ▁. ▁getRuntime Context ▁( ▁) ▁. ▁getB roadcast Variable ▁( ▁STR ▁) ▁; ▁for ▁( ▁int ▁i ▁: ▁ints ▁) ▁{ ▁literal ▁= ▁literal ▁< ▁i ▁? ▁i ▁: ▁literal ▁; ▁} ▁} ▁@ ▁Override ▁public ▁boolean ▁filter ▁( ▁Tuple 3 ▁< ▁Integer ▁, ▁Long ▁, ▁String ▁> ▁value ▁) ▁throws ▁Exception ▁{ ▁return ▁value ▁. ▁f 0 ▁< ▁literal ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Filter With Broadcast Variables ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁Execution Environment ▁env ▁= ▁Execution Environment ▁. ▁getExecution Environment ▁( ▁) ▁; ▁DataSet ▁< ▁Integer ▁> ▁int D s ▁= ▁Collection DataSet s ▁. ▁getInteger DataSet ▁( ▁env ▁) ▁; ▁DataSet ▁< ▁Tuple 3 ▁< ▁Integer ▁, ▁Long ▁, ▁String ▁> ▁> ▁ds ▁= ▁Collection DataSet s ▁. ▁get 3 Tuple DataSet ▁( ▁env ▁) ▁; ▁DataSet ▁< ▁Tuple 3 ▁< ▁Integer ▁, ▁Long ▁, ▁String ▁> ▁> ▁filter D s ▁= ▁ds ▁. ▁filter ▁( ▁new ▁Rich Filter 2 ▁( ▁) ▁) ▁. ▁with Broadcast Set ▁( ▁int D s ▁, ▁STR ▁) ▁; ▁List ▁< ▁Tuple 3 ▁< ▁Integer ▁, ▁Long ▁, ▁String ▁> ▁> ▁result ▁= ▁filter D s ▁. ▁collect ▁( ▁) ▁;
▁exp Calls For Layer ▁. ▁add ▁( ▁new ▁Weight No ise Call ▁( ▁layer Idx s ▁[ ▁i ▁] ▁, ▁STR ▁, ▁2 ▁, ▁0 ▁, ▁true ▁) ▁) ▁; ▁exp Calls For Layer ▁. ▁add ▁( ▁new ▁Weight No ise Call ▁( ▁layer Idx s ▁[ ▁i ▁] ▁, ▁STR ▁, ▁3 ▁, ▁1 ▁, ▁true ▁) ▁) ▁; ▁exp Calls For Layer ▁. ▁add ▁( ▁new ▁Weight No ise Call ▁( ▁layer Idx s ▁[ ▁i ▁] ▁, ▁STR ▁, ▁3 ▁, ▁1 ▁, ▁true ▁) ▁) ▁; ▁exp Calls For Layer ▁. ▁add ▁( ▁new ▁Weight No ise Call ▁( ▁layer Idx s ▁[ ▁i ▁] ▁, ▁STR ▁, ▁4 ▁, ▁1 ▁, ▁true ▁) ▁) ▁; ▁exp Calls For Layer ▁. ▁add ▁( ▁new ▁Weight No ise Call ▁( ▁layer Idx s ▁[ ▁i ▁] ▁, ▁STR ▁, ▁4 ▁, ▁1 ▁, ▁true ▁) ▁) ▁; ▁exp Calls For Layer ▁. ▁add ▁( ▁new ▁Weight No ise Call ▁( ▁layer Idx s ▁[ ▁i ▁] ▁, ▁STR ▁, ▁5 ▁, ▁1 ▁, ▁true ▁) ▁) ▁; ▁exp Calls For Layer ▁. ▁add ▁( ▁new ▁Weight No ise Call ▁( ▁layer Idx s ▁[ ▁i ▁] ▁, ▁STR ▁, ▁5 ▁, ▁1 ▁, ▁true ▁) ▁) ▁; ▁exp Calls For Layer ▁. ▁add ▁( ▁new ▁Weight No ise Call ▁( ▁layer Idx s ▁[ ▁i ▁] ▁, ▁STR ▁, ▁6 ▁, ▁2 ▁, ▁false ▁) ▁) ▁; ▁exp Calls For Layer ▁. ▁add ▁( ▁new ▁Weight No ise Call ▁( ▁layer Idx s ▁[ ▁i ▁] ▁, ▁STR ▁, ▁6 ▁, ▁2 ▁, ▁false ▁) ▁) ▁; ▁exp Calls ▁. ▁add ▁( ▁exp Calls For Layer ▁) ▁; ▁} ▁graph ▁. ▁fit ▁( ▁new ▁Ex ist ing DataSetIterator ▁( ▁train Data ▁. ▁iterator ▁( ▁) ▁) ▁) ▁; ▁graph ▁. ▁fit ▁( ▁new ▁Ex ist ing DataSetIterator ▁( ▁train Data ▁. ▁iterator ▁( ▁) ▁) ▁) ▁; ▁graph ▁. ▁output ▁( ▁train Data ▁. ▁get ▁( ▁0 ▁) ▁. ▁getFeatures ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁assertEquals ▁( ▁exp Calls ▁. ▁get ▁( ▁i ▁) ▁, ▁list ▁. ▁get ▁( ▁i ▁) ▁. ▁getAll Calls ▁( ▁) ▁, ▁String ▁. ▁valueOf ▁( ▁i ▁) ▁) ▁; ▁} ▁} ▁@ ▁Data ▁private ▁static ▁class ▁Custom Weight No ise ▁implements ▁I Weight No ise ▁{ ▁private ▁List ▁< ▁Weight No ise Call ▁> ▁all Calls ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁@ ▁Override ▁public ▁INDArray ▁getParameter ▁( ▁Layer ▁layer ▁, ▁String ▁param Key ▁, ▁int ▁iteration ▁, ▁int ▁epoch ▁, ▁boolean ▁train ▁, ▁Layer WorkspaceMgr ▁workspaceMgr ▁) ▁{ ▁all Calls ▁. ▁add ▁( ▁new ▁Weight No ise Call ▁( ▁layer ▁. ▁getIndex ▁( ▁) ▁, ▁param Key ▁, ▁iteration ▁, ▁epoch ▁, ▁train ▁) ▁) ▁; ▁return ▁layer ▁. ▁getParam ▁( ▁param Key ▁) ▁; ▁} ▁@ ▁Override ▁public ▁I Weight No ise ▁clone ▁( ▁) ▁{ ▁return ▁new ▁Custom Weight No ise ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁Resource Spec Test ▁extends ▁TestLogger ▁{ ▁private ▁static ▁final ▁String ▁EXTERNAL _ RESOURCE _ NAME ▁= ▁STR ▁; ▁@ ▁Test ▁public ▁void ▁test LessThan OrEqual When B oth Specified ▁( ▁) ▁{ ▁Resource Spec ▁rs 1 ▁= ▁Resource Spec ▁. ▁newBuilder ▁( ▁1.0 ▁, ▁100 ▁) ▁. ▁build ▁( ▁) ▁; ▁Resource Spec ▁rs 2 ▁= ▁Resource Spec ▁. ▁newBuilder ▁( ▁1.0 ▁, ▁100 ▁) ▁. ▁build ▁( ▁) ▁; ▁assertTrue ▁( ▁rs 1 ▁. ▁lessThan OrEqual ▁( ▁rs 2 ▁) ▁) ▁; ▁assertTrue ▁( ▁rs 2 ▁. ▁lessThan OrEqual ▁( ▁rs 1 ▁) ▁) ▁; ▁Resource Spec ▁rs 3 ▁= ▁Resource Spec ▁. ▁newBuilder ▁( ▁1.0 ▁, ▁100 ▁) ▁. ▁set Extended Resource ▁( ▁new ▁External Resource ▁( ▁EXTERNAL _ RESOURCE _ NAME ▁, ▁1.1 ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁assertTrue ▁( ▁rs 1 ▁. ▁lessThan OrEqual ▁( ▁rs 3 ▁) ▁) ▁; ▁assertFalse ▁( ▁rs 3 ▁. ▁lessThan OrEqual ▁( ▁rs 1 ▁) ▁) ▁; ▁Resource Spec ▁rs 4 ▁= ▁Resource Spec ▁. ▁newBuilder ▁( ▁1.0 ▁, ▁100 ▁) ▁. ▁set Extended Resource ▁( ▁new ▁External Resource ▁( ▁EXTERNAL _ RESOURCE _ NAME ▁, ▁2. 2 ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁assertFalse ▁( ▁rs 4 ▁. ▁lessThan OrEqual ▁( ▁rs 3 ▁) ▁) ▁; ▁assertTrue ▁( ▁rs 3 ▁. ▁lessThan OrEqual ▁( ▁rs 4 ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test LessThan OrEqual When B oth Unknown ▁( ▁) ▁{ ▁assertTrue ▁( ▁Resource Spec ▁. ▁UNKNOWN ▁. ▁lessThan OrEqual ▁( ▁Resource Spec ▁. ▁UNKNOWN ▁) ▁) ▁; ▁} ▁@ ▁Test ▁( ▁expected ▁= ▁IllegalArgument Exception ▁. ▁class ▁) ▁public ▁void ▁test LessThan OrEqual When Unknown With Specified ▁( ▁) ▁{ ▁final ▁Resource Spec ▁rs 1 ▁= ▁Resource Spec ▁. ▁newBuilder ▁( ▁1.0 ▁, ▁100 ▁) ▁. ▁build ▁( ▁) ▁; ▁assertTrue ▁( ▁Resource Spec ▁. ▁UNKNOWN ▁. ▁lessThan OrEqual ▁( ▁rs 1 ▁) ▁) ▁; ▁} ▁@ ▁Test ▁( ▁expected ▁= ▁IllegalArgument Exception ▁. ▁class ▁) ▁public ▁void ▁test LessThan OrEqual When Specified With Unknown ▁( ▁) ▁{ ▁final ▁Resource Spec ▁rs 1 ▁= ▁Resource Spec ▁. ▁newBuilder ▁( ▁1.0 ▁, ▁100 ▁) ▁. ▁build ▁( ▁) ▁; ▁assertTrue ▁( ▁rs 1 ▁. ▁lessThan OrEqual ▁( ▁Resource Spec ▁. ▁UNKNOWN ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testEquals ▁( ▁) ▁throws ▁Exception ▁{ ▁Resource Spec ▁rs 1 ▁= ▁Resource Spec ▁. ▁newBuilder ▁( ▁1.0 ▁, ▁100 ▁) ▁. ▁build ▁( ▁) ▁; ▁Resource Spec ▁rs 2 ▁= ▁Resource Spec ▁. ▁newBuilder ▁( ▁1.0 ▁, ▁100 ▁) ▁. ▁build ▁( ▁) ▁; ▁assertEquals ▁( ▁rs 1 ▁, ▁rs 2 ▁) ▁; ▁assertEquals ▁( ▁rs 2 ▁, ▁rs 1 ▁) ▁; ▁Resource Spec ▁rs 3 ▁= ▁Resource Spec ▁. ▁newBuilder ▁( ▁1.0 ▁, ▁100 ▁) ▁. ▁set Extended Resource ▁( ▁new ▁External Resource ▁( ▁EXTERNAL _ RESOURCE _ NAME ▁, ▁2. 2 ▁) ▁) ▁. ▁build ▁( ▁) ▁;
▁private ▁static ▁String ▁a bsolutePath ▁( ▁Resource ▁resource ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁! ▁STR ▁. ▁equals ▁( ▁resource ▁. ▁getURI ▁( ▁) ▁. ▁getScheme ▁( ▁) ▁) ▁) ▁{ ▁return ▁resource ▁. ▁getURL ▁( ▁) ▁. ▁to External Form ▁( ▁) ▁; ▁} ▁return ▁resource ▁. ▁getFile ▁( ▁) ▁. ▁getAbsolute File ▁( ▁) ▁. ▁toURI ▁( ▁) ▁. ▁toString ▁( ▁) ▁; ▁} ▁private ▁static ▁String ▁strip Leading Slash es ▁( ▁String ▁path ▁) ▁{ ▁while ▁( ▁path ▁. ▁startsWith ▁( ▁STR ▁) ▁) ▁{ ▁path ▁= ▁path ▁. ▁substring ▁( ▁1 ▁) ▁; ▁} ▁return ▁path ▁; ▁} ▁private ▁static ▁class ▁File Search Resource Loader ▁extends ▁Default Resource Loader ▁{ ▁private ▁final ▁FileSystem Resource Loader ▁files ▁; ▁File Search Resource Loader ▁( ▁ClassLoader ▁classLoader ▁) ▁{ ▁super ▁( ▁classLoader ▁) ▁; ▁this ▁. ▁files ▁= ▁new ▁FileSystem Resource Loader ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Resource ▁getResource ▁( ▁String ▁location ▁) ▁{ ▁Assert ▁. ▁notNull ▁( ▁location ▁, ▁STR ▁) ▁; ▁if ▁( ▁location ▁. ▁startsWith ▁( ▁CLASS PATH _ URL _ PREFIX ▁) ▁) ▁{ ▁return ▁new ▁ClassPath Resource ▁( ▁location ▁. ▁substring ▁( ▁CLASS PATH _ URL _ PREFIX ▁. ▁length ▁( ▁) ▁) ▁, ▁getClassLoader ▁( ▁) ▁) ▁; ▁} ▁if ▁( ▁location ▁. ▁startsWith ▁( ▁FILE _ URL _ PREFIX ▁) ▁) ▁{ ▁return ▁this ▁. ▁files ▁. ▁getResource ▁( ▁location ▁) ▁; ▁} ▁try ▁{ ▁URL ▁url ▁= ▁new ▁URL ▁( ▁location ▁) ▁; ▁return ▁new ▁Url Resource ▁( ▁url ▁) ▁; ▁} ▁catch ▁( ▁Malformed URLException ▁ex ▁) ▁{ ▁return ▁getResource By Path ▁( ▁location ▁) ▁; ▁} ▁} ▁} ▁}
▁catch ▁( ▁Interrupted Exception ▁| ▁B roken Barrier Exception ▁| ▁Timeout Exception ▁e ▁) ▁{ ▁logger ▁. ▁error ▁( ▁STR ▁) ▁; ▁threads ▁. ▁forEach ▁( ▁thread ▁-> ▁logger ▁. ▁info ▁( ▁thread ▁. ▁toString ▁( ▁) ▁+ ▁STR ▁+ ▁Exceptions Helper ▁. ▁format StackTrace ▁( ▁thread ▁. ▁getStackTrace ▁( ▁) ▁) ▁) ▁) ▁; ▁throw ▁new ▁Runtime Exception ▁( ▁e ▁) ▁; ▁} ▁finally ▁{ ▁logger ▁. ▁info ▁( ▁STR ▁) ▁; ▁threads ▁. ▁forEach ▁( ▁C AS Update Thread ▁:: ▁terminate ▁) ▁; ▁threads ▁. ▁forEach ▁( ▁C AS Update Thread ▁:: ▁await ▁) ▁; ▁threads ▁. ▁stream ▁( ▁) ▁. ▁filter ▁( ▁Thread ▁:: ▁isAlive ▁) ▁. ▁forEach ▁( ▁t ▁-> ▁fail ▁( ▁STR ▁+ ▁t ▁) ▁) ▁; ▁} ▁partitions ▁. ▁forEach ▁( ▁Partition ▁:: ▁assert Line ari z able ▁) ▁; ▁} ▁private ▁class ▁C AS Update Thread ▁extends ▁Thread ▁{ ▁private ▁final ▁CyclicBarrier ▁round Barrier ▁; ▁private ▁final ▁List ▁< ▁Partition ▁> ▁partitions ▁; ▁private ▁final ▁int ▁timeout ▁; ▁private ▁volatile ▁boolean ▁stop ▁; ▁private ▁final ▁Random ▁random ▁= ▁new ▁Random ▁( ▁randomLong ▁( ▁) ▁) ▁; ▁private ▁C AS Update Thread ▁( ▁int ▁thread Num ▁, ▁CyclicBarrier ▁round Barrier ▁, ▁List ▁< ▁Partition ▁> ▁partitions ▁, ▁int ▁timeout ▁) ▁{ ▁super ▁( ▁STR ▁+ ▁thread Num ▁) ▁; ▁this ▁. ▁round Barrier ▁= ▁round Barrier ▁; ▁this ▁. ▁partitions ▁= ▁partitions ▁; ▁this ▁. ▁timeout ▁= ▁timeout ▁; ▁setDaemon ▁( ▁true ▁) ▁; ▁} ▁public ▁void ▁run ▁( ▁) ▁{ ▁while ▁( ▁stop ▁== ▁false ▁) ▁{ ▁try ▁{ ▁round Barrier ▁. ▁await ▁( ▁70 ▁, ▁TimeUnit ▁. ▁SECONDS ▁) ▁; ▁int ▁numberOf Updates ▁= ▁randomInt Between ▁( ▁3 ▁, ▁13 ▁) ▁ * ▁partitions ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁numberOf Updates ▁; ▁++ ▁i ▁) ▁{ ▁final ▁int ▁key Index ▁= ▁random ▁. ▁nextInt ▁( ▁partitions ▁. ▁size ▁( ▁) ▁) ▁; ▁final ▁Partition ▁partition ▁= ▁partitions ▁. ▁get ▁( ▁key Index ▁) ▁; ▁final ▁int ▁seqNo Change P ct ▁= ▁random ▁. ▁nextInt ▁( ▁100 ▁) ▁; ▁Version ▁version ▁= ▁random ▁. ▁nextBoolean ▁( ▁) ▁? ▁partition ▁. ▁latest O bser ved Version ▁( ▁) ▁: ▁partition ▁. ▁latest Successful Version ▁( ▁) ▁; ▁if ▁( ▁seqNo Change P ct ▁< ▁10 ▁) ▁{ ▁version ▁= ▁version ▁. ▁next SeqNo ▁( ▁random ▁. ▁nextInt ▁( ▁4 ▁) ▁+ ▁1 ▁) ▁; ▁} ▁else ▁if ▁( ▁seqNo Change P ct ▁< ▁15 ▁) ▁{ ▁version ▁= ▁version ▁. ▁previous SeqNo ▁( ▁random ▁. ▁nextInt ▁( ▁4 ▁) ▁+ ▁1 ▁) ▁; ▁} ▁final ▁int ▁term Change P ct ▁= ▁random ▁. ▁nextInt ▁( ▁100 ▁) ▁; ▁if ▁( ▁term Change P ct ▁< ▁5 ▁) ▁{ ▁version ▁= ▁version ▁. ▁next Term ▁( ▁) ▁; ▁} ▁else ▁if ▁( ▁term Change P ct ▁< ▁10 ▁) ▁{ ▁version ▁= ▁version ▁. ▁previous Term ▁( ▁) ▁; ▁}
▁if ▁( ▁deleted ▁!= ▁null ▁) ▁{ ▁deleted ▁= ▁false ▁; ▁} ▁Number Convertor ▁convert or ▁= ▁new ▁Number Convertor ▁( ▁value ▁. ▁getClass ▁( ▁) ▁) ▁; ▁result ▁. ▁try Success ▁( ▁( ▁V ▁) ▁convert or ▁. ▁convert ▁( ▁res ▁. ▁to Plain String ▁( ▁) ▁) ▁) ▁; ▁return ▁; ▁} ▁map ▁. ▁getAsync ▁( ▁key ▁) ▁. ▁onComplete ▁( ▁( ▁r ▁, ▁e ▁) ▁-> ▁{ ▁if ▁( ▁e ▁!= ▁null ▁) ▁{ ▁result ▁. ▁try Failure ▁( ▁e ▁) ▁; ▁return ▁; ▁} ▁BigDecimal ▁currentValue ▁= ▁new ▁BigDecimal ▁( ▁r ▁. ▁toString ▁( ▁) ▁) ▁; ▁BigDecimal ▁res ▁= ▁currentValue ▁. ▁add ▁( ▁new ▁BigDecimal ▁( ▁value ▁. ▁toString ▁( ▁) ▁) ▁) ▁; ▁operations ▁. ▁add ▁( ▁new ▁Map Add AndGet Operation ▁( ▁map ▁, ▁key ▁, ▁value ▁, ▁transactionId ▁, ▁threadId ▁) ▁) ▁; ▁state ▁. ▁put ▁( ▁key Hash ▁, ▁new ▁Map Entry ▁( ▁key ▁, ▁res ▁) ▁) ▁; ▁if ▁( ▁deleted ▁!= ▁null ▁) ▁{ ▁deleted ▁= ▁false ▁; ▁} ▁Number Convertor ▁convert or ▁= ▁new ▁Number Convertor ▁( ▁value ▁. ▁getClass ▁( ▁) ▁) ▁; ▁result ▁. ▁try Success ▁( ▁( ▁V ▁) ▁convert or ▁. ▁convert ▁( ▁res ▁. ▁to Plain String ▁( ▁) ▁) ▁) ▁; ▁} ▁) ▁; ▁} ▁} ▁) ▁; ▁return ▁result ▁; ▁} ▁protected ▁RFuture ▁< ▁V ▁> ▁put IfExists Operation Async ▁( ▁K ▁key ▁, ▁V ▁value ▁) ▁{ ▁long ▁threadId ▁= ▁Thread ▁. ▁currentThread ▁( ▁) ▁. ▁getId ▁( ▁) ▁; ▁return ▁put IfExists Operation Async ▁( ▁key ▁, ▁value ▁, ▁new ▁Map Put IfExists Operation ▁( ▁map ▁, ▁key ▁, ▁value ▁, ▁transactionId ▁, ▁threadId ▁) ▁) ▁; ▁} ▁protected ▁RFuture ▁< ▁V ▁> ▁put IfExists Operation Async ▁( ▁K ▁key ▁, ▁V ▁value ▁, ▁Map Operation ▁map Operation ▁) ▁{ ▁R Promise ▁< ▁V ▁> ▁result ▁= ▁new ▁Redisson Promise ▁< ▁V ▁> ▁( ▁) ▁; ▁execute Locked ▁( ▁result ▁, ▁key ▁, ▁new ▁Runnable ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁run ▁( ▁) ▁{ ▁Hash Value ▁key Hash ▁= ▁to Key Hash ▁( ▁key ▁) ▁; ▁Map Entry ▁entry ▁= ▁state ▁. ▁get ▁( ▁key Hash ▁) ▁; ▁if ▁( ▁entry ▁!= ▁null ▁) ▁{ ▁operations ▁. ▁add ▁( ▁map Operation ▁) ▁; ▁if ▁( ▁entry ▁!= ▁Map Entry ▁. ▁NULL ▁) ▁{ ▁state ▁. ▁put ▁( ▁key Hash ▁, ▁new ▁Map Entry ▁( ▁key ▁, ▁value ▁) ▁) ▁; ▁if ▁( ▁deleted ▁!= ▁null ▁) ▁{ ▁deleted ▁= ▁false ▁; ▁} ▁result ▁. ▁try Success ▁( ▁( ▁V ▁) ▁entry ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁else ▁{ ▁result ▁. ▁try Success ▁( ▁null ▁) ▁; ▁} ▁return ▁; ▁} ▁map ▁. ▁getAsync ▁( ▁key ▁) ▁. ▁onComplete ▁( ▁( ▁res ▁, ▁e ▁) ▁-> ▁{ ▁if ▁( ▁e ▁!= ▁null ▁) ▁{ ▁result ▁. ▁try Failure ▁( ▁e ▁) ▁; ▁return ▁; ▁} ▁operations ▁. ▁add ▁( ▁map Operation ▁) ▁;
▁public ▁class ▁Oracle Wall Perm it Table Test ▁extends ▁TestCase ▁{ ▁public ▁void ▁test _ per mit Table ▁( ▁) ▁throws ▁Exception ▁{ ▁Assert ▁. ▁assertFalse ▁( ▁WallUtils ▁. ▁isValidate Oracle ▁( ▁STR ▁) ▁) ▁; ▁Assert ▁. ▁assertFalse ▁( ▁WallUtils ▁. ▁isValidate Oracle ▁( ▁STR ▁) ▁) ▁; ▁Assert ▁. ▁assertFalse ▁( ▁WallUtils ▁. ▁isValidate Oracle ▁( ▁STR ▁) ▁) ▁; ▁Assert ▁. ▁assertFalse ▁( ▁WallUtils ▁. ▁isValidate Oracle ▁( ▁STR ▁) ▁) ▁; ▁Assert ▁. ▁assertFalse ▁( ▁WallUtils ▁. ▁isValidate Oracle ▁( ▁STR ▁) ▁) ▁; ▁} ▁public ▁void ▁test _ per mit Table _ sub query ▁( ▁) ▁throws ▁Exception ▁{ ▁Assert ▁. ▁assertTrue ▁( ▁WallUtils ▁. ▁isValidate Oracle ▁( ▁STR ▁) ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁WallUtils ▁. ▁isValidate Oracle ▁( ▁STR ▁) ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁WallUtils ▁. ▁isValidate Oracle ▁( ▁STR ▁) ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁WallUtils ▁. ▁isValidate Oracle ▁( ▁STR ▁) ▁) ▁; ▁} ▁public ▁void ▁test _ per mit Table _ join ▁( ▁) ▁throws ▁Exception ▁{ ▁Assert ▁. ▁assertTrue ▁( ▁WallUtils ▁. ▁isValidate Oracle ▁( ▁STR ▁) ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁WallUtils ▁. ▁isValidate Oracle ▁( ▁STR ▁) ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁WallUtils ▁. ▁isValidate Oracle ▁( ▁STR ▁) ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁WallUtils ▁. ▁isValidate Oracle ▁( ▁STR ▁) ▁) ▁; ▁} ▁}
▁public ▁final ▁class ▁Cassandra Storage ▁extends ▁Storage Component ▁{ ▁public ▁interface ▁SessionFactory ▁{ ▁SessionFactory ▁DEFAULT ▁= ▁new ▁Default SessionFactory ▁( ▁) ▁; ▁C qlSession ▁create ▁( ▁Cassandra Storage ▁storage ▁) ▁; ▁} ▁public ▁static ▁Builder ▁newBuilder ▁( ▁) ▁{ ▁return ▁new ▁Builder ▁( ▁) ▁; ▁} ▁public ▁static ▁final ▁class ▁Builder ▁extends ▁Cassandra Storage Builder ▁< ▁Builder ▁> ▁{ ▁SessionFactory ▁sessionFactory ▁= ▁SessionFactory ▁. ▁DEFAULT ▁; ▁Builder ▁( ▁) ▁{ ▁super ▁( ▁Schema ▁. ▁DEFAULT _ KEY SPACE ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Builder ▁key space ▁( ▁String ▁key space ▁) ▁{ ▁return ▁super ▁. ▁key space ▁( ▁key space ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Builder ▁ensure Schema ▁( ▁boolean ▁ensure Schema ▁) ▁{ ▁return ▁super ▁. ▁ensure Schema ▁( ▁ensure Schema ▁) ▁; ▁} ▁public ▁Builder ▁sessionFactory ▁( ▁SessionFactory ▁sessionFactory ▁) ▁{ ▁if ▁( ▁sessionFactory ▁== ▁null ▁) ▁throw ▁new ▁NullPointer Exception ▁( ▁STR ▁) ▁; ▁this ▁. ▁sessionFactory ▁= ▁sessionFactory ▁; ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁Cassandra Storage ▁build ▁( ▁) ▁{ ▁Auth Provider ▁auth Provider ▁= ▁null ▁; ▁if ▁( ▁username ▁!= ▁null ▁) ▁{ ▁auth Provider ▁= ▁new ▁Program m atic Plain Text Auth Provider ▁( ▁username ▁, ▁password ▁) ▁; ▁} ▁return ▁new ▁Cassandra Storage ▁( ▁strict TraceId ▁, ▁search Enabled ▁, ▁aut ocomplete Keys ▁, ▁aut ocomplete Ttl ▁, ▁aut ocomplete Cardinality ▁, ▁contact Points ▁, ▁local D c ▁, ▁pool ing Options ▁( ▁) ▁, ▁auth Provider ▁, ▁use Ssl ▁, ▁sessionFactory ▁, ▁key space ▁, ▁ensure Schema ▁, ▁max Trace Cols ▁, ▁index Fetch Multi plier ▁) ▁; ▁} ▁} ▁final ▁boolean ▁strict TraceId ▁, ▁search Enabled ▁; ▁final ▁Set ▁< ▁String ▁> ▁aut ocomplete Keys ▁; ▁final ▁int ▁aut ocomplete Ttl ▁, ▁aut ocomplete Cardinality ▁; ▁final ▁String ▁contact Points ▁, ▁local D c ▁; ▁final ▁Map ▁< ▁Driver Option ▁, ▁Integer ▁> ▁pool ing Options ▁; ▁@ ▁Nullable ▁final ▁Auth Provider ▁auth Provider ▁; ▁final ▁boolean ▁use Ssl ▁; ▁final ▁String ▁key space ▁; ▁final ▁boolean ▁ensure Schema ▁; ▁final ▁int ▁max Trace Cols ▁, ▁index Fetch Multi plier ▁; ▁final ▁Lazy Session ▁session ▁; ▁Cassandra Storage ▁( ▁boolean ▁strict TraceId ▁, ▁boolean ▁search Enabled ▁, ▁Set ▁< ▁String ▁> ▁aut ocomplete Keys ▁, ▁int ▁aut ocomplete Ttl ▁, ▁int ▁aut ocomplete Cardinality ▁, ▁String ▁contact Points ▁, ▁String ▁local D c ▁, ▁Map ▁< ▁Driver Option ▁, ▁Integer ▁> ▁pool ing Options ▁, ▁Auth Provider ▁auth Provider ▁, ▁boolean ▁use Ssl ▁, ▁SessionFactory ▁sessionFactory ▁, ▁String ▁key space ▁, ▁boolean ▁ensure Schema ▁, ▁int ▁max Trace Cols ▁, ▁int ▁index Fetch Multi plier ▁) ▁{ ▁this ▁. ▁strict TraceId ▁= ▁strict TraceId ▁; ▁this ▁. ▁search Enabled ▁= ▁search Enabled ▁; ▁this ▁. ▁aut ocomplete Keys ▁= ▁aut ocomplete Keys ▁; ▁this ▁. ▁aut ocomplete Ttl ▁= ▁aut ocomplete Ttl ▁; ▁this ▁. ▁aut ocomplete Cardinality ▁= ▁aut ocomplete Cardinality ▁; ▁this ▁. ▁contact Points ▁= ▁contact Points ▁; ▁this ▁. ▁local D c ▁= ▁local D c ▁; ▁this ▁. ▁pool ing Options ▁= ▁pool ing Options ▁;
▁public ▁final ▁class ▁Sentinel Config Loader ▁{ ▁public ▁static ▁final ▁String ▁SENT INEL _ CONFIG _ EN V _ KEY ▁= ▁STR ▁; ▁public ▁static ▁final ▁String ▁SENT INEL _ CONFIG _ PROPERTY _ KEY ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁DEFAULT _ SENT INEL _ CONFIG _ FILE ▁= ▁STR ▁; ▁private ▁static ▁Properties ▁properties ▁= ▁new ▁Properties ▁( ▁) ▁; ▁static ▁{ ▁try ▁{ ▁load ▁( ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁RecordLog ▁. ▁warn ▁( ▁STR ▁, ▁t ▁) ▁; ▁} ▁} ▁private ▁static ▁void ▁load ▁( ▁) ▁{ ▁String ▁fileName ▁= ▁System ▁. ▁getProperty ▁( ▁SENT INEL _ CONFIG _ PROPERTY _ KEY ▁) ▁; ▁if ▁( ▁StringUtil ▁. ▁isBlank ▁( ▁fileName ▁) ▁) ▁{ ▁fileName ▁= ▁System ▁. ▁getenv ▁( ▁SENT INEL _ CONFIG _ EN V _ KEY ▁) ▁; ▁if ▁( ▁StringUtil ▁. ▁isBlank ▁( ▁fileName ▁) ▁) ▁{ ▁fileName ▁= ▁DEFAULT _ SENT INEL _ CONFIG _ FILE ▁; ▁} ▁} ▁Properties ▁p ▁= ▁Config Util ▁. ▁load Properties ▁( ▁fileName ▁) ▁; ▁if ▁( ▁p ▁!= ▁null ▁&& ▁! ▁p ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁RecordLog ▁. ▁info ▁( ▁STR ▁, ▁fileName ▁) ▁; ▁properties ▁. ▁putAll ▁( ▁p ▁) ▁; ▁} ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Object ▁, ▁Object ▁> ▁entry ▁: ▁new ▁CopyOnWrite Array Set ▁< ▁> ▁( ▁System ▁. ▁getProperties ▁( ▁) ▁. ▁entrySet ▁( ▁) ▁) ▁) ▁{ ▁String ▁config Key ▁= ▁entry ▁. ▁getKey ▁( ▁) ▁. ▁toString ▁( ▁) ▁; ▁String ▁new Config Value ▁= ▁entry ▁. ▁getValue ▁( ▁) ▁. ▁toString ▁( ▁) ▁; ▁String ▁old Config Value ▁= ▁properties ▁. ▁getProperty ▁( ▁config Key ▁) ▁; ▁properties ▁. ▁put ▁( ▁config Key ▁, ▁new Config Value ▁) ▁; ▁if ▁( ▁old Config Value ▁!= ▁null ▁) ▁{ ▁RecordLog ▁. ▁info ▁( ▁STR ▁, ▁config Key ▁, ▁old Config Value ▁, ▁new Config Value ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁Properties ▁getProperties ▁( ▁) ▁{ ▁return ▁properties ▁; ▁} ▁}
▁assertEquals ▁( ▁1 ▁, ▁rsp ▁. ▁getHits ▁( ▁) ▁. ▁getTotal Hits ▁( ▁) ▁. ▁value ▁) ▁; ▁assertEquals ▁( ▁5.0 ▁, ▁rsp ▁. ▁getHits ▁( ▁) ▁. ▁get At ▁( ▁0 ▁) ▁. ▁field ▁( ▁STR ▁) ▁. ▁getValue ▁( ▁) ▁, ▁0.0 D ▁) ▁; ▁} ▁public ▁void ▁test Score ▁( ▁) ▁throws ▁Exception ▁{ ▁createIndex ▁( ▁STR ▁) ▁; ▁ensureGreen ▁( ▁STR ▁) ▁; ▁index Random ▁( ▁true ▁, ▁client ▁( ▁) ▁. ▁prepareIndex ▁( ▁STR ▁) ▁. ▁setId ▁( ▁STR ▁) ▁. ▁setSource ▁( ▁STR ▁, ▁STR ▁) ▁, ▁client ▁( ▁) ▁. ▁prepareIndex ▁( ▁STR ▁) ▁. ▁setId ▁( ▁STR ▁) ▁. ▁setSource ▁( ▁STR ▁, ▁STR ▁) ▁, ▁client ▁( ▁) ▁. ▁prepareIndex ▁( ▁STR ▁) ▁. ▁setId ▁( ▁STR ▁) ▁. ▁setSource ▁( ▁STR ▁, ▁STR ▁) ▁) ▁; ▁Script Score Function Builder ▁score ▁= ▁Score Function Builders ▁. ▁script Function ▁( ▁new ▁Script ▁( ▁Script Type ▁. ▁IN LINE ▁, ▁STR ▁, ▁STR ▁, ▁Collections ▁. ▁emptyMap ▁( ▁) ▁) ▁) ▁; ▁Search RequestBuilder ▁req ▁= ▁client ▁( ▁) ▁. ▁prepareSearch ▁( ▁) ▁. ▁set Indices ▁( ▁STR ▁) ▁; ▁req ▁. ▁setQuery ▁( ▁QueryBuilders ▁. ▁function Score Query ▁( ▁QueryBuilders ▁. ▁termQuery ▁( ▁STR ▁, ▁STR ▁) ▁, ▁score ▁) ▁. ▁b oost Mode ▁( ▁Combine Function ▁. ▁REPLACE ▁) ▁) ▁; ▁req ▁. ▁set Search Type ▁( ▁Search Type ▁. ▁DFS _ QUERY _ TH EN _ FETCH ▁) ▁; ▁SearchResponse ▁rsp ▁= ▁req ▁. ▁get ▁( ▁) ▁; ▁assert SearchResponse ▁( ▁rsp ▁) ▁; ▁Search Hits ▁h its ▁= ▁rsp ▁. ▁getHits ▁( ▁) ▁; ▁assertEquals ▁( ▁3 ▁, ▁h its ▁. ▁getTotal Hits ▁( ▁) ▁. ▁value ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁h its ▁. ▁get At ▁( ▁0 ▁) ▁. ▁getId ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁h its ▁. ▁get At ▁( ▁1 ▁) ▁. ▁getId ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁h its ▁. ▁get At ▁( ▁2 ▁) ▁. ▁getId ▁( ▁) ▁) ▁; ▁req ▁= ▁client ▁( ▁) ▁. ▁prepareSearch ▁( ▁) ▁. ▁set Indices ▁( ▁STR ▁) ▁; ▁req ▁. ▁setQuery ▁( ▁QueryBuilders ▁. ▁function Score Query ▁( ▁QueryBuilders ▁. ▁termQuery ▁( ▁STR ▁, ▁STR ▁) ▁, ▁score ▁) ▁. ▁b oost Mode ▁( ▁Combine Function ▁. ▁REPLACE ▁) ▁) ▁; ▁score ▁= ▁Score Function Builders ▁. ▁script Function ▁( ▁new ▁Script ▁( ▁Script Type ▁. ▁IN LINE ▁, ▁STR ▁, ▁STR ▁, ▁Collections ▁. ▁emptyMap ▁( ▁) ▁) ▁) ▁; ▁req ▁. ▁add Aggregation ▁( ▁Aggregation Builders ▁. ▁max ▁( ▁STR ▁) ▁. ▁script ▁( ▁( ▁score ▁) ▁. ▁getScript ▁( ▁) ▁) ▁) ▁; ▁req ▁. ▁set Search Type ▁( ▁Search Type ▁. ▁DFS _ QUERY _ TH EN _ FETCH ▁) ▁; ▁rsp ▁= ▁req ▁. ▁get ▁( ▁) ▁; ▁assert SearchResponse ▁( ▁rsp ▁) ▁; ▁} ▁public ▁void ▁test Date Methods ▁( ▁) ▁throws ▁Exception ▁{ ▁Elasticsearch Assertions ▁. ▁assertAcked ▁( ▁prepareCreate ▁( ▁STR ▁) ▁. ▁set Mapping ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁) ▁;
▁public ▁class ▁Group ConfigTests ▁extends ▁Abstract XContentTestCase ▁< ▁Group Config ▁> ▁{ ▁public ▁static ▁Group Config ▁random GroupConfig ▁( ▁) ▁{ ▁Map ▁< ▁String ▁, ▁Single GroupSource ▁> ▁groups ▁= ▁new ▁LinkedHashMap ▁< ▁> ▁( ▁) ▁; ▁Set ▁< ▁String ▁> ▁names ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁randomInt Between ▁( ▁1 ▁, ▁4 ▁) ▁; ▁++ ▁i ▁) ▁{ ▁String ▁target FieldName ▁= ▁randomAlpha OfLengthBetween ▁( ▁1 ▁, ▁20 ▁) ▁; ▁if ▁( ▁names ▁. ▁add ▁( ▁target FieldName ▁) ▁) ▁{ ▁Single GroupSource ▁groupBy ▁= ▁null ▁; ▁Single GroupSource ▁. ▁Type ▁type ▁= ▁randomFrom ▁( ▁Single GroupSource ▁. ▁Type ▁. ▁values ▁( ▁) ▁) ▁; ▁switch ▁( ▁type ▁) ▁{ ▁case ▁TER MS ▁: ▁groupBy ▁= ▁Terms GroupSource Tests ▁. ▁random Terms GroupSource ▁( ▁) ▁; ▁break ▁; ▁case ▁H IST OGRAM ▁: ▁groupBy ▁= ▁Histogram GroupSource Tests ▁. ▁random Histogram GroupSource ▁( ▁) ▁; ▁break ▁; ▁case ▁DATE _ H IST OGRAM ▁: ▁groupBy ▁= ▁DateHistogram GroupSource Tests ▁. ▁random Date Histogram GroupSource ▁( ▁) ▁; ▁break ▁; ▁case ▁G E OT ILE _ GR ID ▁: ▁groupBy ▁= ▁GeoTile GroupSource Tests ▁. ▁random Geo Tile GroupSource ▁( ▁) ▁; ▁break ▁; ▁default ▁: ▁fail ▁( ▁STR ▁) ▁; ▁} ▁groups ▁. ▁put ▁( ▁target FieldName ▁, ▁groupBy ▁) ▁; ▁} ▁} ▁return ▁new ▁Group Config ▁( ▁groups ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Group Config ▁createTest Instance ▁( ▁) ▁{ ▁return ▁random GroupConfig ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Group Config ▁doParseInstance ▁( ▁XContentParser ▁parser ▁) ▁throws ▁IOException ▁{ ▁return ▁Group Config ▁. ▁fromXContent ▁( ▁parser ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁boolean ▁supports UnknownFields ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁protected ▁Predicate ▁< ▁String ▁> ▁getRandom Fields ExcludeFilter ▁( ▁) ▁{ ▁return ▁field ▁-> ▁field ▁. ▁isEmpty ▁( ▁) ▁== ▁false ▁; ▁} ▁public ▁void ▁test Len ient Parsing ▁( ▁) ▁throws ▁IOException ▁{ ▁BytesArray ▁json ▁= ▁new ▁BytesArray ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁; ▁XContentParser ▁parser ▁= ▁JsonXContent ▁. ▁json XContent ▁. ▁createParser ▁( ▁NamedXContent Registry ▁. ▁EMPTY ▁, ▁Deprecation Handler ▁. ▁TH ROW _ UNSUPPORTED _ OPERATION ▁, ▁json ▁. ▁streamInput ▁( ▁) ▁) ▁; ▁Group Config ▁gc ▁= ▁Group Config ▁. ▁fromXContent ▁( ▁parser ▁) ▁; ▁assertEquals ▁( ▁gc ▁. ▁getGroups ▁( ▁) ▁. ▁size ▁( ▁) ▁, ▁2 ▁) ▁; ▁assertTrue ▁( ▁gc ▁. ▁getGroups ▁( ▁) ▁. ▁containsKey ▁( ▁STR ▁) ▁) ▁; ▁Single GroupSource ▁group Source ▁= ▁gc ▁. ▁getGroups ▁( ▁) ▁. ▁get ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁group Source ▁, ▁instanceOf ▁( ▁Terms GroupSource ▁. ▁class ▁) ▁) ▁; ▁assertEquals ▁( ▁group Source ▁. ▁getField ▁( ▁) ▁, ▁STR ▁) ▁; ▁}
▁public ▁final ▁class ▁Decoder Counters ▁{ ▁public ▁int ▁decoder Init Count ▁; ▁public ▁int ▁decoder Release Count ▁; ▁public ▁int ▁input Buffer Count ▁; ▁public ▁int ▁skipped InputBuffer Count ▁; ▁public ▁int ▁render ed OutputBuffer Count ▁; ▁public ▁int ▁skipped OutputBuffer Count ▁; ▁public ▁int ▁dropped Buffer Count ▁; ▁public ▁int ▁max Con se cut ive Drop ped Buffer Count ▁; ▁public ▁int ▁dropped To Keyframe Count ▁; ▁public ▁synchronized ▁void ▁ensure Updated ▁( ▁) ▁{ ▁} ▁public ▁void ▁merge ▁( ▁Decoder Counters ▁other ▁) ▁{ ▁decoder Init Count ▁+= ▁other ▁. ▁decoder Init Count ▁; ▁decoder Release Count ▁+= ▁other ▁. ▁decoder Release Count ▁; ▁input Buffer Count ▁+= ▁other ▁. ▁input Buffer Count ▁; ▁skipped InputBuffer Count ▁+= ▁other ▁. ▁skipped InputBuffer Count ▁; ▁render ed OutputBuffer Count ▁+= ▁other ▁. ▁render ed OutputBuffer Count ▁; ▁skipped OutputBuffer Count ▁+= ▁other ▁. ▁skipped OutputBuffer Count ▁; ▁dropped Buffer Count ▁+= ▁other ▁. ▁dropped Buffer Count ▁; ▁max Con se cut ive Drop ped Buffer Count ▁= ▁Math ▁. ▁max ▁( ▁max Con se cut ive Drop ped Buffer Count ▁, ▁other ▁. ▁max Con se cut ive Drop ped Buffer Count ▁) ▁; ▁dropped To Keyframe Count ▁+= ▁other ▁. ▁dropped To Keyframe Count ▁; ▁} ▁}
▁LOG ▁. ▁info ▁( ▁STR ▁+ ▁method ▁+ ▁STR ▁+ ▁user ▁. ▁getShort UserName ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Run SharedCache Cleaner Task Response ▁run Cleaner Task ▁( ▁Run SharedCache Cleaner Task Request ▁request ▁) ▁throws ▁YarnException ▁{ ▁check Acls ▁( ▁STR ▁) ▁; ▁Run SharedCache Cleaner Task Response ▁response ▁= ▁record Factory ▁. ▁newRecord Instance ▁( ▁Run SharedCache Cleaner Task Response ▁. ▁class ▁) ▁; ▁this ▁. ▁clean er Service ▁. ▁run Cleaner Task ▁( ▁) ▁; ▁response ▁. ▁set Accepted ▁( ▁true ▁) ▁; ▁return ▁response ▁; ▁} ▁}
▁public ▁class ▁Job Metrics Handler ▁extends ▁Abstract Metrics Handler ▁< ▁Job Metrics Message Parameters ▁> ▁{ ▁public ▁Job Metrics Handler ▁( ▁final ▁Gateway Retriever ▁< ▁? ▁extends ▁RestfulGateway ▁> ▁leader Retriever ▁, ▁final ▁Time ▁timeout ▁, ▁final ▁Map ▁< ▁String ▁, ▁String ▁> ▁headers ▁, ▁final ▁Metric Fetcher ▁metric Fetcher ▁) ▁{ ▁super ▁( ▁leader Retriever ▁, ▁timeout ▁, ▁headers ▁, ▁Job Metrics Headers ▁. ▁getInstance ▁( ▁) ▁, ▁metric Fetcher ▁) ▁; ▁} ▁@ ▁Nullable ▁@ ▁Override ▁protected ▁Metric Store ▁. ▁Component Metric Store ▁getComponent Metric Store ▁( ▁final ▁HandlerRequest ▁< ▁Empty RequestBody ▁, ▁Job Metrics Message Parameters ▁> ▁request ▁, ▁final ▁Metric Store ▁metric Store ▁) ▁{ ▁return ▁metric Store ▁. ▁getJob Metric Store ▁( ▁request ▁. ▁getPath Parameter ▁( ▁JobID PathParameter ▁. ▁class ▁) ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁}
▁@ ▁Automatic Feature ▁public ▁class ▁Runtime Feature ▁implements ▁Feature ▁{ ▁@ ▁Override ▁public ▁void ▁after Registration ▁( ▁After Registration Access ▁access ▁) ▁{ ▁Runtime Support ▁. ▁initialize Runtime Support ▁( ▁) ▁; ▁ImageSingletons ▁. ▁add ▁( ▁VM Runtime Support ▁. ▁class ▁, ▁Runtime Support ▁. ▁getRuntime Support ▁( ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁Constant Value ▁extends ▁Pattern Value ▁{ ▁long ▁val ▁; ▁public ▁Constant Value ▁( ▁Location ▁location ▁) ▁{ ▁super ▁( ▁location ▁) ▁; ▁} ▁public ▁Constant Value ▁( ▁Location ▁location ▁, ▁long ▁v ▁) ▁{ ▁super ▁( ▁location ▁) ▁; ▁val ▁= ▁v ▁; ▁} ▁@ ▁Override ▁public ▁long ▁getValue ▁( ▁ParserWalker ▁pos ▁) ▁{ ▁return ▁val ▁; ▁} ▁@ ▁Override ▁public ▁Token Pattern ▁gen Min Pattern ▁( ▁VectorSTL ▁< ▁Token Pattern ▁> ▁ops ▁) ▁{ ▁return ▁new ▁Token Pattern ▁( ▁location ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Token Pattern ▁gen Pattern ▁( ▁long ▁v ▁) ▁{ ▁return ▁new ▁Token Pattern ▁( ▁location ▁, ▁val ▁== ▁v ▁) ▁; ▁} ▁@ ▁Override ▁public ▁long ▁minValue ▁( ▁) ▁{ ▁return ▁val ▁; ▁} ▁@ ▁Override ▁public ▁long ▁maxValue ▁( ▁) ▁{ ▁return ▁val ▁; ▁} ▁@ ▁Override ▁public ▁void ▁save Xml ▁( ▁PrintStream ▁s ▁) ▁{ ▁s ▁. ▁append ▁( ▁STR ▁) ▁; ▁s ▁. ▁print ▁( ▁val ▁) ▁; ▁s ▁. ▁append ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁restore Xml ▁( ▁Element ▁el ▁, ▁Trans late ▁trans ▁) ▁{ ▁val ▁= ▁Xml Utils ▁. ▁decode Unknown Long ▁( ▁el ▁. ▁getAttribute Value ▁( ▁STR ▁) ▁) ▁; ▁} ▁}
▁i ▁++ ▁) ▁{ ▁int ▁component Tag ▁= ▁section Data ▁. ▁readUnsigned Byte ▁( ▁) ▁; ▁long ▁component S pl ice P ts ▁= ▁C ▁. ▁TIME _ UNSET ▁; ▁if ▁( ▁! ▁s pl ice I mmediate Flag ▁) ▁{ ▁component S pl ice P ts ▁= ▁Time Signal Command ▁. ▁parse S pl ice Time ▁( ▁section Data ▁, ▁p ts Adj ust ment ▁) ▁; ▁} ▁component S pl ices ▁. ▁add ▁( ▁new ▁Component S pl ice ▁( ▁component Tag ▁, ▁component S pl ice P ts ▁, ▁timestamp Adj uster ▁. ▁adjust Ts Timestamp ▁( ▁component S pl ice P ts ▁) ▁) ▁) ▁; ▁} ▁} ▁if ▁( ▁duration Flag ▁) ▁{ ▁long ▁first Byte ▁= ▁section Data ▁. ▁readUnsigned Byte ▁( ▁) ▁; ▁auto Return ▁= ▁( ▁first Byte ▁& ▁0 x 80 ▁) ▁!= ▁0 ▁; ▁long ▁break Duration 90 k hz ▁= ▁( ▁( ▁first Byte ▁& ▁0 x 01 ▁) ▁<< ▁32 ▁) ▁| ▁section Data ▁. ▁readUnsigned Int ▁( ▁) ▁; ▁break Duration Us ▁= ▁break Duration 90 k hz ▁ * ▁1000 ▁ / ▁90 ▁; ▁} ▁unique Program Id ▁= ▁section Data ▁. ▁readUnsigned Short ▁( ▁) ▁; ▁a vail Num ▁= ▁section Data ▁. ▁readUnsigned Byte ▁( ▁) ▁; ▁a vail s Expected ▁= ▁section Data ▁. ▁readUnsigned Byte ▁( ▁) ▁; ▁} ▁return ▁new ▁S pl ice Insert Command ▁( ▁s pl ice Event Id ▁, ▁s pl ice Event Cancel Indicator ▁, ▁out Of Network Indicator ▁, ▁program S pl ice Flag ▁, ▁s pl ice I mmediate Flag ▁, ▁program S pl ice P ts ▁, ▁timestamp Adj uster ▁. ▁adjust Ts Timestamp ▁( ▁program S pl ice P ts ▁) ▁, ▁component S pl ices ▁, ▁auto Return ▁, ▁break Duration Us ▁, ▁unique Program Id ▁, ▁a vail Num ▁, ▁a vail s Expected ▁) ▁; ▁} ▁public ▁static ▁final ▁class ▁Component S pl ice ▁{ ▁public ▁final ▁int ▁component Tag ▁; ▁public ▁final ▁long ▁component S pl ice P ts ▁; ▁public ▁final ▁long ▁component S pl ice Playback PositionUs ▁; ▁private ▁Component S pl ice ▁( ▁int ▁component Tag ▁, ▁long ▁component S pl ice P ts ▁, ▁long ▁component S pl ice Playback PositionUs ▁) ▁{ ▁this ▁. ▁component Tag ▁= ▁component Tag ▁; ▁this ▁. ▁component S pl ice P ts ▁= ▁component S pl ice P ts ▁; ▁this ▁. ▁component S pl ice Playback PositionUs ▁= ▁component S pl ice Playback PositionUs ▁; ▁} ▁public ▁void ▁writeToParcel ▁( ▁Parcel ▁dest ▁) ▁{ ▁dest ▁. ▁writeInt ▁( ▁component Tag ▁) ▁; ▁dest ▁. ▁writeLong ▁( ▁component S pl ice P ts ▁) ▁; ▁dest ▁. ▁writeLong ▁( ▁component S pl ice Playback PositionUs ▁) ▁; ▁} ▁public ▁static ▁Component S pl ice ▁createFrom Parcel ▁( ▁Parcel ▁in ▁) ▁{ ▁return ▁new ▁Component S pl ice ▁( ▁in ▁. ▁readInt ▁( ▁) ▁, ▁in ▁. ▁readLong ▁( ▁) ▁, ▁in ▁. ▁readLong ▁( ▁) ▁) ▁; ▁} ▁}
▁Response Exception ▁exc ▁= ▁expectThrows ▁( ▁Response Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁submit Async Search ▁( ▁STR ▁+ ▁other ▁, ▁STR ▁, ▁TimeValue ▁. ▁timeValue Seconds ▁( ▁10 ▁) ▁, ▁user ▁) ▁) ▁; ▁assertThat ▁( ▁exc ▁. ▁getResponse ▁( ▁) ▁. ▁getStatusLine ▁( ▁) ▁. ▁getStatusCode ▁( ▁) ▁, ▁equalTo ▁( ▁4 03 ▁) ▁) ▁; ▁assertThat ▁( ▁exc ▁. ▁getMessage ▁( ▁) ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁} ▁private ▁SearchHit ▁[ ▁] ▁getSearch Hits ▁( ▁String ▁async Id ▁, ▁String ▁user ▁) ▁throws ▁IOException ▁{ ▁final ▁Response ▁resp ▁= ▁getAsync Search ▁( ▁async Id ▁, ▁user ▁) ▁; ▁assert OK ▁( ▁resp ▁) ▁; ▁Async SearchResponse ▁searchResponse ▁= ▁Async SearchResponse ▁. ▁fromXContent ▁( ▁XContentHelper ▁. ▁createParser ▁( ▁NamedXContent Registry ▁. ▁EMPTY ▁, ▁Logging Deprecation Handler ▁. ▁INSTANCE ▁, ▁new ▁BytesArray ▁( ▁Entity Utils ▁. ▁toByteArray ▁( ▁resp ▁. ▁getEntity ▁( ▁) ▁) ▁) ▁, ▁XContentType ▁. ▁JSON ▁) ▁) ▁; ▁return ▁searchResponse ▁. ▁getSearch Response ▁( ▁) ▁. ▁getHits ▁( ▁) ▁. ▁getHits ▁( ▁) ▁; ▁} ▁public ▁void ▁test Authorization Of Point In Time ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁authorized User ▁= ▁randomFrom ▁( ▁STR ▁, ▁STR ▁) ▁; ▁final ▁Matcher ▁< ▁SearchHit ▁> ▁hit Matcher ▁= ▁new ▁Custom Matcher ▁< ▁> ▁( ▁STR ▁) ▁{ ▁@ ▁Override ▁public ▁boolean ▁matches ▁( ▁Object ▁actual ▁) ▁{ ▁SearchHit ▁hit ▁= ▁( ▁SearchHit ▁) ▁actual ▁; ▁return ▁hit ▁. ▁getIndex ▁( ▁) ▁. ▁equals ▁( ▁STR ▁+ ▁authorized User ▁) ▁&& ▁hit ▁. ▁getId ▁( ▁) ▁. ▁equals ▁( ▁STR ▁) ▁; ▁} ▁} ▁; ▁final ▁String ▁p it Id ▁= ▁open Point In Time ▁( ▁new ▁String ▁[ ▁] ▁{ ▁STR ▁+ ▁authorized User ▁} ▁, ▁authorized User ▁) ▁; ▁try ▁{ ▁Response ▁submit ▁= ▁submit Async Search With P IT ▁( ▁p it Id ▁, ▁STR ▁, ▁TimeValue ▁. ▁timeValue Seconds ▁( ▁10 ▁) ▁, ▁authorized User ▁) ▁; ▁assert OK ▁( ▁submit ▁) ▁; ▁final ▁Response ▁resp ▁= ▁getAsync Search ▁( ▁extract Response Id ▁( ▁submit ▁) ▁, ▁authorized User ▁) ▁; ▁assert OK ▁( ▁resp ▁) ▁; ▁assertThat ▁( ▁getSearch Hits ▁( ▁extract Response Id ▁( ▁resp ▁) ▁, ▁authorized User ▁) ▁, ▁array Containing InAnyOrder ▁( ▁hit Matcher ▁) ▁) ▁; ▁String ▁un auth orized User ▁= ▁randomValue OtherThan ▁( ▁authorized User ▁, ▁( ▁) ▁-> ▁randomFrom ▁( ▁STR ▁, ▁STR ▁) ▁) ▁; ▁Response Exception ▁exc ▁= ▁expectThrows ▁( ▁Response Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁submit Async Search With P IT ▁( ▁p it Id ▁, ▁STR ▁, ▁TimeValue ▁. ▁timeValue Seconds ▁( ▁10 ▁) ▁, ▁un auth orized User ▁) ▁) ▁; ▁assertThat ▁( ▁exc ▁. ▁getResponse ▁( ▁) ▁. ▁getStatusLine ▁( ▁) ▁. ▁getStatusCode ▁( ▁) ▁, ▁equalTo ▁( ▁4 03 ▁) ▁) ▁; ▁assertThat ▁( ▁exc ▁. ▁getMessage ▁( ▁) ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁} ▁finally ▁{ ▁close Point In Time ▁( ▁p it Id ▁, ▁authorized User ▁) ▁; ▁} ▁}
▁public ▁void ▁set Swing Span 1 ▁( ▁float ▁value ▁) ▁{ ▁DynamicsJNI ▁. ▁bt Con e Tw ist ConstraintData _ swing Span 1_ set ▁( ▁swigCPtr ▁, ▁this ▁, ▁value ▁) ▁; ▁} ▁public ▁float ▁getS w ing Span 1 ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Con e Tw ist ConstraintData _ swing Span 1_ get ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁void ▁set Swing Span 2 ▁( ▁float ▁value ▁) ▁{ ▁DynamicsJNI ▁. ▁bt Con e Tw ist ConstraintData _ swing Span 2_ set ▁( ▁swigCPtr ▁, ▁this ▁, ▁value ▁) ▁; ▁} ▁public ▁float ▁getS w ing Span 2 ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Con e Tw ist ConstraintData _ swing Span 2_ get ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁void ▁setT w ist Span ▁( ▁float ▁value ▁) ▁{ ▁DynamicsJNI ▁. ▁bt Con e Tw ist ConstraintData _ t w ist Span _ set ▁( ▁swigCPtr ▁, ▁this ▁, ▁value ▁) ▁; ▁} ▁public ▁float ▁getT w ist Span ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Con e Tw ist ConstraintData _ t w ist Span _ get ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁void ▁setLimit Soft ness ▁( ▁float ▁value ▁) ▁{ ▁DynamicsJNI ▁. ▁bt Con e Tw ist ConstraintData _ limit Soft ness _ set ▁( ▁swigCPtr ▁, ▁this ▁, ▁value ▁) ▁; ▁} ▁public ▁float ▁getLimit Soft ness ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Con e Tw ist ConstraintData _ limit Soft ness _ get ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁void ▁setB ias Factor ▁( ▁float ▁value ▁) ▁{ ▁DynamicsJNI ▁. ▁bt Con e Tw ist ConstraintData _ b ias Factor _ set ▁( ▁swigCPtr ▁, ▁this ▁, ▁value ▁) ▁; ▁} ▁public ▁float ▁getB ias Factor ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Con e Tw ist ConstraintData _ b ias Factor _ get ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁void ▁setRe l ax ation Factor ▁( ▁float ▁value ▁) ▁{ ▁DynamicsJNI ▁. ▁bt Con e Tw ist ConstraintData _ re l ax ation Factor _ set ▁( ▁swigCPtr ▁, ▁this ▁, ▁value ▁) ▁; ▁} ▁public ▁float ▁getRe l ax ation Factor ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Con e Tw ist ConstraintData _ re l ax ation Factor _ get ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁void ▁setD amp ing ▁( ▁float ▁value ▁) ▁{ ▁DynamicsJNI ▁. ▁bt Con e Tw ist ConstraintData _ d amp ing _ set ▁( ▁swigCPtr ▁, ▁this ▁, ▁value ▁) ▁; ▁} ▁public ▁float ▁getD amp ing ▁( ▁) ▁{ ▁return ▁DynamicsJNI ▁. ▁bt Con e Tw ist ConstraintData _ d amp ing _ get ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁void ▁setP ad ▁( ▁String ▁value ▁) ▁{ ▁DynamicsJNI ▁. ▁bt Con e Tw ist ConstraintData _ pad _ set ▁( ▁swigCPtr ▁, ▁this ▁, ▁value ▁) ▁; ▁}
▁l Arr ▁= ▁layer Listeners ▁. ▁toArray ▁( ▁new ▁Training Listener ▁[ ▁2 ▁] ▁) ▁; ▁assertTrue ▁( ▁l Arr ▁[ ▁0 ▁] ▁instanceof ▁Score Iteration Listener ▁) ▁; ▁assertTrue ▁( ▁l Arr ▁[ ▁1 ▁] ▁instanceof ▁Test Routing Listener ▁) ▁; ▁} ▁net Listeners ▁= ▁cg ▁. ▁getList eners ▁( ▁) ▁; ▁assertEquals ▁( ▁2 ▁, ▁net Listeners ▁. ▁size ▁( ▁) ▁) ▁; ▁l Arr ▁= ▁net Listeners ▁. ▁toArray ▁( ▁new ▁Training Listener ▁[ ▁2 ▁] ▁) ▁; ▁assertTrue ▁( ▁l Arr ▁[ ▁0 ▁] ▁instanceof ▁Score Iteration Listener ▁) ▁; ▁assertTrue ▁( ▁l Arr ▁[ ▁1 ▁] ▁instanceof ▁Test Routing Listener ▁) ▁; ▁} ▁private ▁static ▁class ▁Test Routing Listener ▁extends ▁Base Training Listener ▁implements ▁Routing Iteration Listener ▁{ ▁@ ▁Override ▁public ▁void ▁set Storage Router ▁( ▁Stats Storage Router ▁router ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁Stats Storage Router ▁getStorage Router ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Worker ID ▁( ▁String ▁worker ID ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁String ▁get Worker ID ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Session ID ▁( ▁String ▁session ID ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁String ▁getSession ID ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁Routing Iteration Listener ▁clone ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁void ▁iteration Done ▁( ▁Model ▁model ▁, ▁int ▁iteration ▁, ▁int ▁epoch ▁) ▁{ ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Listener Serialization ▁( ▁@ ▁TempDir ▁Path ▁tempDir ▁) ▁throws ▁Exception ▁{ ▁List ▁< ▁Training Listener ▁> ▁listeners ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁listeners ▁. ▁add ▁( ▁new ▁Score Iteration Listener ▁( ▁) ▁) ▁; ▁listeners ▁. ▁add ▁( ▁new ▁Performance Listener ▁( ▁1 ▁, ▁true ▁, ▁true ▁) ▁) ▁; ▁listeners ▁. ▁add ▁( ▁new ▁Time Iteration Listener ▁( ▁10000 ▁) ▁) ▁; ▁listeners ▁. ▁add ▁( ▁new ▁Composable Iteration Listener ▁( ▁new ▁Score Iteration Listener ▁( ▁) ▁, ▁new ▁Performance Listener ▁( ▁1 ▁, ▁true ▁, ▁true ▁) ▁) ▁) ▁; ▁listeners ▁. ▁add ▁( ▁new ▁Checkpoint Listener ▁. ▁Builder ▁( ▁tempDir ▁. ▁toFile ▁( ▁) ▁) ▁. ▁keep All ▁( ▁) ▁. ▁save E very NI ter ations ▁( ▁3 ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁DataSetIterator ▁iter ▁= ▁new ▁I ri s DataSetIterator ▁( ▁10 ▁, ▁150 ▁) ▁; ▁MultiLayer Configuration ▁conf ▁= ▁new ▁NeuralNet Configuration ▁. ▁Builder ▁( ▁) ▁. ▁list ▁( ▁) ▁. ▁layer ▁( ▁new ▁Output Layer ▁. ▁Builder ▁( ▁) ▁. ▁nIn ▁( ▁4 ▁) ▁. ▁nOut ▁( ▁3 ▁) ▁. ▁activation ▁( ▁Activation ▁. ▁S OFT MAX ▁) ▁. ▁loss Function ▁( ▁Loss Functions ▁. ▁LossFunction ▁. ▁M C X ENT ▁) ▁. ▁build ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁MultiLayer Network ▁net ▁= ▁new ▁MultiLayer Network ▁( ▁conf ▁) ▁; ▁net ▁. ▁init ▁( ▁) ▁; ▁net ▁. ▁set Listeners ▁( ▁listeners ▁) ▁; ▁net ▁. ▁fit ▁( ▁iter ▁) ▁; ▁List ▁< ▁Training Listener ▁> ▁listeners 2 ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁;
▁public ▁final ▁class ▁Plan Cost Estimate ▁{ ▁private ▁static ▁final ▁Plan Cost Estimate ▁IN FIN ITE ▁= ▁new ▁Plan Cost Estimate ▁( ▁POSITIVE _ INFINITY ▁, ▁POSITIVE _ INFINITY ▁, ▁POSITIVE _ INFINITY ▁, ▁POSITIVE _ INFINITY ▁) ▁; ▁private ▁static ▁final ▁Plan Cost Estimate ▁UNKNOWN ▁= ▁new ▁Plan Cost Estimate ▁( ▁NaN ▁, ▁NaN ▁, ▁NaN ▁, ▁NaN ▁) ▁; ▁private ▁static ▁final ▁Plan Cost Estimate ▁ Z ERO ▁= ▁new ▁Plan Cost Estimate ▁( ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁private ▁final ▁double ▁cpu Cost ▁; ▁private ▁final ▁double ▁max Memory ▁; ▁private ▁final ▁double ▁max Memory When Output ting ▁; ▁private ▁final ▁double ▁network Cost ▁; ▁public ▁static ▁Plan Cost Estimate ▁inf inite ▁( ▁) ▁{ ▁return ▁IN FIN ITE ▁; ▁} ▁public ▁static ▁Plan Cost Estimate ▁unknown ▁( ▁) ▁{ ▁return ▁UNKNOWN ▁; ▁} ▁public ▁static ▁Plan Cost Estimate ▁zero ▁( ▁) ▁{ ▁return ▁ Z ERO ▁; ▁} ▁@ ▁JsonCreator ▁public ▁Plan Cost Estimate ▁( ▁@ ▁JsonProperty ▁( ▁STR ▁) ▁double ▁cpu Cost ▁, ▁@ ▁JsonProperty ▁( ▁STR ▁) ▁double ▁max Memory ▁, ▁@ ▁JsonProperty ▁( ▁STR ▁) ▁double ▁max Memory When Output ting ▁, ▁@ ▁JsonProperty ▁( ▁STR ▁) ▁double ▁network Cost ▁) ▁{ ▁checkArgument ▁( ▁! ▁( ▁cpu Cost ▁< ▁0 ▁) ▁, ▁STR ▁, ▁cpu Cost ▁) ▁; ▁checkArgument ▁( ▁! ▁( ▁max Memory ▁< ▁0 ▁) ▁, ▁STR ▁, ▁max Memory ▁) ▁; ▁checkArgument ▁( ▁! ▁( ▁max Memory When Output ting ▁< ▁0 ▁) ▁, ▁STR ▁, ▁max Memory When Output ting ▁) ▁; ▁checkArgument ▁( ▁! ▁( ▁max Memory When Output ting ▁> ▁max Memory ▁) ▁, ▁STR ▁, ▁max Memory When Output ting ▁, ▁max Memory ▁) ▁; ▁checkArgument ▁( ▁! ▁( ▁network Cost ▁< ▁0 ▁) ▁, ▁STR ▁, ▁network Cost ▁) ▁; ▁this ▁. ▁cpu Cost ▁= ▁cpu Cost ▁; ▁this ▁. ▁max Memory ▁= ▁max Memory ▁; ▁this ▁. ▁max Memory When Output ting ▁= ▁max Memory When Output ting ▁; ▁this ▁. ▁network Cost ▁= ▁network Cost ▁; ▁} ▁@ ▁JsonProperty ▁public ▁double ▁getCpu Cost ▁( ▁) ▁{ ▁return ▁cpu Cost ▁; ▁} ▁@ ▁JsonProperty ▁public ▁double ▁getMax Memory ▁( ▁) ▁{ ▁return ▁max Memory ▁; ▁} ▁@ ▁JsonProperty ▁public ▁double ▁getMax Memory When Output ting ▁( ▁) ▁{ ▁return ▁max Memory When Output ting ▁; ▁} ▁@ ▁JsonProperty ▁public ▁double ▁getNetwork Cost ▁( ▁) ▁{ ▁return ▁network Cost ▁; ▁} ▁public ▁boolean ▁has Unknown Components ▁( ▁) ▁{ ▁return ▁isNaN ▁( ▁cpu Cost ▁) ▁|| ▁isNaN ▁( ▁max Memory ▁) ▁|| ▁isNaN ▁( ▁max Memory When Output ting ▁) ▁|| ▁isNaN ▁( ▁network Cost ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁toStringHelper ▁( ▁this ▁) ▁. ▁add ▁( ▁STR ▁, ▁cpu Cost ▁) ▁. ▁add ▁( ▁STR ▁, ▁max Memory ▁) ▁. ▁add ▁( ▁STR ▁, ▁network Cost ▁) ▁. ▁toString ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁o ▁) ▁{ ▁if ▁( ▁this ▁== ▁o ▁) ▁{ ▁return ▁true ▁; ▁}
▁public ▁class ▁Plugin FileReader Test ▁extends ▁TestBase ▁{ ▁Plugin FileReader ▁reader ▁= ▁new ▁Plugin FileReader ▁( ▁) ▁; ▁@ ▁Test ▁public ▁void ▁no _ class _ in _ resource ▁( ▁) ▁throws ▁IOException ▁{ ▁assertNull ▁( ▁reader ▁. ▁read Plugin Class ▁( ▁impl ▁( ▁STR ▁) ▁) ▁) ▁; ▁assertNull ▁( ▁reader ▁. ▁read Plugin Class ▁( ▁impl ▁( ▁STR ▁) ▁) ▁) ▁; ▁assertNull ▁( ▁reader ▁. ▁read Plugin Class ▁( ▁impl ▁( ▁STR ▁) ▁) ▁) ▁; ▁assertNull ▁( ▁reader ▁. ▁read Plugin Class ▁( ▁impl ▁( ▁STR ▁) ▁) ▁) ▁; ▁assertNull ▁( ▁reader ▁. ▁read Plugin Class ▁( ▁impl ▁( ▁STR ▁) ▁) ▁) ▁; ▁assertNull ▁( ▁reader ▁. ▁read Plugin Class ▁( ▁impl ▁( ▁STR ▁) ▁) ▁) ▁; ▁assertNull ▁( ▁reader ▁. ▁read Plugin Class ▁( ▁impl ▁( ▁STR ▁) ▁) ▁) ▁; ▁} ▁private ▁InputStream ▁impl ▁( ▁String ▁s ▁) ▁{ ▁return ▁new ▁ByteArray InputStream ▁( ▁s ▁. ▁getBytes ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁read s _ class _ name ▁( ▁) ▁throws ▁IOException ▁{ ▁assertEquals ▁( ▁STR ▁, ▁reader ▁. ▁read Plugin Class ▁( ▁impl ▁( ▁STR ▁) ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁reader ▁. ▁read Plugin Class ▁( ▁impl ▁( ▁STR ▁) ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁reader ▁. ▁read Plugin Class ▁( ▁impl ▁( ▁STR ▁) ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁reader ▁. ▁read Plugin Class ▁( ▁impl ▁( ▁STR ▁) ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁reader ▁. ▁read Plugin Class ▁( ▁impl ▁( ▁STR ▁) ▁) ▁) ▁; ▁} ▁}
▁public ▁final ▁class ▁New Device Transfer Fragment ▁extends ▁Device Transfer Fragment ▁{ ▁private ▁final ▁Server Task Listener ▁server Task Listener ▁= ▁new ▁Server Task Listener ▁( ▁) ▁; ▁@ ▁Override ▁public ▁void ▁onView Created ▁( ▁@ ▁NonNull ▁View ▁view ▁, ▁@ ▁Nullable ▁Bundle ▁saved InstanceState ▁) ▁{ ▁super ▁. ▁onView Created ▁( ▁view ▁, ▁saved InstanceState ▁) ▁; ▁EventBus ▁. ▁getDefault ▁( ▁) ▁. ▁register ▁( ▁server Task Listener ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁on Destroy View ▁( ▁) ▁{ ▁EventBus ▁. ▁getDefault ▁( ▁) ▁. ▁unregister ▁( ▁server Task Listener ▁) ▁; ▁super ▁. ▁on Destroy View ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁navig ate To Restart Transfer ▁( ▁) ▁{ ▁N av Host Fragment ▁. ▁find Nav Controller ▁( ▁this ▁) ▁. ▁navig ate ▁( ▁R ▁. ▁id ▁. ▁action _ new Device Transfer _ to _ new Device Transfer Instructions ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁navig ate A way From Transfer ▁( ▁) ▁{ ▁EventBus ▁. ▁getDefault ▁( ▁) ▁. ▁unregister ▁( ▁server Task Listener ▁) ▁; ▁N av Host Fragment ▁. ▁find Nav Controller ▁( ▁this ▁) ▁. ▁navig ate ▁( ▁R ▁. ▁id ▁. ▁action _ re start _ to _ w el come Fragment ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁navig ate To Transfer Complete ▁( ▁) ▁{ ▁N av Host Fragment ▁. ▁find Nav Controller ▁( ▁this ▁) ▁. ▁navig ate ▁( ▁R ▁. ▁id ▁. ▁action _ new Device Transfer _ to _ new Device Transfer Complete ▁) ▁; ▁} ▁private ▁class ▁Server Task Listener ▁{ ▁@ ▁Subscribe ▁( ▁thread Mode ▁= ▁Thread Mode ▁. ▁M AIN ▁) ▁public ▁void ▁onEvent MainThread ▁( ▁@ ▁NonNull ▁New Device Server Task ▁. ▁Status ▁event ▁) ▁{ ▁status ▁. ▁setText ▁( ▁getString ▁( ▁R ▁. ▁string ▁. ▁Device Transfer __ d _ m essages _ s o _ f ar ▁, ▁event ▁. ▁getMessage Count ▁( ▁) ▁) ▁) ▁; ▁switch ▁( ▁event ▁. ▁getState ▁( ▁) ▁) ▁{ ▁case ▁IN _ PROGRESS ▁: ▁break ▁; ▁case ▁SUCCESS ▁: ▁transfer Finished ▁= ▁true ▁; ▁Device To Device Transfer Service ▁. ▁stop ▁( ▁require Context ▁( ▁) ▁) ▁; ▁navig ate To Transfer Complete ▁( ▁) ▁; ▁break ▁; ▁case ▁FAILURE _ VERSION _ DOWN GRADE ▁: ▁abort ▁( ▁R ▁. ▁string ▁. ▁New Device Transfer __ c annot _ trans fer _ from _ a _ new er _ version _ of _ s ignal ▁) ▁; ▁break ▁; ▁case ▁FAILURE _ UNKNOWN ▁: ▁abort ▁( ▁) ▁; ▁break ▁; ▁} ▁} ▁} ▁}
▁class ▁App ▁{ ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁final ▁var ▁bus ▁= ▁Data Bus ▁. ▁getInstance ▁( ▁) ▁; ▁bus ▁. ▁subscribe ▁( ▁new ▁Status Member ▁( ▁1 ▁) ▁) ▁; ▁bus ▁. ▁subscribe ▁( ▁new ▁Status Member ▁( ▁2 ▁) ▁) ▁; ▁final ▁var ▁foo ▁= ▁new ▁Message Collector Member ▁( ▁STR ▁) ▁; ▁final ▁var ▁bar ▁= ▁new ▁Message Collector Member ▁( ▁STR ▁) ▁; ▁bus ▁. ▁subscribe ▁( ▁foo ▁) ▁; ▁bus ▁. ▁publish ▁( ▁Start ing Data ▁. ▁of ▁( ▁LocalDateTime ▁. ▁now ▁( ▁) ▁) ▁) ▁; ▁bus ▁. ▁publish ▁( ▁Message Data ▁. ▁of ▁( ▁STR ▁) ▁) ▁; ▁bus ▁. ▁subscribe ▁( ▁bar ▁) ▁; ▁bus ▁. ▁publish ▁( ▁Message Data ▁. ▁of ▁( ▁STR ▁) ▁) ▁; ▁bus ▁. ▁unsubscribe ▁( ▁foo ▁) ▁; ▁bus ▁. ▁publish ▁( ▁Message Data ▁. ▁of ▁( ▁STR ▁) ▁) ▁; ▁bus ▁. ▁publish ▁( ▁Stop ping Data ▁. ▁of ▁( ▁LocalDateTime ▁. ▁now ▁( ▁) ▁) ▁) ▁; ▁} ▁}
▁@ ▁ExtendWith ▁( ▁Mockito Extension ▁. ▁class ▁) ▁class ▁Jmx Endpoint Exporter Tests ▁{ ▁@ ▁Mock ▁private ▁MBeanServer ▁m Bean Server ▁; ▁@ ▁Spy ▁private ▁Endpoint ObjectName Factory ▁objectName Factory ▁= ▁new ▁Test Endpoint ObjectName Factory ▁( ▁) ▁; ▁private ▁Jmx Operation Response Mapper ▁response Mapper ▁= ▁new ▁Test Jmx Operation Response Mapper ▁( ▁) ▁; ▁private ▁List ▁< ▁Exposable Jmx Endpoint ▁> ▁endpoints ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁@ ▁C aptor ▁private ▁ArgumentCaptor ▁< ▁Object ▁> ▁object Captor ▁; ▁@ ▁C aptor ▁private ▁ArgumentCaptor ▁< ▁ObjectName ▁> ▁objectName Captor ▁; ▁private ▁Jmx Endpoint Exporter ▁exporter ▁; ▁@ ▁BeforeEach ▁void ▁setup ▁( ▁) ▁{ ▁this ▁. ▁exporter ▁= ▁new ▁Jmx Endpoint Exporter ▁( ▁this ▁. ▁m Bean Server ▁, ▁this ▁. ▁objectName Factory ▁, ▁this ▁. ▁response Mapper ▁, ▁this ▁. ▁endpoints ▁) ▁; ▁} ▁@ ▁Test ▁void ▁create When MBeanServer IsNull Should ThrowException ▁( ▁) ▁{ ▁assertThat IllegalArgument Exception ▁( ▁) ▁. ▁isThrownBy ▁( ▁( ▁) ▁-> ▁new ▁Jmx Endpoint Exporter ▁( ▁null ▁, ▁this ▁. ▁objectName Factory ▁, ▁this ▁. ▁response Mapper ▁, ▁this ▁. ▁endpoints ▁) ▁) ▁. ▁withMessage Containing ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁void ▁create When ObjectName Factory IsNull Should ThrowException ▁( ▁) ▁{ ▁assertThat IllegalArgument Exception ▁( ▁) ▁. ▁isThrownBy ▁( ▁( ▁) ▁-> ▁new ▁Jmx Endpoint Exporter ▁( ▁this ▁. ▁m Bean Server ▁, ▁null ▁, ▁this ▁. ▁response Mapper ▁, ▁this ▁. ▁endpoints ▁) ▁) ▁. ▁withMessage Containing ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁void ▁create When Response Mapper IsNull Should ThrowException ▁( ▁) ▁{ ▁assertThat IllegalArgument Exception ▁( ▁) ▁. ▁isThrownBy ▁( ▁( ▁) ▁-> ▁new ▁Jmx Endpoint Exporter ▁( ▁this ▁. ▁m Bean Server ▁, ▁this ▁. ▁objectName Factory ▁, ▁null ▁, ▁this ▁. ▁endpoints ▁) ▁) ▁. ▁withMessage Containing ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁void ▁create When Endpoints IsNull Should ThrowException ▁( ▁) ▁{ ▁assertThat IllegalArgument Exception ▁( ▁) ▁. ▁isThrownBy ▁( ▁( ▁) ▁-> ▁new ▁Jmx Endpoint Exporter ▁( ▁this ▁. ▁m Bean Server ▁, ▁this ▁. ▁objectName Factory ▁, ▁this ▁. ▁response Mapper ▁, ▁null ▁) ▁) ▁. ▁withMessage Containing ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁void ▁after PropertiesSet Should Register M Beans ▁( ▁) ▁throws ▁Exception ▁{ ▁this ▁. ▁endpoints ▁. ▁add ▁( ▁new ▁Test Ex posable Jmx Endpoint ▁( ▁new ▁Test Jmx Operation ▁( ▁) ▁) ▁) ▁; ▁this ▁. ▁exporter ▁. ▁after PropertiesSet ▁( ▁) ▁; ▁verify ▁( ▁this ▁. ▁m Bean Server ▁) ▁. ▁register MBean ▁( ▁this ▁. ▁object Captor ▁. ▁capture ▁( ▁) ▁, ▁this ▁. ▁objectName Captor ▁. ▁capture ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁this ▁. ▁object Captor ▁. ▁getValue ▁( ▁) ▁) ▁. ▁isInstanceOf ▁( ▁Endpoint MBean ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁this ▁. ▁objectName Captor ▁. ▁getValue ▁( ▁) ▁. ▁getKey Property ▁( ▁STR ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁}
▁retry able RestTemplate ▁. ▁get ▁( ▁Env ▁. ▁DE V ▁, ▁path ▁, ▁Object ▁. ▁class ▁) ▁; ▁verify ▁( ▁restTemplate ▁, ▁times ▁( ▁1 ▁) ▁) ▁. ▁exchange ▁( ▁eq ▁( ▁service One ▁+ ▁STR ▁+ ▁path ▁) ▁, ▁eq ▁( ▁HttpMethod ▁. ▁GET ▁) ▁, ▁any ▁( ▁HttpEntity ▁. ▁class ▁) ▁, ▁eq ▁( ▁Object ▁. ▁class ▁) ▁) ▁; ▁verify ▁( ▁restTemplate ▁, ▁times ▁( ▁1 ▁) ▁) ▁. ▁exchange ▁( ▁eq ▁( ▁service Two ▁+ ▁STR ▁+ ▁path ▁) ▁, ▁eq ▁( ▁HttpMethod ▁. ▁GET ▁) ▁, ▁any ▁( ▁HttpEntity ▁. ▁class ▁) ▁, ▁eq ▁( ▁Object ▁. ▁class ▁) ▁) ▁; ▁verify ▁( ▁restTemplate ▁, ▁times ▁( ▁1 ▁) ▁) ▁. ▁exchange ▁( ▁eq ▁( ▁service Three ▁+ ▁STR ▁+ ▁path ▁) ▁, ▁eq ▁( ▁HttpMethod ▁. ▁GET ▁) ▁, ▁any ▁( ▁HttpEntity ▁. ▁class ▁) ▁, ▁eq ▁( ▁Object ▁. ▁class ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test One Server Down ▁( ▁) ▁{ ▁ResponseEntity ▁some Entity ▁= ▁mock ▁( ▁ResponseEntity ▁. ▁class ▁) ▁; ▁when ▁( ▁some Entity ▁. ▁getBody ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁result ▁) ▁; ▁when ▁( ▁service Address Locator ▁. ▁getService List ▁( ▁any ▁( ▁) ▁) ▁) ▁. ▁thenReturn ▁( ▁Arrays ▁. ▁asList ▁( ▁mock Service ▁( ▁service One ▁) ▁, ▁mock Service ▁( ▁service Two ▁) ▁, ▁mock Service ▁( ▁service Three ▁) ▁) ▁) ▁; ▁when ▁( ▁restTemplate ▁. ▁exchange ▁( ▁eq ▁( ▁service One ▁+ ▁STR ▁+ ▁path ▁) ▁, ▁eq ▁( ▁HttpMethod ▁. ▁GET ▁) ▁, ▁any ▁( ▁HttpEntity ▁. ▁class ▁) ▁, ▁eq ▁( ▁Object ▁. ▁class ▁) ▁) ▁) ▁. ▁thenThrow ▁( ▁socket TimeoutException ▁) ▁; ▁when ▁( ▁restTemplate ▁. ▁exchange ▁( ▁eq ▁( ▁service Two ▁+ ▁STR ▁+ ▁path ▁) ▁, ▁eq ▁( ▁HttpMethod ▁. ▁GET ▁) ▁, ▁any ▁( ▁HttpEntity ▁. ▁class ▁) ▁, ▁eq ▁( ▁Object ▁. ▁class ▁) ▁) ▁) ▁. ▁thenReturn ▁( ▁some Entity ▁) ▁; ▁when ▁( ▁restTemplate ▁. ▁exchange ▁( ▁eq ▁( ▁service Three ▁+ ▁STR ▁+ ▁path ▁) ▁, ▁eq ▁( ▁HttpMethod ▁. ▁GET ▁) ▁, ▁any ▁( ▁HttpEntity ▁. ▁class ▁) ▁, ▁eq ▁( ▁Object ▁. ▁class ▁) ▁) ▁) ▁. ▁thenThrow ▁( ▁connect TimeoutException ▁) ▁; ▁Object ▁actual Result ▁= ▁retry able RestTemplate ▁. ▁get ▁( ▁Env ▁. ▁DE V ▁, ▁path ▁, ▁Object ▁. ▁class ▁) ▁; ▁verify ▁( ▁restTemplate ▁, ▁times ▁( ▁1 ▁) ▁) ▁. ▁exchange ▁( ▁eq ▁( ▁service One ▁+ ▁STR ▁+ ▁path ▁) ▁, ▁eq ▁( ▁HttpMethod ▁. ▁GET ▁) ▁, ▁any ▁( ▁HttpEntity ▁. ▁class ▁) ▁, ▁eq ▁( ▁Object ▁. ▁class ▁) ▁) ▁; ▁verify ▁( ▁restTemplate ▁, ▁times ▁( ▁1 ▁) ▁) ▁. ▁exchange ▁( ▁eq ▁( ▁service Two ▁+ ▁STR ▁+ ▁path ▁) ▁, ▁eq ▁( ▁HttpMethod ▁. ▁GET ▁) ▁, ▁any ▁( ▁HttpEntity ▁. ▁class ▁) ▁, ▁eq ▁( ▁Object ▁. ▁class ▁) ▁) ▁;
▁@ ▁Ignore ▁( ▁STR ▁) ▁public ▁class ▁Join Cancel ing ITCase ▁extends ▁Cancel ing TestBase ▁{ ▁private ▁void ▁execute Task ▁( ▁Join Function ▁< ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁, ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁, ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁join er ▁, ▁boolean ▁slow ▁) ▁throws ▁Exception ▁{ ▁execute Task ▁( ▁join er ▁, ▁slow ▁, ▁PAR ALLELISM ▁) ▁; ▁} ▁private ▁void ▁execute Task ▁( ▁Join Function ▁< ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁, ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁, ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁join er ▁, ▁boolean ▁slow ▁, ▁int ▁parallelism ▁) ▁throws ▁Exception ▁{ ▁Execution Environment ▁env ▁= ▁Execution Environment ▁. ▁getExecution Environment ▁( ▁) ▁; ▁DataSet ▁< ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁input 1 ▁= ▁env ▁. ▁createInput ▁( ▁new ▁Inf inite Integer Tuple InputFormat ▁( ▁slow ▁) ▁) ▁; ▁DataSet ▁< ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁input 2 ▁= ▁env ▁. ▁createInput ▁( ▁new ▁Inf inite Integer Tuple InputFormat ▁( ▁slow ▁) ▁) ▁; ▁input 1 ▁. ▁join ▁( ▁input 2 ▁, ▁Join OperatorBase ▁. ▁Join Hint ▁. ▁RE PARTITION _ S ORT _ M ERGE ▁) ▁. ▁where ▁( ▁0 ▁) ▁. ▁equalTo ▁( ▁0 ▁) ▁. ▁with ▁( ▁join er ▁) ▁. ▁output ▁( ▁new ▁Discarding OutputFormat ▁< ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁( ▁) ▁) ▁; ▁env ▁. ▁setParallelism ▁( ▁parallelism ▁) ▁; ▁run And Cancel Job ▁( ▁env ▁. ▁create Program Plan ▁( ▁) ▁, ▁5 ▁ * ▁1000 ▁, ▁10 ▁ * ▁1000 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Cancel Sort Match While Reading Slow Inputs ▁( ▁) ▁throws ▁Exception ▁{ ▁execute Task ▁( ▁new ▁Simple Matcher ▁< ▁Integer ▁> ▁( ▁) ▁, ▁true ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Cancel Sort Match While Reading Fast Inputs ▁( ▁) ▁throws ▁Exception ▁{ ▁execute Task ▁( ▁new ▁Simple Matcher ▁< ▁Integer ▁> ▁( ▁) ▁, ▁false ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Cancel Sort Match P ri or To First Record Reading ▁( ▁) ▁throws ▁Exception ▁{ ▁execute Task ▁( ▁new ▁St uck In Open Matcher ▁< ▁Integer ▁> ▁( ▁) ▁, ▁false ▁) ▁; ▁} ▁private ▁void ▁execute Task With Generator ▁( ▁Join Function ▁< ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁, ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁, ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁join er ▁, ▁int ▁keys ▁, ▁int ▁vals ▁, ▁int ▁m se cs T ill Cancel ing ▁, ▁int ▁max Time T ill Canceled ▁) ▁throws ▁Exception ▁{ ▁Execution Environment ▁env ▁= ▁Execution Environment ▁. ▁getExecution Environment ▁( ▁) ▁; ▁DataSet ▁< ▁Tuple 2 ▁< ▁Integer ▁, ▁Integer ▁> ▁> ▁input 1 ▁= ▁env ▁. ▁createInput ▁( ▁new ▁Un iform Int Tuple Generator InputFormat ▁( ▁keys ▁, ▁vals ▁) ▁) ▁;
▁public ▁void ▁gl Draw Elements ▁( ▁int ▁mode ▁, ▁int ▁count ▁, ▁int ▁type ▁, ▁Buffer ▁indices ▁) ▁{ ▁if ▁( ▁indices ▁instanceof ▁Short Buffer ▁&& ▁type ▁== ▁com ▁. ▁bad log ic ▁. ▁g dx ▁. ▁graphics ▁. ▁GL 20 ▁. ▁GL _ UN SIGNED _ SHORT ▁) ▁GL 11 ▁. ▁gl Draw Elements ▁( ▁mode ▁, ▁( ▁Short Buffer ▁) ▁indices ▁) ▁; ▁else ▁if ▁( ▁indices ▁instanceof ▁ByteBuffer ▁&& ▁type ▁== ▁com ▁. ▁bad log ic ▁. ▁g dx ▁. ▁graphics ▁. ▁GL 20 ▁. ▁GL _ UN SIGNED _ SHORT ▁) ▁GL 11 ▁. ▁gl Draw Elements ▁( ▁mode ▁, ▁( ▁( ▁ByteBuffer ▁) ▁indices ▁) ▁. ▁as Short Buffer ▁( ▁) ▁) ▁; ▁else ▁if ▁( ▁indices ▁instanceof ▁ByteBuffer ▁&& ▁type ▁== ▁com ▁. ▁bad log ic ▁. ▁g dx ▁. ▁graphics ▁. ▁GL 20 ▁. ▁GL _ UN SIGNED _ BYTE ▁) ▁GL 11 ▁. ▁gl Draw Elements ▁( ▁mode ▁, ▁( ▁ByteBuffer ▁) ▁indices ▁) ▁; ▁else ▁throw ▁new ▁Gdx RuntimeException ▁( ▁STR ▁+ ▁indices ▁. ▁getClass ▁( ▁) ▁. ▁getName ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁public ▁void ▁gl Enable ▁( ▁int ▁cap ▁) ▁{ ▁GL 11 ▁. ▁gl Enable ▁( ▁cap ▁) ▁; ▁} ▁public ▁void ▁gl Enable Vertex Att rib Array ▁( ▁int ▁index ▁) ▁{ ▁GL 20 ▁. ▁gl Enable Vertex Att rib Array ▁( ▁index ▁) ▁; ▁} ▁public ▁void ▁gl Finish ▁( ▁) ▁{ ▁GL 11 ▁. ▁gl Finish ▁( ▁) ▁; ▁} ▁public ▁void ▁gl Flush ▁( ▁) ▁{ ▁GL 11 ▁. ▁gl Flush ▁( ▁) ▁; ▁} ▁public ▁void ▁gl Frame buffer Render buffer ▁( ▁int ▁target ▁, ▁int ▁attachment ▁, ▁int ▁render buff ert arget ▁, ▁int ▁render buffer ▁) ▁{ ▁EXT Frame buffer Object ▁. ▁gl Frame buffer Render buffer EXT ▁( ▁target ▁, ▁attachment ▁, ▁render buff ert arget ▁, ▁render buffer ▁) ▁; ▁} ▁public ▁void ▁gl Frame buffer Texture 2 D ▁( ▁int ▁target ▁, ▁int ▁attachment ▁, ▁int ▁text arget ▁, ▁int ▁texture ▁, ▁int ▁level ▁) ▁{ ▁EXT Frame buffer Object ▁. ▁gl Frame buffer Texture 2 DEX T ▁( ▁target ▁, ▁attachment ▁, ▁text arget ▁, ▁texture ▁, ▁level ▁) ▁; ▁} ▁public ▁void ▁gl Front F ace ▁( ▁int ▁mode ▁) ▁{ ▁GL 11 ▁. ▁gl Front F ace ▁( ▁mode ▁) ▁; ▁} ▁public ▁void ▁gl Gen Buffers ▁( ▁int ▁n ▁, ▁Int Buffer ▁buffers ▁) ▁{ ▁GL 15 ▁. ▁gl Gen Buffers ▁( ▁buffers ▁) ▁; ▁} ▁public ▁int ▁gl Gen Buffer ▁( ▁) ▁{ ▁return ▁GL 15 ▁. ▁gl Gen Buffers ▁( ▁) ▁; ▁} ▁public ▁void ▁gl Gen Frame b uffers ▁( ▁int ▁n ▁, ▁Int Buffer ▁frame b uffers ▁) ▁{ ▁EXT Frame buffer Object ▁. ▁gl Gen Frame b uffers EXT ▁( ▁frame b uffers ▁) ▁; ▁} ▁public ▁int ▁gl Gen Frame buffer ▁( ▁) ▁{ ▁return ▁EXT Frame buffer Object ▁. ▁gl Gen Frame b uffers EXT ▁( ▁) ▁; ▁}
▁public ▁abstract ▁class ▁LLVM Complex 80 BitFloat Div ▁extends ▁LLVM ExpressionNode ▁{ ▁@ ▁Child ▁private ▁LLVM ExpressionNode ▁a Node ▁; ▁@ ▁Child ▁private ▁LLVM ExpressionNode ▁b Node ▁; ▁@ ▁Child ▁private ▁LLVM ExpressionNode ▁c Node ▁; ▁@ ▁Child ▁private ▁LLVM ExpressionNode ▁d Node ▁; ▁@ ▁Child ▁private ▁LLVM ExpressionNode ▁alloc ▁; ▁@ ▁Child ▁private ▁LLVM 80 BitFloat StoreNode ▁store Real ▁= ▁LLVM 80 BitFloat StoreNode ▁. ▁create ▁( ▁) ▁; ▁@ ▁Child ▁private ▁LLVM 80 BitFloat Offset StoreNode ▁store I m ag ▁= ▁LLVM 80 BitFloat Offset StoreNode ▁. ▁create ▁( ▁) ▁; ▁public ▁LLVM Complex 80 BitFloat Div ▁( ▁LLVM ExpressionNode ▁alloc ▁, ▁LLVM ExpressionNode ▁a ▁, ▁LLVM ExpressionNode ▁b ▁, ▁LLVM ExpressionNode ▁c ▁, ▁LLVM ExpressionNode ▁d ▁) ▁{ ▁this ▁. ▁alloc ▁= ▁alloc ▁; ▁this ▁. ▁a Node ▁= ▁a ▁; ▁this ▁. ▁b Node ▁= ▁b ▁; ▁this ▁. ▁c Node ▁= ▁c ▁; ▁this ▁. ▁d Node ▁= ▁d ▁; ▁} ▁int ▁getSizeInBytes ▁( ▁) ▁{ ▁try ▁{ ▁long ▁value ▁= ▁getData Layout ▁( ▁) ▁. ▁getSize ▁( ▁PrimitiveType ▁. ▁X 8 6_ F P 80 ▁) ▁; ▁assert ▁( ▁int ▁) ▁value ▁== ▁value ▁: ▁STR ▁; ▁return ▁( ▁int ▁) ▁value ▁; ▁} ▁catch ▁( ▁Type Overflow Exception ▁e ▁) ▁{ ▁throw ▁new ▁AssertionError ▁( ▁e ▁) ▁; ▁} ▁} ▁@ ▁Specialization ▁public ▁Object ▁do Div ▁( ▁VirtualFrame ▁frame ▁, ▁@ ▁Cached ▁( ▁STR ▁) ▁int ▁sizeInBytes ▁) ▁{ ▁try ▁{ ▁LLVM 80 BitFloat ▁long Double A ▁= ▁( ▁LLVM 80 BitFloat ▁) ▁a Node ▁. ▁execute Generic ▁( ▁frame ▁) ▁; ▁LLVM 80 BitFloat ▁long Double B ▁= ▁( ▁LLVM 80 BitFloat ▁) ▁b Node ▁. ▁execute Generic ▁( ▁frame ▁) ▁; ▁LLVM 80 BitFloat ▁long Double C ▁= ▁( ▁LLVM 80 BitFloat ▁) ▁c Node ▁. ▁execute Generic ▁( ▁frame ▁) ▁; ▁LLVM 80 BitFloat ▁long Double D ▁= ▁( ▁LLVM 80 BitFloat ▁) ▁d Node ▁. ▁execute Generic ▁( ▁frame ▁) ▁; ▁double ▁a ▁= ▁long Double A ▁. ▁getDouble Value ▁( ▁) ▁; ▁double ▁b ▁= ▁long Double B ▁. ▁getDouble Value ▁( ▁) ▁; ▁double ▁c ▁= ▁long Double C ▁. ▁getDouble Value ▁( ▁) ▁; ▁double ▁d ▁= ▁long Double D ▁. ▁getDouble Value ▁( ▁) ▁; ▁double ▁denom ▁= ▁c ▁ * ▁c ▁+ ▁d ▁ * ▁d ▁; ▁double ▁z Real ▁= ▁( ▁a ▁ * ▁c ▁+ ▁b ▁ * ▁d ▁) ▁ / ▁denom ▁; ▁double ▁z I m ag ▁= ▁( ▁b ▁ * ▁c ▁- ▁a ▁ * ▁d ▁) ▁ / ▁denom ▁; ▁LLVMPointer ▁allocated Memory ▁= ▁alloc ▁. ▁execute LL VMP ointer ▁( ▁frame ▁) ▁; ▁store Real ▁. ▁executeWith Target ▁( ▁allocated Memory ▁, ▁LLVM 80 BitFloat ▁. ▁from Double ▁( ▁z Real ▁) ▁) ▁; ▁store I m ag ▁. ▁executeWith Target ▁( ▁allocated Memory ▁, ▁sizeInBytes ▁, ▁LLVM 80 BitFloat ▁. ▁from Double ▁( ▁z I m ag ▁) ▁) ▁; ▁return ▁allocated Memory ▁; ▁} ▁catch ▁( ▁Unexpected ResultException ▁| ▁Class CastException ▁e ▁) ▁{ ▁Compiler Directives ▁. ▁transferTo Interpreter ▁( ▁) ▁;
▁public ▁class ▁Read Text Dialog ▁extends ▁DialogComponent Provider ▁{ ▁private ▁J TextArea ▁textArea ▁; ▁private ▁JPanel ▁work Panel ▁; ▁public ▁Read Text Dialog ▁( ▁String ▁title ▁, ▁String ▁text ▁) ▁{ ▁super ▁( ▁title ▁, ▁true ▁, ▁false ▁, ▁true ▁, ▁false ▁) ▁; ▁init ▁( ▁create WorkPanel ▁( ▁text ▁) ▁) ▁; ▁} ▁public ▁String ▁getText ▁( ▁) ▁{ ▁return ▁textArea ▁. ▁getText ▁( ▁) ▁; ▁} ▁public ▁void ▁setText ▁( ▁String ▁text ▁) ▁{ ▁textArea ▁. ▁setText ▁( ▁text ▁) ▁; ▁} ▁private ▁void ▁init ▁( ▁JPanel ▁work Panel To Init ▁) ▁{ ▁set Transient ▁( ▁true ▁) ▁; ▁add WorkPanel ▁( ▁work Panel To Init ▁) ▁; ▁add OK Button ▁( ▁) ▁; ▁setRe member Location ▁( ▁false ▁) ▁; ▁setRe member Size ▁( ▁false ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁ok Callback ▁( ▁) ▁{ ▁close ▁( ▁) ▁; ▁} ▁private ▁JPanel ▁create WorkPanel ▁( ▁String ▁text ▁) ▁{ ▁work Panel ▁= ▁new ▁JPanel ▁( ▁new ▁BorderLayout ▁( ▁) ▁) ▁; ▁textArea ▁= ▁new ▁J TextArea ▁( ▁10 ▁, ▁80 ▁) ▁; ▁textArea ▁. ▁setText ▁( ▁text ▁) ▁; ▁textArea ▁. ▁set Editable ▁( ▁false ▁) ▁; ▁textArea ▁. ▁setM argin ▁( ▁new ▁Insets ▁( ▁5 ▁, ▁5 ▁, ▁5 ▁, ▁5 ▁) ▁) ▁; ▁Dock ing Utils ▁. ▁set Trans parent ▁( ▁textArea ▁) ▁; ▁textArea ▁. ▁setC aret Position ▁( ▁0 ▁) ▁; ▁JScrollPane ▁sc rolled Details ▁= ▁new ▁JScrollPane ▁( ▁textArea ▁) ▁; ▁work Panel ▁. ▁add ▁( ▁sc rolled Details ▁, ▁BorderLayout ▁. ▁CENTER ▁) ▁; ▁return ▁work Panel ▁; ▁} ▁}
▁Source ▁source ▁= ▁Source ▁. ▁newBuilder ▁( ▁Instrumentation Test Language ▁. ▁ID ▁, ▁STR ▁, ▁STR ▁) ▁. ▁build ▁( ▁) ▁; ▁Truffle Instrument ▁. ▁Env ▁instr Env ▁= ▁getInstrument Env ▁( ▁ctx ▁. ▁getEngine ▁( ▁) ▁) ▁; ▁attach Listener ▁( ▁new ▁Runnable ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁run ▁( ▁) ▁{ ▁before Sleep ▁. ▁countDown ▁( ▁) ▁; ▁try ▁{ ▁Thread ▁. ▁sleep ▁( ▁10000 ▁) ▁; ▁Assert ▁. ▁fail ▁( ▁) ▁; ▁} ▁catch ▁( ▁Interrupted Exception ▁ie ▁) ▁{ ▁throw ▁new ▁AssertionError ▁( ▁ie ▁) ▁; ▁} ▁} ▁} ▁, ▁instr Env ▁) ▁; ▁Future ▁< ▁? ▁> ▁future ▁= ▁executorService ▁. ▁submit ▁( ▁( ▁) ▁-> ▁{ ▁try ▁{ ▁ctx ▁. ▁eval ▁( ▁source ▁) ▁; ▁Assert ▁. ▁fail ▁( ▁) ▁; ▁} ▁catch ▁( ▁Polyglot Exception ▁pe ▁) ▁{ ▁if ▁( ▁! ▁pe ▁. ▁isCancelled ▁( ▁) ▁|| ▁pe ▁. ▁is Interrupted ▁( ▁) ▁) ▁{ ▁throw ▁pe ▁; ▁} ▁} ▁} ▁) ▁; ▁before Sleep ▁. ▁await ▁( ▁) ▁; ▁ctx ▁. ▁close ▁( ▁true ▁) ▁; ▁future ▁. ▁get ▁( ▁) ▁; ▁} ▁finally ▁{ ▁executorService ▁. ▁shutdownNow ▁( ▁) ▁; ▁executorService ▁. ▁await Termination ▁( ▁100 ▁, ▁TimeUnit ▁. ▁SECONDS ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Parallel Close And Interrupt ▁( ▁) ▁throws ▁Interrupted Exception ▁, ▁IOException ▁, ▁Execution Exception ▁{ ▁ExecutorService ▁executorService ▁= ▁Executors ▁. ▁newFixed ThreadPool ▁( ▁10 ▁) ▁; ▁try ▁( ▁Context ▁ctx ▁= ▁Context ▁. ▁create ▁( ▁) ▁) ▁{ ▁ctx ▁. ▁initialize ▁( ▁Instrumentation Test Language ▁. ▁ID ▁) ▁; ▁CountDownLatch ▁pass Latch ▁= ▁new ▁CountDownLatch ▁( ▁5 ▁) ▁; ▁Source ▁source ▁= ▁Source ▁. ▁newBuilder ▁( ▁Instrumentation Test Language ▁. ▁ID ▁, ▁STR ▁, ▁STR ▁) ▁. ▁build ▁( ▁) ▁; ▁Truffle Instrument ▁. ▁Env ▁instr Env ▁= ▁getInstrument Env ▁( ▁ctx ▁. ▁getEngine ▁( ▁) ▁) ▁; ▁attach Listener ▁( ▁pass Latch ▁:: ▁countDown ▁, ▁instr Env ▁) ▁; ▁List ▁< ▁Future ▁< ▁? ▁> ▁> ▁futures ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁5 ▁; ▁i ▁++ ▁) ▁{ ▁futures ▁. ▁add ▁( ▁executorService ▁. ▁submit ▁( ▁( ▁) ▁-> ▁{ ▁try ▁{ ▁ctx ▁. ▁eval ▁( ▁source ▁) ▁; ▁Assert ▁. ▁fail ▁( ▁) ▁; ▁} ▁catch ▁( ▁Polyglot Exception ▁pe ▁) ▁{ ▁if ▁( ▁! ▁pe ▁. ▁is Interrupted ▁( ▁) ▁&& ▁! ▁pe ▁. ▁isCancelled ▁( ▁) ▁) ▁{ ▁throw ▁pe ▁; ▁} ▁} ▁} ▁) ▁) ▁; ▁} ▁pass Latch ▁. ▁await ▁( ▁) ▁; ▁Random ▁rnd ▁= ▁new ▁Random ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁5 ▁; ▁i ▁++ ▁) ▁{ ▁futures ▁. ▁add ▁( ▁executorService ▁. ▁submit ▁( ▁( ▁) ▁-> ▁{ ▁if ▁( ▁rnd ▁. ▁nextBoolean ▁( ▁) ▁) ▁{ ▁ctx ▁. ▁close ▁( ▁true ▁) ▁; ▁} ▁else ▁{ ▁try ▁{ ▁ctx ▁. ▁interrupt ▁( ▁Duration ▁. ▁ofSeconds ▁( ▁50 ▁) ▁) ▁; ▁} ▁catch ▁( ▁Timeout Exception ▁te ▁) ▁{ ▁throw ▁new ▁AssertionError ▁( ▁te ▁) ▁; ▁} ▁} ▁} ▁) ▁) ▁;
▁public ▁class ▁JSON Utils ▁{ ▁private ▁static ▁final ▁Log ▁log ▁= ▁Log ▁. ▁getLog ▁( ▁JSON Utils ▁. ▁class ▁) ▁; ▁private ▁static ▁final ▁DateTime Formatter ▁DATE _ TIME _ FORMAT TER ▁= ▁DateTime Formatter ▁. ▁ofPattern ▁( ▁STR ▁) ▁. ▁with Z one ▁( ▁ Z oneId ▁. ▁of ▁( ▁STR ▁) ▁) ▁; ▁public ▁static ▁String ▁format Date ▁( ▁Date ▁date ▁) ▁{ ▁return ▁LocalDateTime ▁. ▁of Instant ▁( ▁date ▁. ▁toInstant ▁( ▁) ▁, ▁ Z oneId ▁. ▁of ▁( ▁STR ▁) ▁) ▁. ▁format ▁( ▁DATE _ TIME _ FORMAT TER ▁) ▁; ▁} ▁@ ▁Nullable ▁public ▁static ▁Date ▁parse Date ▁( ▁@ ▁Nullable ▁Object ▁value ▁) ▁{ ▁if ▁( ▁value ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁if ▁( ▁value ▁instanceof ▁Integer ▁|| ▁value ▁instanceof ▁Long ▁) ▁{ ▁return ▁new ▁Date ▁( ▁( ▁( ▁Number ▁) ▁value ▁) ▁. ▁longValue ▁( ▁) ▁) ▁; ▁} ▁if ▁( ▁value ▁instanceof ▁String ▁) ▁{ ▁final ▁Temporal Accessor ▁accessor ▁= ▁DATE _ TIME _ FORMAT TER ▁. ▁parse ▁( ▁( ▁String ▁) ▁value ▁) ▁; ▁final ▁LocalDate ▁local Date ▁= ▁accessor ▁. ▁query ▁( ▁Temporal Queries ▁. ▁local Date ▁( ▁) ▁) ▁; ▁final ▁LocalTime ▁local Time ▁= ▁accessor ▁. ▁query ▁( ▁Temporal Queries ▁. ▁local Time ▁( ▁) ▁) ▁; ▁if ▁( ▁local Time ▁!= ▁null ▁) ▁{ ▁return ▁Date ▁. ▁from ▁( ▁LocalDateTime ▁. ▁of ▁( ▁local Date ▁, ▁local Time ▁) ▁. ▁toInstant ▁( ▁ Z oneOffset ▁. ▁UTC ▁) ▁) ▁; ▁} ▁else ▁{ ▁return ▁Date ▁. ▁from ▁( ▁local Date ▁. ▁at Start OfDay ▁( ▁) ▁. ▁toInstant ▁( ▁ Z oneOffset ▁. ▁UTC ▁) ▁) ▁; ▁} ▁} ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁value ▁+ ▁STR ▁) ▁; ▁} ▁public ▁static ▁String ▁format IS O Date ▁( ▁Date ▁date ▁) ▁{ ▁return ▁STR ▁+ ▁format Date ▁( ▁date ▁) ▁+ ▁STR ▁; ▁} ▁public ▁static ▁String ▁escape Json String ▁( ▁String ▁str ▁) ▁{ ▁if ▁( ▁str ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁StringBuilder ▁result ▁= ▁new ▁StringBuilder ▁( ▁str ▁. ▁length ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁str ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁char ▁c ▁= ▁str ▁. ▁charAt ▁( ▁i ▁) ▁; ▁switch ▁( ▁c ▁) ▁{ ▁case ▁CHAR ▁: ▁result ▁. ▁append ▁( ▁STR ▁) ▁; ▁break ▁; ▁case ▁CHAR ▁: ▁result ▁. ▁append ▁( ▁STR ▁) ▁; ▁break ▁; ▁case ▁CHAR ▁: ▁result ▁. ▁append ▁( ▁STR ▁) ▁; ▁break ▁; ▁case ▁CHAR ▁: ▁result ▁. ▁append ▁( ▁STR ▁) ▁; ▁break ▁; ▁case ▁CHAR ▁: ▁result ▁. ▁append ▁( ▁STR ▁) ▁; ▁break ▁; ▁case ▁CHAR ▁: ▁case ▁CHAR ▁: ▁case ▁CHAR ▁: ▁result ▁. ▁append ▁( ▁STR ▁) ▁. ▁append ▁( ▁c ▁) ▁; ▁break ▁; ▁default ▁: ▁result ▁. ▁append ▁( ▁c ▁) ▁; ▁break ▁; ▁} ▁} ▁return ▁result ▁. ▁toString ▁( ▁) ▁; ▁}
▁public ▁class ▁Transform Info TransportAction ▁extends ▁XPack Info Feature TransportAction ▁{ ▁private ▁static ▁final ▁Logger ▁logger ▁= ▁LogManager ▁. ▁getLogger ▁( ▁Transform Info TransportAction ▁. ▁class ▁) ▁; ▁public ▁static ▁final ▁String ▁[ ▁] ▁PRO VID ED _ STATS ▁= ▁new ▁String ▁[ ▁] ▁{ ▁Transform Indexer Stats ▁. ▁NUM _ PAGE S ▁. ▁getPreferred Name ▁( ▁) ▁, ▁Transform Indexer Stats ▁. ▁NUM _ INPUT _ DOC UMENT S ▁. ▁getPreferred Name ▁( ▁) ▁, ▁Transform Indexer Stats ▁. ▁NUM _ OUTPUT _ DOC UMENT S ▁. ▁getPreferred Name ▁( ▁) ▁, ▁Transform Indexer Stats ▁. ▁NUM _ DE LETED _ DOC UMENT S ▁. ▁getPreferred Name ▁( ▁) ▁, ▁Transform Indexer Stats ▁. ▁NUM _ IN VO CATION S ▁. ▁getPreferred Name ▁( ▁) ▁, ▁Transform Indexer Stats ▁. ▁INDEX _ TIME _ IN _ MS ▁. ▁getPreferred Name ▁( ▁) ▁, ▁Transform Indexer Stats ▁. ▁SEARCH _ TIME _ IN _ MS ▁. ▁getPreferred Name ▁( ▁) ▁, ▁Transform Indexer Stats ▁. ▁PROCESS ING _ TIME _ IN _ MS ▁. ▁getPreferred Name ▁( ▁) ▁, ▁Transform Indexer Stats ▁. ▁DELETE _ TIME _ IN _ MS ▁. ▁getPreferred Name ▁( ▁) ▁, ▁Transform Indexer Stats ▁. ▁INDEX _ TO T AL ▁. ▁getPreferred Name ▁( ▁) ▁, ▁Transform Indexer Stats ▁. ▁SEARCH _ TO T AL ▁. ▁getPreferred Name ▁( ▁) ▁, ▁Transform Indexer Stats ▁. ▁PROCESS ING _ TO T AL ▁. ▁getPreferred Name ▁( ▁) ▁, ▁Transform Indexer Stats ▁. ▁INDEX _ FAILURE S ▁. ▁getPreferred Name ▁( ▁) ▁, ▁Transform Indexer Stats ▁. ▁SEARCH _ FAILURE S ▁. ▁getPreferred Name ▁( ▁) ▁, ▁Transform Indexer Stats ▁. ▁EX P ONENT IAL _ AV G _ CHECK POINT _ DURATION _ MS ▁. ▁getPreferred Name ▁( ▁) ▁, ▁Transform Indexer Stats ▁. ▁EX P ONENT IAL _ AV G _ DOC UMENT S _ INDEX ED ▁. ▁getPreferred Name ▁( ▁) ▁, ▁Transform Indexer Stats ▁. ▁EX P ONENT IAL _ AV G _ DOC UMENT S _ PRO CES SED ▁. ▁getPreferred Name ▁( ▁) ▁, ▁} ▁; ▁@ ▁Inject ▁public ▁Transform Info TransportAction ▁( ▁Transport Service ▁transport Service ▁, ▁ActionFilters ▁actionFilters ▁) ▁{ ▁super ▁( ▁XPack Info FeatureAction ▁. ▁TRANS FORM ▁. ▁name ▁( ▁) ▁, ▁transport Service ▁, ▁actionFilters ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁name ▁( ▁) ▁{ ▁return ▁XPack Field ▁. ▁TRANS FORM ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁available ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁enabled ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁static ▁Transform Indexer Stats ▁parse Search Aggs ▁( ▁SearchResponse ▁searchResponse ▁) ▁{ ▁List ▁< ▁Double ▁> ▁statistics List ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁PRO VID ED _ STATS ▁. ▁length ▁) ▁; ▁for ▁( ▁String ▁stat Name ▁: ▁PRO VID ED _ STATS ▁) ▁{ ▁Aggregation ▁agg ▁= ▁searchResponse ▁. ▁getAggregations ▁( ▁) ▁. ▁get ▁( ▁stat Name ▁) ▁;
▁public ▁class ▁Admin Broker Processor ▁extends ▁Async Netty Request Processor ▁implements ▁Netty Request Processor ▁{ ▁private ▁static ▁final ▁InternalLogger ▁log ▁= ▁InternalLogger Factory ▁. ▁getLogger ▁( ▁Logger Name ▁. ▁BRO KER _ LOGGER _ NAME ▁) ▁; ▁private ▁final ▁Broker Controller ▁broker Controller ▁; ▁public ▁Admin Broker Processor ▁( ▁final ▁Broker Controller ▁broker Controller ▁) ▁{ ▁this ▁. ▁broker Controller ▁= ▁broker Controller ▁; ▁} ▁@ ▁Override ▁public ▁Remoting Command ▁process Request ▁( ▁ChannelHandler Context ▁ctx ▁, ▁Remoting Command ▁request ▁) ▁throws ▁Remoting CommandException ▁{ ▁switch ▁( ▁request ▁. ▁getCode ▁( ▁) ▁) ▁{ ▁case ▁Request Code ▁. ▁UPDATE _ AND _ CREATE _ TOPIC ▁: ▁return ▁this ▁. ▁update And Create Topic ▁( ▁ctx ▁, ▁request ▁) ▁; ▁case ▁Request Code ▁. ▁DELETE _ TOPIC _ IN _ BRO KER ▁: ▁return ▁this ▁. ▁delete Topic ▁( ▁ctx ▁, ▁request ▁) ▁; ▁case ▁Request Code ▁. ▁GET _ ALL _ TOPIC _ CONFIG ▁: ▁return ▁this ▁. ▁getAll Topic Config ▁( ▁ctx ▁, ▁request ▁) ▁; ▁case ▁Request Code ▁. ▁UPDATE _ BRO KER _ CONFIG ▁: ▁return ▁this ▁. ▁update Broker Config ▁( ▁ctx ▁, ▁request ▁) ▁; ▁case ▁Request Code ▁. ▁GET _ BRO KER _ CONFIG ▁: ▁return ▁this ▁. ▁getBroker Config ▁( ▁ctx ▁, ▁request ▁) ▁; ▁case ▁Request Code ▁. ▁SEARCH _ OFFSET _ BY _ TIMESTAMP ▁: ▁return ▁this ▁. ▁search Offset By Timestamp ▁( ▁ctx ▁, ▁request ▁) ▁; ▁case ▁Request Code ▁. ▁GET _ MAX _ OFFSET ▁: ▁return ▁this ▁. ▁getMax Offset ▁( ▁ctx ▁, ▁request ▁) ▁; ▁case ▁Request Code ▁. ▁GET _ MIN _ OFFSET ▁: ▁return ▁this ▁. ▁getMin Offset ▁( ▁ctx ▁, ▁request ▁) ▁; ▁case ▁Request Code ▁. ▁GET _ EAR LI EST _ MSG _ STORE TIME ▁: ▁return ▁this ▁. ▁getE ar li est Msg St or etime ▁( ▁ctx ▁, ▁request ▁) ▁; ▁case ▁Request Code ▁. ▁GET _ BRO KER _ R UNTIME _ INFO ▁: ▁return ▁this ▁. ▁getBroker Runtime Info ▁( ▁ctx ▁, ▁request ▁) ▁; ▁case ▁Request Code ▁. ▁LOCK _ B ATCH _ MQ ▁: ▁return ▁this ▁. ▁lock Batch MQ ▁( ▁ctx ▁, ▁request ▁) ▁; ▁case ▁Request Code ▁. ▁UN LOCK _ B ATCH _ MQ ▁: ▁return ▁this ▁. ▁unlock Batch MQ ▁( ▁ctx ▁, ▁request ▁) ▁; ▁case ▁Request Code ▁. ▁UPDATE _ AND _ CREATE _ SUB SCRIPTION GROUP ▁: ▁return ▁this ▁. ▁update And Create Subscription Group ▁( ▁ctx ▁, ▁request ▁) ▁; ▁case ▁Request Code ▁. ▁GET _ ALL _ SUB SCRIPTION GROUP _ CONFIG ▁: ▁return ▁this ▁. ▁getAll Subscription Group ▁( ▁ctx ▁, ▁request ▁) ▁; ▁case ▁Request Code ▁. ▁DELETE _ SUB SCRIPTION GROUP ▁: ▁return ▁this ▁. ▁delete Subscription Group ▁( ▁ctx ▁, ▁request ▁) ▁; ▁case ▁Request Code ▁. ▁GET _ TOPIC _ STATS _ INFO ▁: ▁return ▁this ▁. ▁getTopic Stats Info ▁( ▁ctx ▁, ▁request ▁) ▁; ▁case ▁Request Code ▁. ▁GET _ CON SUMER _ CONNECTION _ LIST ▁: ▁return ▁this ▁. ▁getConsumer Connection List ▁( ▁ctx ▁, ▁request ▁) ▁;
▁g 2 ▁. ▁set Composite ▁( ▁Al pha Composite ▁. ▁D st In ▁) ▁; ▁g 2 ▁. ▁fill Rect ▁( ▁0 ▁, ▁0 ▁, ▁size ▁. ▁width ▁, ▁size ▁. ▁height ▁) ▁; ▁return ▁buffered Image ▁; ▁} ▁private ▁void ▁paint Records ▁( ▁List ▁< ▁DomainFile Info ▁> ▁records ▁, ▁Graphics ▁g ▁) ▁{ ▁Cell Renderer Pane ▁renderer Pane ▁= ▁new ▁Cell Renderer Pane ▁( ▁) ▁; ▁paint Cell s ▁( ▁records ▁, ▁renderer Pane ▁, ▁g ▁) ▁; ▁} ▁private ▁void ▁paint Cell s ▁( ▁List ▁< ▁DomainFile Info ▁> ▁domainFile Infos ▁, ▁Cell Renderer Pane ▁renderer Pane ▁, ▁Graphics ▁g ▁) ▁{ ▁TableColumn Model ▁cm ▁= ▁table ▁. ▁getColumn Model ▁( ▁) ▁; ▁int ▁column Margin ▁= ▁cm ▁. ▁getColumn Margin ▁( ▁) ▁; ▁Rectangle ▁clip ▁= ▁g ▁. ▁getC lip Bounds ▁( ▁) ▁; ▁int ▁y Offset ▁= ▁clip ▁. ▁y ▁; ▁int ▁rowCount ▁= ▁domainFile Infos ▁. ▁size ▁( ▁) ▁; ▁int ▁column Count ▁= ▁table ▁. ▁getColumnCount ▁( ▁) ▁; ▁int ▁model Row ▁= ▁model ▁. ▁getRow Index ▁( ▁domainFile Infos ▁. ▁get ▁( ▁0 ▁) ▁) ▁; ▁Rectangle ▁cell Rect ▁= ▁table ▁. ▁getCell Rect ▁( ▁model Row ▁, ▁0 ▁, ▁false ▁) ▁; ▁int ▁start Y Offset ▁= ▁cell Rect ▁. ▁y ▁; ▁TableColumn ▁a Column ▁; ▁int ▁column Width ▁; ▁for ▁( ▁int ▁row ▁= ▁0 ▁; ▁row ▁< ▁rowCount ▁; ▁row ▁++ ▁) ▁{ ▁if ▁( ▁clip ▁. ▁y ▁+ ▁clip ▁. ▁height ▁< ▁y Offset ▁- ▁start Y Offset ▁) ▁{ ▁return ▁; ▁} ▁model Row ▁= ▁model ▁. ▁getRow Index ▁( ▁domainFile Infos ▁. ▁get ▁( ▁row ▁) ▁) ▁; ▁cell Rect ▁= ▁table ▁. ▁getCell Rect ▁( ▁model Row ▁, ▁0 ▁, ▁false ▁) ▁; ▁cell Rect ▁. ▁y ▁-= ▁start Y Offset ▁; ▁y Offset ▁+= ▁cell Rect ▁. ▁height ▁; ▁for ▁( ▁int ▁column ▁= ▁0 ▁; ▁column ▁< ▁column Count ▁; ▁column ▁++ ▁) ▁{ ▁a Column ▁= ▁cm ▁. ▁getColumn ▁( ▁column ▁) ▁; ▁column Width ▁= ▁a Column ▁. ▁getWidth ▁( ▁) ▁; ▁cell Rect ▁. ▁width ▁= ▁column Width ▁- ▁column Margin ▁; ▁paint Cell ▁( ▁renderer Pane ▁, ▁g ▁, ▁cell Rect ▁, ▁model Row ▁, ▁column ▁) ▁; ▁cell Rect ▁. ▁x ▁+= ▁column Width ▁; ▁} ▁} ▁} ▁private ▁void ▁paint Cell ▁( ▁Cell Renderer Pane ▁renderer Pane ▁, ▁Graphics ▁g ▁, ▁Rectangle ▁cell Rect ▁, ▁int ▁row ▁, ▁int ▁column ▁) ▁{ ▁Table CellRenderer ▁table Renderer ▁= ▁table ▁. ▁getCell Renderer ▁( ▁row ▁, ▁column ▁) ▁; ▁Component ▁component ▁= ▁table ▁. ▁prepare Renderer ▁( ▁table Renderer ▁, ▁row ▁, ▁column ▁) ▁; ▁renderer Pane ▁. ▁paint Component ▁( ▁g ▁, ▁component ▁, ▁table ▁, ▁cell Rect ▁. ▁x ▁, ▁cell Rect ▁. ▁y ▁, ▁cell Rect ▁. ▁width ▁, ▁cell Rect ▁. ▁height ▁, ▁true ▁) ▁; ▁} ▁private ▁List ▁< ▁DomainFile Info ▁> ▁create Selection List ▁( ▁GTable ▁table To Select ▁) ▁{ ▁ArrayList ▁< ▁DomainFile Info ▁> ▁list ▁= ▁new ▁ArrayList ▁< ▁DomainFile Info ▁> ▁( ▁) ▁;
▁private ▁static ▁Datafeed Job ▁. ▁Analysis Problem Exception ▁create Analysis Problem ▁( ▁String ▁error ▁, ▁String ▁cause ▁) ▁{ ▁Exception ▁cause Exception ▁= ▁new ▁Runtime Exception ▁( ▁cause ▁) ▁; ▁Exception ▁wrapped Exception ▁= ▁new ▁Test Wrapped Exception ▁( ▁error ▁, ▁cause Exception ▁) ▁; ▁return ▁new ▁Datafeed Job ▁. ▁Analysis Problem Exception ▁( ▁0 L ▁, ▁false ▁, ▁wrapped Exception ▁) ▁; ▁} ▁private ▁static ▁class ▁Test Wrapped Exception ▁extends ▁Runtime Exception ▁implements ▁Elasticsearch Wrapper Exception ▁{ ▁Test Wrapped Exception ▁( ▁String ▁message ▁, ▁Throwable ▁cause ▁) ▁{ ▁super ▁( ▁message ▁, ▁cause ▁) ▁; ▁} ▁} ▁}
▁Composite Key Serialization Utils ▁. ▁write Name Space ▁( ▁org Namespace ▁, ▁Int Serializer ▁. ▁INSTANCE ▁, ▁output View ▁, ▁false ▁) ▁; ▁input View ▁. ▁set Buffer ▁( ▁output View ▁. ▁get Copy Of Buffer ▁( ▁) ▁) ▁; ▁int ▁deserialized Name ps ace ▁= ▁Composite Key Serialization Utils ▁. ▁read Namespace ▁( ▁Int Serializer ▁. ▁INSTANCE ▁, ▁input View ▁, ▁false ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁org Namespace ▁, ▁deserialized Name ps ace ▁) ▁; ▁Composite Key Serialization Utils ▁. ▁write Name Space ▁( ▁org Namespace ▁, ▁Int Serializer ▁. ▁INSTANCE ▁, ▁output View ▁, ▁true ▁) ▁; ▁input View ▁. ▁set Buffer ▁( ▁output View ▁. ▁get Copy Of Buffer ▁( ▁) ▁) ▁; ▁deserialized Name ps ace ▁= ▁Composite Key Serialization Utils ▁. ▁read Namespace ▁( ▁Int Serializer ▁. ▁INSTANCE ▁, ▁input View ▁, ▁true ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁org Namespace ▁, ▁deserialized Name ps ace ▁) ▁; ▁} ▁} ▁}
▁public ▁abstract ▁class ▁Abstract Data HighLevel Shader Language MsSymbol ▁extends ▁Abstract MsSymbol ▁implements ▁Name MsSymbol ▁{ ▁protected ▁Data HighLevel Shader Language SymbolInternals ▁internal s ▁; ▁public ▁Abstract Data HighLevel Shader Language MsSymbol ▁( ▁AbstractPdb ▁pdb ▁, ▁PdbByteReader ▁reader ▁, ▁Data HighLevel Shader Language SymbolInternals ▁internal s ▁) ▁throws ▁PdbException ▁{ ▁super ▁( ▁pdb ▁, ▁reader ▁) ▁; ▁this ▁. ▁internal s ▁= ▁internal s ▁; ▁} ▁public ▁long ▁getData Offset ▁( ▁) ▁{ ▁return ▁internal s ▁. ▁getData Offset ▁( ▁) ▁; ▁} ▁public ▁H L SL Register Type ▁getRegister Type ▁( ▁) ▁{ ▁return ▁internal s ▁. ▁getRegister Type ▁( ▁) ▁; ▁} ▁public ▁RecordNumber ▁getType RecordNumber ▁( ▁) ▁{ ▁return ▁internal s ▁. ▁getType RecordNumber ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁internal s ▁. ▁getName ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁emit ▁( ▁StringBuilder ▁builder ▁) ▁{ ▁builder ▁. ▁append ▁( ▁getSymbol TypeName ▁( ▁) ▁) ▁; ▁internal s ▁. ▁emit ▁( ▁builder ▁) ▁; ▁} ▁}
▁public ▁abstract ▁class ▁Annotated Element Utils ▁{ ▁public ▁static ▁Annotated Element ▁for Annotations ▁( ▁Annotation ▁... ▁annotations ▁) ▁{ ▁return ▁new ▁Annotated Element For Annotations ▁( ▁annotations ▁) ▁; ▁} ▁public ▁static ▁Set ▁< ▁String ▁> ▁getMeta Annotation Types ▁( ▁Annotated Element ▁element ▁, ▁Class ▁< ▁? ▁extends ▁Annotation ▁> ▁annotationType ▁) ▁{ ▁return ▁getMeta Annotation Types ▁( ▁element ▁, ▁element ▁. ▁getAnnotation ▁( ▁annotationType ▁) ▁) ▁; ▁} ▁public ▁static ▁Set ▁< ▁String ▁> ▁getMeta Annotation Types ▁( ▁Annotated Element ▁element ▁, ▁String ▁annotation Name ▁) ▁{ ▁for ▁( ▁Annotation ▁annotation ▁: ▁element ▁. ▁getAnnotations ▁( ▁) ▁) ▁{ ▁if ▁( ▁annotation ▁. ▁annotationType ▁( ▁) ▁. ▁getName ▁( ▁) ▁. ▁equals ▁( ▁annotation Name ▁) ▁) ▁{ ▁return ▁getMeta Annotation Types ▁( ▁element ▁, ▁annotation ▁) ▁; ▁} ▁} ▁return ▁Collections ▁. ▁emptySet ▁( ▁) ▁; ▁} ▁private ▁static ▁Set ▁< ▁String ▁> ▁getMeta Annotation Types ▁( ▁Annotated Element ▁element ▁, ▁@ ▁Nullable ▁Annotation ▁annotation ▁) ▁{ ▁if ▁( ▁annotation ▁== ▁null ▁) ▁{ ▁return ▁Collections ▁. ▁emptySet ▁( ▁) ▁; ▁} ▁return ▁getAnnotations ▁( ▁annotation ▁. ▁annotationType ▁( ▁) ▁) ▁. ▁stream ▁( ▁) ▁. ▁map ▁( ▁merged Annotation ▁-> ▁merged Annotation ▁. ▁getType ▁( ▁) ▁. ▁getName ▁( ▁) ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁to Collection ▁( ▁LinkedHashSet ▁:: ▁new ▁) ▁) ▁; ▁} ▁public ▁static ▁boolean ▁has Meta Annotation Types ▁( ▁Annotated Element ▁element ▁, ▁Class ▁< ▁? ▁extends ▁Annotation ▁> ▁annotationType ▁) ▁{ ▁return ▁getAnnotations ▁( ▁element ▁) ▁. ▁stream ▁( ▁annotationType ▁) ▁. ▁anyMatch ▁( ▁Merged Annotation ▁:: ▁is Meta Present ▁) ▁; ▁} ▁public ▁static ▁boolean ▁has Meta Annotation Types ▁( ▁Annotated Element ▁element ▁, ▁String ▁annotation Name ▁) ▁{ ▁return ▁getAnnotations ▁( ▁element ▁) ▁. ▁stream ▁( ▁annotation Name ▁) ▁. ▁anyMatch ▁( ▁Merged Annotation ▁:: ▁is Meta Present ▁) ▁; ▁} ▁public ▁static ▁boolean ▁is Annotated ▁( ▁Annotated Element ▁element ▁, ▁Class ▁< ▁? ▁extends ▁Annotation ▁> ▁annotationType ▁) ▁{ ▁if ▁( ▁Annotation Filter ▁. ▁PLA IN ▁. ▁matches ▁( ▁annotationType ▁) ▁|| ▁Annotation s Scanner ▁. ▁has Plain Java Annotations Only ▁( ▁element ▁) ▁) ▁{ ▁return ▁element ▁. ▁isAnnotation Present ▁( ▁annotationType ▁) ▁; ▁} ▁return ▁getAnnotations ▁( ▁element ▁) ▁. ▁isPresent ▁( ▁annotationType ▁) ▁; ▁} ▁public ▁static ▁boolean ▁is Annotated ▁( ▁Annotated Element ▁element ▁, ▁String ▁annotation Name ▁) ▁{ ▁return ▁getAnnotations ▁( ▁element ▁) ▁. ▁isPresent ▁( ▁annotation Name ▁) ▁; ▁} ▁@ ▁Nullable ▁public ▁static ▁Annotation Attributes ▁getM erged Annotation Attributes ▁( ▁Annotated Element ▁element ▁, ▁Class ▁< ▁? ▁extends ▁Annotation ▁> ▁annotationType ▁) ▁{ ▁Merged Annotation ▁< ▁? ▁> ▁merged Annotation ▁= ▁getAnnotations ▁( ▁element ▁) ▁. ▁get ▁( ▁annotationType ▁, ▁null ▁, ▁Merged Annotation Select ors ▁. ▁first Direct ly Declared ▁( ▁) ▁) ▁; ▁return ▁getAnnotation Attributes ▁( ▁merged Annotation ▁, ▁false ▁, ▁false ▁) ▁; ▁} ▁@ ▁Nullable ▁public ▁static ▁Annotation Attributes ▁getM erged Annotation Attributes ▁( ▁Annotated Element ▁element ▁, ▁String ▁annotation Name ▁) ▁{ ▁return ▁getM erged Annotation Attributes ▁( ▁element ▁, ▁annotation Name ▁, ▁false ▁, ▁false ▁) ▁; ▁}
▁@ ▁Nullable ▁public ▁static ▁MultiValueMap ▁< ▁String ▁, ▁Object ▁> ▁getAll Annotation Attributes ▁( ▁Annotated Element ▁element ▁, ▁String ▁annotation Name ▁, ▁final ▁boolean ▁class Values AsString ▁, ▁final ▁boolean ▁nested Annotations AsMap ▁) ▁{ ▁Adapt ▁[ ▁] ▁adapt ations ▁= ▁Adapt ▁. ▁values ▁( ▁class Values AsString ▁, ▁nested Annotations AsMap ▁) ▁; ▁return ▁getAnnotations ▁( ▁element ▁) ▁. ▁stream ▁( ▁annotation Name ▁) ▁. ▁filter ▁( ▁Merged Annotation Predicates ▁. ▁unique ▁( ▁Merged Annotation ▁:: ▁getMeta Types ▁) ▁) ▁. ▁map ▁( ▁Merged Annotation ▁:: ▁with Non Merged Attributes ▁) ▁. ▁collect ▁( ▁Merged Annotation Collect ors ▁. ▁to MultiValueMap ▁( ▁Annotated Element Utils ▁:: ▁null IfEmpty ▁, ▁adapt ations ▁) ▁) ▁; ▁} ▁public ▁static ▁boolean ▁has Annotation ▁( ▁Annotated Element ▁element ▁, ▁Class ▁< ▁? ▁extends ▁Annotation ▁> ▁annotationType ▁) ▁{ ▁if ▁( ▁Annotation Filter ▁. ▁PLA IN ▁. ▁matches ▁( ▁annotationType ▁) ▁|| ▁Annotation s Scanner ▁. ▁has Plain Java Annotations Only ▁( ▁element ▁) ▁) ▁{ ▁return ▁element ▁. ▁isAnnotation Present ▁( ▁annotationType ▁) ▁; ▁} ▁return ▁find Annotations ▁( ▁element ▁) ▁. ▁isPresent ▁( ▁annotationType ▁) ▁; ▁} ▁@ ▁Nullable ▁public ▁static ▁Annotation Attributes ▁find Merged Annotation Attributes ▁( ▁Annotated Element ▁element ▁, ▁Class ▁< ▁? ▁extends ▁Annotation ▁> ▁annotationType ▁, ▁boolean ▁class Values AsString ▁, ▁boolean ▁nested Annotations AsMap ▁) ▁{ ▁Merged Annotation ▁< ▁? ▁> ▁merged Annotation ▁= ▁find Annotations ▁( ▁element ▁) ▁. ▁get ▁( ▁annotationType ▁, ▁null ▁, ▁Merged Annotation Select ors ▁. ▁first Direct ly Declared ▁( ▁) ▁) ▁; ▁return ▁getAnnotation Attributes ▁( ▁merged Annotation ▁, ▁class Values AsString ▁, ▁nested Annotations AsMap ▁) ▁; ▁} ▁@ ▁Nullable ▁public ▁static ▁Annotation Attributes ▁find Merged Annotation Attributes ▁( ▁Annotated Element ▁element ▁, ▁String ▁annotation Name ▁, ▁boolean ▁class Values AsString ▁, ▁boolean ▁nested Annotations AsMap ▁) ▁{ ▁Merged Annotation ▁< ▁? ▁> ▁merged Annotation ▁= ▁find Annotations ▁( ▁element ▁) ▁. ▁get ▁( ▁annotation Name ▁, ▁null ▁, ▁Merged Annotation Select ors ▁. ▁first Direct ly Declared ▁( ▁) ▁) ▁; ▁return ▁getAnnotation Attributes ▁( ▁merged Annotation ▁, ▁class Values AsString ▁, ▁nested Annotations AsMap ▁) ▁; ▁} ▁@ ▁Nullable ▁public ▁static ▁< ▁A ▁extends ▁Annotation ▁> ▁A ▁find Merged Annotation ▁( ▁Annotated Element ▁element ▁, ▁Class ▁< ▁A ▁> ▁annotationType ▁) ▁{ ▁if ▁( ▁Annotation Filter ▁. ▁PLA IN ▁. ▁matches ▁( ▁annotationType ▁) ▁|| ▁Annotation s Scanner ▁. ▁has Plain Java Annotations Only ▁( ▁element ▁) ▁) ▁{ ▁return ▁element ▁. ▁getDeclared Annotation ▁( ▁annotationType ▁) ▁; ▁} ▁return ▁find Annotations ▁( ▁element ▁) ▁. ▁get ▁( ▁annotationType ▁, ▁null ▁, ▁Merged Annotation Select ors ▁. ▁first Direct ly Declared ▁( ▁) ▁) ▁. ▁syn th es ize ▁( ▁Merged Annotation ▁:: ▁isPresent ▁) ▁. ▁orElse ▁( ▁null ▁) ▁; ▁}
▁@ ▁Ignore ▁( ▁LE G ACY _ FI RE FO X _ X PI ▁) ▁public ▁class ▁M ar ion ette Test ▁extends ▁JUnit 4 TestBase ▁{ ▁private ▁static ▁final ▁String ▁MO OL T IP ASS _ PATH ▁= ▁STR ▁; ▁private ▁Fire fo x Driver ▁local Driver ▁; ▁@ ▁After ▁public ▁void ▁qu it Driver ▁( ▁) ▁{ ▁if ▁( ▁local Driver ▁!= ▁null ▁) ▁{ ▁local Driver ▁. ▁qu it ▁( ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁can Start Driver With Empty Options ▁( ▁) ▁{ ▁local Driver ▁= ▁new ▁Fire fo x Driver ▁( ▁new ▁Fire fo x Options ▁( ▁) ▁) ▁; ▁verify It Is M ar ion ette ▁( ▁local Driver ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁can Start Driver WithNo Parameters ▁( ▁) ▁{ ▁local Driver ▁= ▁new ▁Fire fo x Driver ▁( ▁) ▁; ▁verify It Is M ar ion ette ▁( ▁local Driver ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁can Start Driver With Specified Binary ▁( ▁) ▁{ ▁Fire fo x Binary ▁binary ▁= ▁spy ▁( ▁new ▁Fire fo x Binary ▁( ▁) ▁) ▁; ▁local Driver ▁= ▁new ▁Fire fo x Driver ▁( ▁new ▁Fire fo x Options ▁( ▁) ▁. ▁set Binary ▁( ▁binary ▁) ▁) ▁; ▁verify It Is M ar ion ette ▁( ▁local Driver ▁) ▁; ▁verify ▁( ▁binary ▁, ▁atLeast Once ▁( ▁) ▁) ▁. ▁getPath ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁can Start Driver With Specified Profile ▁( ▁) ▁{ ▁Fire fo x Profile ▁profile ▁= ▁new ▁Fire fo x Profile ▁( ▁) ▁; ▁profile ▁. ▁set Preference ▁( ▁STR ▁, ▁1 ▁) ▁; ▁profile ▁. ▁set Preference ▁( ▁STR ▁, ▁pages ▁. ▁x ht ml Test Page ▁) ▁; ▁local Driver ▁= ▁new ▁Fire fo x Driver ▁( ▁new ▁Fire fo x Options ▁( ▁) ▁. ▁set Profile ▁( ▁profile ▁) ▁) ▁; ▁wait ▁. ▁until ▁( ▁ $ ▁-> ▁STR ▁. ▁equals ▁( ▁local Driver ▁. ▁getTitle ▁( ▁) ▁) ▁) ▁; ▁verify It Is M ar ion ette ▁( ▁local Driver ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁can Start Driver With Specified Binary And Profile ▁( ▁) ▁{ ▁Fire fo x Binary ▁binary ▁= ▁spy ▁( ▁new ▁Fire fo x Binary ▁( ▁) ▁) ▁; ▁Fire fo x Profile ▁profile ▁= ▁new ▁Fire fo x Profile ▁( ▁) ▁; ▁profile ▁. ▁set Preference ▁( ▁STR ▁, ▁1 ▁) ▁; ▁profile ▁. ▁set Preference ▁( ▁STR ▁, ▁pages ▁. ▁x ht ml Test Page ▁) ▁; ▁local Driver ▁= ▁new ▁Fire fo x Driver ▁( ▁new ▁Fire fo x Options ▁( ▁) ▁. ▁set Binary ▁( ▁binary ▁) ▁. ▁set Profile ▁( ▁profile ▁) ▁) ▁; ▁wait ▁. ▁until ▁( ▁ $ ▁-> ▁STR ▁. ▁equals ▁( ▁local Driver ▁. ▁getTitle ▁( ▁) ▁) ▁) ▁; ▁verify It Is M ar ion ette ▁( ▁local Driver ▁) ▁; ▁verify ▁( ▁binary ▁, ▁atLeast Once ▁( ▁) ▁) ▁. ▁getPath ▁( ▁) ▁; ▁}
▁public ▁class ▁ResourceManager Partition Tracker Impl Test ▁extends ▁TestLogger ▁{ ▁private ▁static ▁final ▁Cluster Partition Report ▁EMPTY _ PARTITION _ RE PORT ▁= ▁new ▁Cluster Partition Report ▁( ▁Collections ▁. ▁emptySet ▁( ▁) ▁) ▁; ▁private ▁static ▁final ▁ResourceID ▁TASK _ EXECUTOR _ ID _1 ▁= ▁ResourceID ▁. ▁generate ▁( ▁) ▁; ▁private ▁static ▁final ▁ResourceID ▁TASK _ EXECUTOR _ ID _2 ▁= ▁ResourceID ▁. ▁generate ▁( ▁) ▁; ▁private ▁static ▁final ▁Intermediate DataSetID ▁DATA _ SET _ ID ▁= ▁new ▁Intermediate DataSetID ▁( ▁) ▁; ▁private ▁static ▁final ▁ResultPartition ID ▁PARTITION _ ID _1 ▁= ▁new ▁ResultPartition ID ▁( ▁) ▁; ▁private ▁static ▁final ▁ResultPartition ID ▁PARTITION _ ID _2 ▁= ▁new ▁ResultPartition ID ▁( ▁) ▁; ▁@ ▁Test ▁public ▁void ▁test Process Empty Cluster Partition Report ▁( ▁) ▁{ ▁Test Cluster Partition Re leas er ▁partition Re leas er ▁= ▁new ▁Test Cluster Partition Re leas er ▁( ▁) ▁; ▁final ▁ResourceManager Partition Tracker Impl ▁tracker ▁= ▁new ▁ResourceManager Partition Tracker Impl ▁( ▁partition Re leas er ▁) ▁; ▁report Empty ▁( ▁tracker ▁, ▁TASK _ EXECUTOR _ ID _1 ▁) ▁; ▁assertThat ▁( ▁partition Re leas er ▁. ▁release Calls ▁, ▁empty ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁tracker ▁. ▁are All Maps Empty ▁( ▁) ▁, ▁is ▁( ▁true ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Report Processing With Partition Loss On Same TaskExecutor ▁( ▁) ▁{ ▁Test Cluster Partition Re leas er ▁partition Re leas er ▁= ▁new ▁Test Cluster Partition Re leas er ▁( ▁) ▁; ▁final ▁ResourceManager Partition Tracker ▁tracker ▁= ▁new ▁ResourceManager Partition Tracker Impl ▁( ▁partition Re leas er ▁) ▁; ▁report ▁( ▁tracker ▁, ▁TASK _ EXECUTOR _ ID _1 ▁, ▁DATA _ SET _ ID ▁, ▁2 ▁, ▁PARTITION _ ID _1 ▁, ▁PARTITION _ ID _2 ▁) ▁; ▁report ▁( ▁tracker ▁, ▁TASK _ EXECUTOR _ ID _1 ▁, ▁DATA _ SET _ ID ▁, ▁2 ▁, ▁PARTITION _ ID _2 ▁) ▁; ▁assertThat ▁( ▁partition Re leas er ▁. ▁release Calls ▁, ▁contains ▁( ▁Tuple 2 ▁. ▁of ▁( ▁TASK _ EXECUTOR _ ID _1 ▁, ▁Collections ▁. ▁singleton ▁( ▁DATA _ SET _ ID ▁) ▁) ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Report Processing With Partition Loss On Other TaskExecutor ▁( ▁) ▁{ ▁Test Cluster Partition Re leas er ▁partition Re leas er ▁= ▁new ▁Test Cluster Partition Re leas er ▁( ▁) ▁; ▁final ▁ResourceManager Partition Tracker ▁tracker ▁= ▁new ▁ResourceManager Partition Tracker Impl ▁( ▁partition Re leas er ▁) ▁; ▁report ▁( ▁tracker ▁, ▁TASK _ EXECUTOR _ ID _1 ▁, ▁DATA _ SET _ ID ▁, ▁2 ▁, ▁PARTITION _ ID _1 ▁) ▁; ▁report ▁( ▁tracker ▁, ▁TASK _ EXECUTOR _ ID _2 ▁, ▁DATA _ SET _ ID ▁, ▁2 ▁, ▁PARTITION _ ID _2 ▁) ▁; ▁report Empty ▁( ▁tracker ▁, ▁TASK _ EXECUTOR _ ID _1 ▁) ▁;
▁if ▁( ▁bucket ▁!= ▁null ▁) ▁{ ▁bucket ▁. ▁merge ▁( ▁restored Bucket ▁) ▁; ▁} ▁else ▁{ ▁active Buckets ▁. ▁put ▁( ▁bucket Id ▁, ▁restored Bucket ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁write ▁( ▁IN ▁element ▁, ▁Context ▁context ▁) ▁throws ▁IOException ▁{ ▁bucket er Context ▁. ▁update ▁( ▁context ▁. ▁timestamp ▁( ▁) ▁, ▁context ▁. ▁current Watermark ▁( ▁) ▁, ▁processing TimeService ▁. ▁getCurrent ProcessingTime ▁( ▁) ▁) ▁; ▁final ▁String ▁bucket Id ▁= ▁bucket Assigner ▁. ▁getBucket Id ▁( ▁element ▁, ▁bucket er Context ▁) ▁; ▁final ▁FileWriter Bucket ▁< ▁IN ▁> ▁bucket ▁= ▁getOrCreate Bucket For Bucket Id ▁( ▁bucket Id ▁) ▁; ▁bucket ▁. ▁write ▁( ▁element ▁, ▁processing TimeService ▁. ▁getCurrent ProcessingTime ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁File Sink Commit table ▁> ▁prepare Commit ▁( ▁boolean ▁flush ▁) ▁throws ▁IOException ▁{ ▁List ▁< ▁File Sink Commit table ▁> ▁commit tables ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁Iterator ▁< ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁FileWriter Bucket ▁< ▁IN ▁> ▁> ▁> ▁active Bucket It ▁= ▁active Buckets ▁. ▁entrySet ▁( ▁) ▁. ▁iterator ▁( ▁) ▁; ▁while ▁( ▁active Bucket It ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁FileWriter Bucket ▁< ▁IN ▁> ▁> ▁entry ▁= ▁active Bucket It ▁. ▁next ▁( ▁) ▁; ▁if ▁( ▁! ▁entry ▁. ▁getValue ▁( ▁) ▁. ▁isActive ▁( ▁) ▁) ▁{ ▁active Bucket It ▁. ▁remove ▁( ▁) ▁; ▁} ▁else ▁{ ▁commit tables ▁. ▁addAll ▁( ▁entry ▁. ▁getValue ▁( ▁) ▁. ▁prepare Commit ▁( ▁flush ▁) ▁) ▁; ▁} ▁} ▁return ▁commit tables ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁FileWriter Bucket State ▁> ▁snapshot State ▁( ▁) ▁throws ▁IOException ▁{ ▁checkState ▁( ▁bucket Writer ▁!= ▁null ▁, ▁STR ▁) ▁; ▁List ▁< ▁FileWriter Bucket State ▁> ▁state ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁FileWriter Bucket ▁< ▁IN ▁> ▁bucket ▁: ▁active Buckets ▁. ▁values ▁( ▁) ▁) ▁{ ▁state ▁. ▁add ▁( ▁bucket ▁. ▁snapshot State ▁( ▁) ▁) ▁; ▁} ▁return ▁state ▁; ▁} ▁private ▁FileWriter Bucket ▁< ▁IN ▁> ▁getOrCreate Bucket For Bucket Id ▁( ▁String ▁bucket Id ▁) ▁throws ▁IOException ▁{ ▁FileWriter Bucket ▁< ▁IN ▁> ▁bucket ▁= ▁active Buckets ▁. ▁get ▁( ▁bucket Id ▁) ▁; ▁if ▁( ▁bucket ▁== ▁null ▁) ▁{ ▁final ▁Path ▁bucket Path ▁= ▁ass emble Bucket Path ▁( ▁bucket Id ▁) ▁; ▁bucket ▁= ▁bucket Factory ▁. ▁getNew Bucket ▁( ▁bucket Id ▁, ▁bucket Path ▁, ▁bucket Writer ▁, ▁rolling Policy ▁, ▁outputFile Config ▁) ▁; ▁active Buckets ▁. ▁put ▁( ▁bucket Id ▁, ▁bucket ▁) ▁; ▁} ▁return ▁bucket ▁; ▁} ▁@ ▁Override ▁public ▁void ▁close ▁( ▁) ▁{ ▁if ▁( ▁active Buckets ▁!= ▁null ▁) ▁{ ▁active Buckets ▁. ▁values ▁( ▁) ▁. ▁forEach ▁( ▁FileWriter Bucket ▁:: ▁dispose Part File ▁) ▁; ▁} ▁} ▁private ▁Path ▁ass emble Bucket Path ▁( ▁String ▁bucket Id ▁) ▁{ ▁if ▁( ▁STR ▁. ▁equals ▁( ▁bucket Id ▁) ▁) ▁{ ▁return ▁basePath ▁; ▁}
▁@ ▁Component ▁public ▁class ▁In Mem System Rule Store ▁extends ▁InMemory Rule Repository Adapter ▁< ▁System Rule Entity ▁> ▁{ ▁private ▁static ▁AtomicLong ▁ids ▁= ▁new ▁AtomicLong ▁( ▁0 ▁) ▁; ▁@ ▁Override ▁protected ▁long ▁nextId ▁( ▁) ▁{ ▁return ▁ids ▁. ▁incrementAndGet ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁Execute ▁extends ▁Statement ▁{ ▁private ▁final ▁Identifier ▁name ▁; ▁private ▁final ▁List ▁< ▁Expression ▁> ▁parameters ▁; ▁public ▁Execute ▁( ▁NodeLocation ▁location ▁, ▁Identifier ▁name ▁, ▁List ▁< ▁Expression ▁> ▁parameters ▁) ▁{ ▁this ▁( ▁Optional ▁. ▁of ▁( ▁location ▁) ▁, ▁name ▁, ▁parameters ▁) ▁; ▁} ▁public ▁Execute ▁( ▁Identifier ▁name ▁, ▁List ▁< ▁Expression ▁> ▁parameters ▁) ▁{ ▁this ▁( ▁Optional ▁. ▁empty ▁( ▁) ▁, ▁name ▁, ▁parameters ▁) ▁; ▁} ▁private ▁Execute ▁( ▁Optional ▁< ▁NodeLocation ▁> ▁location ▁, ▁Identifier ▁name ▁, ▁List ▁< ▁Expression ▁> ▁parameters ▁) ▁{ ▁super ▁( ▁location ▁) ▁; ▁this ▁. ▁name ▁= ▁requireNonNull ▁( ▁name ▁, ▁STR ▁) ▁; ▁this ▁. ▁parameters ▁= ▁requireNonNull ▁( ▁ImmutableList ▁. ▁copyOf ▁( ▁parameters ▁) ▁, ▁STR ▁) ▁; ▁} ▁public ▁Identifier ▁getName ▁( ▁) ▁{ ▁return ▁name ▁; ▁} ▁public ▁List ▁< ▁Expression ▁> ▁getParameters ▁( ▁) ▁{ ▁return ▁parameters ▁; ▁} ▁@ ▁Override ▁public ▁< ▁R ▁, ▁C ▁> ▁R ▁accept ▁( ▁AstVisitor ▁< ▁R ▁, ▁C ▁> ▁visitor ▁, ▁C ▁context ▁) ▁{ ▁return ▁visitor ▁. ▁visit Execute ▁( ▁this ▁, ▁context ▁) ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁? ▁extends ▁Node ▁> ▁getChildren ▁( ▁) ▁{ ▁return ▁parameters ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁Objects ▁. ▁hash ▁( ▁name ▁, ▁parameters ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁obj ▁) ▁{ ▁if ▁( ▁this ▁== ▁obj ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁( ▁obj ▁== ▁null ▁) ▁|| ▁( ▁getClass ▁( ▁) ▁!= ▁obj ▁. ▁getClass ▁( ▁) ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁Execute ▁o ▁= ▁( ▁Execute ▁) ▁obj ▁; ▁return ▁Objects ▁. ▁equals ▁( ▁name ▁, ▁o ▁. ▁name ▁) ▁&& ▁Objects ▁. ▁equals ▁( ▁parameters ▁, ▁o ▁. ▁parameters ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁toStringHelper ▁( ▁this ▁) ▁. ▁add ▁( ▁STR ▁, ▁name ▁) ▁. ▁add ▁( ▁STR ▁, ▁parameters ▁) ▁. ▁toString ▁( ▁) ▁; ▁} ▁}
▁public ▁static ▁String ▁decode ▁( ▁byte ▁[ ▁] ▁utf 8 ▁) ▁throws ▁Character Coding Exception ▁{ ▁return ▁decode ▁( ▁ByteBuffer ▁. ▁wrap ▁( ▁utf 8 ▁) ▁, ▁true ▁) ▁; ▁} ▁public ▁static ▁String ▁decode ▁( ▁byte ▁[ ▁] ▁utf 8 ▁, ▁int ▁start ▁, ▁int ▁length ▁) ▁throws ▁Character Coding Exception ▁{ ▁return ▁decode ▁( ▁ByteBuffer ▁. ▁wrap ▁( ▁utf 8 ▁, ▁start ▁, ▁length ▁) ▁, ▁true ▁) ▁; ▁} ▁public ▁static ▁String ▁decode ▁( ▁byte ▁[ ▁] ▁utf 8 ▁, ▁int ▁start ▁, ▁int ▁length ▁, ▁boolean ▁replace ▁) ▁throws ▁Character Coding Exception ▁{ ▁return ▁decode ▁( ▁ByteBuffer ▁. ▁wrap ▁( ▁utf 8 ▁, ▁start ▁, ▁length ▁) ▁, ▁replace ▁) ▁; ▁} ▁private ▁static ▁String ▁decode ▁( ▁ByteBuffer ▁utf 8 ▁, ▁boolean ▁replace ▁) ▁throws ▁Character Coding Exception ▁{ ▁Charset Decoder ▁decoder ▁= ▁DE CODER _ FACTORY ▁. ▁get ▁( ▁) ▁; ▁if ▁( ▁replace ▁) ▁{ ▁decoder ▁. ▁on M alformed Input ▁( ▁java ▁. ▁nio ▁. ▁charset ▁. ▁Co ding Error Action ▁. ▁REPLACE ▁) ▁; ▁decoder ▁. ▁on Unm appable Character ▁( ▁Co ding Error Action ▁. ▁REPLACE ▁) ▁; ▁} ▁String ▁str ▁= ▁decoder ▁. ▁decode ▁( ▁utf 8 ▁) ▁. ▁toString ▁( ▁) ▁; ▁if ▁( ▁replace ▁) ▁{ ▁decoder ▁. ▁on M alformed Input ▁( ▁Co ding Error Action ▁. ▁RE PORT ▁) ▁; ▁decoder ▁. ▁on Unm appable Character ▁( ▁Co ding Error Action ▁. ▁RE PORT ▁) ▁; ▁} ▁return ▁str ▁; ▁} ▁public ▁static ▁ByteBuffer ▁encode ▁( ▁String ▁string ▁) ▁throws ▁Character Coding Exception ▁{ ▁return ▁encode ▁( ▁string ▁, ▁true ▁) ▁; ▁} ▁public ▁static ▁ByteBuffer ▁encode ▁( ▁String ▁string ▁, ▁boolean ▁replace ▁) ▁throws ▁Character Coding Exception ▁{ ▁Charset Encoder ▁encoder ▁= ▁EN CODER _ FACTORY ▁. ▁get ▁( ▁) ▁; ▁if ▁( ▁replace ▁) ▁{ ▁encoder ▁. ▁on M alformed Input ▁( ▁Co ding Error Action ▁. ▁REPLACE ▁) ▁; ▁encoder ▁. ▁on Unm appable Character ▁( ▁Co ding Error Action ▁. ▁REPLACE ▁) ▁; ▁} ▁ByteBuffer ▁bytes ▁= ▁encoder ▁. ▁encode ▁( ▁CharBuffer ▁. ▁wrap ▁( ▁string ▁. ▁toCharArray ▁( ▁) ▁) ▁) ▁; ▁if ▁( ▁replace ▁) ▁{ ▁encoder ▁. ▁on M alformed Input ▁( ▁Co ding Error Action ▁. ▁RE PORT ▁) ▁; ▁encoder ▁. ▁on Unm appable Character ▁( ▁Co ding Error Action ▁. ▁RE PORT ▁) ▁; ▁} ▁return ▁bytes ▁; ▁} ▁static ▁final ▁public ▁int ▁DEFAULT _ MAX _ LEN ▁= ▁1024 ▁ * ▁1024 ▁; ▁public ▁static ▁String ▁readString ▁( ▁DataInput ▁in ▁) ▁throws ▁IOException ▁{ ▁return ▁readString ▁( ▁in ▁, ▁Integer ▁. ▁MAX _ VALUE ▁) ▁; ▁} ▁public ▁static ▁String ▁readString ▁( ▁DataInput ▁in ▁, ▁int ▁maxLength ▁) ▁throws ▁IOException ▁{ ▁int ▁length ▁= ▁WritableUtils ▁. ▁readVInt InRange ▁( ▁in ▁, ▁0 ▁, ▁maxLength ▁) ▁; ▁byte ▁[ ▁] ▁bytes ▁= ▁new ▁byte ▁[ ▁length ▁] ▁; ▁in ▁. ▁readFully ▁( ▁bytes ▁, ▁0 ▁, ▁length ▁) ▁; ▁return ▁decode ▁( ▁bytes ▁) ▁; ▁}
▁DE FIN ITION _ R ULE _ MAP ▁. ▁put ▁( ▁BuiltIn Function Definitions ▁. ▁S Q RT ▁, ▁Custom ized Convert Rule ▁:: ▁convert S q rt ▁) ▁; ▁DE FIN ITION _ R ULE _ MAP ▁. ▁put ▁( ▁Internal Function Definitions ▁. ▁TH ROW _ EXCEPTION ▁, ▁Custom ized Convert Rule ▁:: ▁convert ThrowException ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Optional ▁< ▁RexNode ▁> ▁convert ▁( ▁CallExpression ▁call ▁, ▁Convert Context ▁context ▁) ▁{ ▁Conver sion ▁conversion ▁= ▁DE FIN ITION _ R ULE _ MAP ▁. ▁get ▁( ▁call ▁. ▁getFunction Definition ▁( ▁) ▁) ▁; ▁return ▁Optional ▁. ▁ofNullable ▁( ▁conversion ▁) ▁. ▁map ▁( ▁c ▁-> ▁c ▁. ▁convert ▁( ▁call ▁, ▁context ▁) ▁) ▁; ▁} ▁private ▁static ▁RexNode ▁convert Cast ▁( ▁CallExpression ▁call ▁, ▁Convert Context ▁context ▁) ▁{ ▁checkArgument Number ▁( ▁call ▁, ▁2 ▁) ▁; ▁final ▁RexNode ▁child ▁= ▁context ▁. ▁to Re x Node ▁( ▁call ▁. ▁getChildren ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁) ▁; ▁final ▁TypeLiteral Expression ▁targetType ▁= ▁( ▁TypeLiteral Expression ▁) ▁call ▁. ▁getChildren ▁( ▁) ▁. ▁get ▁( ▁1 ▁) ▁; ▁final ▁RelDataType ▁target Rel DataType ▁= ▁context ▁. ▁getType Factory ▁( ▁) ▁. ▁create FieldType From Log icalType ▁( ▁targetType ▁. ▁getOutput DataType ▁( ▁) ▁. ▁getLogicalType ▁( ▁) ▁) ▁; ▁return ▁context ▁. ▁getRe l Builder ▁( ▁) ▁. ▁getRe x Builder ▁( ▁) ▁. ▁make Abstract Cast ▁( ▁target Rel DataType ▁, ▁child ▁) ▁; ▁} ▁private ▁static ▁RexNode ▁convert Order Asc ▁( ▁CallExpression ▁call ▁, ▁Convert Context ▁context ▁) ▁{ ▁checkArgument Number ▁( ▁call ▁, ▁1 ▁) ▁; ▁return ▁context ▁. ▁to Re x Node ▁( ▁call ▁. ▁getChildren ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁) ▁; ▁} ▁private ▁static ▁RexNode ▁convert Timestamp Diff ▁( ▁CallExpression ▁call ▁, ▁Convert Context ▁context ▁) ▁{ ▁checkArgument Number ▁( ▁call ▁, ▁3 ▁) ▁; ▁List ▁< ▁RexNode ▁> ▁children Re x Node ▁= ▁to Re x Nodes ▁( ▁context ▁, ▁call ▁. ▁getChildren ▁( ▁) ▁) ▁; ▁return ▁context ▁. ▁getRe l Builder ▁( ▁) ▁. ▁call ▁( ▁Flink Sql Operator Table ▁. ▁TIMESTAMP _ DI FF ▁, ▁children Re x Node ▁. ▁get ▁( ▁0 ▁) ▁, ▁children Re x Node ▁. ▁get ▁( ▁2 ▁) ▁, ▁children Re x Node ▁. ▁get ▁( ▁1 ▁) ▁) ▁; ▁} ▁private ▁static ▁RexNode ▁convert Not Between ▁( ▁CallExpression ▁call ▁, ▁Convert Context ▁context ▁) ▁{ ▁checkArgument Number ▁( ▁call ▁, ▁3 ▁) ▁; ▁List ▁< ▁RexNode ▁> ▁children Re x Node ▁= ▁to Re x Nodes ▁( ▁context ▁, ▁call ▁. ▁getChildren ▁( ▁) ▁) ▁; ▁RexNode ▁expr ▁= ▁children Re x Node ▁. ▁get ▁( ▁0 ▁) ▁; ▁RexNode ▁lowerBound ▁= ▁children Re x Node ▁. ▁get ▁( ▁1 ▁) ▁; ▁RexNode ▁upperBound ▁= ▁children Re x Node ▁. ▁get ▁( ▁2 ▁) ▁;
▁public ▁class ▁Apollo Dynamic Configuration ▁implements ▁Dynamic Configuration ▁{ ▁private ▁static ▁final ▁Logger ▁logger ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Apollo Dynamic Configuration ▁. ▁class ▁) ▁; ▁private ▁static ▁final ▁String ▁A POL LO _ EN V _ KEY ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁A POL LO _ ADDR _ KEY ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁A POL LO _ CLUSTER _ KEY ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁A POL LO _ PROTOCOL _ PREFIX ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁A POL LO _ APPLICATION _ KEY ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁A POL LO _ APP ID _ KEY ▁= ▁STR ▁; ▁private ▁URL ▁url ▁; ▁private ▁Config ▁dubbo Config ▁; ▁private ▁ConfigFile ▁dubbo ConfigFile ▁; ▁private ▁ConcurrentMap ▁< ▁String ▁, ▁Apollo Listener ▁> ▁listeners ▁= ▁new ▁Concurrent HashMap ▁< ▁> ▁( ▁) ▁; ▁Apollo Dynamic Configuration ▁( ▁URL ▁url ▁) ▁{ ▁this ▁. ▁url ▁= ▁url ▁; ▁String ▁config Env ▁= ▁url ▁. ▁getParameter ▁( ▁A POL LO _ EN V _ KEY ▁) ▁; ▁String ▁config Addr ▁= ▁getAddress With Protocol Prefix ▁( ▁url ▁) ▁; ▁String ▁config Cluster ▁= ▁url ▁. ▁getParameter ▁( ▁CLUSTER _ KEY ▁) ▁; ▁String ▁config AppId ▁= ▁url ▁. ▁getParameter ▁( ▁A POL LO _ APP ID _ KEY ▁) ▁; ▁if ▁( ▁StringUtils ▁. ▁isEmpty ▁( ▁System ▁. ▁getProperty ▁( ▁A POL LO _ EN V _ KEY ▁) ▁) ▁&& ▁config Env ▁!= ▁null ▁) ▁{ ▁System ▁. ▁setProperty ▁( ▁A POL LO _ EN V _ KEY ▁, ▁config Env ▁) ▁; ▁} ▁if ▁( ▁StringUtils ▁. ▁isEmpty ▁( ▁System ▁. ▁getProperty ▁( ▁A POL LO _ ADDR _ KEY ▁) ▁) ▁&& ▁! ▁ANY HOST _ VALUE ▁. ▁equals ▁( ▁url ▁. ▁getHost ▁( ▁) ▁) ▁) ▁{ ▁System ▁. ▁setProperty ▁( ▁A POL LO _ ADDR _ KEY ▁, ▁config Addr ▁) ▁; ▁} ▁if ▁( ▁StringUtils ▁. ▁isEmpty ▁( ▁System ▁. ▁getProperty ▁( ▁A POL LO _ CLUSTER _ KEY ▁) ▁) ▁&& ▁config Cluster ▁!= ▁null ▁) ▁{ ▁System ▁. ▁setProperty ▁( ▁A POL LO _ CLUSTER _ KEY ▁, ▁config Cluster ▁) ▁; ▁} ▁if ▁( ▁StringUtils ▁. ▁isEmpty ▁( ▁System ▁. ▁getProperty ▁( ▁A POL LO _ APP ID _ KEY ▁) ▁) ▁&& ▁config AppId ▁!= ▁null ▁) ▁{ ▁System ▁. ▁setProperty ▁( ▁A POL LO _ APP ID _ KEY ▁, ▁config AppId ▁) ▁; ▁} ▁String ▁namespace ▁= ▁url ▁. ▁getParameter ▁( ▁CONFIG _ NAMESPACE _ KEY ▁, ▁DEFAULT _ GROUP ▁) ▁; ▁String ▁ap ollo Namespace ▁= ▁StringUtils ▁. ▁isEmpty ▁( ▁namespace ▁) ▁? ▁url ▁. ▁getGroup ▁( ▁DEFAULT _ GROUP ▁) ▁: ▁namespace ▁; ▁dubbo Config ▁= ▁Config Service ▁. ▁getConfig ▁( ▁ap ollo Namespace ▁) ▁; ▁dubbo ConfigFile ▁= ▁Config Service ▁. ▁getConfig File ▁( ▁ap ollo Namespace ▁, ▁ConfigFile Format ▁. ▁Properties ▁) ▁; ▁boolean ▁check ▁= ▁url ▁. ▁getParameter ▁( ▁CHECK _ KEY ▁, ▁true ▁) ▁;
▁public ▁class ▁SQLServer AlterTable Test _13 _ default ▁extends ▁TestCase ▁{ ▁public ▁void ▁test _ alter _ first ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁List ▁< ▁SQLStatement ▁> ▁sqlStatement s ▁= ▁SQLUtils ▁. ▁parseStatements ▁( ▁sql ▁, ▁DbType ▁. ▁sql server ▁) ▁; ▁SQLStatement ▁stmt ▁= ▁sqlStatement s ▁. ▁get ▁( ▁0 ▁) ▁; ▁SQLServerSchema StatVisitor ▁visitor ▁= ▁new ▁SQLServerSchema StatVisitor ▁( ▁) ▁; ▁stmt ▁. ▁accept ▁( ▁visitor ▁) ▁; ▁{ ▁String ▁output ▁= ▁SQLUtils ▁. ▁toSQLString ▁( ▁stmt ▁, ▁JdbcConstants ▁. ▁SQL _ SERVER ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁+ ▁STR ▁, ▁output ▁) ▁; ▁} ▁{ ▁String ▁output ▁= ▁SQLUtils ▁. ▁toSQLString ▁( ▁stmt ▁, ▁JdbcConstants ▁. ▁SQL _ SERVER ▁, ▁SQLUtils ▁. ▁DEFAULT _ LCASE _ FORMAT _ OPTION ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁+ ▁STR ▁, ▁output ▁) ▁; ▁} ▁Assert ▁. ▁assertEquals ▁( ▁1 ▁, ▁visitor ▁. ▁getTables ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁1 ▁, ▁visitor ▁. ▁getColumns ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test _ alter _ table _ con straint _ default ▁( ▁) ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁List ▁< ▁SQLStatement ▁> ▁sqlStatement s ▁= ▁SQLUtils ▁. ▁parseStatements ▁( ▁sql ▁, ▁com ▁. ▁alibaba ▁. ▁druid ▁. ▁DbType ▁. ▁sql server ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁+ ▁STR ▁, ▁sqlStatement s ▁. ▁get ▁( ▁0 ▁) ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test _ alter _ table _ add _ default ▁( ▁) ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁List ▁< ▁SQLStatement ▁> ▁sqlStatement s ▁= ▁SQLUtils ▁. ▁parseStatements ▁( ▁sql ▁, ▁com ▁. ▁alibaba ▁. ▁druid ▁. ▁DbType ▁. ▁sql server ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁+ ▁STR ▁, ▁sqlStatement s ▁. ▁get ▁( ▁0 ▁) ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁}
▁@ ▁Interface Audience ▁. ▁Private ▁public ▁class ▁Buffer P ul lee ▁< ▁I K ▁, ▁I V ▁> ▁implements ▁I Data Loader ▁{ ▁public ▁static ▁final ▁int ▁KV _ HEADER _ LENGTH ▁= ▁Constants ▁. ▁SI Z EOF _ KV _ LENGTH ▁; ▁private ▁final ▁S ized Writable ▁< ▁I K ▁> ▁tmp Input Key ▁; ▁private ▁final ▁S ized Writable ▁< ▁I V ▁> ▁tmp Input Value ▁; ▁private ▁boolean ▁input KV Buffer d ▁= ▁false ▁; ▁private ▁Raw KeyValue Iterator ▁r Iter ▁; ▁private ▁ByteBuffer Data Writer ▁native Writer ▁; ▁protected ▁KV Serializer ▁< ▁I K ▁, ▁I V ▁> ▁serializer ▁; ▁private ▁final ▁OutputBuffer ▁output Buffer ▁; ▁private ▁final ▁Native Data Target ▁target ▁; ▁private ▁boolean ▁closed ▁= ▁false ▁; ▁public ▁Buffer P ul lee ▁( ▁Class ▁< ▁I K ▁> ▁i K Class ▁, ▁Class ▁< ▁I V ▁> ▁i V Class ▁, ▁Raw KeyValue Iterator ▁r Iter ▁, ▁Native Data Target ▁target ▁) ▁throws ▁IOException ▁{ ▁this ▁. ▁r Iter ▁= ▁r Iter ▁; ▁tmp Input Key ▁= ▁new ▁S ized Writable ▁< ▁I K ▁> ▁( ▁i K Class ▁) ▁; ▁tmp Input Value ▁= ▁new ▁S ized Writable ▁< ▁I V ▁> ▁( ▁i V Class ▁) ▁; ▁if ▁( ▁null ▁!= ▁i K Class ▁&& ▁null ▁!= ▁i V Class ▁) ▁{ ▁this ▁. ▁serializer ▁= ▁new ▁KV Serializer ▁< ▁I K ▁, ▁I V ▁> ▁( ▁i K Class ▁, ▁i V Class ▁) ▁; ▁} ▁this ▁. ▁output Buffer ▁= ▁target ▁. ▁getOutput Buffer ▁( ▁) ▁; ▁this ▁. ▁target ▁= ▁target ▁; ▁} ▁@ ▁Override ▁public ▁int ▁load ▁( ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁closed ▁) ▁{ ▁return ▁0 ▁; ▁} ▁if ▁( ▁null ▁== ▁output Buffer ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁STR ▁) ▁; ▁} ▁this ▁. ▁native Writer ▁= ▁new ▁ByteBuffer Data Writer ▁( ▁target ▁) ▁; ▁output Buffer ▁. ▁rewind ▁( ▁) ▁; ▁int ▁written ▁= ▁0 ▁; ▁boolean ▁first KV ▁= ▁true ▁; ▁if ▁( ▁input KV Buffer d ▁) ▁{ ▁written ▁+= ▁serializer ▁. ▁serialize KV ▁( ▁native Writer ▁, ▁tmp Input Key ▁, ▁tmp Input Value ▁) ▁; ▁input KV Buffer d ▁= ▁false ▁; ▁first KV ▁= ▁false ▁; ▁} ▁while ▁( ▁r Iter ▁. ▁next ▁( ▁) ▁) ▁{ ▁input KV Buffer d ▁= ▁false ▁; ▁tmp Input Key ▁. ▁readFields ▁( ▁r Iter ▁. ▁getKey ▁( ▁) ▁) ▁; ▁tmp Input Value ▁. ▁readFields ▁( ▁r Iter ▁. ▁getValue ▁( ▁) ▁) ▁; ▁serializer ▁. ▁update Length ▁( ▁tmp Input Key ▁, ▁tmp Input Value ▁) ▁; ▁final ▁int ▁kv Size ▁= ▁tmp Input Key ▁. ▁length ▁+ ▁tmp Input Value ▁. ▁length ▁+ ▁KV _ HEADER _ LENGTH ▁; ▁if ▁( ▁! ▁first KV ▁&& ▁native Writer ▁. ▁short Of Space ▁( ▁kv Size ▁) ▁) ▁{ ▁input KV Buffer d ▁= ▁true ▁; ▁break ▁; ▁} ▁else ▁{ ▁written ▁+= ▁serializer ▁. ▁serialize KV ▁( ▁native Writer ▁, ▁tmp Input Key ▁, ▁tmp Input Value ▁) ▁; ▁first KV ▁= ▁false ▁; ▁} ▁}
▁class ▁L VAL ong Test Min imal ▁{ ▁long ▁b roken ▁( ▁long ▁a ▁) ▁{ ▁long ▁z ▁= ▁test 2 ▁( ▁a ▁) ▁; ▁return ▁z ▁; ▁} ▁long ▁work s ▁( ▁int ▁x ▁) ▁{ ▁long ▁a ▁= ▁test 3 ▁( ▁x ▁) ▁; ▁return ▁a ▁; ▁} ▁long ▁work sWith Cast ▁( ▁long ▁x ▁) ▁{ ▁long ▁a ▁= ▁test 3 ▁( ▁( ▁int ▁) ▁x ▁) ▁; ▁return ▁a ▁; ▁} ▁long ▁test 2 ▁( ▁long ▁a ▁) ▁{ ▁return ▁0 L ▁; ▁} ▁long ▁test 3 ▁( ▁int ▁x ▁) ▁{ ▁return ▁0 L ▁; ▁} ▁}
▁public ▁void ▁testFrom Json ▁( ▁) ▁throws ▁IOException ▁{ ▁String ▁json ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁; ▁F uzzy QueryBuilder ▁parsed ▁= ▁( ▁F uzzy QueryBuilder ▁) ▁parse Query ▁( ▁json ▁) ▁; ▁check Generated Json ▁( ▁json ▁, ▁parsed ▁) ▁; ▁assertEquals ▁( ▁json ▁, ▁42 .0 ▁, ▁parsed ▁. ▁b oost ▁( ▁) ▁, ▁0.00001 ▁) ▁; ▁assertEquals ▁( ▁json ▁, ▁2 ▁, ▁parsed ▁. ▁f uzz iness ▁( ▁) ▁. ▁as Float ▁( ▁) ▁, ▁0 f ▁) ▁; ▁assertEquals ▁( ▁json ▁, ▁false ▁, ▁parsed ▁. ▁trans pos ition s ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁testParse Fail sWith Multiple Fields ▁( ▁) ▁throws ▁IOException ▁{ ▁String ▁json 1 ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁; ▁parse Query ▁( ▁json 1 ▁) ▁; ▁String ▁json 2 ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁; ▁Parsing Exception ▁e ▁= ▁expectThrows ▁( ▁Parsing Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁parse Query ▁( ▁json 2 ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁e ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁String ▁short Json ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁; ▁e ▁= ▁expectThrows ▁( ▁Parsing Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁parse Query ▁( ▁short Json ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁e ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁testParse Fail sWith ValueArray ▁( ▁) ▁{ ▁String ▁query ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁; ▁Parsing Exception ▁e ▁= ▁expectThrows ▁( ▁Parsing Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁parse Query ▁( ▁query ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁e ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁testTo Query With Trans pos ition s ▁( ▁) ▁throws ▁Exception ▁{ ▁Query ▁query ▁= ▁new ▁F uzzy QueryBuilder ▁( ▁TEXT _ FIELD _ NAME ▁, ▁STR ▁) ▁. ▁to Query ▁( ▁create Search ExecutionContext ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁query ▁, ▁instanceOf ▁( ▁F uzzy Query ▁. ▁class ▁) ▁) ▁; ▁assertEquals ▁( ▁F uzzy Query ▁. ▁default Trans pos ition s ▁, ▁( ▁( ▁F uzzy Query ▁) ▁query ▁) ▁. ▁get Trans pos ition s ▁( ▁) ▁) ▁; ▁query ▁= ▁new ▁F uzzy QueryBuilder ▁( ▁TEXT _ FIELD _ NAME ▁, ▁STR ▁) ▁. ▁trans pos ition s ▁( ▁true ▁) ▁. ▁to Query ▁( ▁create Search ExecutionContext ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁query ▁, ▁instanceOf ▁( ▁F uzzy Query ▁. ▁class ▁) ▁) ▁; ▁assertEquals ▁( ▁true ▁, ▁( ▁( ▁F uzzy Query ▁) ▁query ▁) ▁. ▁get Trans pos ition s ▁( ▁) ▁) ▁; ▁query ▁= ▁new ▁F uzzy QueryBuilder ▁( ▁TEXT _ FIELD _ NAME ▁, ▁STR ▁) ▁. ▁trans pos ition s ▁( ▁false ▁) ▁. ▁to Query ▁( ▁create Search ExecutionContext ▁( ▁) ▁) ▁;
▁public ▁class ▁Rest Tasks Action ▁extends ▁Abstract C at Action ▁{ ▁private ▁final ▁Supplier ▁< ▁DiscoveryNodes ▁> ▁nodes In Cluster ▁; ▁public ▁Rest Tasks Action ▁( ▁Supplier ▁< ▁DiscoveryNodes ▁> ▁nodes In Cluster ▁) ▁{ ▁this ▁. ▁nodes In Cluster ▁= ▁nodes In Cluster ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁Route ▁> ▁routes ▁( ▁) ▁{ ▁return ▁List ▁. ▁of ▁( ▁new ▁Route ▁( ▁GET ▁, ▁STR ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁documentation ▁( ▁StringBuilder ▁sb ▁) ▁{ ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁RestChannel Consumer ▁do C at Request ▁( ▁final ▁RestRequest ▁request ▁, ▁final ▁NodeClient ▁client ▁) ▁{ ▁final ▁List Tasks Request ▁list Tasks Request ▁= ▁generate List Tasks Request ▁( ▁request ▁) ▁; ▁return ▁channel ▁-> ▁client ▁. ▁admin ▁( ▁) ▁. ▁cluster ▁( ▁) ▁. ▁list Tasks ▁( ▁list Tasks Request ▁, ▁new ▁RestResponse Listener ▁< ▁> ▁( ▁channel ▁) ▁{ ▁@ ▁Override ▁public ▁RestResponse ▁build Response ▁( ▁List Tasks Response ▁list Tasks Response ▁) ▁throws ▁Exception ▁{ ▁return ▁Rest Table ▁. ▁build Response ▁( ▁build Table ▁( ▁request ▁, ▁list Tasks Response ▁) ▁, ▁channel ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁private ▁static ▁final ▁Set ▁< ▁String ▁> ▁RESPONSE _ PARAMS ▁; ▁static ▁{ ▁final ▁Set ▁< ▁String ▁> ▁response Params ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁response Params ▁. ▁add ▁( ▁STR ▁) ▁; ▁response Params ▁. ▁addAll ▁( ▁Abstract C at Action ▁. ▁RESPONSE _ PARAMS ▁) ▁; ▁RESPONSE _ PARAMS ▁= ▁Collections ▁. ▁unmodifiableSet ▁( ▁response Params ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Set ▁< ▁String ▁> ▁response Params ▁( ▁) ▁{ ▁return ▁RESPONSE _ PARAMS ▁; ▁} ▁@ ▁Override ▁protected ▁Table ▁getTable With Header ▁( ▁final ▁RestRequest ▁request ▁) ▁{ ▁boolean ▁det ailed ▁= ▁request ▁. ▁paramAsBoolean ▁( ▁STR ▁, ▁false ▁) ▁; ▁Table ▁table ▁= ▁new ▁Table ▁( ▁) ▁; ▁table ▁. ▁start Headers ▁( ▁) ▁; ▁table ▁. ▁addCell ▁( ▁STR ▁, ▁STR ▁) ▁; ▁table ▁. ▁addCell ▁( ▁STR ▁, ▁STR ▁) ▁; ▁table ▁. ▁addCell ▁( ▁STR ▁, ▁STR ▁) ▁; ▁table ▁. ▁addCell ▁( ▁STR ▁, ▁STR ▁) ▁; ▁table ▁. ▁addCell ▁( ▁STR ▁, ▁STR ▁) ▁; ▁table ▁. ▁addCell ▁( ▁STR ▁, ▁STR ▁) ▁; ▁table ▁. ▁addCell ▁( ▁STR ▁, ▁STR ▁) ▁; ▁table ▁. ▁addCell ▁( ▁STR ▁, ▁STR ▁) ▁; ▁table ▁. ▁addCell ▁( ▁STR ▁, ▁STR ▁) ▁; ▁table ▁. ▁addCell ▁( ▁STR ▁, ▁STR ▁) ▁; ▁table ▁. ▁addCell ▁( ▁STR ▁, ▁STR ▁) ▁; ▁table ▁. ▁addCell ▁( ▁STR ▁, ▁STR ▁) ▁; ▁table ▁. ▁addCell ▁( ▁STR ▁, ▁STR ▁) ▁; ▁table ▁. ▁addCell ▁( ▁STR ▁, ▁STR ▁) ▁; ▁table ▁. ▁addCell ▁( ▁STR ▁, ▁STR ▁) ▁; ▁if ▁( ▁det ailed ▁) ▁{ ▁table ▁. ▁addCell ▁( ▁STR ▁, ▁STR ▁) ▁; ▁} ▁table ▁. ▁end Headers ▁( ▁) ▁; ▁return ▁table ▁; ▁}
▁private ▁Test Handler ▁( ▁List ▁< ▁Pattern ▁> ▁expected ▁, ▁List ▁< ▁Pattern ▁> ▁un expected ▁, ▁Consumer ▁< ▁LogRecord ▁> ▁on Publish Action ▁) ▁{ ▁this ▁. ▁expected ▁= ▁expected ▁; ▁this ▁. ▁un expected ▁= ▁un expected ▁; ▁this ▁. ▁on Publish Action ▁= ▁on Publish Action ▁; ▁this ▁. ▁failed Un expected ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁this ▁. ▁all Events ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁this ▁. ▁state ▁= ▁State ▁. ▁NEW ▁; ▁} ▁@ ▁Override ▁public ▁synchronized ▁void ▁publish ▁( ▁LogRecord ▁l r ▁) ▁{ ▁all Events ▁. ▁add ▁( ▁new ▁Log Entry ▁( ▁Thread ▁. ▁currentThread ▁( ▁) ▁. ▁getId ▁( ▁) ▁, ▁state ▁, ▁l r ▁. ▁getMessage ▁( ▁) ▁) ▁) ▁; ▁switch ▁( ▁state ▁) ▁{ ▁case ▁NEW ▁: ▁return ▁; ▁case ▁ACTIVE ▁: ▁break ▁; ▁case ▁DISPOSED ▁: ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁default ▁: ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁+ ▁state ▁) ▁; ▁} ▁try ▁{ ▁for ▁( ▁Iterator ▁< ▁Pattern ▁> ▁it ▁= ▁expected ▁. ▁iterator ▁( ▁) ▁; ▁it ▁. ▁hasNext ▁( ▁) ▁; ▁) ▁{ ▁Pattern ▁p ▁= ▁it ▁. ▁next ▁( ▁) ▁; ▁if ▁( ▁p ▁. ▁matcher ▁( ▁l r ▁. ▁getMessage ▁( ▁) ▁) ▁. ▁matches ▁( ▁) ▁) ▁{ ▁it ▁. ▁remove ▁( ▁) ▁; ▁return ▁; ▁} ▁} ▁for ▁( ▁Pattern ▁p ▁: ▁un expected ▁) ▁{ ▁if ▁( ▁p ▁. ▁matcher ▁( ▁l r ▁. ▁getMessage ▁( ▁) ▁) ▁. ▁matches ▁( ▁) ▁) ▁{ ▁failed Un expected ▁. ▁add ▁( ▁p ▁) ▁; ▁return ▁; ▁} ▁} ▁} ▁finally ▁{ ▁if ▁( ▁on Publish Action ▁!= ▁null ▁) ▁{ ▁on Publish Action ▁. ▁accept ▁( ▁l r ▁) ▁; ▁} ▁} ▁} ▁@ ▁Override ▁public ▁void ▁flush ▁( ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁close ▁( ▁) ▁throws ▁Security Exception ▁{ ▁} ▁synchronized ▁void ▁start ▁( ▁) ▁{ ▁state ▁= ▁State ▁. ▁ACTIVE ▁; ▁} ▁synchronized ▁void ▁assert Logs ▁( ▁) ▁{ ▁state ▁= ▁State ▁. ▁DISPOSED ▁; ▁StringBuilder ▁sb ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁if ▁( ▁! ▁expected ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁for ▁( ▁Pattern ▁p ▁: ▁expected ▁) ▁{ ▁sb ▁. ▁append ▁( ▁p ▁. ▁toString ▁( ▁) ▁) ▁. ▁append ▁( ▁STR ▁) ▁; ▁} ▁} ▁if ▁( ▁! ▁failed Un expected ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁for ▁( ▁Pattern ▁p ▁: ▁failed Un expected ▁) ▁{ ▁sb ▁. ▁append ▁( ▁p ▁. ▁toString ▁( ▁) ▁) ▁. ▁append ▁( ▁STR ▁) ▁; ▁} ▁} ▁if ▁( ▁sb ▁. ▁length ▁( ▁) ▁> ▁0 ▁) ▁{ ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁for ▁( ▁Log Entry ▁entry ▁: ▁all Events ▁) ▁{ ▁sb ▁. ▁append ▁( ▁entry ▁) ▁. ▁append ▁( ▁STR ▁) ▁; ▁} ▁Assert ▁. ▁fail ▁( ▁sb ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁} ▁static ▁Builder ▁newBuilder ▁( ▁) ▁{ ▁return ▁new ▁Builder ▁( ▁) ▁; ▁}
▁public ▁class ▁Logged Discrete C DF ▁implements ▁De ep Compare ▁{ ▁long ▁number Values ▁= ▁- ▁1 L ▁; ▁long ▁minimum ▁= ▁Long ▁. ▁MIN _ VALUE ▁; ▁List ▁< ▁Logged Single Relative Rank ing ▁> ▁rank ings ▁= ▁new ▁ArrayList ▁< ▁Logged Single Relative Rank ing ▁> ▁( ▁) ▁; ▁long ▁maximum ▁= ▁Long ▁. ▁MAX _ VALUE ▁; ▁void ▁setC DF ▁( ▁Histogram ▁data ▁, ▁int ▁[ ▁] ▁steps ▁, ▁int ▁mod ul us ▁) ▁{ ▁number Values ▁= ▁data ▁. ▁getTotal Count ▁( ▁) ▁; ▁long ▁[ ▁] ▁C DF ▁= ▁data ▁. ▁getC DF ▁( ▁mod ul us ▁, ▁steps ▁) ▁; ▁if ▁( ▁C DF ▁!= ▁null ▁) ▁{ ▁minimum ▁= ▁C DF ▁[ ▁0 ▁] ▁; ▁maximum ▁= ▁C DF ▁[ ▁C DF ▁. ▁length ▁- ▁1 ▁] ▁; ▁rank ings ▁= ▁new ▁ArrayList ▁< ▁Logged Single Relative Rank ing ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁C DF ▁. ▁length ▁- ▁1 ▁; ▁++ ▁i ▁) ▁{ ▁Logged Single Relative Rank ing ▁s rr ▁= ▁new ▁Logged Single Relative Rank ing ▁( ▁) ▁; ▁s rr ▁. ▁set Relative Rank ing ▁( ▁( ▁( ▁double ▁) ▁steps ▁[ ▁i ▁- ▁1 ▁] ▁) ▁ / ▁mod ul us ▁) ▁; ▁s rr ▁. ▁setD at um ▁( ▁C DF ▁[ ▁i ▁] ▁) ▁; ▁rank ings ▁. ▁add ▁( ▁s rr ▁) ▁; ▁} ▁} ▁} ▁public ▁long ▁getMinimum ▁( ▁) ▁{ ▁return ▁minimum ▁; ▁} ▁void ▁setMinimum ▁( ▁long ▁minimum ▁) ▁{ ▁this ▁. ▁minimum ▁= ▁minimum ▁; ▁} ▁public ▁List ▁< ▁Logged Single Relative Rank ing ▁> ▁getR ank ings ▁( ▁) ▁{ ▁return ▁rank ings ▁; ▁} ▁void ▁set Rank ings ▁( ▁List ▁< ▁Logged Single Relative Rank ing ▁> ▁rank ings ▁) ▁{ ▁this ▁. ▁rank ings ▁= ▁rank ings ▁; ▁} ▁public ▁long ▁getMaximum ▁( ▁) ▁{ ▁return ▁maximum ▁; ▁} ▁void ▁setMaximum ▁( ▁long ▁maximum ▁) ▁{ ▁this ▁. ▁maximum ▁= ▁maximum ▁; ▁} ▁public ▁long ▁getNumber Values ▁( ▁) ▁{ ▁return ▁number Values ▁; ▁} ▁void ▁setNumber Values ▁( ▁long ▁number Values ▁) ▁{ ▁this ▁. ▁number Values ▁= ▁number Values ▁; ▁} ▁private ▁void ▁compare 1 ▁( ▁long ▁c 1 ▁, ▁long ▁c 2 ▁, ▁TreePath ▁loc ▁, ▁String ▁el t name ▁) ▁throws ▁De ep In equal ity Exception ▁{ ▁if ▁( ▁c 1 ▁!= ▁c 2 ▁) ▁{ ▁throw ▁new ▁De ep In equal ity Exception ▁( ▁el t name ▁+ ▁STR ▁, ▁new ▁TreePath ▁( ▁loc ▁, ▁el t name ▁) ▁) ▁; ▁} ▁} ▁private ▁void ▁compare 1 ▁( ▁List ▁< ▁Logged Single Relative Rank ing ▁> ▁c 1 ▁, ▁List ▁< ▁Logged Single Relative Rank ing ▁> ▁c 2 ▁, ▁TreePath ▁loc ▁, ▁String ▁el t name ▁) ▁throws ▁De ep In equal ity Exception ▁{ ▁if ▁( ▁c 1 ▁== ▁null ▁&& ▁c 2 ▁== ▁null ▁) ▁{ ▁return ▁; ▁}
▁public ▁class ▁Sub string Function Processor ▁implements ▁Processor ▁{ ▁public ▁static ▁final ▁String ▁NAME ▁= ▁STR ▁; ▁private ▁final ▁Processor ▁input ▁, ▁start ▁, ▁length ▁; ▁public ▁Sub string Function Processor ▁( ▁Processor ▁input ▁, ▁Processor ▁start ▁, ▁Processor ▁length ▁) ▁{ ▁this ▁. ▁input ▁= ▁input ▁; ▁this ▁. ▁start ▁= ▁start ▁; ▁this ▁. ▁length ▁= ▁length ▁; ▁} ▁public ▁Sub string Function Processor ▁( ▁StreamInput ▁in ▁) ▁throws ▁IOException ▁{ ▁input ▁= ▁in ▁. ▁read NamedWriteable ▁( ▁Processor ▁. ▁class ▁) ▁; ▁start ▁= ▁in ▁. ▁read NamedWriteable ▁( ▁Processor ▁. ▁class ▁) ▁; ▁length ▁= ▁in ▁. ▁read NamedWriteable ▁( ▁Processor ▁. ▁class ▁) ▁; ▁} ▁@ ▁Override ▁public ▁final ▁void ▁writeTo ▁( ▁StreamOutput ▁out ▁) ▁throws ▁IOException ▁{ ▁out ▁. ▁write NamedWriteable ▁( ▁input ▁) ▁; ▁out ▁. ▁write NamedWriteable ▁( ▁start ▁) ▁; ▁out ▁. ▁write NamedWriteable ▁( ▁length ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁process ▁( ▁Object ▁o ▁) ▁{ ▁return ▁do Process ▁( ▁input ▁. ▁process ▁( ▁o ▁) ▁, ▁start ▁. ▁process ▁( ▁o ▁) ▁, ▁length ▁. ▁process ▁( ▁o ▁) ▁) ▁; ▁} ▁public ▁static ▁Object ▁do Process ▁( ▁Object ▁input ▁, ▁Object ▁start ▁, ▁Object ▁length ▁) ▁{ ▁if ▁( ▁input ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁if ▁( ▁( ▁input ▁instanceof ▁String ▁|| ▁input ▁instanceof ▁Character ▁) ▁== ▁false ▁) ▁{ ▁throw ▁new ▁Sql IllegalArgument Exception ▁( ▁STR ▁, ▁input ▁) ▁; ▁} ▁if ▁( ▁start ▁== ▁null ▁|| ▁length ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁Check ▁. ▁is Fixed Number And InRange ▁( ▁start ▁, ▁STR ▁, ▁( ▁long ▁) ▁Integer ▁. ▁MIN _ VALUE ▁+ ▁1 ▁, ▁( ▁long ▁) ▁Integer ▁. ▁MAX _ VALUE ▁) ▁; ▁Check ▁. ▁is Fixed Number And InRange ▁( ▁length ▁, ▁STR ▁, ▁0 L ▁, ▁( ▁long ▁) ▁Integer ▁. ▁MAX _ VALUE ▁) ▁; ▁return ▁String Function Utils ▁. ▁substring ▁( ▁input ▁instanceof ▁Character ▁? ▁input ▁. ▁toString ▁( ▁) ▁: ▁( ▁String ▁) ▁input ▁, ▁( ▁( ▁Number ▁) ▁start ▁) ▁. ▁intValue ▁( ▁) ▁- ▁1 ▁, ▁( ▁( ▁Number ▁) ▁length ▁) ▁. ▁intValue ▁( ▁) ▁) ▁; ▁} ▁protected ▁Processor ▁input ▁( ▁) ▁{ ▁return ▁input ▁; ▁} ▁protected ▁Processor ▁start ▁( ▁) ▁{ ▁return ▁start ▁; ▁} ▁protected ▁Processor ▁length ▁( ▁) ▁{ ▁return ▁length ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁obj ▁) ▁{ ▁if ▁( ▁this ▁== ▁obj ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁obj ▁== ▁null ▁|| ▁getClass ▁( ▁) ▁!= ▁obj ▁. ▁getClass ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁Sub string Function Processor ▁other ▁= ▁( ▁Sub string Function Processor ▁) ▁obj ▁; ▁return ▁Objects ▁. ▁equals ▁( ▁input ▁( ▁) ▁, ▁other ▁. ▁input ▁( ▁) ▁) ▁&& ▁Objects ▁. ▁equals ▁( ▁start ▁( ▁) ▁, ▁other ▁. ▁start ▁( ▁) ▁) ▁&& ▁Objects ▁. ▁equals ▁( ▁length ▁( ▁) ▁, ▁other ▁. ▁length ▁( ▁) ▁) ▁; ▁}
▁Where Query Impl ▁< ▁Select Query Impl ▁> ▁query ▁= ▁select ▁( ▁) ▁. ▁all ▁( ▁) ▁. ▁from ▁( ▁client ▁. ▁getDatabase ▁( ▁) ▁, ▁UIT emplate ▁. ▁INDEX _ NAME ▁) ▁. ▁where ▁( ▁eq ▁( ▁Influx Constants ▁. ▁Tag Name ▁. ▁ID _ COLUMN ▁, ▁ui Template ▁. ▁id ▁( ▁) ▁) ▁) ▁; ▁QueryResult ▁. ▁Ser ies ▁ser ies ▁= ▁client ▁. ▁query For Single Series ▁( ▁query ▁) ▁; ▁if ▁( ▁Objects ▁. ▁nonNull ▁( ▁ser ies ▁) ▁) ▁{ ▁final ▁Point ▁point ▁= ▁Point ▁. ▁measurement ▁( ▁UIT emplate ▁. ▁INDEX _ NAME ▁) ▁. ▁fields ▁( ▁builder ▁. ▁entity 2 Storage ▁( ▁ui Template ▁) ▁) ▁. ▁tag ▁( ▁Influx Constants ▁. ▁Tag Name ▁. ▁ID _ COLUMN ▁, ▁ui Template ▁. ▁id ▁( ▁) ▁) ▁. ▁time ▁( ▁1 L ▁, ▁TimeUnit ▁. ▁NANOSECONDS ▁) ▁. ▁build ▁( ▁) ▁; ▁client ▁. ▁write ▁( ▁point ▁) ▁; ▁return ▁Template Change Status ▁. ▁builder ▁( ▁) ▁. ▁status ▁( ▁true ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁else ▁{ ▁return ▁Template Change Status ▁. ▁builder ▁( ▁) ▁. ▁status ▁( ▁false ▁) ▁. ▁message ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁Template Change Status ▁disable Template ▁( ▁final ▁String ▁name ▁) ▁throws ▁IOException ▁{ ▁Where Query Impl ▁< ▁Select Query Impl ▁> ▁query ▁= ▁select ▁( ▁) ▁. ▁all ▁( ▁) ▁. ▁from ▁( ▁client ▁. ▁getDatabase ▁( ▁) ▁, ▁UIT emplate ▁. ▁INDEX _ NAME ▁) ▁. ▁where ▁( ▁eq ▁( ▁Influx Constants ▁. ▁Tag Name ▁. ▁ID _ COLUMN ▁, ▁name ▁) ▁) ▁; ▁QueryResult ▁. ▁Ser ies ▁ser ies ▁= ▁client ▁. ▁query For Single Series ▁( ▁query ▁) ▁; ▁if ▁( ▁Objects ▁. ▁nonNull ▁( ▁ser ies ▁) ▁) ▁{ ▁final ▁Point ▁point ▁= ▁Point ▁. ▁measurement ▁( ▁UIT emplate ▁. ▁INDEX _ NAME ▁) ▁. ▁tag ▁( ▁Influx Constants ▁. ▁Tag Name ▁. ▁ID _ COLUMN ▁, ▁name ▁) ▁. ▁addField ▁( ▁UIT emplate ▁. ▁DISABLED ▁, ▁Boolean Utils ▁. ▁TRUE ▁) ▁. ▁time ▁( ▁1 L ▁, ▁TimeUnit ▁. ▁NANOSECONDS ▁) ▁. ▁build ▁( ▁) ▁; ▁client ▁. ▁write ▁( ▁point ▁) ▁; ▁return ▁Template Change Status ▁. ▁builder ▁( ▁) ▁. ▁status ▁( ▁true ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁else ▁{ ▁return ▁Template Change Status ▁. ▁builder ▁( ▁) ▁. ▁status ▁( ▁false ▁) ▁. ▁message ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁} ▁}
▁public ▁final ▁class ▁One ToOne Translator Through put Test ▁extends ▁Abstract Perf Test Dis ruptor ▁{ ▁private ▁static ▁final ▁int ▁BUFFER _ SI Z E ▁= ▁1024 ▁ * ▁64 ▁; ▁private ▁static ▁final ▁long ▁ITER ATIONS ▁= ▁1000 L ▁ * ▁1000 L ▁ * ▁100 L ▁; ▁private ▁final ▁long ▁expectedResult ▁= ▁Perf TestUtil ▁. ▁accum ulated Ad dition ▁( ▁ITER ATIONS ▁) ▁; ▁private ▁final ▁Value Ad dition EventHandler ▁handler ▁= ▁new ▁Value Ad dition EventHandler ▁( ▁) ▁; ▁private ▁final ▁R ingBuffer ▁< ▁Value Event ▁> ▁ringBuffer ▁; ▁private ▁final ▁Mutable Long ▁value ▁= ▁new ▁Mutable Long ▁( ▁0 ▁) ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁One ToOne Translator Through put Test ▁( ▁) ▁{ ▁Dis ruptor ▁< ▁Value Event ▁> ▁dis ruptor ▁= ▁new ▁Dis ruptor ▁< ▁> ▁( ▁Value Event ▁. ▁EVENT _ FACTORY ▁, ▁BUFFER _ SI Z E ▁, ▁D aemon ThreadFactory ▁. ▁INSTANCE ▁, ▁Producer Type ▁. ▁SINGLE ▁, ▁new ▁Y ield ing Wait Strategy ▁( ▁) ▁) ▁; ▁dis ruptor ▁. ▁handle Event sWith ▁( ▁handler ▁) ▁; ▁this ▁. ▁ringBuffer ▁= ▁dis ruptor ▁. ▁start ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁int ▁getRequired Processor Count ▁( ▁) ▁{ ▁return ▁2 ▁; ▁} ▁@ ▁Override ▁protected ▁Perf TestContext ▁run Dis ruptor Pass ▁( ▁) ▁throws ▁Interrupted Exception ▁{ ▁Perf TestContext ▁perf TestContext ▁= ▁new ▁Perf TestContext ▁( ▁) ▁; ▁Mutable Long ▁value ▁= ▁this ▁. ▁value ▁; ▁final ▁CountDownLatch ▁latch ▁= ▁new ▁CountDownLatch ▁( ▁1 ▁) ▁; ▁long ▁expected Count ▁= ▁ringBuffer ▁. ▁getMinimum G ating Sequence ▁( ▁) ▁+ ▁ITER ATIONS ▁; ▁handler ▁. ▁reset ▁( ▁latch ▁, ▁expected Count ▁) ▁; ▁long ▁start ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁; ▁final ▁R ingBuffer ▁< ▁Value Event ▁> ▁rb ▁= ▁ringBuffer ▁; ▁for ▁( ▁long ▁l ▁= ▁0 ▁; ▁l ▁< ▁ITER ATIONS ▁; ▁l ▁++ ▁) ▁{ ▁value ▁. ▁set ▁( ▁l ▁) ▁; ▁rb ▁. ▁publish Event ▁( ▁Trans lator ▁. ▁INSTANCE ▁, ▁value ▁) ▁; ▁} ▁latch ▁. ▁await ▁( ▁) ▁; ▁perf TestContext ▁. ▁set Dis ruptor Ops ▁( ▁( ▁ITER ATIONS ▁ * ▁1000 L ▁) ▁ / ▁( ▁System ▁. ▁current TimeMillis ▁( ▁) ▁- ▁start ▁) ▁) ▁; ▁perf TestContext ▁. ▁set Batch Data ▁( ▁handler ▁. ▁getBatch es Processed ▁( ▁) ▁, ▁ITER ATIONS ▁) ▁; ▁waitFor Event Processor Sequence ▁( ▁expected Count ▁) ▁; ▁fail IfNot ▁( ▁expectedResult ▁, ▁handler ▁. ▁getValue ▁( ▁) ▁) ▁; ▁return ▁perf TestContext ▁; ▁} ▁private ▁static ▁class ▁Trans lator ▁implements ▁Event Translator One Arg ▁< ▁Value Event ▁, ▁Mutable Long ▁> ▁{ ▁private ▁static ▁final ▁Trans lator ▁INSTANCE ▁= ▁new ▁Trans lator ▁( ▁) ▁; ▁@ ▁Override ▁public ▁void ▁translate To ▁( ▁final ▁Value Event ▁event ▁, ▁final ▁long ▁sequence ▁, ▁final ▁Mutable Long ▁arg 0 ▁) ▁{ ▁event ▁. ▁setValue ▁( ▁arg 0 ▁. ▁get ▁( ▁) ▁) ▁; ▁} ▁}
▁Tool Item ▁move Up Item ▁= ▁UIUtils ▁. ▁create Tool Item ▁( ▁button s Toolbar ▁, ▁D T U IMessages ▁. ▁sql _ s cript _ task _ page _ settings _ t ool _ item _ text _ move _ data _ source _ up ▁, ▁UI Icon ▁. ▁AR ROW _ UP ▁, ▁new ▁Selection Adapter ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁widget Selected ▁( ▁Selection Event ▁e ▁) ▁{ ▁int ▁selection Index ▁= ▁ds Table ▁. ▁getSelection Index ▁( ▁) ▁; ▁if ▁( ▁selection Index ▁> ▁0 ▁) ▁{ ▁DBN DataSource ▁prev Script ▁= ▁selected DataSources ▁. ▁get ▁( ▁selection Index ▁- ▁1 ▁) ▁; ▁selected DataSources ▁. ▁set ▁( ▁selection Index ▁- ▁1 ▁, ▁selected DataSources ▁. ▁get ▁( ▁selection Index ▁) ▁) ▁; ▁selected DataSources ▁. ▁set ▁( ▁selection Index ▁, ▁prev Script ▁) ▁; ▁refresh DataSources ▁( ▁) ▁; ▁} ▁} ▁} ▁) ▁; ▁Tool Item ▁move Down Item ▁= ▁UIUtils ▁. ▁create Tool Item ▁( ▁button s Toolbar ▁, ▁D T U IMessages ▁. ▁sql _ s cript _ task _ page _ settings _ t ool _ item _ text _ move _ data _ source _ down ▁, ▁UI Icon ▁. ▁AR ROW _ DOWN ▁, ▁new ▁Selection Adapter ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁widget Selected ▁( ▁Selection Event ▁e ▁) ▁{ ▁int ▁selection Index ▁= ▁ds Table ▁. ▁getSelection Index ▁( ▁) ▁; ▁if ▁( ▁selection Index ▁< ▁ds Table ▁. ▁getItem Count ▁( ▁) ▁- ▁1 ▁) ▁{ ▁DBN DataSource ▁next Script ▁= ▁selected DataSources ▁. ▁get ▁( ▁selection Index ▁+ ▁1 ▁) ▁; ▁selected DataSources ▁. ▁set ▁( ▁selection Index ▁+ ▁1 ▁, ▁selected DataSources ▁. ▁get ▁( ▁selection Index ▁) ▁) ▁; ▁selected DataSources ▁. ▁set ▁( ▁selection Index ▁, ▁next Script ▁) ▁; ▁refresh Scripts ▁( ▁) ▁; ▁} ▁} ▁} ▁) ▁; ▁dataSource Viewer ▁. ▁add Selection ChangedListener ▁( ▁event ▁-> ▁{ ▁int ▁selection Index ▁= ▁ds Table ▁. ▁getSelection Index ▁( ▁) ▁; ▁delete Item ▁. ▁setEnabled ▁( ▁selection Index ▁>= ▁0 ▁) ▁; ▁move Up Item ▁. ▁setEnabled ▁( ▁selection Index ▁> ▁0 ▁) ▁; ▁move Down Item ▁. ▁setEnabled ▁( ▁selection Index ▁< ▁ds Table ▁. ▁getItem Count ▁( ▁) ▁- ▁1 ▁) ▁; ▁} ▁) ▁; ▁delete Item ▁. ▁setEnabled ▁( ▁false ▁) ▁; ▁} ▁{ ▁Composite ▁settings Group ▁= ▁UIUtils ▁. ▁createControl Group ▁( ▁composite ▁, ▁D T Messages ▁. ▁sql _ s cript _ task _ page _ settings _ group _ s cript ▁, ▁3 ▁, ▁GridData ▁. ▁H ORI Z ONTAL _ ALIGN _ BE GIN N ING ▁, ▁0 ▁) ▁; ▁ignore Errors Check ▁= ▁UIUtils ▁. ▁create Checkbox ▁( ▁settings Group ▁, ▁D T Messages ▁. ▁sql _ s cript _ task _ page _ settings _ option _ ign ore _ error s ▁, ▁STR ▁, ▁dt Settings ▁. ▁is Ignore Errors ▁( ▁) ▁, ▁1 ▁) ▁;
▁if ▁( ▁to State ▁!= ▁State ▁. ▁P END ING ▁) ▁{ ▁run Time Interval ▁= ▁run Time Interval ▁== ▁null ▁? ▁new ▁Test Interval ▁( ▁now ▁, ▁now ▁) ▁: ▁run Time Interval ▁. ▁with End Millis ▁( ▁now ▁) ▁; ▁} ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁@ ▁Nullable ▁public ▁Test Interval ▁getRuntime ▁( ▁) ▁{ ▁return ▁run Time Interval ▁; ▁} ▁public ▁Test Result ▁. ▁Status ▁getTest Result Status ▁( ▁) ▁{ ▁return ▁state ▁. ▁getTest Result Status ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Test Result ▁build Result ▁( ▁) ▁{ ▁String ▁name ▁= ▁getDescription ▁( ▁) ▁. ▁getMethodName ▁( ▁) ▁; ▁String ▁className ▁= ▁getDescription ▁( ▁) ▁. ▁getClassName ▁( ▁) ▁; ▁if ▁( ▁name ▁== ▁null ▁) ▁{ ▁name ▁= ▁className ▁; ▁className ▁= ▁parent ▁. ▁getDescription ▁( ▁) ▁. ▁getDisplayName ▁( ▁) ▁; ▁} ▁List ▁< ▁Test Result ▁> ▁child Results ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁Description ▁dynamic Test ▁: ▁getDescription ▁( ▁) ▁. ▁getChildren ▁( ▁) ▁) ▁{ ▁child Results ▁. ▁add ▁( ▁build Dynamic Result ▁( ▁dynamic Test ▁, ▁getRuntime ▁( ▁) ▁, ▁getTest Result Status ▁( ▁) ▁) ▁) ▁; ▁} ▁int ▁num Tests ▁= ▁getDescription ▁( ▁) ▁. ▁is Test ▁( ▁) ▁? ▁1 ▁: ▁getDescription ▁( ▁) ▁. ▁getChildren ▁( ▁) ▁. ▁size ▁( ▁) ▁; ▁int ▁num Failures ▁= ▁global Failures ▁. ▁isEmpty ▁( ▁) ▁? ▁dynamic Test To Failures ▁. ▁keySet ▁( ▁) ▁. ▁size ▁( ▁) ▁: ▁num Tests ▁; ▁return ▁new ▁Test Result ▁. ▁Builder ▁( ▁) ▁. ▁name ▁( ▁name ▁) ▁. ▁className ▁( ▁className ▁) ▁. ▁properties ▁( ▁properties ▁) ▁. ▁failures ▁( ▁new ▁ArrayList ▁< ▁> ▁( ▁global Failures ▁) ▁) ▁. ▁run Time Interval ▁( ▁getRuntime ▁( ▁) ▁) ▁. ▁status ▁( ▁getTest Result Status ▁( ▁) ▁) ▁. ▁num Tests ▁( ▁num Tests ▁) ▁. ▁num Failures ▁( ▁num Failures ▁) ▁. ▁child Results ▁( ▁child Results ▁) ▁. ▁in tegration s ▁( ▁in tegration s ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁private ▁Test Result ▁build Dynamic Result ▁( ▁Description ▁test ▁, ▁@ ▁Nullable ▁Test Interval ▁run Time ▁, ▁Test Result ▁. ▁Status ▁status ▁) ▁{ ▁List ▁< ▁Throwable ▁> ▁dynamic Failures ▁= ▁dynamic Test To Failures ▁. ▁get ▁( ▁test ▁) ▁; ▁if ▁( ▁dynamic Failures ▁== ▁null ▁) ▁{ ▁dynamic Failures ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁} ▁boolean ▁failed ▁= ▁! ▁global Failures ▁. ▁isEmpty ▁( ▁) ▁|| ▁! ▁dynamic Failures ▁. ▁isEmpty ▁( ▁) ▁;
▁@ ▁GwtIncompatible ▁final ▁class ▁Serialization ▁{ ▁private ▁Serialization ▁( ▁) ▁{ ▁} ▁static ▁int ▁read Count ▁( ▁Object InputStream ▁stream ▁) ▁throws ▁IOException ▁{ ▁return ▁stream ▁. ▁readInt ▁( ▁) ▁; ▁} ▁static ▁< ▁K ▁, ▁V ▁> ▁void ▁write Map ▁( ▁Map ▁< ▁K ▁, ▁V ▁> ▁map ▁, ▁Object OutputStream ▁stream ▁) ▁throws ▁IOException ▁{ ▁stream ▁. ▁writeInt ▁( ▁map ▁. ▁size ▁( ▁) ▁) ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁K ▁, ▁V ▁> ▁entry ▁: ▁map ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁stream ▁. ▁writeObject ▁( ▁entry ▁. ▁getKey ▁( ▁) ▁) ▁; ▁stream ▁. ▁writeObject ▁( ▁entry ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁} ▁static ▁< ▁K ▁, ▁V ▁> ▁void ▁populate Map ▁( ▁Map ▁< ▁K ▁, ▁V ▁> ▁map ▁, ▁Object InputStream ▁stream ▁) ▁throws ▁IOException ▁, ▁ClassNot FoundException ▁{ ▁int ▁size ▁= ▁stream ▁. ▁readInt ▁( ▁) ▁; ▁populate Map ▁( ▁map ▁, ▁stream ▁, ▁size ▁) ▁; ▁} ▁static ▁< ▁K ▁, ▁V ▁> ▁void ▁populate Map ▁( ▁Map ▁< ▁K ▁, ▁V ▁> ▁map ▁, ▁Object InputStream ▁stream ▁, ▁int ▁size ▁) ▁throws ▁IOException ▁, ▁ClassNot FoundException ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁size ▁; ▁i ▁++ ▁) ▁{ ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁K ▁key ▁= ▁( ▁K ▁) ▁stream ▁. ▁readObject ▁( ▁) ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁V ▁value ▁= ▁( ▁V ▁) ▁stream ▁. ▁readObject ▁( ▁) ▁; ▁map ▁. ▁put ▁( ▁key ▁, ▁value ▁) ▁; ▁} ▁} ▁static ▁< ▁E ▁> ▁void ▁write Multiset ▁( ▁Multiset ▁< ▁E ▁> ▁multiset ▁, ▁Object OutputStream ▁stream ▁) ▁throws ▁IOException ▁{ ▁int ▁entry Count ▁= ▁multiset ▁. ▁entrySet ▁( ▁) ▁. ▁size ▁( ▁) ▁; ▁stream ▁. ▁writeInt ▁( ▁entry Count ▁) ▁; ▁for ▁( ▁Multiset ▁. ▁Entry ▁< ▁E ▁> ▁entry ▁: ▁multiset ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁stream ▁. ▁writeObject ▁( ▁entry ▁. ▁getElement ▁( ▁) ▁) ▁; ▁stream ▁. ▁writeInt ▁( ▁entry ▁. ▁getCount ▁( ▁) ▁) ▁; ▁} ▁} ▁static ▁< ▁E ▁> ▁void ▁populate Multiset ▁( ▁Multiset ▁< ▁E ▁> ▁multiset ▁, ▁Object InputStream ▁stream ▁) ▁throws ▁IOException ▁, ▁ClassNot FoundException ▁{ ▁int ▁distinct Elements ▁= ▁stream ▁. ▁readInt ▁( ▁) ▁; ▁populate Multiset ▁( ▁multiset ▁, ▁stream ▁, ▁distinct Elements ▁) ▁; ▁} ▁static ▁< ▁E ▁> ▁void ▁populate Multiset ▁( ▁Multiset ▁< ▁E ▁> ▁multiset ▁, ▁Object InputStream ▁stream ▁, ▁int ▁distinct Elements ▁) ▁throws ▁IOException ▁, ▁ClassNot FoundException ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁distinct Elements ▁; ▁i ▁++ ▁) ▁{ ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁E ▁element ▁= ▁( ▁E ▁) ▁stream ▁. ▁readObject ▁( ▁) ▁; ▁int ▁count ▁= ▁stream ▁. ▁readInt ▁( ▁) ▁; ▁multiset ▁. ▁add ▁( ▁element ▁, ▁count ▁) ▁; ▁} ▁} ▁static ▁< ▁K ▁, ▁V ▁> ▁void ▁write Multimap ▁( ▁Multimap ▁< ▁K ▁, ▁V ▁> ▁multimap ▁, ▁Object OutputStream ▁stream ▁) ▁throws ▁IOException ▁{ ▁stream ▁. ▁writeInt ▁( ▁multimap ▁. ▁asMap ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁;
▁break ▁; ▁case ▁9 ▁: ▁pending G v r Audio Sur round Format ▁= ▁G v r Audio Sur round ▁. ▁S ur round Format ▁. ▁SECOND _ ORDER _ AM B I SON ICS ▁; ▁break ▁; ▁case ▁16 ▁: ▁pending G v r Audio Sur round Format ▁= ▁G v r Audio Sur round ▁. ▁S ur round Format ▁. ▁TH IR D _ ORDER _ AM B I SON ICS ▁; ▁break ▁; ▁default ▁: ▁throw ▁new ▁Un hand led Audio FormatException ▁( ▁input Audio Format ▁) ▁; ▁} ▁if ▁( ▁buffer ▁== ▁EMPTY _ BUFFER ▁) ▁{ ▁buffer ▁= ▁ByteBuffer ▁. ▁allocate Direct ▁( ▁FR AME S _ PER _ OUTPUT _ BUFFER ▁ * ▁OUTPUT _ FRAME _ SI Z E ▁) ▁. ▁order ▁( ▁ByteOrder ▁. ▁native Order ▁( ▁) ▁) ▁; ▁} ▁pending Input Audio Format ▁= ▁input Audio Format ▁; ▁return ▁new ▁AudioFormat ▁( ▁input Audio Format ▁. ▁sampleRate ▁, ▁OUTPUT _ CHANNEL _ COUNT ▁, ▁C ▁. ▁ENCODING _ PC M _16 BIT ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁isActive ▁( ▁) ▁{ ▁return ▁pending G v r Audio Sur round Format ▁!= ▁NO _ S UR R OUND _ FORMAT ▁|| ▁g v r Audio Sur round ▁!= ▁null ▁; ▁} ▁@ ▁Override ▁public ▁void ▁queue Input ▁( ▁ByteBuffer ▁input ▁) ▁{ ▁int ▁position ▁= ▁input ▁. ▁position ▁( ▁) ▁; ▁Assertions ▁. ▁checkNotNull ▁( ▁g v r Audio Sur round ▁) ▁; ▁int ▁readBytes ▁= ▁g v r Audio Sur round ▁. ▁addInput ▁( ▁input ▁, ▁position ▁, ▁input ▁. ▁limit ▁( ▁) ▁- ▁position ▁) ▁; ▁input ▁. ▁position ▁( ▁position ▁+ ▁readBytes ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁queue EndOf Stream ▁( ▁) ▁{ ▁if ▁( ▁g v r Audio Sur round ▁!= ▁null ▁) ▁{ ▁g v r Audio Sur round ▁. ▁trigger Processing ▁( ▁) ▁; ▁} ▁input En ded ▁= ▁true ▁; ▁} ▁@ ▁Override ▁public ▁ByteBuffer ▁getOutput ▁( ▁) ▁{ ▁if ▁( ▁g v r Audio Sur round ▁== ▁null ▁) ▁{ ▁return ▁EMPTY _ BUFFER ▁; ▁} ▁int ▁written Bytes ▁= ▁g v r Audio Sur round ▁. ▁getOutput ▁( ▁buffer ▁, ▁0 ▁, ▁buffer ▁. ▁capacity ▁( ▁) ▁) ▁; ▁buffer ▁. ▁position ▁( ▁0 ▁) ▁. ▁limit ▁( ▁written Bytes ▁) ▁; ▁return ▁buffer ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is En ded ▁( ▁) ▁{ ▁return ▁input En ded ▁&& ▁( ▁g v r Audio Sur round ▁== ▁null ▁|| ▁g v r Audio Sur round ▁. ▁getAvailable Output Size ▁( ▁) ▁== ▁0 ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁flush ▁( ▁) ▁{ ▁if ▁( ▁pending G v r Audio Sur round Format ▁!= ▁NO _ S UR R OUND _ FORMAT ▁) ▁{ ▁maybe Release G v r Audio Sur round ▁( ▁) ▁;
▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁@ ▁Substitute ▁@ ▁TargetClass ▁( ▁className ▁= ▁STR ▁, ▁onlyWith ▁= ▁JDK 8 Or E ar lier ▁. ▁class ▁) ▁final ▁class ▁ Z ip Coder ▁{ ▁String ▁toString ▁( ▁byte ▁[ ▁] ▁ba ▁, ▁int ▁off ▁, ▁int ▁length ▁) ▁{ ▁Charset Decoder ▁cd ▁= ▁decoder ▁( ▁) ▁. ▁reset ▁( ▁) ▁; ▁int ▁len ▁= ▁( ▁int ▁) ▁( ▁length ▁ * ▁cd ▁. ▁max Chars Per Byte ▁( ▁) ▁) ▁; ▁char ▁[ ▁] ▁ca ▁= ▁new ▁char ▁[ ▁len ▁] ▁; ▁if ▁( ▁len ▁== ▁0 ▁) ▁return ▁new ▁String ▁( ▁ca ▁) ▁; ▁if ▁( ▁is UTF 8 ▁&& ▁cd ▁instanceof ▁Array Decoder ▁) ▁{ ▁int ▁cl en ▁= ▁( ▁( ▁Array Decoder ▁) ▁cd ▁) ▁. ▁decode ▁( ▁ba ▁, ▁off ▁, ▁length ▁, ▁ca ▁) ▁; ▁if ▁( ▁cl en ▁== ▁- ▁1 ▁) ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁return ▁new ▁String ▁( ▁ca ▁, ▁0 ▁, ▁cl en ▁) ▁; ▁} ▁ByteBuffer ▁bb ▁= ▁ByteBuffer ▁. ▁wrap ▁( ▁ba ▁, ▁off ▁, ▁length ▁) ▁; ▁CharBuffer ▁cb ▁= ▁CharBuffer ▁. ▁wrap ▁( ▁ca ▁) ▁; ▁Co der Result ▁cr ▁= ▁cd ▁. ▁decode ▁( ▁bb ▁, ▁cb ▁, ▁true ▁) ▁; ▁if ▁( ▁! ▁cr ▁. ▁is Under flow ▁( ▁) ▁) ▁throw ▁new ▁IllegalArgument Exception ▁( ▁cr ▁. ▁toString ▁( ▁) ▁) ▁; ▁cr ▁= ▁cd ▁. ▁flush ▁( ▁cb ▁) ▁; ▁if ▁( ▁! ▁cr ▁. ▁is Under flow ▁( ▁) ▁) ▁throw ▁new ▁IllegalArgument Exception ▁( ▁cr ▁. ▁toString ▁( ▁) ▁) ▁; ▁return ▁new ▁String ▁( ▁ca ▁, ▁0 ▁, ▁cb ▁. ▁position ▁( ▁) ▁) ▁; ▁} ▁@ ▁Substitute ▁String ▁toString ▁( ▁byte ▁[ ▁] ▁ba ▁, ▁int ▁length ▁) ▁{ ▁return ▁toString ▁( ▁ba ▁, ▁0 ▁, ▁length ▁) ▁; ▁} ▁@ ▁Substitute ▁String ▁toString ▁( ▁byte ▁[ ▁] ▁ba ▁) ▁{ ▁return ▁toString ▁( ▁ba ▁, ▁0 ▁, ▁ba ▁. ▁length ▁) ▁; ▁} ▁@ ▁Substitute ▁byte ▁[ ▁] ▁getBytes ▁( ▁String ▁s ▁) ▁{ ▁Charset Encoder ▁ce ▁= ▁encoder ▁( ▁) ▁. ▁reset ▁( ▁) ▁; ▁char ▁[ ▁] ▁ca ▁= ▁s ▁. ▁toCharArray ▁( ▁) ▁; ▁int ▁len ▁= ▁( ▁int ▁) ▁( ▁ca ▁. ▁length ▁ * ▁ce ▁. ▁maxBytes Per Char ▁( ▁) ▁) ▁; ▁byte ▁[ ▁] ▁ba ▁= ▁new ▁byte ▁[ ▁len ▁] ▁; ▁if ▁( ▁len ▁== ▁0 ▁) ▁return ▁ba ▁; ▁if ▁( ▁is UTF 8 ▁&& ▁ce ▁instanceof ▁Array Encoder ▁) ▁{ ▁int ▁bl en ▁= ▁( ▁( ▁Array Encoder ▁) ▁ce ▁) ▁. ▁encode ▁( ▁ca ▁, ▁0 ▁, ▁ca ▁. ▁length ▁, ▁ba ▁) ▁; ▁if ▁( ▁bl en ▁== ▁- ▁1 ▁) ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁return ▁Arrays ▁. ▁copyOf ▁( ▁ba ▁, ▁bl en ▁) ▁; ▁} ▁ByteBuffer ▁bb ▁= ▁ByteBuffer ▁. ▁wrap ▁( ▁ba ▁) ▁; ▁CharBuffer ▁cb ▁= ▁CharBuffer ▁. ▁wrap ▁( ▁ca ▁) ▁; ▁Co der Result ▁cr ▁= ▁ce ▁. ▁encode ▁( ▁cb ▁, ▁bb ▁, ▁true ▁) ▁;
▁@ ▁Slf 4 j ▁@ ▁Tag ▁( ▁TagNames ▁. ▁W OR K SPACES ▁) ▁@ ▁NativeTag ▁@ ▁Execution ▁( ▁ExecutionMode ▁. ▁SAME _ THREAD ▁) ▁public ▁class ▁Debug Mode Tests ▁extends ▁Base Nd 4 j TestWith Backends ▁{ ▁@ ▁BeforeEach ▁public ▁void ▁turn Me Up ▁( ▁) ▁{ ▁Nd 4 j ▁. ▁getWorkspace Manager ▁( ▁) ▁. ▁set Debug Mode ▁( ▁Debug Mode ▁. ▁DISABLED ▁) ▁; ▁} ▁@ ▁AfterEach ▁public ▁void ▁turn Me Down ▁( ▁) ▁{ ▁Nd 4 j ▁. ▁getWorkspace Manager ▁( ▁) ▁. ▁set Debug Mode ▁( ▁Debug Mode ▁. ▁DISABLED ▁) ▁; ▁Nd 4 j ▁. ▁getMemory Manager ▁( ▁) ▁. ▁setCurrent Workspace ▁( ▁null ▁) ▁; ▁Nd 4 j ▁. ▁getWorkspace Manager ▁( ▁) ▁. ▁destroy All Workspace sFor CurrentThread ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁char ▁ordering ▁( ▁) ▁{ ▁return ▁CHAR ▁; ▁} ▁@ ▁Parameterized Test ▁@ ▁MethodSource ▁( ▁STR ▁) ▁public ▁void ▁test Debug Mode _1 ▁( ▁Nd 4 jBackend ▁backend ▁) ▁{ ▁assertEquals ▁( ▁Debug Mode ▁. ▁DISABLED ▁, ▁Nd 4 j ▁. ▁getWorkspace Manager ▁( ▁) ▁. ▁getDebug Mode ▁( ▁) ▁) ▁; ▁Nd 4 j ▁. ▁getWorkspace Manager ▁( ▁) ▁. ▁set Debug Mode ▁( ▁Debug Mode ▁. ▁SP IL L _ E VERY TH ING ▁) ▁; ▁assertEquals ▁( ▁Debug Mode ▁. ▁SP IL L _ E VERY TH ING ▁, ▁Nd 4 j ▁. ▁getWorkspace Manager ▁( ▁) ▁. ▁getDebug Mode ▁( ▁) ▁) ▁; ▁} ▁@ ▁Parameterized Test ▁@ ▁MethodSource ▁( ▁STR ▁) ▁public ▁void ▁test Spill Mode _1 ▁( ▁Nd 4 jBackend ▁backend ▁) ▁{ ▁Nd 4 j ▁. ▁getWorkspace Manager ▁( ▁) ▁. ▁set Debug Mode ▁( ▁Debug Mode ▁. ▁SP IL L _ E VERY TH ING ▁) ▁; ▁val ▁basic Config ▁= ▁Workspace Configuration ▁. ▁builder ▁( ▁) ▁. ▁initial Size ▁( ▁10 ▁ * ▁1024 ▁ * ▁1024 ▁) ▁. ▁maxSize ▁( ▁10 ▁ * ▁1024 ▁ * ▁1024 ▁) ▁. ▁over al location Limit ▁( ▁0.1 ▁) ▁. ▁policy Allocation ▁( ▁Allocation Policy ▁. ▁STRICT ▁) ▁. ▁policy Learning ▁( ▁Le arning Policy ▁. ▁FIRST _ LO OP ▁) ▁. ▁policy Mirror ing ▁( ▁M irror ing Policy ▁. ▁FULL ▁) ▁. ▁policy Spill ▁( ▁Spill Policy ▁. ▁EXTERNAL ▁) ▁. ▁build ▁( ▁) ▁; ▁try ▁( ▁val ▁ws ▁= ▁( ▁Nd 4 j Workspace ▁) ▁Nd 4 j ▁. ▁getWorkspace Manager ▁( ▁) ▁. ▁getAnd Act ivate Workspace ▁( ▁basic Config ▁, ▁STR ▁) ▁) ▁{ ▁assertEquals ▁( ▁10 ▁ * ▁1024 ▁ * ▁1024 L ▁, ▁ws ▁. ▁getCurrent Size ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁ws ▁. ▁getDevice Offset ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁ws ▁. ▁getPrimary Offset ▁( ▁) ▁) ▁; ▁val ▁array ▁= ▁Nd 4 j ▁. ▁create ▁( ▁DataType ▁. ▁DOUBLE ▁, ▁10 ▁, ▁10 ▁) ▁. ▁assign ▁( ▁1.0 f ▁) ▁; ▁assertTrue ▁( ▁array ▁. ▁isA tt ached ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁ws ▁. ▁getPrimary Offset ▁( ▁) ▁) ▁;
▁@ ▁RunWith ▁( ▁MockitoJUnit Runner ▁. ▁class ▁) ▁public ▁class ▁HealthCheck UnitTest ▁{ ▁@ ▁Test ▁public ▁void ▁when Check Method Returns Z ero _ then Health Method Returns Status UP ▁( ▁) ▁{ ▁HealthCheck ▁healthCheck ▁= ▁Mockito ▁. ▁spy ▁( ▁new ▁HealthCheck ▁( ▁) ▁) ▁; ▁when ▁( ▁healthCheck ▁. ▁check ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁0 ▁) ▁; ▁Health ▁health ▁= ▁healthCheck ▁. ▁health ▁( ▁) ▁; ▁assertThat ▁( ▁health ▁. ▁getStatus ▁( ▁) ▁, ▁is ▁( ▁Status ▁. ▁UP ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁when Check Method Returns OtherThan Z ero _ then Health Method Returns Status DOWN ▁( ▁) ▁{ ▁HealthCheck ▁healthCheck ▁= ▁Mockito ▁. ▁spy ▁( ▁new ▁HealthCheck ▁( ▁) ▁) ▁; ▁when ▁( ▁healthCheck ▁. ▁check ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁- ▁1 ▁) ▁; ▁Health ▁health ▁= ▁healthCheck ▁. ▁health ▁( ▁) ▁; ▁assertThat ▁( ▁health ▁. ▁getStatus ▁( ▁) ▁, ▁is ▁( ▁Status ▁. ▁DOWN ▁) ▁) ▁; ▁} ▁}
▁@ ▁Component ▁public ▁class ▁DubboBootstrap Start CommandLine Runner ▁implements ▁CommandLine Runner ▁, ▁Application EventPublisher Aware ▁{ ▁private ▁Application EventPublisher ▁application EventPublisher ▁; ▁@ ▁Override ▁public ▁void ▁setApplication EventPublisher ▁( ▁Application EventPublisher ▁application EventPublisher ▁) ▁{ ▁this ▁. ▁application EventPublisher ▁= ▁application EventPublisher ▁; ▁} ▁@ ▁Override ▁public ▁void ▁run ▁( ▁String ▁... ▁args ▁) ▁{ ▁application EventPublisher ▁. ▁publish Event ▁( ▁new ▁DubboBootstrap Started Event ▁( ▁DubboBootstrap Wrapper ▁. ▁getInstance ▁( ▁) ▁) ▁) ▁; ▁} ▁}
▁@ ▁SpringBoot Application ▁public ▁class ▁R mi Client ▁{ ▁@ ▁Bean ▁R mi Proxy FactoryBean ▁service ▁( ▁) ▁{ ▁R mi Proxy FactoryBean ▁r mi Proxy Factory ▁= ▁new ▁R mi Proxy FactoryBean ▁( ▁) ▁; ▁r mi Proxy Factory ▁. ▁setService Url ▁( ▁STR ▁) ▁; ▁r mi Proxy Factory ▁. ▁setService Interface ▁( ▁C ab Book ingService ▁. ▁class ▁) ▁; ▁return ▁r mi Proxy Factory ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁throws ▁Book ingException ▁{ ▁C ab Book ingService ▁service ▁= ▁Spring Application ▁. ▁run ▁( ▁R mi Client ▁. ▁class ▁, ▁args ▁) ▁. ▁getBean ▁( ▁C ab Book ingService ▁. ▁class ▁) ▁; ▁Book ing ▁book ing Outcome ▁= ▁service ▁. ▁book R ide ▁( ▁STR ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁book ing Outcome ▁) ▁; ▁} ▁}
▁public ▁void ▁setNode Status Updater ▁( ▁Node Status Updater ▁node Status Updater ▁) ▁{ ▁this ▁. ▁node Status Updater ▁= ▁node Status Updater ▁; ▁} ▁protected ▁Container Executor ▁create Container Executor ▁( ▁) ▁{ ▁Default Container Executor ▁exec ▁= ▁new ▁Default Container Executor ▁( ▁) ▁; ▁exec ▁. ▁setConf ▁( ▁conf ▁) ▁; ▁return ▁spy ▁( ▁exec ▁) ▁; ▁} ▁@ ▁Before ▁public ▁void ▁setup ▁( ▁) ▁throws ▁IOException ▁{ ▁local FS ▁. ▁delete ▁( ▁new ▁Path ▁( ▁local Dir ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁, ▁true ▁) ▁; ▁local FS ▁. ▁delete ▁( ▁new ▁Path ▁( ▁tmpDir ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁, ▁true ▁) ▁; ▁local FS ▁. ▁delete ▁( ▁new ▁Path ▁( ▁local LogDir ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁, ▁true ▁) ▁; ▁local FS ▁. ▁delete ▁( ▁new ▁Path ▁( ▁remote LogDir ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁, ▁true ▁) ▁; ▁local Dir ▁. ▁mkdir ▁( ▁) ▁; ▁tmpDir ▁. ▁mkdir ▁( ▁) ▁; ▁local LogDir ▁. ▁mkdir ▁( ▁) ▁; ▁remote LogDir ▁. ▁mkdir ▁( ▁) ▁; ▁LOG ▁. ▁info ▁( ▁STR ▁+ ▁local Dir ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁; ▁LOG ▁. ▁info ▁( ▁STR ▁+ ▁tmpDir ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁; ▁String ▁bind Address ▁= ▁STR ▁+ ▁ServerSocket Util ▁. ▁getPort ▁( ▁4 9 162 ▁, ▁10 ▁) ▁; ▁conf ▁. ▁set ▁( ▁Yarn Configuration ▁. ▁NM _ ADDRESS ▁, ▁bind Address ▁) ▁; ▁conf ▁. ▁set ▁( ▁Yarn Configuration ▁. ▁NM _ LOCAL _ DIR S ▁, ▁local Dir ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁; ▁conf ▁. ▁set ▁( ▁Yarn Configuration ▁. ▁NM _ LOG _ DIR S ▁, ▁local LogDir ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁; ▁conf ▁. ▁set ▁( ▁Yarn Configuration ▁. ▁NM _ RE MOTE _ APP _ LOG _ DIR ▁, ▁remote LogDir ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁; ▁conf ▁. ▁set ▁( ▁Yarn Configuration ▁. ▁NM _ LOCAL I Z ER _ ADDRESS ▁, ▁STR ▁+ ▁ServerSocket Util ▁. ▁getPort ▁( ▁80 40 ▁, ▁10 ▁) ▁) ▁; ▁conf ▁. ▁setLong ▁( ▁Yarn Configuration ▁. ▁NM _ LOG _ RE TA IN _ SECONDS ▁, ▁1 ▁) ▁; ▁exec ▁= ▁create Container Executor ▁( ▁) ▁; ▁del S r vc ▁= ▁create Deletion Service ▁( ▁) ▁; ▁del S r vc ▁. ▁init ▁( ▁conf ▁) ▁; ▁dir s Handler ▁= ▁new ▁Local Dirs Handler Service ▁( ▁) ▁; ▁dir s Handler ▁. ▁init ▁( ▁conf ▁) ▁; ▁node Health Checker Service ▁= ▁new ▁Node Health Checker Service ▁( ▁dir s Handler ▁) ▁; ▁node Status Updater ▁= ▁new ▁Node Status Updater Impl ▁( ▁context ▁, ▁new ▁Async Dispatcher ▁( ▁) ▁, ▁node Health Checker Service ▁, ▁metrics ▁) ▁{ ▁@ ▁Override ▁protected ▁Resource Tracker ▁getRM Client ▁( ▁) ▁{ ▁return ▁new ▁Local RM Interface ▁( ▁) ▁; ▁} ▁; ▁@ ▁Override ▁protected ▁void ▁stop RM Proxy ▁( ▁) ▁{ ▁return ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁start Status Updater ▁( ▁) ▁{ ▁return ▁; ▁} ▁@ ▁Override ▁public ▁long ▁getRM Identifier ▁( ▁) ▁{ ▁return ▁DUMMY _ RM _ IDENT IFIER ▁; ▁} ▁} ▁;
▁Spring Application ▁cluster ▁= ▁new ▁Spring Application Builder ▁( ▁cls ▁) ▁. ▁web ▁( ▁WebApplication Type ▁. ▁SER V LET ▁) ▁. ▁environment ▁( ▁environment ▁) ▁. ▁properties ▁( ▁cluster Info ▁) ▁. ▁properties ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁; ▁Configurable Application Context ▁context ▁= ▁cluster ▁. ▁run ▁( ▁) ▁; ▁Distributed Database Operate Impl ▁oper ate ▁= ▁context ▁. ▁getBean ▁( ▁Distributed Database Operate Impl ▁. ▁class ▁) ▁; ▁CP Protocol ▁protocol ▁= ▁context ▁. ▁getBean ▁( ▁CP Protocol ▁. ▁class ▁) ▁; ▁protocol ▁. ▁protocol MetaData ▁( ▁) ▁. ▁subscribe ▁( ▁oper ate ▁. ▁group ▁( ▁) ▁, ▁Metadata Key ▁. ▁LE ADER _ META _ DATA ▁, ▁o ▁-> ▁{ ▁Protocol MetaData ▁. ▁Value Item ▁item ▁= ▁( ▁Protocol MetaData ▁. ▁Value Item ▁) ▁o ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁( ▁7 ▁+ ▁index ▁) ▁+ ▁STR ▁+ ▁item ▁. ▁getData ▁( ▁) ▁) ▁; ▁if ▁( ▁FIN ISHED ▁[ ▁index ▁] ▁. ▁compareAndSet ▁( ▁false ▁, ▁true ▁) ▁) ▁{ ▁latch ▁. ▁countDown ▁( ▁) ▁; ▁} ▁} ▁) ▁; ▁new ▁Thread ▁( ▁( ▁) ▁-> ▁{ ▁try ▁{ ▁Thread ▁. ▁sleep ▁( ▁5000 L ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁e ▁. ▁printStackTrace ▁( ▁) ▁; ▁} ▁finally ▁{ ▁if ▁( ▁FIN ISHED ▁[ ▁index ▁] ▁. ▁compareAndSet ▁( ▁false ▁, ▁true ▁) ▁) ▁{ ▁latch ▁. ▁countDown ▁( ▁) ▁; ▁} ▁} ▁} ▁) ▁; ▁application s ▁. ▁put ▁( ▁String ▁. ▁valueOf ▁( ▁properties ▁. ▁get ▁( ▁STR ▁) ▁) ▁, ▁context ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁e ▁) ▁{ ▁e ▁. ▁printStackTrace ▁( ▁) ▁; ▁} ▁finally ▁{ ▁latch ▁. ▁countDown ▁( ▁) ▁; ▁} ▁} ▁; ▁runnable ▁. ▁run ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁Share Res Patch Info ▁{ ▁public ▁String ▁ar sc Base C rc ▁= ▁null ▁; ▁public ▁String ▁res Ar sc Md 5 ▁= ▁null ▁; ▁public ▁ArrayList ▁< ▁String ▁> ▁add Res ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁public ▁ArrayList ▁< ▁String ▁> ▁delete Res ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁public ▁ArrayList ▁< ▁String ▁> ▁mod Res ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁public ▁HashMap ▁< ▁String ▁, ▁File ▁> ▁store Res ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁public ▁ArrayList ▁< ▁String ▁> ▁l arge Mod Res ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁public ▁HashMap ▁< ▁String ▁, ▁L arge Mode Info ▁> ▁l arge Mod Map ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁public ▁HashSet ▁< ▁Pattern ▁> ▁patterns ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁public ▁static ▁void ▁parse All Res Patch Info ▁( ▁String ▁meta ▁, ▁Share Res Patch Info ▁info ▁) ▁{ ▁if ▁( ▁meta ▁== ▁null ▁|| ▁meta ▁. ▁length ▁( ▁) ▁== ▁0 ▁) ▁{ ▁return ▁; ▁} ▁String ▁[ ▁] ▁lines ▁= ▁meta ▁. ▁split ▁( ▁STR ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁lines ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁String ▁line ▁= ▁lines ▁[ ▁i ▁] ▁; ▁if ▁( ▁line ▁== ▁null ▁|| ▁line ▁. ▁length ▁( ▁) ▁<= ▁0 ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁line ▁. ▁startsWith ▁( ▁Share Constants ▁. ▁RES _ TITLE ▁) ▁) ▁{ ▁final ▁String ▁[ ▁] ▁kv ▁= ▁line ▁. ▁split ▁( ▁STR ▁, ▁3 ▁) ▁; ▁info ▁. ▁ar sc Base C rc ▁= ▁kv ▁[ ▁1 ▁] ▁; ▁info ▁. ▁res Ar sc Md 5 ▁= ▁kv ▁[ ▁2 ▁] ▁; ▁} ▁else ▁if ▁( ▁line ▁. ▁startsWith ▁( ▁Share Constants ▁. ▁RES _ PATTERN _ TITLE ▁) ▁) ▁{ ▁final ▁String ▁[ ▁] ▁kv ▁= ▁line ▁. ▁split ▁( ▁STR ▁, ▁2 ▁) ▁; ▁int ▁size ▁= ▁Integer ▁. ▁parseInt ▁( ▁kv ▁[ ▁1 ▁] ▁) ▁; ▁for ▁( ▁; ▁size ▁> ▁0 ▁; ▁size ▁-- ▁) ▁{ ▁info ▁. ▁patterns ▁. ▁add ▁( ▁convertTo Pattern String ▁( ▁lines ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁) ▁; ▁i ▁++ ▁; ▁} ▁} ▁else ▁if ▁( ▁line ▁. ▁startsWith ▁( ▁Share Constants ▁. ▁RES _ ADD _ TITLE ▁) ▁) ▁{ ▁final ▁String ▁[ ▁] ▁kv ▁= ▁line ▁. ▁split ▁( ▁STR ▁, ▁2 ▁) ▁; ▁int ▁size ▁= ▁Integer ▁. ▁parseInt ▁( ▁kv ▁[ ▁1 ▁] ▁) ▁; ▁for ▁( ▁; ▁size ▁> ▁0 ▁; ▁size ▁-- ▁) ▁{ ▁info ▁. ▁add Res ▁. ▁add ▁( ▁lines ▁[ ▁i ▁+ ▁1 ▁] ▁) ▁; ▁i ▁++ ▁; ▁} ▁} ▁else ▁if ▁( ▁line ▁. ▁startsWith ▁( ▁Share Constants ▁. ▁RES _ MOD _ TITLE ▁) ▁) ▁{ ▁final ▁String ▁[ ▁] ▁kv ▁= ▁line ▁. ▁split ▁( ▁STR ▁, ▁2 ▁) ▁; ▁int ▁size ▁= ▁Integer ▁. ▁parseInt ▁( ▁kv ▁[ ▁1 ▁] ▁) ▁; ▁for ▁( ▁; ▁size ▁> ▁0 ▁;
▁public ▁class ▁Write As Array _ list _ obj _ first _ pu blic ▁extends ▁TestCase ▁{ ▁public ▁void ▁test _0 ▁( ▁) ▁throws ▁Exception ▁{ ▁VO ▁vo ▁= ▁new ▁VO ▁( ▁) ▁; ▁vo ▁. ▁setId ▁( ▁123 ▁) ▁; ▁vo ▁. ▁setName ▁( ▁STR ▁) ▁; ▁vo ▁. ▁getF value s ▁( ▁) ▁. ▁add ▁( ▁new ▁A ▁( ▁) ▁) ▁; ▁String ▁text ▁= ▁JSON ▁. ▁toJSONString ▁( ▁vo ▁, ▁Serializer Feature ▁. ▁Bean ToArray ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁text ▁) ▁; ▁VO ▁vo 2 ▁= ▁JSON ▁. ▁parseObject ▁( ▁text ▁, ▁VO ▁. ▁class ▁, ▁Feature ▁. ▁Support ArrayToBean ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁vo ▁. ▁getId ▁( ▁) ▁, ▁vo 2 ▁. ▁getId ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁vo ▁. ▁getName ▁( ▁) ▁, ▁vo 2 ▁. ▁getName ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁vo ▁. ▁getF value s ▁( ▁) ▁. ▁size ▁( ▁) ▁, ▁vo 2 ▁. ▁getF value s ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁vo ▁. ▁getF value s ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁getClass ▁( ▁) ▁, ▁vo 2 ▁. ▁getF value s ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁getClass ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁vo ▁. ▁getF value s ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁getValue ▁( ▁) ▁, ▁vo 2 ▁. ▁getF value s ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁public ▁static ▁class ▁VO ▁{ ▁private ▁long ▁id ▁; ▁private ▁String ▁name ▁; ▁private ▁List ▁< ▁A ▁> ▁f value s ▁= ▁new ▁ArrayList ▁< ▁A ▁> ▁( ▁) ▁; ▁public ▁long ▁getId ▁( ▁) ▁{ ▁return ▁id ▁; ▁} ▁public ▁void ▁setId ▁( ▁long ▁id ▁) ▁{ ▁this ▁. ▁id ▁= ▁id ▁; ▁} ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁name ▁; ▁} ▁public ▁void ▁setName ▁( ▁String ▁name ▁) ▁{ ▁this ▁. ▁name ▁= ▁name ▁; ▁} ▁public ▁List ▁< ▁A ▁> ▁getF value s ▁( ▁) ▁{ ▁return ▁f value s ▁; ▁} ▁public ▁void ▁setF value s ▁( ▁List ▁< ▁A ▁> ▁f value s ▁) ▁{ ▁this ▁. ▁f value s ▁= ▁f value s ▁; ▁} ▁} ▁public ▁static ▁class ▁A ▁{ ▁private ▁int ▁value ▁; ▁public ▁int ▁getValue ▁( ▁) ▁{ ▁return ▁value ▁; ▁} ▁public ▁void ▁setValue ▁( ▁int ▁value ▁) ▁{ ▁this ▁. ▁value ▁= ▁value ▁; ▁} ▁} ▁}
▁m ln ▁. ▁set Layer Mask Arrays ▁( ▁data ▁. ▁getFeatures Mask Array ▁( ▁0 ▁) ▁, ▁data ▁. ▁getLabels Mask Array ▁( ▁0 ▁) ▁) ▁; ▁m ln ▁. ▁compute Gradient And Score ▁( ▁) ▁; ▁gradient Flat ▁= ▁m ln ▁. ▁getF lat ten ed Gradient s ▁( ▁) ▁; ▁grad ▁= ▁m ▁. ▁gradient ▁( ▁) ▁. ▁gradient For Variable ▁( ▁) ▁; ▁} ▁else ▁if ▁( ▁model Type ▁== ▁Model Type ▁. ▁C G ▁) ▁{ ▁MultiDataSet ▁data ▁= ▁tc ▁. ▁getG radient s TestData ▁( ▁) ▁; ▁cg ▁. ▁set Inputs ▁( ▁data ▁. ▁getFeatures ▁( ▁) ▁) ▁; ▁cg ▁. ▁set Labels ▁( ▁data ▁. ▁getLabels ▁( ▁) ▁) ▁; ▁cg ▁. ▁set Layer Mask Arrays ▁( ▁data ▁. ▁getFeatures Mask Arrays ▁( ▁) ▁, ▁data ▁. ▁getLabels Mask Arrays ▁( ▁) ▁) ▁; ▁cg ▁. ▁compute Gradient And Score ▁( ▁) ▁; ▁gradient Flat ▁= ▁cg ▁. ▁getF lat ten ed Gradient s ▁( ▁) ▁; ▁grad ▁= ▁m ▁. ▁gradient ▁( ▁) ▁. ▁gradient For Variable ▁( ▁) ▁; ▁} ▁else ▁{ ▁Map ▁< ▁String ▁, ▁INDArray ▁> ▁ph ▁= ▁tc ▁. ▁getG radient s TestData Same Diff ▁( ▁) ▁; ▁List ▁< ▁String ▁> ▁all Vars ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁SDVariable ▁v ▁: ▁sd ▁. ▁variables ▁( ▁) ▁) ▁{ ▁if ▁( ▁v ▁. ▁getVariable Type ▁( ▁) ▁== ▁Variable Type ▁. ▁VAR IABLE ▁) ▁{ ▁all Vars ▁. ▁add ▁( ▁v ▁. ▁name ▁( ▁) ▁) ▁; ▁} ▁} ▁grad ▁= ▁sd ▁. ▁calculate Gradient s ▁( ▁ph ▁, ▁all Vars ▁) ▁; ▁} ▁if ▁( ▁model Type ▁!= ▁Model Type ▁. ▁SAME DI FF ▁) ▁{ ▁File ▁g Flat File ▁= ▁new ▁File ▁( ▁test Base Dir ▁, ▁Integration TestRunner ▁. ▁F LAT _ GR AD IENT S _ FILENAME ▁) ▁; ▁Integration TestRunner ▁. ▁write ▁( ▁gradient Flat ▁, ▁g Flat File ▁) ▁; ▁} ▁File ▁gradient Dir ▁= ▁new ▁File ▁( ▁test Base Dir ▁, ▁STR ▁) ▁; ▁gradient Dir ▁. ▁mkdir ▁( ▁) ▁; ▁for ▁( ▁String ▁s ▁: ▁grad ▁. ▁keySet ▁( ▁) ▁) ▁{ ▁File ▁f ▁= ▁new ▁File ▁( ▁gradient Dir ▁, ▁s ▁+ ▁STR ▁) ▁; ▁Integration TestRunner ▁. ▁write ▁( ▁grad ▁. ▁get ▁( ▁s ▁) ▁, ▁f ▁) ▁; ▁} ▁} ▁if ▁( ▁tc ▁. ▁is Test Uns up er vised Training ▁( ▁) ▁) ▁{ ▁log ▁. ▁info ▁( ▁STR ▁) ▁; ▁Multi DataSetIterator ▁iter ▁= ▁tc ▁. ▁get Uns up er vised Train Data ▁( ▁) ▁; ▁INDArray ▁params Post Training ▁; ▁if ▁( ▁model Type ▁== ▁Model Type ▁. ▁ML N ▁) ▁{ ▁int ▁[ ▁] ▁layers To Train ▁= ▁tc ▁. ▁get Uns up er vised Train Layers ML N ▁( ▁) ▁; ▁Preconditions ▁. ▁checkState ▁( ▁layers To Train ▁!= ▁null ▁, ▁STR ▁) ▁; ▁DataSetIterator ▁ds i ▁= ▁new ▁MultiDataSet Wrapper Iterator ▁( ▁iter ▁) ▁;
▁compute All Perm ut ations Impl ▁( ▁operator ▁, ▁appl ic able Args ▁, ▁collector ▁, ▁index ▁+ ▁1 ▁, ▁selected ▁) ▁; ▁} ▁} ▁} ▁private ▁static ▁Set ▁< ▁? ▁extends ▁String ▁> ▁filter L anguages ▁( ▁final ▁TestContext ▁context ▁, ▁final ▁Predicate ▁< ▁String ▁> ▁pre dic te ▁) ▁{ ▁final ▁Set ▁< ▁? ▁extends ▁String ▁> ▁installed Lang s ▁= ▁context ▁. ▁getIn st alled Providers ▁( ▁) ▁. ▁keySet ▁( ▁) ▁; ▁return ▁pre dic te ▁== ▁null ▁? ▁installed Lang s ▁: ▁installed Lang s ▁. ▁stream ▁( ▁) ▁. ▁filter ▁( ▁pre dic te ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toSet ▁( ▁) ▁) ▁; ▁} ▁private ▁static ▁Illegal StateException ▁provider NotFound ▁( ▁String ▁property ▁, ▁Set ▁< ▁String ▁> ▁provider Ids ▁, ▁Set ▁< ▁String ▁> ▁installed Providers ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁String ▁. ▁format ▁( ▁STR ▁+ ▁STR ▁, ▁String ▁. ▁join ▁( ▁STR ▁, ▁provider Ids ▁) ▁, ▁property ▁, ▁String ▁. ▁join ▁( ▁STR ▁, ▁installed Providers ▁) ▁) ▁) ▁; ▁} ▁abstract ▁static ▁class ▁Collect ing Matcher ▁< ▁T ▁> ▁extends ▁Base Matcher ▁< ▁T ▁> ▁implements ▁Consumer ▁< ▁Map ▁. ▁Entry ▁< ▁T ▁, ▁Boolean ▁> ▁> ▁{ ▁} ▁private ▁static ▁final ▁class ▁T oo Many Failures Matcher ▁< ▁T ▁> ▁extends ▁Collect ing Matcher ▁< ▁T ▁> ▁{ ▁private ▁int ▁failures ▁; ▁private ▁boolean ▁log ged Too Many Failures ▁; ▁T oo Many Failures Matcher ▁( ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁boolean ▁matches ▁( ▁Object ▁item ▁) ▁{ ▁return ▁failures ▁< ▁MAX _ FAILURE S ▁; ▁} ▁@ ▁Override ▁public ▁void ▁describe To ▁( ▁Description ▁description ▁) ▁{ ▁if ▁( ▁! ▁log ged Too Many Failures ▁) ▁{ ▁log ged Too Many Failures ▁= ▁true ▁; ▁description ▁. ▁appendText ▁( ▁STR ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁accept ▁( ▁final ▁Map ▁. ▁Entry ▁< ▁T ▁, ▁Boolean ▁> ▁testRun ▁) ▁{ ▁if ▁( ▁! ▁testRun ▁. ▁getValue ▁( ▁) ▁) ▁{ ▁failures ▁++ ▁; ▁} ▁} ▁} ▁}
▁@ ▁Test ▁public ▁void ▁map Fail Handler Throws Conditional ▁( ▁) ▁{ ▁TestSubscriber Ex ▁< ▁Integer ▁> ▁ts ▁= ▁Flowable ▁. ▁range ▁( ▁0 ▁, ▁2 ▁) ▁. ▁parallel ▁( ▁1 ▁) ▁. ▁map Optional ▁( ▁v ▁-> ▁Optional ▁. ▁of ▁( ▁1 ▁ / ▁v ▁) ▁, ▁new ▁BiFunction ▁< ▁Long ▁, ▁Throwable ▁, ▁Parallel Failure Handling ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Parallel Failure Handling ▁apply ▁( ▁Long ▁n ▁, ▁Throwable ▁e ▁) ▁throws ▁Exception ▁{ ▁throw ▁new ▁TestException ▁( ▁) ▁; ▁} ▁} ▁) ▁. ▁filter ▁( ▁Functions ▁. ▁always True ▁( ▁) ▁) ▁. ▁se quential ▁( ▁) ▁. ▁to ▁( ▁TestHelper ▁. ▁< ▁Integer ▁> ▁test Consumer ▁( ▁) ▁) ▁. ▁assertFailure ▁( ▁Composite Exception ▁. ▁class ▁) ▁; ▁TestHelper ▁. ▁assert Composite Exceptions ▁( ▁ts ▁, ▁Arithmetic Exception ▁. ▁class ▁, ▁TestException ▁. ▁class ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁map Wrong Parallelism Conditional ▁( ▁) ▁{ ▁TestHelper ▁. ▁check Invalid Parallel Subscribers ▁( ▁Flowable ▁. ▁just ▁( ▁1 ▁) ▁. ▁parallel ▁( ▁1 ▁) ▁. ▁map Optional ▁( ▁Optional ▁:: ▁of ▁, ▁Parallel Failure Handling ▁. ▁ERROR ▁) ▁. ▁filter ▁( ▁Functions ▁. ▁always True ▁( ▁) ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁map Invalid Source Conditional ▁( ▁) ▁{ ▁List ▁< ▁Throwable ▁> ▁errors ▁= ▁TestHelper ▁. ▁track Plugin Errors ▁( ▁) ▁; ▁try ▁{ ▁new ▁Parallel Invalid ▁( ▁) ▁. ▁map Optional ▁( ▁Optional ▁:: ▁of ▁, ▁Parallel Failure Handling ▁. ▁ERROR ▁) ▁. ▁filter ▁( ▁Functions ▁. ▁always True ▁( ▁) ▁) ▁. ▁se quential ▁( ▁) ▁. ▁test ▁( ▁) ▁; ▁TestHelper ▁. ▁assertUn deliver able ▁( ▁errors ▁, ▁0 ▁, ▁TestException ▁. ▁class ▁) ▁; ▁} ▁finally ▁{ ▁RxJavaPlugins ▁. ▁reset ▁( ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁failure Handling Enum ▁( ▁) ▁{ ▁TestHelper ▁. ▁check Enum ▁( ▁Parallel Failure Handling ▁. ▁class ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁all None ▁( ▁) ▁{ ▁Flowable ▁. ▁range ▁( ▁1 ▁, ▁1000 ▁) ▁. ▁parallel ▁( ▁) ▁. ▁map Optional ▁( ▁v ▁-> ▁Optional ▁. ▁empty ▁( ▁) ▁, ▁Parallel Failure Handling ▁. ▁SKIP ▁) ▁. ▁se quential ▁( ▁) ▁. ▁test ▁( ▁) ▁. ▁assertResult ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁all None Conditional ▁( ▁) ▁{ ▁Flowable ▁. ▁range ▁( ▁1 ▁, ▁1000 ▁) ▁. ▁parallel ▁( ▁) ▁. ▁map Optional ▁( ▁v ▁-> ▁Optional ▁. ▁empty ▁( ▁) ▁, ▁Parallel Failure Handling ▁. ▁SKIP ▁) ▁. ▁filter ▁( ▁v ▁-> ▁true ▁) ▁. ▁se quential ▁( ▁) ▁. ▁test ▁( ▁) ▁. ▁assertResult ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁m ix ed ▁( ▁) ▁{ ▁Flowable ▁. ▁range ▁( ▁1 ▁, ▁1000 ▁) ▁. ▁parallel ▁( ▁) ▁. ▁map Optional ▁( ▁v ▁-> ▁v ▁ % ▁2 ▁== ▁0 ▁? ▁Optional ▁. ▁of ▁( ▁v ▁) ▁: ▁Optional ▁. ▁empty ▁( ▁) ▁, ▁Parallel Failure Handling ▁. ▁SKIP ▁) ▁. ▁se quential ▁( ▁) ▁. ▁test ▁( ▁) ▁. ▁assert ValueCount ▁( ▁500 ▁) ▁. ▁assertNoErrors ▁( ▁) ▁. ▁assert Complete ▁( ▁) ▁;
▁public ▁Record Set Summary ▁( ▁String ▁topic ▁, ▁int ▁partition ▁, ▁long ▁count ▁, ▁long ▁min Offset ▁, ▁long ▁max Offset ▁) ▁{ ▁super ▁( ▁topic ▁, ▁partition ▁) ▁; ▁this ▁. ▁count ▁= ▁count ▁; ▁this ▁. ▁min Offset ▁= ▁min Offset ▁; ▁this ▁. ▁max Offset ▁= ▁max Offset ▁; ▁} ▁@ ▁JsonProperty ▁public ▁long ▁count ▁( ▁) ▁{ ▁return ▁count ▁; ▁} ▁@ ▁JsonProperty ▁public ▁long ▁min Offset ▁( ▁) ▁{ ▁return ▁min Offset ▁; ▁} ▁@ ▁JsonProperty ▁public ▁long ▁max Offset ▁( ▁) ▁{ ▁return ▁max Offset ▁; ▁} ▁} ▁private ▁static ▁Argument Parser ▁arg Parser ▁( ▁) ▁{ ▁Argument Parser ▁parser ▁= ▁Argument Parsers ▁. ▁new Argument Parser ▁( ▁STR ▁) ▁. ▁default Help ▁( ▁true ▁) ▁. ▁description ▁( ▁STR ▁) ▁; ▁M ut ually Exclusive Group ▁connection Group ▁= ▁parser ▁. ▁add Mut ually Exclusive Group ▁( ▁STR ▁) ▁. ▁description ▁( ▁STR ▁) ▁. ▁required ▁( ▁true ▁) ▁; ▁connection Group ▁. ▁add Argument ▁( ▁STR ▁) ▁. ▁action ▁( ▁store ▁( ▁) ▁) ▁. ▁required ▁( ▁false ▁) ▁. ▁type ▁( ▁String ▁. ▁class ▁) ▁. ▁met av ar ▁( ▁STR ▁) ▁. ▁dest ▁( ▁STR ▁) ▁. ▁help ▁( ▁STR ▁) ▁; ▁connection Group ▁. ▁add Argument ▁( ▁STR ▁) ▁. ▁action ▁( ▁store ▁( ▁) ▁) ▁. ▁required ▁( ▁false ▁) ▁. ▁type ▁( ▁String ▁. ▁class ▁) ▁. ▁met av ar ▁( ▁STR ▁) ▁. ▁dest ▁( ▁STR ▁) ▁. ▁help ▁( ▁STR ▁) ▁; ▁parser ▁. ▁add Argument ▁( ▁STR ▁) ▁. ▁action ▁( ▁store ▁( ▁) ▁) ▁. ▁required ▁( ▁true ▁) ▁. ▁type ▁( ▁String ▁. ▁class ▁) ▁. ▁met av ar ▁( ▁STR ▁) ▁. ▁help ▁( ▁STR ▁) ▁; ▁parser ▁. ▁add Argument ▁( ▁STR ▁) ▁. ▁action ▁( ▁store ▁( ▁) ▁) ▁. ▁required ▁( ▁true ▁) ▁. ▁type ▁( ▁String ▁. ▁class ▁) ▁. ▁met av ar ▁( ▁STR ▁) ▁. ▁dest ▁( ▁STR ▁) ▁. ▁help ▁( ▁STR ▁) ▁; ▁parser ▁. ▁add Argument ▁( ▁STR ▁) ▁. ▁action ▁( ▁store ▁( ▁) ▁) ▁. ▁required ▁( ▁false ▁) ▁. ▁type ▁( ▁String ▁. ▁class ▁) ▁. ▁met av ar ▁( ▁STR ▁) ▁. ▁dest ▁( ▁STR ▁) ▁. ▁help ▁( ▁STR ▁) ▁; ▁parser ▁. ▁add Argument ▁( ▁STR ▁) ▁. ▁action ▁( ▁store ▁( ▁) ▁) ▁. ▁required ▁( ▁false ▁) ▁. ▁type ▁( ▁Integer ▁. ▁class ▁) ▁. ▁setDefault ▁( ▁- ▁1 ▁) ▁. ▁met av ar ▁( ▁STR ▁) ▁. ▁dest ▁( ▁STR ▁) ▁. ▁help ▁( ▁STR ▁) ▁; ▁parser ▁. ▁add Argument ▁( ▁STR ▁) ▁. ▁action ▁( ▁store ▁( ▁) ▁) ▁. ▁required ▁( ▁false ▁) ▁. ▁setDefault ▁( ▁30000 ▁) ▁. ▁type ▁( ▁Integer ▁. ▁class ▁) ▁. ▁met av ar ▁( ▁STR ▁) ▁. ▁dest ▁( ▁STR ▁) ▁. ▁help ▁( ▁STR ▁) ▁; ▁parser ▁. ▁add Argument ▁( ▁STR ▁) ▁. ▁action ▁( ▁store True ▁( ▁) ▁) ▁. ▁type ▁( ▁Boolean ▁. ▁class ▁) ▁. ▁met av ar ▁( ▁STR ▁) ▁. ▁help ▁( ▁STR ▁) ▁;
▁start ▁+= ▁EXPECTED _ H B _ RESPONSE ID _ MESSAGE ▁. ▁length ▁( ▁) ▁; ▁try ▁{ ▁return ▁Integer ▁. ▁parseInt ▁( ▁exception Message ▁. ▁substring ▁( ▁start ▁, ▁end ▁) ▁) ▁; ▁} ▁catch ▁( ▁Number FormatException ▁ex ▁) ▁{ ▁return ▁- ▁1 ▁; ▁} ▁} ▁public ▁static ▁int ▁getNext Response Id ▁( ▁int ▁response Id ▁) ▁{ ▁return ▁( ▁response Id ▁+ ▁1 ▁) ▁& ▁Integer ▁. ▁MAX _ VALUE ▁; ▁} ▁public ▁static ▁void ▁addTo Out st anding Scheduling Requests ▁( ▁Collection ▁< ▁Scheduling Request ▁> ▁requests ▁, ▁Map ▁< ▁Set ▁< ▁String ▁> ▁, ▁List ▁< ▁Scheduling Request ▁> ▁> ▁out st anding S ched Requests ▁) ▁{ ▁for ▁( ▁Scheduling Request ▁req ▁: ▁requests ▁) ▁{ ▁List ▁< ▁Scheduling Request ▁> ▁s cheduling Requests ▁= ▁out st anding S ched Requests ▁. ▁computeIfAbsent ▁( ▁req ▁. ▁get Allocation Tags ▁( ▁) ▁, ▁x ▁-> ▁new ▁LinkedList ▁< ▁> ▁( ▁) ▁) ▁; ▁Scheduling Request ▁matching Req ▁= ▁null ▁; ▁for ▁( ▁Scheduling Request ▁sched Req ▁: ▁s cheduling Requests ▁) ▁{ ▁if ▁( ▁is Matching Scheduling Requests ▁( ▁req ▁, ▁sched Req ▁) ▁) ▁{ ▁matching Req ▁= ▁sched Req ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁matching Req ▁!= ▁null ▁) ▁{ ▁matching Req ▁. ▁getResource S izing ▁( ▁) ▁. ▁setNum Allocations ▁( ▁req ▁. ▁getResource S izing ▁( ▁) ▁. ▁getNum Allocations ▁( ▁) ▁) ▁; ▁} ▁else ▁{ ▁s cheduling Requests ▁. ▁add ▁( ▁req ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁boolean ▁is Matching Scheduling Requests ▁( ▁Scheduling Request ▁sched Req 1 ▁, ▁Scheduling Request ▁sched Req 2 ▁) ▁{ ▁return ▁sched Req 1 ▁. ▁getPriority ▁( ▁) ▁. ▁equals ▁( ▁sched Req 2 ▁. ▁getPriority ▁( ▁) ▁) ▁&& ▁sched Req 1 ▁. ▁getExecution Type ▁( ▁) ▁. ▁getExecution Type ▁( ▁) ▁. ▁equals ▁( ▁sched Req 1 ▁. ▁getExecution Type ▁( ▁) ▁. ▁getExecution Type ▁( ▁) ▁) ▁&& ▁sched Req 1 ▁. ▁get Allocation RequestId ▁( ▁) ▁== ▁sched Req 2 ▁. ▁get Allocation RequestId ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁remove From Out st anding Scheduling Requests ▁( ▁Collection ▁< ▁Container ▁> ▁containers ▁, ▁Map ▁< ▁Set ▁< ▁String ▁> ▁, ▁List ▁< ▁Scheduling Request ▁> ▁> ▁out st anding S ched Requests ▁) ▁{ ▁if ▁( ▁containers ▁== ▁null ▁|| ▁containers ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁return ▁; ▁} ▁for ▁( ▁Container ▁container ▁: ▁containers ▁) ▁{ ▁if ▁( ▁container ▁. ▁get Allocation Tags ▁( ▁) ▁!= ▁null ▁) ▁{ ▁List ▁< ▁Scheduling Request ▁> ▁sched Req s ▁= ▁out st anding S ched Requests ▁. ▁get ▁( ▁container ▁. ▁get Allocation Tags ▁( ▁) ▁) ▁; ▁if ▁( ▁sched Req s ▁!= ▁null ▁&& ▁! ▁sched Req s ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁Iterator ▁< ▁Scheduling Request ▁> ▁iter ▁= ▁sched Req s ▁. ▁iterator ▁( ▁) ▁; ▁while ▁( ▁iter ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁Scheduling Request ▁sched Req ▁= ▁iter ▁. ▁next ▁( ▁) ▁;
▁@ ▁Override ▁public ▁void ▁string Field ▁( ▁Field Info ▁field Info ▁, ▁byte ▁[ ▁] ▁bytes ▁) ▁{ ▁assert ▁Id FieldMapper ▁. ▁NAME ▁. ▁equals ▁( ▁field Info ▁. ▁name ▁) ▁== ▁false ▁: ▁STR ▁; ▁assert ▁source FieldName ▁. ▁equals ▁( ▁field Info ▁. ▁name ▁) ▁== ▁false ▁: ▁STR ▁; ▁final ▁String ▁value ▁= ▁new ▁String ▁( ▁bytes ▁, ▁Standard Charsets ▁. ▁UTF _8 ▁) ▁; ▁addValue ▁( ▁field Info ▁. ▁name ▁, ▁value ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁int Field ▁( ▁Field Info ▁field Info ▁, ▁int ▁value ▁) ▁{ ▁addValue ▁( ▁field Info ▁. ▁name ▁, ▁value ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁long Field ▁( ▁Field Info ▁field Info ▁, ▁long ▁value ▁) ▁{ ▁addValue ▁( ▁field Info ▁. ▁name ▁, ▁value ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁float Field ▁( ▁Field Info ▁field Info ▁, ▁float ▁value ▁) ▁{ ▁addValue ▁( ▁field Info ▁. ▁name ▁, ▁value ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁double Field ▁( ▁Field Info ▁field Info ▁, ▁double ▁value ▁) ▁{ ▁addValue ▁( ▁field Info ▁. ▁name ▁, ▁value ▁) ▁; ▁} ▁public ▁void ▁object Field ▁( ▁Field Info ▁field Info ▁, ▁Object ▁object ▁) ▁{ ▁assert ▁Id FieldMapper ▁. ▁NAME ▁. ▁equals ▁( ▁field Info ▁. ▁name ▁) ▁== ▁false ▁: ▁STR ▁; ▁assert ▁source FieldName ▁. ▁equals ▁( ▁field Info ▁. ▁name ▁) ▁== ▁false ▁: ▁STR ▁; ▁addValue ▁( ▁field Info ▁. ▁name ▁, ▁object ▁) ▁; ▁} ▁public ▁BytesReference ▁source ▁( ▁) ▁{ ▁return ▁source ▁; ▁} ▁public ▁String ▁id ▁( ▁) ▁{ ▁return ▁id ▁; ▁} ▁public ▁String ▁routing ▁( ▁) ▁{ ▁if ▁( ▁fields Values ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁List ▁< ▁Object ▁> ▁values ▁= ▁fields Values ▁. ▁get ▁( ▁Routing FieldMapper ▁. ▁NAME ▁) ▁; ▁if ▁( ▁values ▁== ▁null ▁|| ▁values ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁assert ▁values ▁. ▁size ▁( ▁) ▁== ▁1 ▁; ▁return ▁values ▁. ▁get ▁( ▁0 ▁) ▁. ▁toString ▁( ▁) ▁; ▁} ▁public ▁Map ▁< ▁String ▁, ▁List ▁< ▁Object ▁> ▁> ▁fields ▁( ▁) ▁{ ▁return ▁fields Values ▁!= ▁null ▁? ▁fields Values ▁: ▁emptyMap ▁( ▁) ▁; ▁} ▁public ▁void ▁reset ▁( ▁) ▁{ ▁if ▁( ▁fields Values ▁!= ▁null ▁) ▁fields Values ▁. ▁clear ▁( ▁) ▁; ▁source ▁= ▁null ▁; ▁id ▁= ▁null ▁; ▁required Fields ▁. ▁addAll ▁( ▁BASE _ RE QUIRED _ FI ELDS ▁) ▁; ▁if ▁( ▁load Source ▁) ▁{ ▁required Fields ▁. ▁add ▁( ▁source FieldName ▁) ▁; ▁} ▁} ▁void ▁addValue ▁( ▁String ▁name ▁, ▁Object ▁value ▁) ▁{ ▁if ▁( ▁fields Values ▁== ▁null ▁) ▁{ ▁fields Values ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁} ▁List ▁< ▁Object ▁> ▁values ▁= ▁fields Values ▁. ▁get ▁( ▁name ▁) ▁; ▁if ▁( ▁values ▁== ▁null ▁) ▁{ ▁values ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁2 ▁) ▁; ▁fields Values ▁. ▁put ▁( ▁name ▁, ▁values ▁) ▁; ▁} ▁values ▁. ▁add ▁( ▁value ▁) ▁; ▁} ▁}
▁@ ▁SpringBootTest ▁class ▁Sample Cache Application Tests ▁{ ▁@ ▁Autowired ▁private ▁CacheManager ▁cacheManager ▁; ▁@ ▁Autowired ▁private ▁Country Repository ▁country Repository ▁; ▁@ ▁Test ▁void ▁validate Cache ▁( ▁) ▁{ ▁Cache ▁count ries ▁= ▁this ▁. ▁cacheManager ▁. ▁getCache ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁count ries ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁count ries ▁. ▁clear ▁( ▁) ▁; ▁assertThat ▁( ▁count ries ▁. ▁get ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁Country ▁be ▁= ▁this ▁. ▁country Repository ▁. ▁findBy Code ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁( ▁Country ▁) ▁count ries ▁. ▁get ▁( ▁STR ▁) ▁. ▁get ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁be ▁) ▁; ▁} ▁}
▁public ▁class ▁Chunk ing ConfigTests ▁extends ▁Abstract Serializing TestCase ▁< ▁Chunk ing Config ▁> ▁{ ▁@ ▁Override ▁protected ▁Chunk ing Config ▁createTest Instance ▁( ▁) ▁{ ▁return ▁createRandom ized Chunk ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Writeable ▁. ▁Reader ▁< ▁Chunk ing Config ▁> ▁instanceReader ▁( ▁) ▁{ ▁return ▁Chunk ing Config ▁:: ▁new ▁; ▁} ▁@ ▁Override ▁protected ▁Chunk ing Config ▁doParseInstance ▁( ▁XContentParser ▁parser ▁) ▁{ ▁return ▁Chunk ing Config ▁. ▁STRICT _ PARSER ▁. ▁apply ▁( ▁parser ▁, ▁null ▁) ▁; ▁} ▁public ▁void ▁test Constructor Given Auto And Time Span ▁( ▁) ▁{ ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁Chunk ing Config ▁( ▁Chunk ing Config ▁. ▁Mode ▁. ▁AUTO ▁, ▁TimeValue ▁. ▁timeValueMillis ▁( ▁1000 ▁) ▁) ▁) ▁; ▁} ▁public ▁void ▁test Constructor Given Off And Time Span ▁( ▁) ▁{ ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁Chunk ing Config ▁( ▁Chunk ing Config ▁. ▁Mode ▁. ▁OFF ▁, ▁TimeValue ▁. ▁timeValueMillis ▁( ▁1000 ▁) ▁) ▁) ▁; ▁} ▁public ▁void ▁test Constructor Given Manual And No Time Span ▁( ▁) ▁{ ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁Chunk ing Config ▁( ▁Chunk ing Config ▁. ▁Mode ▁. ▁MAN UAL ▁, ▁null ▁) ▁) ▁; ▁} ▁public ▁void ▁testIs Enabled ▁( ▁) ▁{ ▁assertThat ▁( ▁Chunk ing Config ▁. ▁new Auto ▁( ▁) ▁. ▁isEnabled ▁( ▁) ▁, ▁is ▁( ▁true ▁) ▁) ▁; ▁assertThat ▁( ▁Chunk ing Config ▁. ▁new Manual ▁( ▁TimeValue ▁. ▁timeValueMillis ▁( ▁1000 ▁) ▁) ▁. ▁isEnabled ▁( ▁) ▁, ▁is ▁( ▁true ▁) ▁) ▁; ▁assertThat ▁( ▁Chunk ing Config ▁. ▁new Off ▁( ▁) ▁. ▁isEnabled ▁( ▁) ▁, ▁is ▁( ▁false ▁) ▁) ▁; ▁} ▁public ▁static ▁Chunk ing Config ▁createRandom ized Chunk ▁( ▁) ▁{ ▁Chunk ing Config ▁. ▁Mode ▁mode ▁= ▁randomFrom ▁( ▁Chunk ing Config ▁. ▁Mode ▁. ▁values ▁( ▁) ▁) ▁; ▁TimeValue ▁time Span ▁= ▁null ▁; ▁if ▁( ▁mode ▁== ▁Chunk ing Config ▁. ▁Mode ▁. ▁MAN UAL ▁) ▁{ ▁time Span ▁= ▁random Positive Seconds Minutes Hours ▁( ▁) ▁; ▁} ▁return ▁new ▁Chunk ing Config ▁( ▁mode ▁, ▁time Span ▁) ▁; ▁} ▁private ▁static ▁TimeValue ▁random Positive Seconds Minutes Hours ▁( ▁) ▁{ ▁return ▁new ▁TimeValue ▁( ▁randomInt Between ▁( ▁1 ▁, ▁1000 ▁) ▁, ▁randomFrom ▁( ▁Arrays ▁. ▁asList ▁( ▁TimeUnit ▁. ▁SECONDS ▁, ▁TimeUnit ▁. ▁MINUTES ▁, ▁TimeUnit ▁. ▁HOURS ▁) ▁) ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Chunk ing Config ▁mutateInstance ▁( ▁Chunk ing Config ▁instance ▁) ▁throws ▁IOException ▁{ ▁Chunk ing Config ▁. ▁Mode ▁mode ▁= ▁instance ▁. ▁getMode ▁( ▁) ▁; ▁TimeValue ▁time Span ▁= ▁instance ▁. ▁getTime Span ▁( ▁) ▁; ▁switch ▁( ▁between ▁( ▁0 ▁, ▁1 ▁) ▁) ▁{ ▁case ▁0 ▁: ▁List ▁< ▁Chunk ing Config ▁. ▁Mode ▁> ▁modes ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁Chunk ing Config ▁. ▁Mode ▁. ▁values ▁( ▁) ▁) ▁) ▁; ▁modes ▁. ▁remove ▁( ▁mode ▁) ▁;
▁public ▁class ▁H Table Interceptor ▁implements ▁InstanceMethods A roundInterceptor ▁, ▁Instance Constructor Interceptor ▁{ ▁private ▁static ▁final ▁String ▁PREFIX _ OPERATION _ NAME ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁H BASE _ DB _ TYPE ▁= ▁STR ▁; ▁@ ▁Override ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁void ▁beforeMethod ▁( ▁En hancedInstance ▁objInst ▁, ▁Method ▁method ▁, ▁Object ▁[ ▁] ▁allArguments ▁, ▁Class ▁< ▁? ▁> ▁[ ▁] ▁argumentsTypes ▁, ▁Method InterceptResult ▁result ▁) ▁throws ▁Throwable ▁{ ▁boolean ▁can Tracing Server ▁= ▁false ▁; ▁List ▁< ▁Operation With Attributes ▁> ▁operations ▁= ▁null ▁; ▁Operation With Attributes ▁operation ▁= ▁null ▁; ▁if ▁( ▁allArguments ▁!= ▁null ▁&& ▁allArguments ▁. ▁length ▁> ▁0 ▁) ▁{ ▁if ▁( ▁allArguments ▁[ ▁0 ▁] ▁instanceof ▁List ▁) ▁{ ▁List ▁list ▁= ▁( ▁List ▁) ▁allArguments ▁[ ▁0 ▁] ▁; ▁if ▁( ▁! ▁Collection Util ▁. ▁isEmpty ▁( ▁list ▁) ▁&& ▁list ▁. ▁get ▁( ▁0 ▁) ▁instanceof ▁Operation With Attributes ▁) ▁{ ▁operations ▁= ▁list ▁; ▁can Tracing Server ▁= ▁true ▁; ▁} ▁} ▁else ▁if ▁( ▁allArguments ▁[ ▁0 ▁] ▁instanceof ▁Operation With Attributes ▁) ▁{ ▁operation ▁= ▁( ▁Operation With Attributes ▁) ▁allArguments ▁[ ▁0 ▁] ▁; ▁can Tracing Server ▁= ▁true ▁; ▁} ▁} ▁AbstractSpan ▁span ▁; ▁if ▁( ▁can Tracing Server ▁) ▁{ ▁ContextCarrier ▁contextCarrier ▁= ▁new ▁ContextCarrier ▁( ▁) ▁; ▁span ▁= ▁ContextManager ▁. ▁create Exit Span ▁( ▁PREFIX _ OPERATION _ NAME ▁+ ▁method ▁. ▁getName ▁( ▁) ▁, ▁contextCarrier ▁, ▁( ▁String ▁) ▁objInst ▁. ▁getSkyWalking DynamicField ▁( ▁) ▁) ▁; ▁C arrier Item ▁next ▁= ▁contextCarrier ▁. ▁items ▁( ▁) ▁; ▁while ▁( ▁next ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁next ▁= ▁next ▁. ▁next ▁( ▁) ▁; ▁if ▁( ▁operation ▁!= ▁null ▁) ▁{ ▁operation ▁. ▁setAttribute ▁( ▁next ▁. ▁getHead Key ▁( ▁) ▁, ▁next ▁. ▁getHead Value ▁( ▁) ▁. ▁getBytes ▁( ▁Standard Charsets ▁. ▁UTF _8 ▁) ▁) ▁; ▁} ▁else ▁{ ▁for ▁( ▁Operation With Attributes ▁o ▁: ▁operations ▁) ▁{ ▁o ▁. ▁setAttribute ▁( ▁next ▁. ▁getHead Key ▁( ▁) ▁, ▁next ▁. ▁getHead Value ▁( ▁) ▁. ▁getBytes ▁( ▁Standard Charsets ▁. ▁UTF _8 ▁) ▁) ▁; ▁} ▁} ▁} ▁} ▁else ▁{ ▁span ▁= ▁ContextManager ▁. ▁create Exit Span ▁( ▁PREFIX _ OPERATION _ NAME ▁+ ▁method ▁. ▁getName ▁( ▁) ▁, ▁( ▁String ▁) ▁objInst ▁. ▁getSkyWalking DynamicField ▁( ▁) ▁) ▁; ▁} ▁span ▁. ▁setComponent ▁( ▁Components Define ▁. ▁H BASE ▁) ▁; ▁Tags ▁. ▁DB _ TYPE ▁. ▁set ▁( ▁span ▁, ▁H BASE _ DB _ TYPE ▁) ▁; ▁Tags ▁. ▁DB _ INSTANCE ▁. ▁set ▁( ▁span ▁, ▁( ▁( ▁H Table ▁) ▁objInst ▁) ▁. ▁getName ▁( ▁) ▁. ▁getName AsString ▁( ▁) ▁) ▁; ▁SpanLayer ▁. ▁as DB ▁( ▁span ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁afterMethod ▁( ▁En hancedInstance ▁objInst ▁, ▁Method ▁method ▁, ▁Object ▁[ ▁] ▁allArguments ▁, ▁Class ▁< ▁? ▁> ▁[ ▁] ▁argumentsTypes ▁, ▁Object ▁ret ▁) ▁throws ▁Throwable ▁{ ▁ContextManager ▁. ▁stopSpan ▁( ▁) ▁; ▁return ▁ret ▁; ▁}
▁if ▁( ▁database ▁== ▁null ▁) ▁{ ▁throw ▁new ▁DBException ▁( ▁STR ▁+ ▁catalog Id ▁+ ▁STR ▁) ▁; ▁} ▁List ▁< ▁Postgre Schema ▁> ▁s chemas ▁= ▁null ▁; ▁List ▁< ▁Postgre TableBase ▁> ▁tables ▁= ▁null ▁; ▁if ▁( ▁! ▁CommonUtils ▁. ▁isEmpty ▁( ▁schema Names ▁) ▁) ▁{ ▁s chemas ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁String ▁schemaName ▁: ▁schema Names ▁) ▁{ ▁Postgre Schema ▁schema ▁= ▁database ▁. ▁getSchema ▁( ▁monitor ▁, ▁schemaName ▁) ▁; ▁if ▁( ▁schema ▁!= ▁null ▁) ▁{ ▁s chemas ▁. ▁add ▁( ▁schema ▁) ▁; ▁} ▁else ▁{ ▁log ▁. ▁debug ▁( ▁STR ▁+ ▁schemaName ▁+ ▁STR ▁+ ▁database ▁. ▁getName ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁! ▁CommonUtils ▁. ▁isEmpty ▁( ▁table Names ▁) ▁&& ▁! ▁CommonUtils ▁. ▁isEmpty ▁( ▁s chemas ▁) ▁) ▁{ ▁Postgre Schema ▁schema ▁= ▁s chemas ▁. ▁get ▁( ▁0 ▁) ▁; ▁tables ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁String ▁tableName ▁: ▁table Names ▁) ▁{ ▁Postgre TableBase ▁table ▁= ▁schema ▁. ▁getTable Cache ▁( ▁) ▁. ▁getObject ▁( ▁monitor ▁, ▁schema ▁, ▁tableName ▁) ▁; ▁if ▁( ▁table ▁!= ▁null ▁) ▁{ ▁tables ▁. ▁add ▁( ▁table ▁) ▁; ▁} ▁else ▁{ ▁log ▁. ▁debug ▁( ▁STR ▁+ ▁tableName ▁+ ▁STR ▁+ ▁schema ▁. ▁getName ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁} ▁} ▁export Info ▁[ ▁0 ▁] ▁= ▁new ▁PostgreDatabase Backup Info ▁( ▁database ▁, ▁s chemas ▁, ▁tables ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁e ▁) ▁{ ▁throw ▁new ▁Invocation TargetException ▁( ▁e ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁catch ▁( ▁Invocation TargetException ▁e ▁) ▁{ ▁log ▁. ▁error ▁( ▁STR ▁, ▁e ▁) ▁; ▁} ▁catch ▁( ▁Interrupted Exception ▁e ▁) ▁{ ▁} ▁return ▁export Info ▁[ ▁0 ▁] ▁; ▁} ▁@ ▁Override ▁public ▁void ▁save Settings ▁( ▁DBR Runnable Context ▁runnable Context ▁, ▁DBP PreferenceStore ▁store ▁) ▁{ ▁super ▁. ▁save Settings ▁( ▁runnable Context ▁, ▁store ▁) ▁; ▁store ▁. ▁setValue ▁( ▁STR ▁, ▁compression ▁) ▁; ▁store ▁. ▁setValue ▁( ▁STR ▁, ▁encoding ▁) ▁; ▁store ▁. ▁setValue ▁( ▁STR ▁, ▁show Views ▁) ▁; ▁store ▁. ▁setValue ▁( ▁STR ▁, ▁use Insert s ▁) ▁; ▁store ▁. ▁setValue ▁( ▁STR ▁, ▁no Privileges ▁) ▁; ▁store ▁. ▁setValue ▁( ▁STR ▁, ▁no Owner ▁) ▁; ▁if ▁( ▁store ▁instanceof ▁DBP Preference Map ▁&& ▁! ▁CommonUtils ▁. ▁isEmpty ▁( ▁export Objects ▁) ▁) ▁{ ▁List ▁< ▁Map ▁< ▁String ▁, ▁Object ▁> ▁> ▁object List ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁PostgreDatabase Backup Info ▁object ▁: ▁export Objects ▁) ▁{ ▁Map ▁< ▁String ▁, ▁Object ▁> ▁obj Info ▁= ▁new ▁LinkedHashMap ▁< ▁> ▁( ▁) ▁; ▁obj Info ▁. ▁put ▁( ▁STR ▁, ▁DBUtils ▁. ▁getObject Full Id ▁( ▁object ▁. ▁getDatabase ▁( ▁) ▁) ▁) ▁; ▁if ▁( ▁! ▁CommonUtils ▁. ▁isEmpty ▁( ▁object ▁. ▁getS chemas ▁( ▁) ▁) ▁) ▁{ ▁List ▁< ▁String ▁> ▁table List ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁;
▁@ ▁Immutable ▁public ▁final ▁class ▁Single Jar Action Builder ▁{ ▁private ▁static ▁final ▁ImmutableList ▁< ▁String ▁> ▁SOURCE _ JAR _ COMMAND _ LINE _ ARGS ▁= ▁ImmutableList ▁. ▁of ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁private ▁static ▁Spawn Action ▁. ▁Builder ▁single Jar Action Builder ▁( ▁Java Toolchain Provider ▁provider ▁) ▁{ ▁Artifact ▁single Jar ▁= ▁provider ▁. ▁getSingle Jar ▁( ▁) ▁; ▁Spawn Action ▁. ▁Builder ▁builder ▁= ▁new ▁Spawn Action ▁. ▁Builder ▁( ▁) ▁; ▁if ▁( ▁single Jar ▁. ▁getFilename ▁( ▁) ▁. ▁endsWith ▁( ▁STR ▁) ▁) ▁{ ▁builder ▁. ▁addTransitive Inputs ▁( ▁provider ▁. ▁getJava Runtime ▁( ▁) ▁. ▁java Base Inputs ▁( ▁) ▁) ▁. ▁set Jar Executable ▁( ▁provider ▁. ▁getJava Runtime ▁( ▁) ▁. ▁java Binary Exec Path Fragment ▁( ▁) ▁, ▁single Jar ▁, ▁provider ▁. ▁getJvm Options ▁( ▁) ▁) ▁. ▁set Execution Info ▁( ▁Execution Requirements ▁. ▁W OR KER _ MODE _ ENABLED ▁) ▁; ▁} ▁else ▁{ ▁builder ▁. ▁set Executable ▁( ▁single Jar ▁) ▁; ▁} ▁return ▁builder ▁; ▁} ▁public ▁static ▁void ▁create Source Jar Action ▁( ▁RuleContext ▁ruleContext ▁, ▁Java Semantics ▁s emantics ▁, ▁NestedSet ▁< ▁Artifact ▁> ▁resources ▁, ▁NestedSet ▁< ▁Artifact ▁> ▁resource Jars ▁, ▁Artifact ▁output Jar ▁) ▁{ ▁create Source Jar Action ▁( ▁ruleContext ▁, ▁ruleContext ▁, ▁s emantics ▁, ▁resources ▁, ▁resource Jars ▁, ▁output Jar ▁, ▁Java Toolchain Provider ▁. ▁from ▁( ▁ruleContext ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁create Source Jar Action ▁( ▁Action Registry ▁action Registry ▁, ▁Action Construction Context ▁action Construction Context ▁, ▁Java Semantics ▁s emantics ▁, ▁NestedSet ▁< ▁Artifact ▁> ▁resources ▁, ▁NestedSet ▁< ▁Artifact ▁> ▁resource Jars ▁, ▁Artifact ▁output Jar ▁, ▁Java Toolchain Provider ▁toolchain Provider ▁) ▁{ ▁requireNonNull ▁( ▁resource Jars ▁) ▁; ▁requireNonNull ▁( ▁output Jar ▁) ▁; ▁if ▁( ▁! ▁resources ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁requireNonNull ▁( ▁s emantics ▁) ▁; ▁} ▁Spawn Action ▁. ▁Builder ▁builder ▁= ▁single Jar Action Builder ▁( ▁toolchain Provider ▁) ▁. ▁add Output ▁( ▁output Jar ▁) ▁. ▁addTransitive Inputs ▁( ▁resources ▁) ▁. ▁addTransitive Inputs ▁( ▁resource Jars ▁) ▁. ▁add CommandLine ▁( ▁source Jar CommandLine ▁( ▁output Jar ▁, ▁s emantics ▁, ▁resources ▁, ▁resource Jars ▁) ▁, ▁Param FileInfo ▁. ▁builder ▁( ▁Parameter File Type ▁. ▁SH EL L _ QUO TED ▁) ▁. ▁setUse Always ▁( ▁true ▁) ▁. ▁build ▁( ▁) ▁) ▁. ▁setProgress Message ▁( ▁STR ▁, ▁output Jar ▁. ▁prettyPrint ▁( ▁) ▁) ▁. ▁setM nemonic ▁( ▁STR ▁) ▁; ▁action Registry ▁. ▁register Action ▁( ▁builder ▁. ▁build ▁( ▁action Construction Context ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁create Single Jar Action ▁( ▁RuleContext ▁ruleContext ▁, ▁NestedSet ▁< ▁Artifact ▁> ▁jar s ▁, ▁Artifact ▁output ▁) ▁{ ▁requireNonNull ▁( ▁ruleContext ▁) ▁; ▁requireNonNull ▁( ▁jar s ▁) ▁; ▁requireNonNull ▁( ▁output ▁) ▁;
▁try ▁{ ▁context ▁. ▁initialize ▁( ▁TRANS ITIVE ▁) ▁; ▁fail ▁( ▁) ▁; ▁} ▁catch ▁( ▁IllegalArgument Exception ▁e ▁) ▁{ ▁} ▁try ▁{ ▁context ▁. ▁initialize ▁( ▁INTERNAL ▁) ▁; ▁fail ▁( ▁) ▁; ▁} ▁catch ▁( ▁IllegalArgument Exception ▁e ▁) ▁{ ▁} ▁context ▁. ▁close ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Act ivate During Final ize ▁( ▁) ▁{ ▁Context ▁context ▁= ▁Context ▁. ▁create ▁( ▁) ▁; ▁context ▁. ▁initialize ▁( ▁ACT I VATE _ D UR ING _ FIN ALI Z E ▁) ▁; ▁assertNotNull ▁( ▁getOrder ▁( ▁ACT I VATE _ D UR ING _ FIN ALI Z E ▁) ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁getOrder ▁( ▁ACT I VATE _ D UR ING _ FIN ALI Z E ▁) ▁. ▁createContext ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁getOrder ▁( ▁ACT I VATE _ D UR ING _ FIN ALI Z E ▁) ▁. ▁initialize Thread ▁) ▁; ▁assertEquals ▁( ▁2 ▁, ▁getOrder ▁( ▁ACT I VATE _ D UR ING _ FIN ALI Z E ▁) ▁. ▁initialize Context ▁) ▁; ▁context ▁. ▁close ▁( ▁) ▁; ▁assertEquals ▁( ▁3 ▁, ▁getOrder ▁( ▁ACT I VATE _ D UR ING _ FIN ALI Z E ▁) ▁. ▁finalize Context ▁) ▁; ▁assertEquals ▁( ▁4 ▁, ▁getOrder ▁( ▁PUBLIC ▁) ▁. ▁createContext ▁) ▁; ▁assertEquals ▁( ▁5 ▁, ▁getOrder ▁( ▁INTERNAL ▁) ▁. ▁createContext ▁) ▁; ▁assertEquals ▁( ▁6 ▁, ▁getOrder ▁( ▁INTERNAL ▁) ▁. ▁initialize Thread ▁) ▁; ▁assertEquals ▁( ▁7 ▁, ▁getOrder ▁( ▁INTERNAL ▁) ▁. ▁initialize Context ▁) ▁; ▁assertEquals ▁( ▁8 ▁, ▁getOrder ▁( ▁PUBLIC ▁) ▁. ▁initialize Thread ▁) ▁; ▁assertEquals ▁( ▁9 ▁, ▁getOrder ▁( ▁PUBLIC ▁) ▁. ▁initialize Context ▁) ▁; ▁assertEquals ▁( ▁10 ▁, ▁getOrder ▁( ▁PUBLIC ▁) ▁. ▁finalize Context ▁) ▁; ▁assertEquals ▁( ▁11 ▁, ▁getOrder ▁( ▁INTERNAL ▁) ▁. ▁finalize Context ▁) ▁; ▁assertEquals ▁( ▁12 ▁, ▁getOrder ▁( ▁ACT I VATE _ D UR ING _ FIN ALI Z E ▁) ▁. ▁dispose Thread ▁) ▁; ▁assertEquals ▁( ▁13 ▁, ▁getOrder ▁( ▁ACT I VATE _ D UR ING _ FIN ALI Z E ▁) ▁. ▁dispose Context ▁) ▁; ▁assertEquals ▁( ▁14 ▁, ▁getOrder ▁( ▁PUBLIC ▁) ▁. ▁dispose Thread ▁) ▁; ▁assertEquals ▁( ▁15 ▁, ▁getOrder ▁( ▁PUBLIC ▁) ▁. ▁dispose Context ▁) ▁; ▁assertEquals ▁( ▁16 ▁, ▁getOrder ▁( ▁INTERNAL ▁) ▁. ▁dispose Thread ▁) ▁; ▁assertEquals ▁( ▁17 ▁, ▁getOrder ▁( ▁INTERNAL ▁) ▁. ▁dispose Context ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Act ivate During Dispose ▁( ▁) ▁{ ▁Context ▁context ▁= ▁Context ▁. ▁create ▁( ▁) ▁; ▁context ▁. ▁initialize ▁( ▁ACT I VATE _ D UR ING _ DIS PO SE ▁) ▁; ▁assertNotNull ▁( ▁getOrder ▁( ▁ACT I VATE _ D UR ING _ DIS PO SE ▁) ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁getOrder ▁( ▁ACT I VATE _ D UR ING _ DIS PO SE ▁) ▁. ▁createContext ▁) ▁;
▁public ▁class ▁Postgre View ▁extends ▁Postgre View Base ▁{ ▁public ▁Postgre View ▁( ▁Postgre Schema ▁catalog ▁) ▁{ ▁super ▁( ▁catalog ▁) ▁; ▁} ▁public ▁Postgre View ▁( ▁Postgre Schema ▁catalog ▁, ▁ResultSet ▁dbResult ▁) ▁{ ▁super ▁( ▁catalog ▁, ▁dbResult ▁) ▁; ▁} ▁@ ▁NotNull ▁@ ▁Property ▁( ▁viewable ▁= ▁true ▁, ▁editable ▁= ▁true ▁, ▁value Transformer ▁= ▁DB ObjectName Case Transformer ▁. ▁class ▁, ▁order ▁= ▁1 ▁) ▁@ ▁Override ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁super ▁. ▁getName ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is View ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁? ▁extends ▁DBS TableIndex ▁> ▁getIndex es ▁( ▁DBR ProgressMonitor ▁monitor ▁) ▁throws ▁DBException ▁{ ▁return ▁null ▁; ▁} ▁public ▁String ▁getView Type ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁}
▁return ▁hashCode ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁@ ▁Nullable ▁Object ▁obj ▁) ▁{ ▁if ▁( ▁this ▁== ▁obj ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁obj ▁== ▁null ▁|| ▁getClass ▁( ▁) ▁!= ▁obj ▁. ▁getClass ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁Event Message ▁other ▁= ▁( ▁Event Message ▁) ▁obj ▁; ▁return ▁duration Ms ▁== ▁other ▁. ▁duration Ms ▁&& ▁id ▁== ▁other ▁. ▁id ▁&& ▁Util ▁. ▁are Equal ▁( ▁scheme Id Uri ▁, ▁other ▁. ▁scheme Id Uri ▁) ▁&& ▁Util ▁. ▁are Equal ▁( ▁value ▁, ▁other ▁. ▁value ▁) ▁&& ▁Arrays ▁. ▁equals ▁( ▁message Data ▁, ▁other ▁. ▁message Data ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁scheme Id Uri ▁+ ▁STR ▁+ ▁id ▁+ ▁STR ▁+ ▁duration Ms ▁+ ▁STR ▁+ ▁value ▁; ▁} ▁@ ▁Override ▁public ▁int ▁describe Contents ▁( ▁) ▁{ ▁return ▁0 ▁; ▁} ▁@ ▁Override ▁public ▁void ▁writeToParcel ▁( ▁Parcel ▁dest ▁, ▁int ▁flags ▁) ▁{ ▁dest ▁. ▁writeString ▁( ▁scheme Id Uri ▁) ▁; ▁dest ▁. ▁writeString ▁( ▁value ▁) ▁; ▁dest ▁. ▁writeLong ▁( ▁duration Ms ▁) ▁; ▁dest ▁. ▁writeLong ▁( ▁id ▁) ▁; ▁dest ▁. ▁write ByteArray ▁( ▁message Data ▁) ▁; ▁} ▁public ▁static ▁final ▁Parcelable ▁. ▁Creator ▁< ▁Event Message ▁> ▁CREATOR ▁= ▁new ▁Parcelable ▁. ▁Creator ▁< ▁Event Message ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Event Message ▁createFrom Parcel ▁( ▁Parcel ▁in ▁) ▁{ ▁return ▁new ▁Event Message ▁( ▁in ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Event Message ▁[ ▁] ▁newArray ▁( ▁int ▁size ▁) ▁{ ▁return ▁new ▁Event Message ▁[ ▁size ▁] ▁; ▁} ▁} ▁; ▁}
▁public ▁final ▁class ▁Class _ is Primitive 01 ▁extends ▁JTTTest ▁{ ▁public ▁static ▁boolean ▁test ▁( ▁int ▁i ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁return ▁int ▁. ▁class ▁. ▁isPrimitive ▁( ▁) ▁; ▁} ▁if ▁( ▁i ▁== ▁1 ▁) ▁{ ▁return ▁int ▁[ ▁] ▁. ▁class ▁. ▁isPrimitive ▁( ▁) ▁; ▁} ▁if ▁( ▁i ▁== ▁2 ▁) ▁{ ▁return ▁Object ▁. ▁class ▁. ▁isPrimitive ▁( ▁) ▁; ▁} ▁if ▁( ▁i ▁== ▁3 ▁) ▁{ ▁return ▁Object ▁[ ▁] ▁. ▁class ▁. ▁isPrimitive ▁( ▁) ▁; ▁} ▁if ▁( ▁i ▁== ▁4 ▁) ▁{ ▁return ▁Class _ is Primitive 01 ▁. ▁class ▁. ▁isPrimitive ▁( ▁) ▁; ▁} ▁if ▁( ▁i ▁== ▁5 ▁) ▁{ ▁return ▁Clone able ▁. ▁class ▁. ▁isPrimitive ▁( ▁) ▁; ▁} ▁if ▁( ▁i ▁== ▁6 ▁) ▁{ ▁return ▁Runnable ▁. ▁class ▁. ▁isPrimitive ▁( ▁) ▁; ▁} ▁if ▁( ▁i ▁== ▁7 ▁) ▁{ ▁return ▁void ▁. ▁class ▁. ▁isPrimitive ▁( ▁) ▁; ▁} ▁return ▁false ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 0 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁0 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 1 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁1 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 2 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁2 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 3 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁3 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 4 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁4 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 5 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁5 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 6 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁6 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 7 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁7 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 8 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁8 ▁) ▁; ▁} ▁}
▁@ ▁RunWith ▁( ▁Parameterized ▁. ▁class ▁) ▁public ▁class ▁Job Submit Handler Test ▁extends ▁TestLogger ▁{ ▁@ ▁Parameterized ▁. ▁Parameters ▁( ▁name ▁= ▁STR ▁) ▁public ▁static ▁Iterable ▁< ▁Tuple 2 ▁< ▁Boolean ▁, ▁String ▁> ▁> ▁data ▁( ▁) ▁{ ▁ArrayList ▁< ▁Tuple 2 ▁< ▁Boolean ▁, ▁String ▁> ▁> ▁parameters ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁3 ▁) ▁; ▁parameters ▁. ▁add ▁( ▁Tuple 2 ▁. ▁of ▁( ▁false ▁, ▁STR ▁) ▁) ▁; ▁for ▁( ▁String ▁ssl Provider ▁: ▁SSL UtilsTest ▁. ▁AV AILABLE _ SSL _ PROVIDER S ▁) ▁{ ▁parameters ▁. ▁add ▁( ▁Tuple 2 ▁. ▁of ▁( ▁true ▁, ▁ssl Provider ▁) ▁) ▁; ▁} ▁return ▁parameters ▁; ▁} ▁@ ▁ClassRule ▁public ▁static ▁final ▁TemporaryFolder ▁TEMP OR ARY _ FOLDER ▁= ▁new ▁TemporaryFolder ▁( ▁) ▁; ▁private ▁final ▁Configuration ▁configuration ▁; ▁private ▁Blob Server ▁blob Server ▁; ▁public ▁Job Submit Handler Test ▁( ▁Tuple 2 ▁< ▁Boolean ▁, ▁String ▁> ▁with Ssl ▁) ▁{ ▁this ▁. ▁configuration ▁= ▁with Ssl ▁. ▁f 0 ▁? ▁SSL UtilsTest ▁. ▁create Internal Ssl Config WithKey And Trust Store s ▁( ▁with Ssl ▁. ▁f 1 ▁) ▁: ▁new ▁Configuration ▁( ▁) ▁; ▁} ▁@ ▁Before ▁public ▁void ▁setup ▁( ▁) ▁throws ▁IOException ▁{ ▁Configuration ▁config ▁= ▁new ▁Configuration ▁( ▁configuration ▁) ▁; ▁config ▁. ▁setString ▁( ▁Blob Server Options ▁. ▁ST ORAGE _ DIRECTORY ▁, ▁TEMP OR ARY _ FOLDER ▁. ▁newFolder ▁( ▁) ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁; ▁blob Server ▁= ▁new ▁Blob Server ▁( ▁config ▁, ▁new ▁Void BlobStore ▁( ▁) ▁) ▁; ▁blob Server ▁. ▁start ▁( ▁) ▁; ▁} ▁@ ▁After ▁public ▁void ▁teardown ▁( ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁blob Server ▁!= ▁null ▁) ▁{ ▁blob Server ▁. ▁close ▁( ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Serialization Failure Handling ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁Path ▁jobGraph File ▁= ▁TEMP OR ARY _ FOLDER ▁. ▁newFile ▁( ▁) ▁. ▁toPath ▁( ▁) ▁; ▁Dispatcher Gateway ▁mock Gateway ▁= ▁new ▁Testing Dispatcher Gateway ▁. ▁Builder ▁( ▁) ▁. ▁set Submit Function ▁( ▁jobGraph ▁-> ▁Completable Future ▁. ▁completedFuture ▁( ▁Acknowledge ▁. ▁get ▁( ▁) ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁Job Submit Handler ▁handler ▁= ▁new ▁Job Submit Handler ▁( ▁( ▁) ▁-> ▁Completable Future ▁. ▁completedFuture ▁( ▁mock Gateway ▁) ▁, ▁Rpc Utils ▁. ▁IN F _ TIMEOUT ▁, ▁Collections ▁. ▁emptyMap ▁( ▁) ▁, ▁Testing Utils ▁. ▁default Executor ▁( ▁) ▁, ▁configuration ▁) ▁; ▁Job Submit RequestBody ▁request ▁= ▁new ▁Job Submit RequestBody ▁( ▁jobGraph File ▁. ▁toString ▁( ▁) ▁, ▁Collections ▁. ▁emptyList ▁( ▁) ▁, ▁Collections ▁. ▁emptyList ▁( ▁) ▁) ▁; ▁try ▁{ ▁handler ▁. ▁handleRequest ▁( ▁new ▁HandlerRequest ▁< ▁> ▁( ▁request ▁, ▁Empty Message Parameters ▁. ▁getInstance ▁( ▁) ▁) ▁, ▁mock Gateway ▁) ▁; ▁Assert ▁. ▁fail ▁( ▁) ▁; ▁} ▁catch ▁( ▁Rest HandlerException ▁r he ▁) ▁{ ▁Assert ▁. ▁assertEquals ▁( ▁HttpResponse Status ▁. ▁BAD _ REQUEST ▁, ▁r he ▁. ▁get HttpResponse Status ▁( ▁) ▁) ▁; ▁} ▁}
▁@ ▁Interface Audience ▁. ▁Public ▁@ ▁Interface Stability ▁. ▁Unstable ▁public ▁class ▁Application Entity ▁extends ▁Hierarch ical Timeline Entity ▁{ ▁public ▁static ▁final ▁String ▁QUEUE _ INFO _ KEY ▁= ▁TimelineEntity ▁. ▁SYSTEM _ INFO _ KEY _ PREFIX ▁+ ▁STR ▁; ▁public ▁Application Entity ▁( ▁) ▁{ ▁super ▁( ▁TimelineEntity Type ▁. ▁YARN _ APPLICATION ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁public ▁Application Entity ▁( ▁TimelineEntity ▁entity ▁) ▁{ ▁super ▁( ▁entity ▁) ▁; ▁if ▁( ▁! ▁entity ▁. ▁getType ▁( ▁) ▁. ▁equals ▁( ▁TimelineEntity Type ▁. ▁YARN _ APPLICATION ▁. ▁toString ▁( ▁) ▁) ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁getId ▁( ▁) ▁) ▁; ▁} ▁} ▁public ▁String ▁getQueue ▁( ▁) ▁{ ▁return ▁getInfo ▁( ▁) ▁. ▁get ▁( ▁QUEUE _ INFO _ KEY ▁) ▁. ▁toString ▁( ▁) ▁; ▁} ▁public ▁void ▁setQueue ▁( ▁String ▁queue ▁) ▁{ ▁add Info ▁( ▁QUEUE _ INFO _ KEY ▁, ▁queue ▁) ▁; ▁} ▁public ▁static ▁boolean ▁is Application Entity ▁( ▁TimelineEntity ▁te ▁) ▁{ ▁return ▁( ▁te ▁== ▁null ▁? ▁false ▁: ▁te ▁. ▁getType ▁( ▁) ▁. ▁equals ▁( ▁TimelineEntity Type ▁. ▁YARN _ APPLICATION ▁. ▁toString ▁( ▁) ▁) ▁) ▁; ▁} ▁public ▁static ▁Timeline Event ▁getApplication Event ▁( ▁TimelineEntity ▁te ▁, ▁String ▁event Id ▁) ▁{ ▁if ▁( ▁is Application Entity ▁( ▁te ▁) ▁) ▁{ ▁for ▁( ▁Timeline Event ▁event ▁: ▁te ▁. ▁get Events ▁( ▁) ▁) ▁{ ▁if ▁( ▁event ▁. ▁getId ▁( ▁) ▁. ▁equals ▁( ▁event Id ▁) ▁) ▁{ ▁return ▁event ▁; ▁} ▁} ▁} ▁return ▁null ▁; ▁} ▁}
▁blob ▁. ▁upload Text ▁( ▁STR ▁) ▁; ▁written ▁++ ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁LOG ▁. ▁error ▁( ▁STR ▁, ▁blob Name ▁, ▁e ▁) ▁; ▁break ▁; ▁} ▁} ▁LOG ▁. ▁info ▁( ▁STR ▁, ▁written ▁) ▁; ▁return ▁written ▁; ▁} ▁} ▁) ▁; ▁} ▁List ▁< ▁Future ▁< ▁Integer ▁> ▁> ▁futures ▁= ▁executorService ▁. ▁invoke All ▁( ▁tasks ▁, ▁getTest TimeoutMillis ▁( ▁) ▁, ▁TimeUnit ▁. ▁MILLISECONDS ▁) ▁; ▁long ▁elapsed Ms ▁= ▁timer ▁. ▁elapsed TimeMs ▁( ▁) ▁; ▁LOG ▁. ▁info ▁( ▁STR ▁, ▁elapsed Ms ▁) ▁; ▁for ▁( ▁Future ▁< ▁Integer ▁> ▁future ▁: ▁futures ▁) ▁{ ▁assertTrue ▁( ▁STR ▁, ▁future ▁. ▁isDone ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁files Per Thread ▁, ▁future ▁. ▁get ▁( ▁) ▁. ▁intValue ▁( ▁) ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test _0 200 _ List Status Per formance ▁( ▁) ▁throws ▁Exception ▁{ ▁Contract TestUtils ▁. ▁N ano Timer ▁timer ▁= ▁new ▁Contract TestUtils ▁. ▁N ano Timer ▁( ▁) ▁; ▁FileStatus ▁[ ▁] ▁file List ▁= ▁fs ▁. ▁listStatus ▁( ▁TEST _ DIR _ PATH ▁) ▁; ▁long ▁elapsed Ms ▁= ▁timer ▁. ▁elapsed TimeMs ▁( ▁) ▁; ▁LOG ▁. ▁info ▁( ▁String ▁. ▁format ▁( ▁STR ▁, ▁file List ▁. ▁length ▁, ▁elapsed Ms ▁) ▁) ▁; ▁Map ▁< ▁Path ▁, ▁FileStatus ▁> ▁found In List ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁expected File Count ▁) ▁; ▁for ▁( ▁FileStatus ▁file Status ▁: ▁file List ▁) ▁{ ▁found In List ▁. ▁put ▁( ▁file Status ▁. ▁getPath ▁( ▁) ▁, ▁file Status ▁) ▁; ▁LOG ▁. ▁info ▁( ▁STR ▁, ▁file Status ▁. ▁getPath ▁( ▁) ▁, ▁file Status ▁. ▁isDirectory ▁( ▁) ▁? ▁STR ▁: ▁STR ▁) ▁; ▁} ▁assertEquals ▁( ▁STR ▁, ▁expected File Count ▁, ▁file List ▁. ▁length ▁) ▁; ▁Contract TestUtils ▁. ▁N ano Timer ▁initial Status Call Timer ▁= ▁new ▁Contract TestUtils ▁. ▁N ano Timer ▁( ▁) ▁; ▁Remote Iterator ▁< ▁Located FileStatus ▁> ▁listing ▁= ▁fs ▁. ▁listFiles ▁( ▁TEST _ DIR _ PATH ▁, ▁true ▁) ▁; ▁long ▁initial List Time ▁= ▁initial Status Call Timer ▁. ▁elapsed TimeMs ▁( ▁) ▁; ▁timer ▁= ▁new ▁Contract TestUtils ▁. ▁N ano Timer ▁( ▁) ▁; ▁while ▁( ▁listing ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁FileStatus ▁file Status ▁= ▁listing ▁. ▁next ▁( ▁) ▁; ▁Path ▁path ▁= ▁file Status ▁. ▁getPath ▁( ▁) ▁; ▁FileStatus ▁removed ▁= ▁found In List ▁. ▁remove ▁( ▁path ▁) ▁; ▁assertNotNull ▁( ▁STR ▁+ ▁path ▁+ ▁STR ▁, ▁removed ▁) ▁; ▁} ▁elapsed Ms ▁= ▁timer ▁. ▁elapsed TimeMs ▁( ▁) ▁; ▁LOG ▁. ▁info ▁( ▁STR ▁+ ▁STR ▁, ▁initial List Time ▁, ▁elapsed Ms ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁0 ▁, ▁found In List ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test _0 3 00_ Bulk Delete Per formance ▁( ▁) ▁throws ▁Exception ▁{ ▁Contract TestUtils ▁. ▁N ano Timer ▁timer ▁= ▁new ▁Contract TestUtils ▁. ▁N ano Timer ▁( ▁) ▁;
▁Instruction Table Data Object ▁cell 30 ▁= ▁( ▁Instruction Table Data Object ▁) ▁preview Table ▁. ▁getModel ▁( ▁) ▁. ▁getValue At ▁( ▁3 ▁, ▁0 ▁) ▁; ▁assertEquals ▁( ▁cell 30 ▁. ▁getData ▁( ▁) ▁. ▁trim ▁( ▁) ▁, ▁STR ▁) ▁; ▁Instruction Table Data Object ▁cell 40 ▁= ▁( ▁Instruction Table Data Object ▁) ▁preview Table ▁. ▁getModel ▁( ▁) ▁. ▁getValue At ▁( ▁4 ▁, ▁0 ▁) ▁; ▁assertEquals ▁( ▁cell 40 ▁. ▁getData ▁( ▁) ▁. ▁trim ▁( ▁) ▁, ▁STR ▁) ▁; ▁Instruction Table Data Object ▁cell 50 ▁= ▁( ▁Instruction Table Data Object ▁) ▁preview Table ▁. ▁getModel ▁( ▁) ▁. ▁getValue At ▁( ▁5 ▁, ▁0 ▁) ▁; ▁assertEquals ▁( ▁cell 50 ▁. ▁getData ▁( ▁) ▁. ▁trim ▁( ▁) ▁, ▁STR ▁) ▁; ▁Instruction Table Data Object ▁cell 60 ▁= ▁( ▁Instruction Table Data Object ▁) ▁preview Table ▁. ▁getModel ▁( ▁) ▁. ▁getValue At ▁( ▁6 ▁, ▁0 ▁) ▁; ▁assertEquals ▁( ▁cell 60 ▁. ▁getData ▁( ▁) ▁. ▁trim ▁( ▁) ▁, ▁STR ▁) ▁; ▁Instruction Table Data Object ▁cell 70 ▁= ▁( ▁Instruction Table Data Object ▁) ▁preview Table ▁. ▁getModel ▁( ▁) ▁. ▁getValue At ▁( ▁7 ▁, ▁0 ▁) ▁; ▁assertEquals ▁( ▁cell 70 ▁. ▁getData ▁( ▁) ▁. ▁trim ▁( ▁) ▁, ▁STR ▁) ▁; ▁press Button ByName ▁( ▁component ▁, ▁STR ▁) ▁; ▁dialog ▁. ▁waitFor Current Task ▁( ▁) ▁; ▁cell 00 ▁= ▁( ▁Instruction Table Data Object ▁) ▁preview Table ▁. ▁getModel ▁( ▁) ▁. ▁getValue At ▁( ▁0 ▁, ▁0 ▁) ▁; ▁assertEquals ▁( ▁cell 00 ▁. ▁getData ▁( ▁) ▁. ▁trim ▁( ▁) ▁, ▁STR ▁) ▁; ▁cell 10 ▁= ▁( ▁Instruction Table Data Object ▁) ▁preview Table ▁. ▁getModel ▁( ▁) ▁. ▁getValue At ▁( ▁1 ▁, ▁0 ▁) ▁; ▁assertEquals ▁( ▁cell 10 ▁. ▁getData ▁( ▁) ▁. ▁trim ▁( ▁) ▁, ▁STR ▁) ▁; ▁cell 20 ▁= ▁( ▁Instruction Table Data Object ▁) ▁preview Table ▁. ▁getModel ▁( ▁) ▁. ▁getValue At ▁( ▁2 ▁, ▁0 ▁) ▁; ▁assertEquals ▁( ▁cell 20 ▁. ▁getData ▁( ▁) ▁. ▁trim ▁( ▁) ▁, ▁STR ▁) ▁; ▁cell 30 ▁= ▁( ▁Instruction Table Data Object ▁) ▁preview Table ▁. ▁getModel ▁( ▁) ▁. ▁getValue At ▁( ▁3 ▁, ▁0 ▁) ▁; ▁assertEquals ▁( ▁cell 30 ▁. ▁getData ▁( ▁) ▁. ▁trim ▁( ▁) ▁, ▁STR ▁) ▁; ▁cell 40 ▁= ▁( ▁Instruction Table Data Object ▁) ▁preview Table ▁. ▁getModel ▁( ▁) ▁. ▁getValue At ▁( ▁4 ▁, ▁0 ▁) ▁; ▁assertEquals ▁( ▁cell 40 ▁. ▁getData ▁( ▁) ▁. ▁trim ▁( ▁) ▁, ▁STR ▁) ▁; ▁cell 50 ▁= ▁( ▁Instruction Table Data Object ▁) ▁preview Table ▁. ▁getModel ▁( ▁) ▁. ▁getValue At ▁( ▁5 ▁, ▁0 ▁) ▁; ▁assertEquals ▁( ▁cell 50 ▁. ▁getData ▁( ▁) ▁. ▁trim ▁( ▁) ▁, ▁STR ▁) ▁; ▁cell 60 ▁= ▁( ▁Instruction Table Data Object ▁) ▁preview Table ▁. ▁getModel ▁( ▁) ▁. ▁getValue At ▁( ▁6 ▁, ▁0 ▁) ▁;
▁Path ▁file ▁= ▁new ▁Path ▁( ▁STR ▁) ▁; ▁Distributed FileSystem ▁dfs ▁= ▁cluster ▁. ▁getFileSystem ▁( ▁) ▁; ▁FSData OutputStream ▁out ▁= ▁dfs ▁. ▁create ▁( ▁file ▁) ▁; ▁final ▁int ▁FILE _ SI Z E ▁= ▁128 ▁ * ▁1024 ▁; ▁int ▁count ▁= ▁0 ▁; ▁while ▁( ▁count ▁< ▁FILE _ SI Z E ▁) ▁{ ▁out ▁. ▁writeBytes ▁( ▁STR ▁) ▁; ▁count ▁+= ▁8 ▁; ▁} ▁out ▁. ▁hsync ▁( ▁) ▁; ▁( ▁( ▁DFS OutputStream ▁) ▁out ▁. ▁getWrapped Stream ▁( ▁) ▁) ▁. ▁abort ▁( ▁) ▁; ▁Located Blocks ▁locations ▁= ▁cluster ▁. ▁getNameNode Rpc ▁( ▁) ▁. ▁getBlock Locations ▁( ▁file ▁. ▁toString ▁( ▁) ▁, ▁0 ▁, ▁count ▁) ▁; ▁ExtendedBlock ▁block ▁= ▁locations ▁. ▁get ▁( ▁0 ▁) ▁. ▁getBlock ▁( ▁) ▁; ▁cluster ▁. ▁getData Nodes ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁getFS Dataset ▁( ▁) ▁. ▁finalize Block ▁( ▁block ▁, ▁false ▁) ▁; ▁cluster ▁. ▁delete Meta ▁( ▁0 ▁, ▁block ▁) ▁; ▁Distributed FileSystem ▁new D fs ▁= ▁( ▁Distributed FileSystem ▁) ▁FileSystem ▁. ▁newInstance ▁( ▁cluster ▁. ▁get Configuration ▁( ▁0 ▁) ▁) ▁; ▁count ▁= ▁0 ▁; ▁while ▁( ▁count ▁++ ▁< ▁15 ▁&& ▁! ▁new D fs ▁. ▁recover Lease ▁( ▁file ▁) ▁) ▁{ ▁Thread ▁. ▁sleep ▁( ▁1000 ▁) ▁; ▁} ▁assertTrue ▁( ▁STR ▁, ▁new D fs ▁. ▁recover Lease ▁( ▁file ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Lease Recovery And Append ▁( ▁) ▁throws ▁Exception ▁{ ▁test Lease Recovery And Append ▁( ▁new ▁Configuration ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Lease Recovery And Append WithView DFS ▁( ▁) ▁throws ▁Exception ▁{ ▁Configuration ▁conf ▁= ▁new ▁Configuration ▁( ▁) ▁; ▁conf ▁. ▁set ▁( ▁STR ▁, ▁View Distributed FileSystem ▁. ▁class ▁. ▁getName ▁( ▁) ▁) ▁; ▁test Lease Recovery And Append ▁( ▁conf ▁) ▁; ▁} ▁private ▁void ▁test Lease Recovery And Append ▁( ▁Configuration ▁conf ▁) ▁throws ▁Exception ▁{ ▁try ▁{ ▁cluster ▁= ▁new ▁MiniDFSCluster ▁. ▁Builder ▁( ▁conf ▁) ▁. ▁numDataNodes ▁( ▁1 ▁) ▁. ▁build ▁( ▁) ▁; ▁Path ▁file ▁= ▁new ▁Path ▁( ▁STR ▁) ▁; ▁Distributed FileSystem ▁dfs ▁= ▁cluster ▁. ▁getFileSystem ▁( ▁) ▁; ▁FSData OutputStream ▁out ▁= ▁dfs ▁. ▁create ▁( ▁file ▁) ▁; ▁out ▁. ▁h flush ▁( ▁) ▁; ▁out ▁. ▁hsync ▁( ▁) ▁; ▁( ▁( ▁DFS OutputStream ▁) ▁out ▁. ▁getWrapped Stream ▁( ▁) ▁) ▁. ▁abort ▁( ▁) ▁; ▁Distributed FileSystem ▁new dfs ▁= ▁( ▁Distributed FileSystem ▁) ▁FileSystem ▁. ▁newInstance ▁( ▁cluster ▁. ▁get Configuration ▁( ▁0 ▁) ▁) ▁; ▁try ▁{ ▁new dfs ▁. ▁append ▁( ▁file ▁) ▁; ▁fail ▁( ▁STR ▁) ▁; ▁} ▁catch ▁( ▁RemoteException ▁e ▁) ▁{ ▁assertTrue ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁. ▁contains ▁( ▁STR ▁) ▁) ▁; ▁} ▁boolean ▁recover Lease ▁= ▁new dfs ▁. ▁recover Lease ▁( ▁file ▁) ▁; ▁assertTrue ▁( ▁recover Lease ▁) ▁; ▁FSData OutputStream ▁append ▁= ▁new dfs ▁. ▁append ▁( ▁file ▁) ▁;
▁public ▁class ▁MySql AlterTable Test 47 ▁extends ▁TestCase ▁{ ▁public ▁void ▁test _0 ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁List ▁< ▁SQLStatement ▁> ▁stmtList ▁= ▁SQLUtils ▁. ▁parseStatements ▁( ▁sql ▁, ▁JdbcConstants ▁. ▁MYSQL ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁stmtList ▁. ▁size ▁( ▁) ▁) ▁; ▁SQLStatement ▁stmt ▁= ▁stmtList ▁. ▁get ▁( ▁0 ▁) ▁; ▁String ▁output ▁= ▁stmt ▁. ▁toString ▁( ▁) ▁; ▁assertEquals ▁( ▁STR ▁+ ▁STR ▁, ▁output ▁) ▁; ▁} ▁}
▁@ ▁GwtCompatible ▁@ ▁Ignore ▁public ▁class ▁ConcurrentMap Replace Tester ▁< ▁K ▁, ▁V ▁> ▁extends ▁AbstractMap Tester ▁< ▁K ▁, ▁V ▁> ▁{ ▁@ ▁Override ▁protected ▁ConcurrentMap ▁< ▁K ▁, ▁V ▁> ▁getMap ▁( ▁) ▁{ ▁return ▁( ▁ConcurrentMap ▁< ▁K ▁, ▁V ▁> ▁) ▁super ▁. ▁getMap ▁( ▁) ▁; ▁} ▁@ ▁MapFeature ▁. ▁Require ▁( ▁SUPPORTS _ PUT ▁) ▁@ ▁CollectionSize ▁. ▁Require ▁( ▁absent ▁= ▁ Z ERO ▁) ▁public ▁void ▁test Replace _ supported Present ▁( ▁) ▁{ ▁assertEquals ▁( ▁v 0 ▁( ▁) ▁, ▁getMap ▁( ▁) ▁. ▁replace ▁( ▁k 0 ▁( ▁) ▁, ▁v 3 ▁( ▁) ▁) ▁) ▁; ▁expect Replacement ▁( ▁entry ▁( ▁k 0 ▁( ▁) ▁, ▁v 3 ▁( ▁) ▁) ▁) ▁; ▁} ▁@ ▁MapFeature ▁. ▁Require ▁( ▁SUPPORTS _ PUT ▁) ▁@ ▁CollectionSize ▁. ▁Require ▁( ▁absent ▁= ▁ Z ERO ▁) ▁public ▁void ▁test Replace _ supported Present No Change ▁( ▁) ▁{ ▁assertEquals ▁( ▁v 0 ▁( ▁) ▁, ▁getMap ▁( ▁) ▁. ▁replace ▁( ▁k 0 ▁( ▁) ▁, ▁v 0 ▁( ▁) ▁) ▁) ▁; ▁expectUnchanged ▁( ▁) ▁; ▁} ▁@ ▁MapFeature ▁. ▁Require ▁( ▁SUPPORTS _ PUT ▁) ▁public ▁void ▁test Replace _ supported Absent ▁( ▁) ▁{ ▁assertNull ▁( ▁getMap ▁( ▁) ▁. ▁replace ▁( ▁k 3 ▁( ▁) ▁, ▁v 3 ▁( ▁) ▁) ▁) ▁; ▁expectUnchanged ▁( ▁) ▁; ▁} ▁@ ▁MapFeature ▁. ▁Require ▁( ▁value ▁= ▁SUPPORTS _ PUT ▁, ▁absent ▁= ▁ALLOWS _ NULL _ VALUES ▁) ▁@ ▁CollectionSize ▁. ▁Require ▁( ▁absent ▁= ▁ Z ERO ▁) ▁public ▁void ▁test Replace _ present NullValue Unsupported ▁( ▁) ▁{ ▁try ▁{ ▁getMap ▁( ▁) ▁. ▁replace ▁( ▁k 0 ▁( ▁) ▁, ▁null ▁) ▁; ▁fail ▁( ▁STR ▁) ▁; ▁} ▁catch ▁( ▁NullPointer Exception ▁expected ▁) ▁{ ▁} ▁expectUnchanged ▁( ▁) ▁; ▁} ▁@ ▁MapFeature ▁. ▁Require ▁( ▁value ▁= ▁SUPPORTS _ PUT ▁, ▁absent ▁= ▁ALLOWS _ NULL _ VALUE _ QUERIES ▁) ▁public ▁void ▁test Replace _ ab sent NullValue Unsupported ▁( ▁) ▁{ ▁try ▁{ ▁getMap ▁( ▁) ▁. ▁replace ▁( ▁k 3 ▁( ▁) ▁, ▁null ▁) ▁; ▁} ▁catch ▁( ▁NullPointer Exception ▁toler ated ▁) ▁{ ▁} ▁expectUnchanged ▁( ▁) ▁; ▁} ▁@ ▁MapFeature ▁. ▁Require ▁( ▁value ▁= ▁SUPPORTS _ PUT ▁, ▁absent ▁= ▁ALLOWS _ NULL _ KEY _ QUERIES ▁) ▁public ▁void ▁test Replace _ ab sent Null Key Unsupported ▁( ▁) ▁{ ▁try ▁{ ▁getMap ▁( ▁) ▁. ▁replace ▁( ▁null ▁, ▁v 3 ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁NullPointer Exception ▁toler ated ▁) ▁{ ▁} ▁expectUnchanged ▁( ▁) ▁; ▁} ▁@ ▁MapFeature ▁. ▁Require ▁( ▁absent ▁= ▁SUPPORTS _ PUT ▁) ▁@ ▁CollectionSize ▁. ▁Require ▁( ▁absent ▁= ▁ Z ERO ▁) ▁public ▁void ▁test Replace _ un supported Present ▁( ▁) ▁{ ▁try ▁{ ▁getMap ▁( ▁) ▁. ▁replace ▁( ▁k 0 ▁( ▁) ▁, ▁v 3 ▁( ▁) ▁) ▁; ▁fail ▁( ▁STR ▁) ▁; ▁} ▁catch ▁( ▁Unsupported Operation Exception ▁expected ▁) ▁{ ▁} ▁expectUnchanged ▁( ▁) ▁; ▁} ▁}
▁val ▁= ▁shell ▁. ▁run ▁( ▁new ▁String ▁[ ▁] ▁{ ▁STR ▁, ▁to E rase ▁. ▁toString ▁( ▁) ▁} ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁0 ▁, ▁val ▁) ▁; ▁checkNot In Tra sh ▁( ▁tra sh Root Fs ▁, ▁tra sh Root ▁, ▁to E rase ▁. ▁toString ▁( ▁) ▁) ▁; ▁checkNot In Tra sh ▁( ▁tra sh Root Fs ▁, ▁tra sh Root ▁, ▁to E rase ▁. ▁toString ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁{ ▁String ▁[ ▁] ▁args ▁= ▁new ▁String ▁[ ▁1 ▁] ▁; ▁args ▁[ ▁0 ▁] ▁= ▁STR ▁; ▁int ▁val ▁= ▁- ▁1 ▁; ▁val ▁= ▁shell ▁. ▁run ▁( ▁args ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁0 ▁, ▁val ▁) ▁; ▁} ▁checkNot In Tra sh ▁( ▁tra sh Root Fs ▁, ▁tra sh Root ▁, ▁new ▁Path ▁( ▁base ▁, ▁STR ▁) ▁. ▁toString ▁( ▁) ▁) ▁; ▁mkdir ▁( ▁fs ▁, ▁my Path ▁) ▁; ▁writeFile ▁( ▁fs ▁, ▁my File ▁, ▁10 ▁) ▁; ▁{ ▁String ▁[ ▁] ▁args ▁= ▁new ▁String ▁[ ▁2 ▁] ▁; ▁args ▁[ ▁0 ▁] ▁= ▁STR ▁; ▁args ▁[ ▁1 ▁] ▁= ▁my File ▁. ▁toString ▁( ▁) ▁; ▁int ▁val ▁= ▁- ▁1 ▁; ▁val ▁= ▁shell ▁. ▁run ▁( ▁args ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁0 ▁, ▁val ▁) ▁; ▁check Tra sh ▁( ▁tra sh Root Fs ▁, ▁tra sh Root ▁, ▁my File ▁) ▁; ▁args ▁= ▁new ▁String ▁[ ▁2 ▁] ▁; ▁args ▁[ ▁0 ▁] ▁= ▁STR ▁; ▁args ▁[ ▁1 ▁] ▁= ▁my Path ▁. ▁toString ▁( ▁) ▁; ▁val ▁= ▁- ▁1 ▁; ▁val ▁= ▁shell ▁. ▁run ▁( ▁args ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁0 ▁, ▁val ▁) ▁; ▁check Tra sh ▁( ▁tra sh Root Fs ▁, ▁tra sh Root ▁, ▁my Path ▁) ▁; ▁} ▁{ ▁String ▁[ ▁] ▁args ▁= ▁new ▁String ▁[ ▁2 ▁] ▁; ▁args ▁[ ▁0 ▁] ▁= ▁STR ▁; ▁args ▁[ ▁1 ▁] ▁= ▁tra sh Root ▁. ▁getParent ▁( ▁) ▁. ▁getParent ▁( ▁) ▁. ▁toString ▁( ▁) ▁; ▁int ▁val ▁= ▁- ▁1 ▁; ▁val ▁= ▁shell ▁. ▁run ▁( ▁args ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁1 ▁, ▁val ▁) ▁; ▁assertTrue ▁( ▁tra sh Root Fs ▁. ▁exists ▁( ▁tra sh Root ▁) ▁) ▁; ▁} ▁mkdir ▁( ▁fs ▁, ▁my Path ▁) ▁; ▁writeFile ▁( ▁fs ▁, ▁my File ▁, ▁10 ▁) ▁; ▁{ ▁String ▁[ ▁] ▁args ▁= ▁new ▁String ▁[ ▁3 ▁] ▁; ▁args ▁[ ▁0 ▁] ▁= ▁STR ▁; ▁args ▁[ ▁1 ▁] ▁= ▁STR ▁; ▁args ▁[ ▁2 ▁] ▁= ▁my File ▁. ▁toString ▁( ▁) ▁; ▁int ▁val ▁= ▁- ▁1 ▁; ▁assertEquals ▁( ▁STR ▁, ▁0 ▁, ▁shell ▁. ▁run ▁( ▁new ▁String ▁[ ▁] ▁{ ▁STR ▁} ▁) ▁) ▁; ▁val ▁= ▁shell ▁. ▁run ▁( ▁args ▁) ▁;
▁suite ▁. ▁addTest ▁( ▁suite For Bytes ▁( ▁sl ic edLong MaxValue ▁, ▁bytes ▁, ▁name ▁+ ▁STR ▁, ▁desc ▁, ▁false ▁) ▁) ▁; ▁Byte Source Factory ▁sl ic ed Offset P ast End ▁= ▁Source Sink Factories ▁. ▁as Sl ic ed Byte Source Factory ▁( ▁factory ▁, ▁expected ▁. ▁length ▁+ ▁2 ▁, ▁expected ▁. ▁length ▁+ ▁10 ▁) ▁; ▁suite ▁. ▁addTest ▁( ▁suite For Bytes ▁( ▁sl ic ed Offset P ast End ▁, ▁bytes ▁, ▁name ▁+ ▁STR ▁, ▁desc ▁, ▁false ▁) ▁) ▁; ▁} ▁return ▁suite ▁; ▁} ▁private ▁Byte Source ▁source ▁; ▁public ▁Byte Source Tester ▁( ▁Byte Source Factory ▁factory ▁, ▁byte ▁[ ▁] ▁bytes ▁, ▁String ▁suite Name ▁, ▁String ▁case Desc ▁, ▁Method ▁method ▁) ▁{ ▁super ▁( ▁factory ▁, ▁bytes ▁, ▁suite Name ▁, ▁case Desc ▁, ▁method ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setUp ▁( ▁) ▁throws ▁IOException ▁{ ▁source ▁= ▁factory ▁. ▁create Source ▁( ▁data ▁) ▁; ▁} ▁public ▁void ▁test Open Stream ▁( ▁) ▁throws ▁IOException ▁{ ▁InputStream ▁in ▁= ▁source ▁. ▁openStream ▁( ▁) ▁; ▁try ▁{ ▁byte ▁[ ▁] ▁readBytes ▁= ▁Byte Streams ▁. ▁toByteArray ▁( ▁in ▁) ▁; ▁assert Expected Bytes ▁( ▁readBytes ▁) ▁; ▁} ▁finally ▁{ ▁in ▁. ▁close ▁( ▁) ▁; ▁} ▁} ▁public ▁void ▁test Open Buffered Stream ▁( ▁) ▁throws ▁IOException ▁{ ▁InputStream ▁in ▁= ▁source ▁. ▁open Buffered Stream ▁( ▁) ▁; ▁try ▁{ ▁byte ▁[ ▁] ▁readBytes ▁= ▁Byte Streams ▁. ▁toByteArray ▁( ▁in ▁) ▁; ▁assert Expected Bytes ▁( ▁readBytes ▁) ▁; ▁} ▁finally ▁{ ▁in ▁. ▁close ▁( ▁) ▁; ▁} ▁} ▁public ▁void ▁testRead ▁( ▁) ▁throws ▁IOException ▁{ ▁byte ▁[ ▁] ▁readBytes ▁= ▁source ▁. ▁read ▁( ▁) ▁; ▁assert Expected Bytes ▁( ▁readBytes ▁) ▁; ▁} ▁public ▁void ▁test Copy To _ out put Stream ▁( ▁) ▁throws ▁IOException ▁{ ▁ByteArray OutputStream ▁out ▁= ▁new ▁ByteArray OutputStream ▁( ▁) ▁; ▁source ▁. ▁copyTo ▁( ▁out ▁) ▁; ▁assert Expected Bytes ▁( ▁out ▁. ▁toByteArray ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁test Copy To _ byte Sink ▁( ▁) ▁throws ▁IOException ▁{ ▁final ▁ByteArray OutputStream ▁out ▁= ▁new ▁ByteArray OutputStream ▁( ▁) ▁; ▁source ▁. ▁copyTo ▁( ▁new ▁Byte Sink ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁OutputStream ▁openStream ▁( ▁) ▁throws ▁IOException ▁{ ▁return ▁out ▁; ▁} ▁} ▁) ▁; ▁assert Expected Bytes ▁( ▁out ▁. ▁toByteArray ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁testIs Empty ▁( ▁) ▁throws ▁IOException ▁{ ▁assertEquals ▁( ▁expected ▁. ▁length ▁== ▁0 ▁, ▁source ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁test Size ▁( ▁) ▁throws ▁IOException ▁{ ▁assertEquals ▁( ▁expected ▁. ▁length ▁, ▁source ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁test Size If Known ▁( ▁) ▁throws ▁IOException ▁{ ▁Optional ▁< ▁Long ▁> ▁size If Known ▁= ▁source ▁. ▁size If Known ▁( ▁) ▁; ▁if ▁( ▁size If Known ▁. ▁isPresent ▁( ▁) ▁) ▁{ ▁assertEquals ▁( ▁expected ▁. ▁length ▁, ▁( ▁long ▁) ▁size If Known ▁. ▁get ▁( ▁) ▁) ▁; ▁}
▁FileSystem ▁local ▁= ▁FileSystem ▁. ▁getLocal ▁( ▁conf ▁) ▁; ▁final ▁Path ▁token File ▁= ▁new ▁Path ▁( ▁local ▁. ▁getWork ingDirectory ▁( ▁) ▁, ▁remaining ▁[ ▁0 ▁] ▁) ▁; ▁UserGroup Information ▁. ▁getCurrentUser ▁( ▁) ▁. ▁do As ▁( ▁new ▁Privileged Exception Action ▁< ▁Object ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Object ▁run ▁( ▁) ▁throws ▁Exception ▁{ ▁if ▁( ▁print ▁) ▁{ ▁print Tokens ▁( ▁conf ▁, ▁token File ▁, ▁verbose ▁) ▁; ▁} ▁else ▁if ▁( ▁cancel ▁) ▁{ ▁cancel Tokens ▁( ▁conf ▁, ▁token File ▁) ▁; ▁} ▁else ▁if ▁( ▁renew ▁) ▁{ ▁renew Tokens ▁( ▁conf ▁, ▁token File ▁) ▁; ▁} ▁else ▁{ ▁FileSystem ▁fs ▁= ▁getFileSystem ▁( ▁conf ▁, ▁web Url ▁) ▁; ▁save DelegationToken ▁( ▁conf ▁, ▁fs ▁, ▁renew er ▁, ▁token File ▁) ▁; ▁} ▁return ▁null ▁; ▁} ▁} ▁) ▁; ▁} ▁private ▁static ▁FileSystem ▁getFileSystem ▁( ▁Configuration ▁conf ▁, ▁String ▁url ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁url ▁== ▁null ▁) ▁{ ▁return ▁FileSystem ▁. ▁get ▁( ▁conf ▁) ▁; ▁} ▁URI ▁fs Uri ▁= ▁URI ▁. ▁create ▁( ▁url ▁. ▁replace First ▁( ▁STR ▁, ▁Web Hdfs Constants ▁. ▁WEB HDFS _ SCHEME ▁+ ▁STR ▁) ▁. ▁replace First ▁( ▁STR ▁, ▁Web Hdfs Constants ▁. ▁SW EB HDFS _ SCHEME ▁+ ▁STR ▁) ▁) ▁; ▁return ▁FileSystem ▁. ▁get ▁( ▁fs Uri ▁, ▁conf ▁) ▁; ▁} ▁@ ▁Visible ForTesting ▁static ▁void ▁cancel Tokens ▁( ▁final ▁Configuration ▁conf ▁, ▁final ▁Path ▁token File ▁) ▁throws ▁IOException ▁, ▁Interrupted Exception ▁{ ▁for ▁( ▁Token ▁< ▁? ▁> ▁token ▁: ▁read Tokens ▁( ▁token File ▁, ▁conf ▁) ▁) ▁{ ▁if ▁( ▁token ▁. ▁is Managed ▁( ▁) ▁) ▁{ ▁token ▁. ▁cancel ▁( ▁conf ▁) ▁; ▁if ▁( ▁LOG ▁. ▁isDebugEnabled ▁( ▁) ▁) ▁{ ▁LOG ▁. ▁debug ▁( ▁STR ▁+ ▁token ▁. ▁getService ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁} ▁@ ▁Visible ForTesting ▁static ▁void ▁renew Tokens ▁( ▁final ▁Configuration ▁conf ▁, ▁final ▁Path ▁token File ▁) ▁throws ▁IOException ▁, ▁Interrupted Exception ▁{ ▁for ▁( ▁Token ▁< ▁? ▁> ▁token ▁: ▁read Tokens ▁( ▁token File ▁, ▁conf ▁) ▁) ▁{ ▁if ▁( ▁token ▁. ▁is Managed ▁( ▁) ▁) ▁{ ▁long ▁result ▁= ▁token ▁. ▁renew ▁( ▁conf ▁) ▁; ▁if ▁( ▁LOG ▁. ▁isDebugEnabled ▁( ▁) ▁) ▁{ ▁LOG ▁. ▁debug ▁( ▁STR ▁+ ▁token ▁. ▁getService ▁( ▁) ▁+ ▁STR ▁+ ▁new ▁Date ▁( ▁result ▁) ▁) ▁; ▁} ▁} ▁} ▁} ▁@ ▁Visible ForTesting ▁static ▁void ▁save DelegationToken ▁( ▁Configuration ▁conf ▁, ▁FileSystem ▁fs ▁, ▁final ▁String ▁renew er ▁, ▁final ▁Path ▁token File ▁) ▁throws ▁IOException ▁{ ▁Token ▁< ▁? ▁> ▁token ▁= ▁fs ▁. ▁get DelegationToken ▁( ▁renew er ▁) ▁; ▁if ▁( ▁null ▁!= ▁token ▁) ▁{ ▁Credentials ▁cred ▁= ▁new ▁Credentials ▁( ▁) ▁; ▁cred ▁. ▁add Token ▁( ▁token ▁. ▁getService ▁( ▁) ▁, ▁token ▁) ▁; ▁cred ▁. ▁write Token Storage File ▁( ▁token File ▁, ▁conf ▁, ▁Credentials ▁. ▁Serialized Format ▁. ▁WR IT ABLE ▁) ▁;
▁public ▁interface ▁Slice Long State ▁extends ▁Two Nullable Value State ▁{ ▁Slice ▁getFirst ▁( ▁) ▁; ▁void ▁setFirst ▁( ▁Slice ▁first ▁) ▁; ▁long ▁getSecond ▁( ▁) ▁; ▁void ▁set Second ▁( ▁long ▁second ▁) ▁; ▁}
▁@ ▁Repository ▁public ▁class ▁Book Repository ▁{ ▁private ▁List ▁< ▁Book ▁> ▁books ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁public ▁Optional ▁< ▁Book ▁> ▁findById ▁( ▁long ▁id ▁) ▁{ ▁return ▁books ▁. ▁stream ▁( ▁) ▁. ▁filter ▁( ▁book ▁-> ▁book ▁. ▁getId ▁( ▁) ▁== ▁id ▁) ▁. ▁findFirst ▁( ▁) ▁; ▁} ▁public ▁void ▁add ▁( ▁Book ▁book ▁) ▁{ ▁books ▁. ▁add ▁( ▁book ▁) ▁; ▁} ▁}
▁public ▁class ▁WrapI DataModelScript Debug Client ▁extends ▁Unknown With Utils ▁implements ▁I DataModelScript Debug Client ▁{ ▁public ▁static ▁class ▁ByReference ▁extends ▁WrapI DataModelScript Debug Client ▁implements ▁Structure ▁. ▁ByReference ▁{ ▁} ▁public ▁WrapI DataModelScript Debug Client ▁( ▁) ▁{ ▁} ▁public ▁WrapI DataModelScript Debug Client ▁( ▁Pointer ▁pv Instance ▁) ▁{ ▁super ▁( ▁pv Instance ▁) ▁; ▁} ▁@ ▁Override ▁public ▁HRESULT ▁Notify Debug Event ▁( ▁Pointer ▁p Event Info ▁, ▁Pointer ▁p Script ▁, ▁Pointer ▁p Event Data Object ▁, ▁Pointer ▁resume Event Kind ▁) ▁{ ▁return ▁_ invokeHR ▁( ▁VTIndices ▁. ▁NOT IFY _ DEBUG _ EVENT ▁, ▁getPointer ▁( ▁) ▁, ▁p Event Info ▁, ▁p Script ▁, ▁p Event Data Object ▁, ▁resume Event Kind ▁) ▁; ▁} ▁}
▁@ ▁Override ▁protected ▁void ▁compute Key ▁( ▁Action KeyContext ▁action KeyContext ▁, ▁@ ▁Nullable ▁Artifact ▁. ▁Artifact Expander ▁artifact Expander ▁, ▁Fingerprint ▁fp ▁) ▁{ ▁fp ▁. ▁add String ▁( ▁getPrimary Output ▁( ▁) ▁. ▁getExec Path String ▁( ▁) ▁) ▁; ▁fp ▁. ▁add Int ▁( ▁execution Counter ▁. ▁get ▁( ▁) ▁) ▁; ▁} ▁} ▁private ▁static ▁class ▁Execution Counting Cache By pass ingAction ▁extends ▁Execution Count ingAction ▁{ ▁Execution Counting Cache By pass ingAction ▁( ▁Artifact ▁input ▁, ▁Artifact ▁output ▁, ▁AtomicInteger ▁execution Counter ▁) ▁{ ▁super ▁( ▁input ▁, ▁output ▁, ▁execution Counter ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁execute Un con dition ally ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁isV olatile ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁private ▁static ▁class ▁Sky frame Aware Execution Count ingAction ▁extends ▁Execution Counting Cache By pass ingAction ▁implements ▁Sky frame Aware Action ▁< ▁IOException ▁> ▁{ ▁private ▁final ▁SkyKey ▁action Dep Key ▁; ▁Sky frame Aware Execution Count ingAction ▁( ▁Artifact ▁input ▁, ▁Artifact ▁output ▁, ▁AtomicInteger ▁execution Counter ▁, ▁SkyKey ▁action Dep Key ▁) ▁{ ▁super ▁( ▁input ▁, ▁output ▁, ▁execution Counter ▁) ▁; ▁this ▁. ▁action Dep Key ▁= ▁action Dep Key ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁process Sky frame Values ▁( ▁ImmutableList ▁< ▁? ▁extends ▁SkyKey ▁> ▁keys ▁, ▁Map ▁< ▁SkyKey ▁, ▁Value Or Exception ▁< ▁IOException ▁> ▁> ▁values ▁, ▁boolean ▁values Missing ▁) ▁{ ▁assertThat ▁( ▁keys ▁) ▁. ▁containsExactly ▁( ▁action Dep Key ▁) ▁; ▁assertThat ▁( ▁values ▁. ▁keySet ▁( ▁) ▁) ▁. ▁containsExactly ▁( ▁action Dep Key ▁) ▁; ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁ImmutableList ▁< ▁SkyKey ▁> ▁get Direct Sky frame Dependencies ▁( ▁) ▁{ ▁return ▁ImmutableList ▁. ▁of ▁( ▁action Dep Key ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Class ▁< ▁IOException ▁> ▁getException Type ▁( ▁) ▁{ ▁return ▁IOException ▁. ▁class ▁; ▁} ▁@ ▁Override ▁public ▁Immutable Graph ▁< ▁SkyKey ▁> ▁getS ky frame Dependencies For Rew ind ing ▁( ▁SkyKey ▁self ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁} ▁private ▁interface ▁Execution Count ingAction Factory ▁{ ▁Execution Count ingAction ▁create ▁( ▁Artifact ▁input ▁, ▁Artifact ▁output ▁, ▁AtomicInteger ▁execution Counter ▁) ▁; ▁} ▁private ▁enum ▁Change Artifact ▁{ ▁D ONT _ CHANGE ▁, ▁CH ANGE _ M TIME ▁{ ▁@ ▁Override ▁boolean ▁change M time ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁, ▁CH ANGE _ M TIME _ AND _ CONTENT ▁{ ▁@ ▁Override ▁boolean ▁change M time ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁boolean ▁change Content ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁; ▁boolean ▁change M time ▁( ▁) ▁{ ▁return ▁false ▁; ▁} ▁boolean ▁change Content ▁( ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁private ▁enum ▁Ex pect Action Is ▁{ ▁NOT _ DIR TI ED ▁{ ▁@ ▁Override ▁boolean ▁act ually Clean ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁}
▁@ ▁M ojo ▁( ▁name ▁= ▁STR ▁, ▁default Phase ▁= ▁Lifecycle Phase ▁. ▁COMP ILE ▁) ▁public ▁class ▁Compile M ojo ▁extends ▁Abstract M ojo ▁{ ▁private ▁static ▁int ▁available Processors ▁= ▁Runtime ▁. ▁getRuntime ▁( ▁) ▁. ▁available Processors ▁( ▁) ▁; ▁@ ▁Parameter ▁( ▁defaultValue ▁= ▁STR ▁) ▁private ▁File ▁output ▁; ▁@ ▁Parameter ▁( ▁defaultValue ▁= ▁STR ▁, ▁required ▁= ▁true ▁) ▁private ▁File ▁source ▁; ▁@ ▁Parameter ▁private ▁String ▁target ▁; ▁@ ▁Parameter ▁private ▁Map ▁< ▁String ▁, ▁String ▁> ▁env ▁; ▁@ ▁Parameter ▁private ▁Map ▁< ▁String ▁, ▁String ▁> ▁vars ▁; ▁private ▁static ▁void ▁validate Platform ▁( ▁) ▁throws ▁M ojo Execution Exception ▁{ ▁if ▁( ▁System ▁. ▁getProperty ▁( ▁STR ▁) ▁. ▁toLowerCase ▁( ▁Locale ▁. ▁ENGLISH ▁) ▁. ▁startsWith ▁( ▁STR ▁) ▁) ▁{ ▁throw ▁new ▁M ojo Execution Exception ▁( ▁STR ▁+ ▁STR ▁) ▁; ▁} ▁} ▁public ▁void ▁execute ▁( ▁) ▁throws ▁M ojo Execution Exception ▁{ ▁long ▁start ▁= ▁System ▁. ▁nanoTime ▁( ▁) ▁; ▁validate Platform ▁( ▁) ▁; ▁run C M ake ▁( ▁) ▁; ▁run M ake ▁( ▁) ▁; ▁long ▁end ▁= ▁System ▁. ▁nanoTime ▁( ▁) ▁; ▁getLog ▁( ▁) ▁. ▁info ▁( ▁STR ▁+ ▁TimeUnit ▁. ▁MILLISECONDS ▁. ▁convert ▁( ▁end ▁- ▁start ▁, ▁TimeUnit ▁. ▁NANOSECONDS ▁) ▁+ ▁STR ▁) ▁; ▁} ▁static ▁void ▁validate Source Params ▁( ▁File ▁source ▁, ▁File ▁output ▁) ▁throws ▁M ojo Execution Exception ▁{ ▁String ▁c Output ▁= ▁null ▁, ▁c Source ▁= ▁null ▁; ▁try ▁{ ▁c Output ▁= ▁output ▁. ▁getCanonical Path ▁( ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁throw ▁new ▁M ojo Execution Exception ▁( ▁STR ▁+ ▁STR ▁, ▁e ▁) ▁; ▁} ▁try ▁{ ▁c Source ▁= ▁source ▁. ▁getCanonical Path ▁( ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁throw ▁new ▁M ojo Execution Exception ▁( ▁STR ▁+ ▁STR ▁, ▁e ▁) ▁; ▁} ▁if ▁( ▁c Source ▁. ▁startsWith ▁( ▁c Output ▁) ▁) ▁{ ▁throw ▁new ▁M ojo Execution Exception ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁; ▁} ▁} ▁public ▁void ▁run C M ake ▁( ▁) ▁throws ▁M ojo Execution Exception ▁{ ▁validate Platform ▁( ▁) ▁; ▁validate Source Params ▁( ▁source ▁, ▁output ▁) ▁; ▁if ▁( ▁output ▁. ▁mkdirs ▁( ▁) ▁) ▁{ ▁getLog ▁( ▁) ▁. ▁info ▁( ▁STR ▁+ ▁output ▁+ ▁STR ▁) ▁; ▁} ▁List ▁< ▁String ▁> ▁cmd ▁= ▁new ▁LinkedList ▁< ▁String ▁> ▁( ▁) ▁; ▁cmd ▁. ▁add ▁( ▁STR ▁) ▁; ▁cmd ▁. ▁add ▁( ▁source ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁String ▁> ▁entry ▁: ▁vars ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁if ▁( ▁( ▁entry ▁. ▁getValue ▁( ▁) ▁!= ▁null ▁) ▁&& ▁( ▁! ▁entry ▁. ▁getValue ▁( ▁) ▁. ▁equals ▁( ▁STR ▁) ▁) ▁) ▁{ ▁cmd ▁. ▁add ▁( ▁STR ▁+ ▁entry ▁. ▁getKey ▁( ▁) ▁+ ▁STR ▁+ ▁entry ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁} ▁cmd ▁. ▁add ▁( ▁STR ▁) ▁;
▁class ▁Jdk Base Application Protocol Negot iator ▁implements ▁Jdk Application Protocol Negot iator ▁{ ▁private ▁final ▁List ▁< ▁String ▁> ▁protocols ▁; ▁private ▁final ▁Protocol Selector Factory ▁selector Factory ▁; ▁private ▁final ▁Protocol Selection Listener Factory ▁listener Factory ▁; ▁private ▁final ▁Ssl Engine Wrapper Factory ▁wrapper Factory ▁; ▁Jdk Base Application Protocol Negot iator ▁( ▁Ssl Engine Wrapper Factory ▁wrapper Factory ▁, ▁Protocol Selector Factory ▁selector Factory ▁, ▁Protocol Selection Listener Factory ▁listener Factory ▁, ▁Iterable ▁< ▁String ▁> ▁protocols ▁) ▁{ ▁this ▁( ▁wrapper Factory ▁, ▁selector Factory ▁, ▁listener Factory ▁, ▁toList ▁( ▁protocols ▁) ▁) ▁; ▁} ▁Jdk Base Application Protocol Negot iator ▁( ▁Ssl Engine Wrapper Factory ▁wrapper Factory ▁, ▁Protocol Selector Factory ▁selector Factory ▁, ▁Protocol Selection Listener Factory ▁listener Factory ▁, ▁String ▁... ▁protocols ▁) ▁{ ▁this ▁( ▁wrapper Factory ▁, ▁selector Factory ▁, ▁listener Factory ▁, ▁toList ▁( ▁protocols ▁) ▁) ▁; ▁} ▁private ▁Jdk Base Application Protocol Negot iator ▁( ▁Ssl Engine Wrapper Factory ▁wrapper Factory ▁, ▁Protocol Selector Factory ▁selector Factory ▁, ▁Protocol Selection Listener Factory ▁listener Factory ▁, ▁List ▁< ▁String ▁> ▁protocols ▁) ▁{ ▁this ▁. ▁wrapper Factory ▁= ▁checkNotNull ▁( ▁wrapper Factory ▁, ▁STR ▁) ▁; ▁this ▁. ▁selector Factory ▁= ▁checkNotNull ▁( ▁selector Factory ▁, ▁STR ▁) ▁; ▁this ▁. ▁listener Factory ▁= ▁checkNotNull ▁( ▁listener Factory ▁, ▁STR ▁) ▁; ▁this ▁. ▁protocols ▁= ▁Collections ▁. ▁unmodifiable List ▁( ▁checkNotNull ▁( ▁protocols ▁, ▁STR ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁String ▁> ▁protocols ▁( ▁) ▁{ ▁return ▁protocols ▁; ▁} ▁@ ▁Override ▁public ▁Protocol Selector Factory ▁protocol Selector Factory ▁( ▁) ▁{ ▁return ▁selector Factory ▁; ▁} ▁@ ▁Override ▁public ▁Protocol Selection Listener Factory ▁protocol Listener Factory ▁( ▁) ▁{ ▁return ▁listener Factory ▁; ▁} ▁@ ▁Override ▁public ▁Ssl Engine Wrapper Factory ▁wrapper Factory ▁( ▁) ▁{ ▁return ▁wrapper Factory ▁; ▁} ▁static ▁final ▁Protocol Selector Factory ▁FAIL _ SE LE CTOR _ FACTORY ▁= ▁new ▁Protocol Selector Factory ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Protocol Selector ▁new Selector ▁( ▁SSLEngine ▁engine ▁, ▁Set ▁< ▁String ▁> ▁supported Protocols ▁) ▁{ ▁return ▁new ▁Fail Protocol Selector ▁( ▁( ▁Jdk Ssl Engine ▁) ▁engine ▁, ▁supported Protocols ▁) ▁; ▁} ▁} ▁; ▁static ▁final ▁Protocol Selector Factory ▁NO _ FAIL _ SE LE CTOR _ FACTORY ▁= ▁new ▁Protocol Selector Factory ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Protocol Selector ▁new Selector ▁( ▁SSLEngine ▁engine ▁, ▁Set ▁< ▁String ▁> ▁supported Protocols ▁) ▁{ ▁return ▁new ▁No Fail Protocol Selector ▁( ▁( ▁Jdk Ssl Engine ▁) ▁engine ▁, ▁supported Protocols ▁) ▁; ▁} ▁} ▁; ▁static ▁final ▁Protocol Selection Listener Factory ▁FAIL _ SELECTION _ LIST ENER _ FACTORY ▁= ▁new ▁Protocol Selection Listener Factory ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Protocol Selection Listener ▁new Listener ▁( ▁SSLEngine ▁engine ▁, ▁List ▁< ▁String ▁> ▁supported Protocols ▁) ▁{ ▁return ▁new ▁Fail Protocol Selection Listener ▁( ▁( ▁Jdk Ssl Engine ▁) ▁engine ▁, ▁supported Protocols ▁) ▁; ▁} ▁} ▁;
▁if ▁( ▁c ▁. ▁getTemp Mode ▁( ▁) ▁!= ▁Temp Mode ▁. ▁NONE ▁) ▁{ ▁this ▁. ▁memory Consumer Weights ▁++ ▁; ▁} ▁} ▁for ▁( ▁Channel ▁c ▁: ▁visit able ▁. ▁getB roadcast Inputs ▁( ▁) ▁) ▁{ ▁if ▁( ▁c ▁. ▁getLocal Strategy ▁( ▁) ▁. ▁d ams ▁( ▁) ▁) ▁{ ▁this ▁. ▁memory Consumer Weights ▁++ ▁; ▁} ▁if ▁( ▁c ▁. ▁getTemp Mode ▁( ▁) ▁!= ▁Temp Mode ▁. ▁NONE ▁) ▁{ ▁this ▁. ▁memory Consumer Weights ▁++ ▁; ▁} ▁} ▁if ▁( ▁visit able ▁instanceof ▁Iteration PlanNode ▁) ▁{ ▁final ▁Iteration PlanNode ▁iter Node ▁= ▁( ▁Iteration PlanNode ▁) ▁visit able ▁; ▁this ▁. ▁stack Of Iteration Nodes ▁. ▁addLast ▁( ▁iter Node ▁) ▁; ▁( ▁( ▁Iteration PlanNode ▁) ▁visit able ▁) ▁. ▁accept For Step Function ▁( ▁this ▁) ▁; ▁this ▁. ▁stack Of Iteration Nodes ▁. ▁remove Last ▁( ▁) ▁; ▁} ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁void ▁post Visit ▁( ▁PlanNode ▁visit able ▁) ▁{ ▁} ▁}
▁@ ▁Deprecated ▁public ▁interface ▁Re member Me Services ▁{ ▁Authentication ▁auto Login ▁( ▁HttpServlet Request ▁request ▁, ▁HttpServlet Response ▁response ▁) ▁; ▁void ▁login Fail ▁( ▁HttpServlet Request ▁request ▁, ▁HttpServlet Response ▁response ▁) ▁; ▁void ▁login Success ▁( ▁HttpServlet Request ▁request ▁, ▁HttpServlet Response ▁response ▁, ▁Authentication ▁successful Authentication ▁) ▁; ▁static ▁Re member Me Services ▁from Spring ▁( ▁org ▁. ▁springframework ▁. ▁security ▁. ▁web ▁. ▁authentication ▁. ▁Re member Me Services ▁r ms ▁) ▁{ ▁if ▁( ▁r ms ▁instanceof ▁Re member Me Services Spring Impl ▁) ▁{ ▁return ▁( ▁( ▁Re member Me Services Spring Impl ▁) ▁r ms ▁) ▁. ▁delegate ▁; ▁} ▁return ▁new ▁Re member Me Services ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Authentication ▁auto Login ▁( ▁HttpServlet Request ▁request ▁, ▁HttpServlet Response ▁response ▁) ▁{ ▁org ▁. ▁springframework ▁. ▁security ▁. ▁core ▁. ▁Authentication ▁a ▁= ▁r ms ▁. ▁auto Login ▁( ▁request ▁, ▁response ▁) ▁; ▁return ▁a ▁!= ▁null ▁? ▁Authentication ▁. ▁from Spring ▁( ▁a ▁) ▁: ▁null ▁; ▁} ▁@ ▁Override ▁public ▁void ▁login Fail ▁( ▁HttpServlet Request ▁request ▁, ▁HttpServlet Response ▁response ▁) ▁{ ▁r ms ▁. ▁login Fail ▁( ▁request ▁, ▁response ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁login Success ▁( ▁HttpServlet Request ▁request ▁, ▁HttpServlet Response ▁response ▁, ▁Authentication ▁successful Authentication ▁) ▁{ ▁r ms ▁. ▁login Success ▁( ▁request ▁, ▁response ▁, ▁successful Authentication ▁. ▁to Spring ▁( ▁) ▁) ▁; ▁} ▁} ▁; ▁} ▁default ▁org ▁. ▁springframework ▁. ▁security ▁. ▁web ▁. ▁authentication ▁. ▁Re member Me Services ▁to Spring ▁( ▁) ▁{ ▁return ▁new ▁Re member Me Services Spring Impl ▁( ▁this ▁) ▁; ▁} ▁}
▁public ▁class ▁Primitive Bundle Initialized ▁{ ▁public ▁byte ▁byteValue ▁= ▁( ▁byte ▁) ▁1 ▁; ▁public ▁short ▁short Value ▁= ▁( ▁short ▁) ▁1 ▁; ▁public ▁int ▁intValue ▁= ▁1 ▁; ▁public ▁long ▁longValue ▁= ▁1 L ▁; ▁public ▁float ▁floatValue ▁= ▁1.0 f ▁; ▁public ▁double ▁doubleValue ▁= ▁1 ▁; ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁STR ▁+ ▁byteValue ▁+ ▁STR ▁+ ▁STR ▁+ ▁short Value ▁+ ▁STR ▁+ ▁STR ▁+ ▁intValue ▁+ ▁STR ▁+ ▁STR ▁+ ▁longValue ▁+ ▁STR ▁+ ▁STR ▁+ ▁floatValue ▁+ ▁STR ▁+ ▁STR ▁+ ▁doubleValue ▁+ ▁STR ▁; ▁} ▁}
▁public ▁class ▁Node Property Test ▁{ ▁@ ▁Rule ▁public ▁JenkinsRule ▁j ▁= ▁new ▁JenkinsRule ▁( ▁) ▁; ▁@ ▁Rule ▁public ▁Logger Rule ▁logs ▁= ▁new ▁Logger Rule ▁( ▁) ▁; ▁@ ▁Test ▁public ▁void ▁inv isible Property ▁( ▁) ▁throws ▁Exception ▁{ ▁logs ▁. ▁record ▁( ▁Descriptor ▁. ▁class ▁, ▁Level ▁. ▁ALL ▁) ▁; ▁D umb Slave ▁s ▁= ▁j ▁. ▁create Slave ▁( ▁) ▁; ▁Inv isible Property ▁before ▁= ▁new ▁Inv isible Property ▁( ▁) ▁; ▁s ▁. ▁getNode Properties ▁( ▁) ▁. ▁add ▁( ▁before ▁) ▁; ▁assertFalse ▁( ▁before ▁. ▁re config ured ▁) ▁; ▁D umb Slave ▁s 2 ▁= ▁j ▁. ▁config Round t rip ▁( ▁s ▁) ▁; ▁assertNotSame ▁( ▁s ▁, ▁s 2 ▁) ▁; ▁Inv isible Property ▁after ▁= ▁s 2 ▁. ▁getNode Properties ▁( ▁) ▁. ▁get ▁( ▁Inv isible Property ▁. ▁class ▁) ▁; ▁assertSame ▁( ▁before ▁, ▁after ▁) ▁; ▁assertTrue ▁( ▁after ▁. ▁re config ured ▁) ▁; ▁} ▁public ▁static ▁class ▁Inv isible Property ▁extends ▁Node Property ▁< ▁Sl ave ▁> ▁{ ▁boolean ▁re config ured ▁= ▁false ▁; ▁@ ▁Override ▁public ▁Node Property ▁< ▁? ▁> ▁re config ure ▁( ▁StaplerRequest ▁req ▁, ▁JSONObject ▁form ▁) ▁throws ▁Form Exception ▁{ ▁re config ured ▁= ▁true ▁; ▁return ▁this ▁; ▁} ▁@ ▁TestExtension ▁( ▁STR ▁) ▁public ▁static ▁class ▁DescriptorImpl ▁extends ▁Node Property Descriptor ▁{ ▁} ▁} ▁@ ▁Test ▁public ▁void ▁basic Config Round t rip ▁( ▁) ▁throws ▁Exception ▁{ ▁D umb Slave ▁s ▁= ▁j ▁. ▁create Slave ▁( ▁) ▁; ▁Html Form ▁f ▁= ▁j ▁. ▁createWebClient ▁( ▁) ▁. ▁goTo ▁( ▁STR ▁+ ▁s ▁. ▁getNode Name ▁( ▁) ▁+ ▁STR ▁) ▁. ▁getF orm ByName ▁( ▁STR ▁) ▁; ▁( ▁( ▁Html Label ▁) ▁D om Node Util ▁. ▁select Single Node ▁( ▁f ▁, ▁STR ▁) ▁) ▁. ▁click ▁( ▁) ▁; ▁j ▁. ▁submit ▁( ▁f ▁) ▁; ▁Property Impl ▁p ▁= ▁j ▁. ▁jenkins ▁. ▁getNode ▁( ▁s ▁. ▁getNode Name ▁( ▁) ▁) ▁. ▁getNode Properties ▁( ▁) ▁. ▁get ▁( ▁Property Impl ▁. ▁class ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁p ▁. ▁name ▁) ▁; ▁p ▁. ▁name ▁= ▁STR ▁; ▁j ▁. ▁config Round t rip ▁( ▁s ▁) ▁; ▁Property Impl ▁p 2 ▁= ▁j ▁. ▁jenkins ▁. ▁getNode ▁( ▁s ▁. ▁getNode Name ▁( ▁) ▁) ▁. ▁getNode Properties ▁( ▁) ▁. ▁get ▁( ▁Property Impl ▁. ▁class ▁) ▁; ▁assertNotSame ▁( ▁p ▁, ▁p 2 ▁) ▁; ▁j ▁. ▁assertEqual Data Bound Beans ▁( ▁p ▁, ▁p 2 ▁) ▁; ▁} ▁public ▁static ▁class ▁Property Impl ▁extends ▁Node Property ▁< ▁Sl ave ▁> ▁{ ▁public ▁String ▁name ▁; ▁@ ▁Data Bound Constructor ▁public ▁Property Impl ▁( ▁String ▁name ▁) ▁{ ▁this ▁. ▁name ▁= ▁name ▁; ▁} ▁@ ▁TestExtension ▁( ▁STR ▁) ▁public ▁static ▁class ▁DescriptorImpl ▁extends ▁Node Property Descriptor ▁{ ▁} ▁} ▁}
▁@ ▁Specialization ▁( ▁guards ▁= ▁STR ▁) ▁int ▁s 12 ▁( ▁int ▁arg ▁, ▁@ ▁Ex clusive ▁@ ▁Cached ▁( ▁STR ▁) ▁int ▁cached Arg ▁) ▁{ ▁assertEquals ▁( ▁arg ▁, ▁cached Arg ▁) ▁; ▁return ▁arg ▁; ▁} ▁@ ▁Specialization ▁( ▁guards ▁= ▁STR ▁) ▁int ▁s 13 ▁( ▁int ▁arg ▁, ▁@ ▁Ex clusive ▁@ ▁Cached ▁( ▁STR ▁) ▁int ▁cached Arg ▁) ▁{ ▁assertEquals ▁( ▁arg ▁, ▁cached Arg ▁) ▁; ▁return ▁arg ▁; ▁} ▁@ ▁Specialization ▁( ▁guards ▁= ▁STR ▁) ▁int ▁s 14 ▁( ▁int ▁arg ▁, ▁@ ▁Ex clusive ▁@ ▁Cached ▁( ▁STR ▁) ▁int ▁cached Arg ▁) ▁{ ▁assertEquals ▁( ▁arg ▁, ▁cached Arg ▁) ▁; ▁return ▁arg ▁; ▁} ▁@ ▁Specialization ▁( ▁guards ▁= ▁STR ▁) ▁int ▁s 15 ▁( ▁int ▁arg ▁, ▁@ ▁Ex clusive ▁@ ▁Cached ▁( ▁STR ▁) ▁int ▁cached Arg ▁) ▁{ ▁assertEquals ▁( ▁arg ▁, ▁cached Arg ▁) ▁; ▁return ▁arg ▁; ▁} ▁} ▁abstract ▁static ▁class ▁Test 32 Bits ▁extends ▁Test 16 Bits ▁{ ▁@ ▁Specialization ▁( ▁guards ▁= ▁STR ▁) ▁int ▁s 16 ▁( ▁int ▁arg ▁, ▁@ ▁Ex clusive ▁@ ▁Cached ▁( ▁STR ▁) ▁int ▁cached Arg ▁) ▁{ ▁assertEquals ▁( ▁arg ▁, ▁cached Arg ▁) ▁; ▁return ▁arg ▁; ▁} ▁@ ▁Specialization ▁( ▁guards ▁= ▁STR ▁) ▁int ▁s 17 ▁( ▁int ▁arg ▁, ▁@ ▁Ex clusive ▁@ ▁Cached ▁( ▁STR ▁) ▁int ▁cached Arg ▁) ▁{ ▁assertEquals ▁( ▁arg ▁, ▁cached Arg ▁) ▁; ▁return ▁arg ▁; ▁} ▁@ ▁Specialization ▁( ▁guards ▁= ▁STR ▁) ▁int ▁s 18 ▁( ▁int ▁arg ▁, ▁@ ▁Ex clusive ▁@ ▁Cached ▁( ▁STR ▁) ▁int ▁cached Arg ▁) ▁{ ▁assertEquals ▁( ▁arg ▁, ▁cached Arg ▁) ▁; ▁return ▁arg ▁; ▁} ▁@ ▁Specialization ▁( ▁guards ▁= ▁STR ▁) ▁int ▁s 19 ▁( ▁int ▁arg ▁, ▁@ ▁Ex clusive ▁@ ▁Cached ▁( ▁STR ▁) ▁int ▁cached Arg ▁) ▁{ ▁assertEquals ▁( ▁arg ▁, ▁cached Arg ▁) ▁; ▁return ▁arg ▁; ▁} ▁@ ▁Specialization ▁( ▁guards ▁= ▁STR ▁) ▁int ▁s 20 ▁( ▁int ▁arg ▁, ▁@ ▁Ex clusive ▁@ ▁Cached ▁( ▁STR ▁) ▁int ▁cached Arg ▁) ▁{ ▁assertEquals ▁( ▁arg ▁, ▁cached Arg ▁) ▁; ▁return ▁arg ▁; ▁} ▁@ ▁Specialization ▁( ▁guards ▁= ▁STR ▁) ▁int ▁s 21 ▁( ▁int ▁arg ▁, ▁@ ▁Ex clusive ▁@ ▁Cached ▁( ▁STR ▁) ▁int ▁cached Arg ▁) ▁{ ▁assertEquals ▁( ▁arg ▁, ▁cached Arg ▁) ▁; ▁return ▁arg ▁; ▁} ▁@ ▁Specialization ▁( ▁guards ▁= ▁STR ▁) ▁int ▁s 22 ▁( ▁int ▁arg ▁, ▁@ ▁Ex clusive ▁@ ▁Cached ▁( ▁STR ▁) ▁int ▁cached Arg ▁) ▁{ ▁assertEquals ▁( ▁arg ▁, ▁cached Arg ▁) ▁; ▁return ▁arg ▁; ▁} ▁@ ▁Specialization ▁( ▁guards ▁= ▁STR ▁) ▁int ▁s 23 ▁( ▁int ▁arg ▁, ▁@ ▁Ex clusive ▁@ ▁Cached ▁( ▁STR ▁) ▁int ▁cached Arg ▁) ▁{ ▁assertEquals ▁( ▁arg ▁, ▁cached Arg ▁) ▁; ▁return ▁arg ▁; ▁}
▁choose Button And Apply ▁( ▁STR ▁, ▁MY _ B UTTON ▁) ▁; ▁waitFor Merge Completion ▁( ▁) ▁; ▁External Manager ▁external Manager ▁= ▁result Program ▁. ▁getExternal Manager ▁( ▁) ▁; ▁External Location ▁ext Loc App le s ▁= ▁external Manager ▁. ▁getUnique External Location ▁( ▁STR ▁, ▁STR ▁) ▁; ▁assertNotNull ▁( ▁ext Loc App le s ▁) ▁; ▁External Location ▁ext Loc Or anges ▁= ▁external Manager ▁. ▁getUnique External Location ▁( ▁STR ▁, ▁STR ▁) ▁; ▁assertNull ▁( ▁ext Loc Or anges ▁) ▁; ▁Reference Manager ▁ref Mgr ▁= ▁result Program ▁. ▁getReference Manager ▁( ▁) ▁; ▁Reference ▁[ ▁] ▁refs ▁; ▁refs ▁= ▁ref Mgr ▁. ▁get References From ▁( ▁addr ▁( ▁STR ▁) ▁, ▁0 ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁refs ▁. ▁length ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁( ▁( ▁External Reference ▁) ▁refs ▁[ ▁0 ▁] ▁) ▁. ▁getExternal Location ▁( ▁) ▁. ▁toString ▁( ▁) ▁) ▁; ▁assertNull ▁( ▁( ▁( ▁External Reference ▁) ▁refs ▁[ ▁0 ▁] ▁) ▁. ▁getExternal Location ▁( ▁) ▁. ▁getAddress ▁( ▁) ▁) ▁; ▁assertTrue ▁( ▁refs ▁[ ▁0 ▁] ▁. ▁getSource ▁( ▁) ▁== ▁SourceType ▁. ▁USER _ DEFINED ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Ext Label Only Ref Change Same No Conflict ▁( ▁) ▁throws ▁Exception ▁{ ▁mt f ▁. ▁initialize ▁( ▁STR ▁, ▁new ▁Original Program Modifier Listener ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁modify Original ▁( ▁ProgramDB ▁program ▁) ▁{ ▁int ▁tx Id ▁= ▁program ▁. ▁start Transaction ▁( ▁STR ▁) ▁; ▁boolean ▁commit ▁= ▁false ▁; ▁try ▁{ ▁Reference Manager ▁ref Mgr ▁= ▁program ▁. ▁getReference Manager ▁( ▁) ▁; ▁Reference ▁[ ▁] ▁refs ▁; ▁refs ▁= ▁ref Mgr ▁. ▁get References From ▁( ▁addr ▁( ▁program ▁, ▁STR ▁) ▁, ▁0 ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁refs ▁. ▁length ▁) ▁; ▁ref Mgr ▁. ▁add External Reference ▁( ▁addr ▁( ▁program ▁, ▁STR ▁) ▁, ▁STR ▁, ▁STR ▁, ▁addr ▁( ▁program ▁, ▁STR ▁) ▁, ▁SourceType ▁. ▁USER _ DEFINED ▁, ▁0 ▁, ▁RefType ▁. ▁DATA ▁) ▁; ▁commit ▁= ▁true ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁Assert ▁. ▁fail ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁} ▁finally ▁{ ▁program ▁. ▁endTransaction ▁( ▁tx Id ▁, ▁commit ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁modify Latest ▁( ▁ProgramDB ▁program ▁) ▁{ ▁int ▁tx Id ▁= ▁program ▁. ▁start Transaction ▁( ▁STR ▁) ▁; ▁boolean ▁commit ▁= ▁false ▁; ▁try ▁{ ▁Reference Manager ▁ref Mgr ▁= ▁program ▁. ▁getReference Manager ▁( ▁) ▁; ▁Reference ▁[ ▁] ▁refs ▁; ▁refs ▁= ▁ref Mgr ▁. ▁get References From ▁( ▁addr ▁( ▁program ▁, ▁STR ▁) ▁, ▁0 ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁refs ▁. ▁length ▁) ▁; ▁assertTrue ▁( ▁refs ▁[ ▁0 ▁] ▁. ▁isExternal Reference ▁( ▁) ▁) ▁; ▁change External Reference Label ▁( ▁program ▁, ▁( ▁External Reference ▁) ▁refs ▁[ ▁0 ▁] ▁, ▁STR ▁, ▁addr ▁( ▁program ▁, ▁STR ▁) ▁, ▁RefType ▁. ▁COMP U TED _ CALL _ TERMIN ATOR ▁) ▁;
▁public ▁class ▁Process Plugin Constants ▁{ ▁public ▁static ▁final ▁ServiceType ▁SERVICE _ TYPE ▁= ▁ServiceType Factory ▁. ▁of ▁( ▁600 5 ▁, ▁STR ▁) ▁; ▁public ▁static ▁final ▁AnnotationKey ▁PROCESS _ COMMAND ▁= ▁AnnotationKey Factory ▁. ▁of ▁( ▁180 ▁, ▁STR ▁, ▁VIEW _ IN _ RECORD _ SET ▁) ▁; ▁public ▁static ▁final ▁AnnotationKey ▁PROCESS _ ID ▁= ▁AnnotationKey Factory ▁. ▁of ▁( ▁1 81 ▁, ▁STR ▁, ▁VIEW _ IN _ RECORD _ SET ▁) ▁; ▁}
▁public ▁class ▁ServletRequest Path Utils Tests ▁{ ▁@ ▁Test ▁void ▁parse And Cache ▁( ▁) ▁{ ▁testParse And Cache ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁testParse And Cache ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁testParse And Cache ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁testParse And Cache ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁testParse And Cache ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁testParse And Cache ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁} ▁private ▁void ▁testParse And Cache ▁( ▁String ▁request Uri ▁, ▁String ▁contextPath ▁, ▁String ▁servlet Path ▁, ▁String ▁path Within Application ▁) ▁{ ▁MockHttpServlet Request ▁request ▁= ▁new ▁MockHttpServlet Request ▁( ▁STR ▁, ▁request Uri ▁) ▁; ▁request ▁. ▁setContext Path ▁( ▁contextPath ▁) ▁; ▁request ▁. ▁set Servlet Path ▁( ▁servlet Path ▁) ▁; ▁request ▁. ▁set HttpServlet Mapping ▁( ▁new ▁MockHttpServlet Mapping ▁( ▁path Within Application ▁, ▁contextPath ▁, ▁STR ▁, ▁Mapping Match ▁. ▁PATH ▁) ▁) ▁; ▁Request Path ▁request Path ▁= ▁ServletRequest Path Utils ▁. ▁parse And Cache ▁( ▁request ▁) ▁; ▁assertThat ▁( ▁request Path ▁. ▁contextPath ▁( ▁) ▁. ▁value ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁contextPath ▁) ▁; ▁assertThat ▁( ▁request Path ▁. ▁path Within Application ▁( ▁) ▁. ▁value ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁path Within Application ▁) ▁; ▁} ▁}
▁@ ▁U sed By Generated Code ▁public ▁static ▁boolean ▁primitive Long Long ▁( ▁Slice ▁left ▁, ▁Slice ▁right ▁, ▁MethodHandle ▁getResult MethodHandle ▁) ▁{ ▁return ▁invoke Get Result ▁( ▁getResult MethodHandle ▁, ▁compare ▁( ▁left ▁, ▁right ▁) ▁) ▁; ▁} ▁private ▁static ▁Sql ScalarFunction ▁distinct Operator ▁( ▁) ▁{ ▁return ▁make Binary Operator Function Builder ▁( ▁IS _ DI STIN CT _ FROM ▁) ▁. ▁choice ▁( ▁choice ▁-> ▁choice ▁. ▁argument Properties ▁( ▁valueType Argument Property ▁( ▁USE _ NULL _ FLAG ▁) ▁, ▁valueType Argument Property ▁( ▁USE _ NULL _ FLAG ▁) ▁) ▁. ▁implementation ▁( ▁methods Group ▁-> ▁methods Group ▁. ▁methods ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁. ▁choice ▁( ▁choice ▁-> ▁choice ▁. ▁argument Properties ▁( ▁valueType Argument Property ▁( ▁BLOCK _ AND _ POSITION ▁) ▁, ▁valueType Argument Property ▁( ▁BLOCK _ AND _ POSITION ▁) ▁) ▁. ▁implementation ▁( ▁methods Group ▁-> ▁methods Group ▁. ▁method With Explicit Java Types ▁( ▁STR ▁, ▁asList ▁( ▁Optional ▁. ▁of ▁( ▁Slice ▁. ▁class ▁) ▁, ▁Optional ▁. ▁of ▁( ▁Slice ▁. ▁class ▁) ▁) ▁) ▁. ▁method With Explicit Java Types ▁( ▁STR ▁, ▁asList ▁( ▁Optional ▁. ▁of ▁( ▁long ▁. ▁class ▁) ▁, ▁Optional ▁. ▁of ▁( ▁long ▁. ▁class ▁) ▁) ▁) ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁@ ▁U sed By Generated Code ▁public ▁static ▁boolean ▁distinct Block Position Long Long ▁( ▁Block ▁left ▁, ▁int ▁left Position ▁, ▁Block ▁right ▁, ▁int ▁right Position ▁) ▁{ ▁if ▁( ▁left ▁. ▁isNull ▁( ▁left Position ▁) ▁!= ▁right ▁. ▁isNull ▁( ▁right Position ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁left ▁. ▁isNull ▁( ▁left Position ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁long ▁left Low ▁= ▁left ▁. ▁getLong ▁( ▁left Position ▁, ▁0 ▁) ▁; ▁long ▁left High ▁= ▁left ▁. ▁getLong ▁( ▁left Position ▁, ▁SI Z E _ OF _ LONG ▁) ▁; ▁long ▁right Low ▁= ▁right ▁. ▁getLong ▁( ▁right Position ▁, ▁0 ▁) ▁; ▁long ▁right High ▁= ▁right ▁. ▁getLong ▁( ▁right Position ▁, ▁SI Z E _ OF _ LONG ▁) ▁; ▁return ▁Un sc aled Decimal 128 Arithmetic ▁. ▁compare ▁( ▁left Low ▁, ▁left High ▁, ▁right Low ▁, ▁right High ▁) ▁!= ▁0 ▁; ▁} ▁@ ▁U sed By Generated Code ▁public ▁static ▁boolean ▁distinct Block Position Short Short ▁( ▁Block ▁left ▁, ▁int ▁left Position ▁, ▁Block ▁right ▁, ▁int ▁right Position ▁) ▁{ ▁if ▁( ▁left ▁. ▁isNull ▁( ▁left Position ▁) ▁!= ▁right ▁. ▁isNull ▁( ▁right Position ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁left ▁. ▁isNull ▁( ▁left Position ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁long ▁left Value ▁= ▁left ▁. ▁getLong ▁( ▁left Position ▁) ▁; ▁long ▁right Value ▁= ▁right ▁. ▁getLong ▁( ▁right Position ▁) ▁; ▁return ▁Long ▁. ▁compare ▁( ▁left Value ▁, ▁right Value ▁) ▁!= ▁0 ▁; ▁}
▁@ ▁Override ▁public ▁void ▁notify Checkpoint Ab orted ▁( ▁long ▁checkpointId ▁) ▁{ ▁} ▁} ▁private ▁static ▁class ▁Identity Map Function ▁extends ▁Rich Map Function ▁< ▁Long ▁, ▁Tuple 1 ▁< ▁Long ▁> ▁> ▁implements ▁Checkpoint Listener ▁{ ▁static ▁final ▁List ▁< ▁Long ▁> ▁[ ▁] ▁COMP LETED _ CHECK POINTS ▁= ▁create Checkpoint Lists ▁( ▁PAR ALLELISM ▁) ▁; ▁private ▁volatile ▁boolean ▁notification Already ▁; ▁@ ▁Override ▁public ▁Tuple 1 ▁< ▁Long ▁> ▁map ▁( ▁Long ▁value ▁) ▁throws ▁Exception ▁{ ▁return ▁Tuple 1 ▁. ▁of ▁( ▁value ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁notify Checkpoint Complete ▁( ▁long ▁checkpointId ▁) ▁{ ▁int ▁partition ▁= ▁getRuntime Context ▁( ▁) ▁. ▁getIndex Of This Subtask ▁( ▁) ▁; ▁COMP LETED _ CHECK POINTS ▁[ ▁partition ▁] ▁. ▁add ▁( ▁checkpointId ▁) ▁; ▁if ▁( ▁On ce Fail ing Reducer ▁. ▁has Failed ▁&& ▁! ▁notification Already ▁) ▁{ ▁notification Already ▁= ▁true ▁; ▁Gener ating Source Function ▁. ▁num Post Failure Notification s ▁. ▁incrementAndGet ▁( ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁notify Checkpoint Ab orted ▁( ▁long ▁checkpointId ▁) ▁{ ▁} ▁} ▁private ▁static ▁class ▁Long R ich Filter Function ▁extends ▁Rich Filter Function ▁< ▁Long ▁> ▁implements ▁Checkpoint Listener ▁{ ▁static ▁final ▁List ▁< ▁Long ▁> ▁[ ▁] ▁COMP LETED _ CHECK POINTS ▁= ▁create Checkpoint Lists ▁( ▁PAR ALLELISM ▁) ▁; ▁private ▁volatile ▁boolean ▁notification Already ▁; ▁@ ▁Override ▁public ▁boolean ▁filter ▁( ▁Long ▁value ▁) ▁{ ▁return ▁value ▁< ▁100 ▁; ▁} ▁@ ▁Override ▁public ▁void ▁notify Checkpoint Complete ▁( ▁long ▁checkpointId ▁) ▁{ ▁int ▁partition ▁= ▁getRuntime Context ▁( ▁) ▁. ▁getIndex Of This Subtask ▁( ▁) ▁; ▁COMP LETED _ CHECK POINTS ▁[ ▁partition ▁] ▁. ▁add ▁( ▁checkpointId ▁) ▁; ▁if ▁( ▁On ce Fail ing Reducer ▁. ▁has Failed ▁&& ▁! ▁notification Already ▁) ▁{ ▁notification Already ▁= ▁true ▁; ▁Gener ating Source Function ▁. ▁num Post Failure Notification s ▁. ▁incrementAndGet ▁( ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁notify Checkpoint Ab orted ▁( ▁long ▁checkpointId ▁) ▁{ ▁} ▁} ▁private ▁static ▁class ▁Left Identity Co R ich FlatMap Function ▁extends ▁Rich Co FlatMap Function ▁< ▁Long ▁, ▁Long ▁, ▁Long ▁> ▁implements ▁Checkpoint Listener ▁{ ▁static ▁final ▁List ▁< ▁Long ▁> ▁[ ▁] ▁COMP LETED _ CHECK POINTS ▁= ▁create Checkpoint Lists ▁( ▁PAR ALLELISM ▁) ▁; ▁private ▁volatile ▁boolean ▁notification Already ▁; ▁@ ▁Override ▁public ▁void ▁flatMap 1 ▁( ▁Long ▁value ▁, ▁Collector ▁< ▁Long ▁> ▁out ▁) ▁{ ▁out ▁. ▁collect ▁( ▁value ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁flatMap 2 ▁( ▁Long ▁value ▁, ▁Collector ▁< ▁Long ▁> ▁out ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁notify Checkpoint Complete ▁( ▁long ▁checkpointId ▁) ▁{ ▁int ▁partition ▁= ▁getRuntime Context ▁( ▁) ▁. ▁getIndex Of This Subtask ▁( ▁) ▁; ▁COMP LETED _ CHECK POINTS ▁[ ▁partition ▁] ▁. ▁add ▁( ▁checkpointId ▁) ▁; ▁if ▁( ▁On ce Fail ing Reducer ▁. ▁has Failed ▁&& ▁! ▁notification Already ▁) ▁{ ▁notification Already ▁= ▁true ▁;
▁class ▁PluginTest ▁{ ▁@ ▁Test ▁void ▁map Plugin Should Intercept Get ▁( ▁) ▁{ ▁Map ▁map ▁= ▁new ▁HashMap ▁( ▁) ▁; ▁map ▁= ▁( ▁Map ▁) ▁new ▁Al ways Map Plugin ▁( ▁) ▁. ▁plugin ▁( ▁map ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁map ▁. ▁get ▁( ▁STR ▁) ▁) ▁; ▁} ▁@ ▁Test ▁void ▁shouldNot Intercept ToString ▁( ▁) ▁{ ▁Map ▁map ▁= ▁new ▁HashMap ▁( ▁) ▁; ▁map ▁= ▁( ▁Map ▁) ▁new ▁Al ways Map Plugin ▁( ▁) ▁. ▁plugin ▁( ▁map ▁) ▁; ▁assertNotEquals ▁( ▁STR ▁, ▁map ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁@ ▁Inter cept s ▁( ▁{ ▁@ ▁Signature ▁( ▁type ▁= ▁Map ▁. ▁class ▁, ▁method ▁= ▁STR ▁, ▁args ▁= ▁{ ▁Object ▁. ▁class ▁} ▁) ▁} ▁) ▁public ▁static ▁class ▁Al ways Map Plugin ▁implements ▁Interceptor ▁{ ▁@ ▁Override ▁public ▁Object ▁intercept ▁( ▁Invocation ▁invocation ▁) ▁{ ▁return ▁STR ▁; ▁} ▁} ▁}
▁public ▁class ▁Regex p QueryBuilder ▁extends ▁Abstract QueryBuilder ▁< ▁Regex p QueryBuilder ▁> ▁implements ▁Multi Term QueryBuilder ▁{ ▁public ▁static ▁final ▁String ▁NAME ▁= ▁STR ▁; ▁public ▁static ▁final ▁int ▁DEFAULT _ FLAGS _ VALUE ▁= ▁Regex p Flag ▁. ▁ALL ▁. ▁value ▁( ▁) ▁; ▁public ▁static ▁final ▁int ▁DEFAULT _ MAX _ DE TERMIN I Z ED _ STATE S ▁= ▁Oper ations ▁. ▁DEFAULT _ MAX _ DE TERMIN I Z ED _ STATE S ▁; ▁public ▁static ▁final ▁boolean ▁DEFAULT _ CASE _ INS ENS IT IV ITY ▁= ▁false ▁; ▁private ▁static ▁final ▁ParseField ▁FLAG S _ VALUE _ FIELD ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁ParseField ▁MAX _ DE TERMIN I Z ED _ STATE S _ FIELD ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁ParseField ▁FLAG S _ FIELD ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁ParseField ▁CASE _ INSENSITIVE _ FIELD ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁ParseField ▁RE WRITE _ FIELD ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁ParseField ▁VALUE _ FIELD ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁private ▁final ▁String ▁fieldName ▁; ▁private ▁final ▁String ▁value ▁; ▁private ▁int ▁syn tax Flags Value ▁= ▁DEFAULT _ FLAGS _ VALUE ▁; ▁private ▁boolean ▁caseInsensitive ▁= ▁DEFAULT _ CASE _ INS ENS IT IV ITY ▁; ▁private ▁int ▁max Determin ized States ▁= ▁DEFAULT _ MAX _ DE TERMIN I Z ED _ STATE S ▁; ▁private ▁String ▁rewrite ▁; ▁public ▁Regex p QueryBuilder ▁( ▁String ▁fieldName ▁, ▁String ▁value ▁) ▁{ ▁if ▁( ▁Strings ▁. ▁isEmpty ▁( ▁fieldName ▁) ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁if ▁( ▁value ▁== ▁null ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁this ▁. ▁fieldName ▁= ▁fieldName ▁; ▁this ▁. ▁value ▁= ▁value ▁; ▁} ▁public ▁Regex p QueryBuilder ▁( ▁StreamInput ▁in ▁) ▁throws ▁IOException ▁{ ▁super ▁( ▁in ▁) ▁; ▁fieldName ▁= ▁in ▁. ▁readString ▁( ▁) ▁; ▁value ▁= ▁in ▁. ▁readString ▁( ▁) ▁; ▁syn tax Flags Value ▁= ▁in ▁. ▁readVInt ▁( ▁) ▁; ▁max Determin ized States ▁= ▁in ▁. ▁readVInt ▁( ▁) ▁; ▁rewrite ▁= ▁in ▁. ▁read OptionalString ▁( ▁) ▁; ▁if ▁( ▁in ▁. ▁getVersion ▁( ▁) ▁. ▁onOrAfter ▁( ▁Version ▁. ▁V _7 _10 _0 ▁) ▁) ▁{ ▁caseInsensitive ▁= ▁in ▁. ▁readBoolean ▁( ▁) ▁; ▁} ▁} ▁@ ▁Override ▁protected ▁void ▁do WriteTo ▁( ▁StreamOutput ▁out ▁) ▁throws ▁IOException ▁{ ▁out ▁. ▁writeString ▁( ▁fieldName ▁) ▁; ▁out ▁. ▁writeString ▁( ▁value ▁) ▁; ▁out ▁. ▁writeVInt ▁( ▁syn tax Flags Value ▁) ▁; ▁out ▁. ▁writeVInt ▁( ▁max Determin ized States ▁) ▁; ▁out ▁. ▁write OptionalString ▁( ▁rewrite ▁) ▁; ▁if ▁( ▁out ▁. ▁getVersion ▁( ▁) ▁. ▁onOrAfter ▁( ▁Version ▁. ▁V _7 _10 _0 ▁) ▁) ▁{ ▁out ▁. ▁writeBoolean ▁( ▁caseInsensitive ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁String ▁fieldName ▁( ▁) ▁{ ▁return ▁this ▁. ▁fieldName ▁; ▁}
▁public ▁class ▁Open ALL wjgl 3 Audio ▁implements ▁Lwjgl 3 Audio ▁{ ▁private ▁final ▁int ▁device BufferSize ▁; ▁private ▁final ▁int ▁device Buffer Count ▁; ▁private ▁IntArray ▁idle Sources ▁, ▁all Sources ▁; ▁private ▁Long Map ▁< ▁Integer ▁> ▁sound Id To Source ▁; ▁private ▁Int Map ▁< ▁Long ▁> ▁source To S ound Id ▁; ▁private ▁long ▁next S ound Id ▁= ▁0 ▁; ▁private ▁Object Map ▁< ▁String ▁, ▁Class ▁< ▁? ▁extends ▁Open AL S ound ▁> ▁> ▁extension To S ound Class ▁= ▁new ▁Object Map ▁( ▁) ▁; ▁private ▁Object Map ▁< ▁String ▁, ▁Class ▁< ▁? ▁extends ▁Open AL M us ic ▁> ▁> ▁extension To M us ic Class ▁= ▁new ▁Object Map ▁( ▁) ▁; ▁private ▁Open AL S ound ▁[ ▁] ▁rec ent S ound s ▁; ▁private ▁int ▁m ost Rec et S ound ▁= ▁- ▁1 ▁; ▁Array ▁< ▁Open AL M us ic ▁> ▁m us ic ▁= ▁new ▁Array ▁( ▁false ▁, ▁1 ▁, ▁Open AL M us ic ▁. ▁class ▁) ▁; ▁long ▁device ▁; ▁long ▁context ▁; ▁boolean ▁no Device ▁= ▁false ▁; ▁public ▁Open ALL wjgl 3 Audio ▁( ▁) ▁{ ▁this ▁( ▁16 ▁, ▁9 ▁, ▁512 ▁) ▁; ▁} ▁public ▁Open ALL wjgl 3 Audio ▁( ▁int ▁sim ult an eo us Sources ▁, ▁int ▁device Buffer Count ▁, ▁int ▁device BufferSize ▁) ▁{ ▁this ▁. ▁device BufferSize ▁= ▁device BufferSize ▁; ▁this ▁. ▁device Buffer Count ▁= ▁device Buffer Count ▁; ▁register S ound ▁( ▁STR ▁, ▁O gg ▁. ▁S ound ▁. ▁class ▁) ▁; ▁register M us ic ▁( ▁STR ▁, ▁O gg ▁. ▁M us ic ▁. ▁class ▁) ▁; ▁register S ound ▁( ▁STR ▁, ▁W av ▁. ▁S ound ▁. ▁class ▁) ▁; ▁register M us ic ▁( ▁STR ▁, ▁W av ▁. ▁M us ic ▁. ▁class ▁) ▁; ▁register S ound ▁( ▁STR ▁, ▁M p 3 ▁. ▁S ound ▁. ▁class ▁) ▁; ▁register M us ic ▁( ▁STR ▁, ▁M p 3 ▁. ▁M us ic ▁. ▁class ▁) ▁; ▁device ▁= ▁al c Open Device ▁( ▁( ▁ByteBuffer ▁) ▁null ▁) ▁; ▁if ▁( ▁device ▁== ▁0 L ▁) ▁{ ▁no Device ▁= ▁true ▁; ▁return ▁; ▁} ▁AL C Capabilities ▁device Capabilities ▁= ▁AL C ▁. ▁create Capabilities ▁( ▁device ▁) ▁; ▁context ▁= ▁al c Create Context ▁( ▁device ▁, ▁( ▁Int Buffer ▁) ▁null ▁) ▁; ▁if ▁( ▁context ▁== ▁0 L ▁) ▁{ ▁al c Close Device ▁( ▁device ▁) ▁; ▁no Device ▁= ▁true ▁; ▁return ▁; ▁} ▁if ▁( ▁! ▁al c M ake Context Current ▁( ▁context ▁) ▁) ▁{ ▁no Device ▁= ▁true ▁; ▁return ▁; ▁} ▁AL ▁. ▁create Capabilities ▁( ▁device Capabilities ▁) ▁; ▁al Get Error ▁( ▁) ▁; ▁all Sources ▁= ▁new ▁IntArray ▁( ▁false ▁, ▁sim ult an eo us Sources ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁sim ult an eo us Sources ▁;
▁file Chooser Panel ▁= ▁new ▁Ghidra FileChooser Panel ▁( ▁STR ▁, ▁preferences Key ▁, ▁default O u pt ut FilePath ▁, ▁true ▁, ▁Ghidra FileChooser Panel ▁. ▁OUTPUT _ MODE ▁) ▁; ▁JButton ▁run Button ▁= ▁new ▁JButton ▁( ▁STR ▁) ▁; ▁run Button ▁. ▁addAction Listener ▁( ▁e ▁-> ▁model ▁. ▁reload ▁( ▁) ▁) ▁; ▁JPanel ▁run Button Panel ▁= ▁new ▁JPanel ▁( ▁new ▁M id dle Layout ▁( ▁) ▁) ▁; ▁run Button Panel ▁. ▁add ▁( ▁run Button ▁) ▁; ▁button Panel ▁. ▁add ▁( ▁file Chooser Panel ▁, ▁BorderLayout ▁. ▁N OR TH ▁) ▁; ▁button Panel ▁. ▁add ▁( ▁run Button Panel ▁, ▁BorderLayout ▁. ▁CENTER ▁) ▁; ▁return ▁button Panel ▁; ▁} ▁private ▁List ▁< ▁Function Algorithm ▁> ▁find Al gorithms ▁( ▁) ▁{ ▁return ▁new ▁ArrayList ▁< ▁> ▁( ▁Class Searcher ▁. ▁getInstances ▁( ▁Function Algorithm ▁. ▁class ▁) ▁) ▁; ▁} ▁private ▁Component ▁build Table Panel ▁( ▁) ▁{ ▁JPanel ▁panel ▁= ▁new ▁JPanel ▁( ▁new ▁BorderLayout ▁( ▁) ▁) ▁; ▁panel ▁. ▁setBorder ▁( ▁BorderFactory ▁. ▁createEmpty Border ▁( ▁3 ▁, ▁3 ▁, ▁3 ▁, ▁3 ▁) ▁) ▁; ▁model ▁= ▁new ▁Sample TableModel ▁( ▁plugin ▁) ▁; ▁filter Table ▁= ▁new ▁G Filter Table ▁< ▁> ▁( ▁model ▁) ▁; ▁panel ▁. ▁add ▁( ▁filter Table ▁) ▁; ▁return ▁panel ▁; ▁} ▁private ▁void ▁create Actions ▁( ▁) ▁{ ▁DockingAction ▁options Action ▁= ▁new ▁DockingAction ▁( ▁STR ▁, ▁plugin ▁. ▁getName ▁( ▁) ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁actionPerformed ▁( ▁ActionContext ▁context ▁) ▁{ ▁Options Service ▁service ▁= ▁tool ▁. ▁getService ▁( ▁Options Service ▁. ▁class ▁) ▁; ▁service ▁. ▁show Options Dialog ▁( ▁OPTION S _ TITLE ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁isEnabledFor Context ▁( ▁ActionContext ▁context ▁) ▁{ ▁return ▁tool ▁. ▁getService ▁( ▁Options Service ▁. ▁class ▁) ▁!= ▁null ▁; ▁} ▁} ▁; ▁ImageIcon ▁icon ▁= ▁ResourceManager ▁. ▁loadImage ▁( ▁STR ▁) ▁; ▁options Action ▁. ▁setTool BarData ▁( ▁new ▁ToolBarData ▁( ▁icon ▁) ▁) ▁; ▁DockingAction ▁save Table Data Action ▁= ▁new ▁DockingAction ▁( ▁STR ▁, ▁plugin ▁. ▁getName ▁( ▁) ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁actionPerformed ▁( ▁ActionContext ▁context ▁) ▁{ ▁StringBuilder ▁buffer ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁buffer ▁. ▁append ▁( ▁STR ▁) ▁; ▁buffer ▁. ▁append ▁( ▁HTML Utilities ▁. ▁escape HTML ▁( ▁file Chooser Panel ▁. ▁getFileName ▁( ▁) ▁) ▁) ▁; ▁List ▁< ▁Function Stats RowObject ▁> ▁selected Objects ▁= ▁filter Table ▁. ▁getSelected Row Objects ▁( ▁) ▁; ▁for ▁( ▁Function Stats RowObject ▁stats ▁: ▁selected Objects ▁) ▁{ ▁buffer ▁. ▁append ▁( ▁STR ▁+ ▁stats ▁. ▁getAlgorithm Name ▁( ▁) ▁) ▁; ▁} ▁Msg ▁. ▁show Info ▁( ▁this ▁, ▁filter Table ▁, ▁STR ▁, ▁HTML Utilities ▁. ▁to HTML ▁( ▁buffer ▁. ▁toString ▁( ▁) ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁isEnabledFor Context ▁( ▁ActionContext ▁context ▁) ▁{ ▁return ▁filter Table ▁. ▁getSelected Row Objects ▁( ▁) ▁. ▁size ▁( ▁) ▁> ▁0 ▁; ▁}
▁public ▁class ▁A PT Code Model Helper ▁{ ▁private ▁static ▁final ▁List ▁< ▁String ▁> ▁IG NO RED _ ANNOTATIONS ▁= ▁Collections ▁. ▁singletonList ▁( ▁STR ▁) ▁; ▁private ▁Android Annotations Environment ▁environment ▁; ▁public ▁A PT Code Model Helper ▁( ▁Android Annotations Environment ▁environment ▁) ▁{ ▁this ▁. ▁environment ▁= ▁environment ▁; ▁} ▁public ▁Abstract JClass ▁type Mirror To JClass ▁( ▁TypeMirror ▁type ▁) ▁{ ▁return ▁type Mirror To JClass ▁( ▁type ▁, ▁Collections ▁. ▁< ▁String ▁, ▁TypeMirror ▁> ▁emptyMap ▁( ▁) ▁) ▁; ▁} ▁private ▁Abstract JClass ▁type Mirror To JClass ▁( ▁TypeMirror ▁type ▁, ▁Map ▁< ▁String ▁, ▁TypeMirror ▁> ▁sub stit ute ▁) ▁{ ▁if ▁( ▁type ▁instanceof ▁Declared Type ▁) ▁{ ▁return ▁type Mirror To JClass ▁( ▁( ▁Declared Type ▁) ▁type ▁, ▁sub stit ute ▁) ▁; ▁} ▁else ▁if ▁( ▁type ▁instanceof ▁Wildcard Type ▁) ▁{ ▁return ▁type Mirror To JClass ▁( ▁( ▁Wildcard Type ▁) ▁type ▁, ▁sub stit ute ▁) ▁; ▁} ▁else ▁if ▁( ▁type ▁instanceof ▁ArrayType ▁) ▁{ ▁return ▁type Mirror To JClass ▁( ▁( ▁ArrayType ▁) ▁type ▁, ▁sub stit ute ▁) ▁; ▁} ▁else ▁{ ▁TypeMirror ▁sub stit uted ▁= ▁sub stit ute ▁. ▁get ▁( ▁type ▁. ▁toString ▁( ▁) ▁) ▁; ▁if ▁( ▁sub stit uted ▁!= ▁null ▁&& ▁type ▁!= ▁sub stit uted ▁) ▁{ ▁return ▁type Mirror To JClass ▁( ▁sub stit uted ▁, ▁sub stit ute ▁) ▁; ▁} ▁return ▁environment ▁. ▁getJ Class ▁( ▁type ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁} ▁private ▁Abstract JClass ▁type Mirror To JClass ▁( ▁Declared Type ▁declared Type ▁, ▁Map ▁< ▁String ▁, ▁TypeMirror ▁> ▁sub stit ute ▁) ▁{ ▁String ▁declared TypeName ▁= ▁declared Type ▁. ▁as Element ▁( ▁) ▁. ▁toString ▁( ▁) ▁; ▁Abstract JClass ▁declared Class ▁= ▁environment ▁. ▁getJ Class ▁( ▁declared TypeName ▁) ▁; ▁List ▁< ▁? ▁extends ▁TypeMirror ▁> ▁type Arguments ▁= ▁declared Type ▁. ▁getType Arguments ▁( ▁) ▁; ▁List ▁< ▁Abstract JClass ▁> ▁type Argument J Classes ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁TypeMirror ▁type Argument ▁: ▁type Arguments ▁) ▁{ ▁type Argument J Classes ▁. ▁add ▁( ▁type Mirror To JClass ▁( ▁type Argument ▁, ▁sub stit ute ▁) ▁) ▁; ▁} ▁if ▁( ▁type Argument J Classes ▁. ▁size ▁( ▁) ▁> ▁0 ▁) ▁{ ▁declared Class ▁= ▁declared Class ▁. ▁n arrow ▁( ▁type Argument J Classes ▁) ▁; ▁} ▁return ▁declared Class ▁; ▁} ▁private ▁Abstract JClass ▁type Mirror To JClass ▁( ▁Wildcard Type ▁w ildcard Type ▁, ▁Map ▁< ▁String ▁, ▁TypeMirror ▁> ▁sub stit ute ▁) ▁{ ▁TypeMirror ▁bound ▁= ▁w ildcard Type ▁. ▁get Ext ends Bound ▁( ▁) ▁; ▁if ▁( ▁bound ▁== ▁null ▁) ▁{ ▁bound ▁= ▁w ildcard Type ▁. ▁getSuper Bound ▁( ▁) ▁; ▁if ▁( ▁bound ▁== ▁null ▁) ▁{ ▁return ▁environment ▁. ▁getClasses ▁( ▁) ▁. ▁OBJECT ▁. ▁w ildcard Ext ends ▁( ▁) ▁; ▁} ▁return ▁type Mirror To JClass ▁( ▁bound ▁, ▁sub stit ute ▁) ▁. ▁w ildcard Super ▁( ▁) ▁; ▁}
▁public ▁void ▁test Per form Action Failure ▁( ▁) ▁{ ▁String ▁indexName ▁= ▁randomAlpha OfLength ▁( ▁10 ▁) ▁; ▁String ▁policy Name ▁= ▁STR ▁; ▁{ ▁IndexMetadata ▁. ▁Builder ▁indexMetadata Builder ▁= ▁IndexMetadata ▁. ▁builder ▁( ▁indexName ▁) ▁. ▁settings ▁( ▁settings ▁( ▁Version ▁. ▁CURRENT ▁) ▁. ▁put ▁( ▁Lifecycle Settings ▁. ▁LI F EC YCLE _ NAME ▁, ▁policy Name ▁) ▁) ▁. ▁numberOf Shards ▁( ▁randomInt Between ▁( ▁1 ▁, ▁5 ▁) ▁) ▁. ▁numberOf Replicas ▁( ▁randomInt Between ▁( ▁0 ▁, ▁5 ▁) ▁) ▁; ▁IndexMetadata ▁indexMetadata ▁= ▁indexMetadata Builder ▁. ▁build ▁( ▁) ▁; ▁ClusterState ▁clusterState ▁= ▁ClusterState ▁. ▁builder ▁( ▁empty ClusterState ▁( ▁) ▁) ▁. ▁metadata ▁( ▁Metadata ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁indexMetadata ▁, ▁true ▁) ▁. ▁build ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁Mount Snapshot Step ▁mount Snapshot Step ▁= ▁createRandom Instance ▁( ▁) ▁; ▁Exception ▁e ▁= ▁expectThrows ▁( ▁Illegal StateException ▁. ▁class ▁, ▁( ▁) ▁-> ▁Plain ActionFuture ▁. ▁< ▁Boolean ▁, ▁Exception ▁> ▁get ▁( ▁f ▁-> ▁mount Snapshot Step ▁. ▁performAction ▁( ▁indexMetadata ▁, ▁clusterState ▁, ▁null ▁, ▁f ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁is ▁( ▁STR ▁+ ▁policy Name ▁+ ▁STR ▁+ ▁indexName ▁+ ▁STR ▁) ▁) ▁; ▁} ▁{ ▁IndexMetadata ▁. ▁Builder ▁indexMetadata Builder ▁= ▁IndexMetadata ▁. ▁builder ▁( ▁indexName ▁) ▁. ▁settings ▁( ▁settings ▁( ▁Version ▁. ▁CURRENT ▁) ▁. ▁put ▁( ▁Lifecycle Settings ▁. ▁LI F EC YCLE _ NAME ▁, ▁policy Name ▁) ▁) ▁. ▁numberOf Shards ▁( ▁randomInt Between ▁( ▁1 ▁, ▁5 ▁) ▁) ▁. ▁numberOf Replicas ▁( ▁randomInt Between ▁( ▁0 ▁, ▁5 ▁) ▁) ▁; ▁Map ▁< ▁String ▁, ▁String ▁> ▁ilm Custom ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁String ▁repository ▁= ▁STR ▁; ▁ilm Custom ▁. ▁put ▁( ▁STR ▁, ▁repository ▁) ▁; ▁indexMetadata Builder ▁. ▁put Custom ▁( ▁Lifecycle ExecutionState ▁. ▁I L M _ C USTOM _ METADATA _ KEY ▁, ▁ilm Custom ▁) ▁; ▁IndexMetadata ▁indexMetadata ▁= ▁indexMetadata Builder ▁. ▁build ▁( ▁) ▁; ▁ClusterState ▁clusterState ▁= ▁ClusterState ▁. ▁builder ▁( ▁empty ClusterState ▁( ▁) ▁) ▁. ▁metadata ▁( ▁Metadata ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁indexMetadata ▁, ▁true ▁) ▁. ▁build ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁Mount Snapshot Step ▁mount Snapshot Step ▁= ▁createRandom Instance ▁( ▁) ▁; ▁Exception ▁e ▁= ▁expectThrows ▁( ▁Illegal StateException ▁. ▁class ▁, ▁( ▁) ▁-> ▁Plain ActionFuture ▁. ▁< ▁Boolean ▁, ▁Exception ▁> ▁get ▁( ▁f ▁-> ▁mount Snapshot Step ▁. ▁performAction ▁( ▁indexMetadata ▁, ▁clusterState ▁, ▁null ▁, ▁f ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁is ▁( ▁STR ▁+ ▁policy Name ▁+ ▁STR ▁+ ▁indexName ▁+ ▁STR ▁) ▁) ▁; ▁} ▁} ▁public ▁void ▁test Per form Action ▁( ▁) ▁{ ▁String ▁indexName ▁= ▁randomAlpha OfLength ▁( ▁10 ▁) ▁; ▁String ▁policy Name ▁= ▁STR ▁; ▁Map ▁< ▁String ▁, ▁String ▁> ▁ilm Custom ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁String ▁snapshot Name ▁= ▁indexName ▁+ ▁STR ▁+ ▁policy Name ▁;
▁@ ▁RunWith ▁( ▁MockitoJUnit Runner ▁. ▁class ▁) ▁public ▁final ▁class ▁Drop User Statement Event Mapper Test ▁{ ▁@ ▁Test ▁public ▁void ▁assert Map To Drop User Statement Event ▁( ▁) ▁{ ▁Drop User Statement Event Mapper ▁drop User Statement Event Mapper ▁= ▁new ▁Drop User Statement Event Mapper ▁( ▁) ▁; ▁Drop User Statement Event ▁drop User Statement Event ▁= ▁drop User Statement Event Mapper ▁. ▁map ▁( ▁getD rop User Statement ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁drop User Statement Event ▁. ▁getUser s ▁( ▁) ▁. ▁size ▁( ▁) ▁, ▁is ▁( ▁1 ▁) ▁) ▁; ▁assertThat ▁( ▁drop User Statement Event ▁. ▁getUser s ▁( ▁) ▁. ▁iterator ▁( ▁) ▁. ▁next ▁( ▁) ▁, ▁is ▁( ▁STR ▁) ▁) ▁; ▁} ▁private ▁Drop User Statement ▁getD rop User Statement ▁( ▁) ▁{ ▁MySQL Drop User Statement ▁result ▁= ▁new ▁MySQL Drop User Statement ▁( ▁) ▁; ▁result ▁. ▁getUser s ▁( ▁) ▁. ▁add ▁( ▁STR ▁) ▁; ▁return ▁result ▁; ▁} ▁}
▁class ▁Pipe s Non Java InputFormat ▁implements ▁InputFormat ▁< ▁Float Writable ▁, ▁Null Writable ▁> ▁{ ▁public ▁RecordReader ▁< ▁Float Writable ▁, ▁Null Writable ▁> ▁get RecordReader ▁( ▁InputSplit ▁generic Split ▁, ▁JobConf ▁job ▁, ▁Reporter ▁reporter ▁) ▁throws ▁IOException ▁{ ▁return ▁new ▁Pipe s Dummy RecordReader ▁( ▁job ▁, ▁generic Split ▁) ▁; ▁} ▁public ▁InputSplit ▁[ ▁] ▁getSplit s ▁( ▁JobConf ▁job ▁, ▁int ▁num Splits ▁) ▁throws ▁IOException ▁{ ▁return ▁ReflectionUtils ▁. ▁newInstance ▁( ▁job ▁. ▁getClass ▁( ▁Submit ter ▁. ▁INPUT _ FORMAT ▁, ▁Text InputFormat ▁. ▁class ▁, ▁InputFormat ▁. ▁class ▁) ▁, ▁job ▁) ▁. ▁getSplit s ▁( ▁job ▁, ▁num Splits ▁) ▁; ▁} ▁static ▁class ▁Pipe s Dummy RecordReader ▁implements ▁RecordReader ▁< ▁Float Writable ▁, ▁Null Writable ▁> ▁{ ▁float ▁progress ▁= ▁0.0 f ▁; ▁public ▁Pipe s Dummy RecordReader ▁( ▁Configuration ▁job ▁, ▁InputSplit ▁split ▁) ▁throws ▁IOException ▁{ ▁} ▁public ▁Float Writable ▁createKey ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁public ▁Null Writable ▁createValue ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁public ▁synchronized ▁void ▁close ▁( ▁) ▁throws ▁IOException ▁{ ▁} ▁public ▁synchronized ▁long ▁getPos ▁( ▁) ▁throws ▁IOException ▁{ ▁return ▁0 ▁; ▁} ▁public ▁float ▁getProgress ▁( ▁) ▁{ ▁return ▁progress ▁; ▁} ▁public ▁synchronized ▁boolean ▁next ▁( ▁Float Writable ▁key ▁, ▁Null Writable ▁value ▁) ▁throws ▁IOException ▁{ ▁progress ▁= ▁key ▁. ▁get ▁( ▁) ▁; ▁return ▁true ▁; ▁} ▁} ▁}
▁Assert ▁. ▁assertEquals ▁( ▁TriState ▁. ▁FALSE ▁, ▁info ▁. ▁getException Seen ▁( ▁1 ▁) ▁) ▁; ▁info ▁= ▁profile ▁( ▁STR ▁, ▁true ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁TriState ▁. ▁TRUE ▁, ▁info ▁. ▁getException Seen ▁( ▁1 ▁) ▁) ▁; ▁reset Profile ▁( ▁STR ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁TriState ▁. ▁FALSE ▁, ▁info ▁. ▁getException Seen ▁( ▁1 ▁) ▁) ▁; ▁} ▁public ▁static ▁int ▁null Pointer Exception Snippet ▁( ▁Object ▁obj ▁) ▁{ ▁try ▁{ ▁return ▁obj ▁. ▁hashCode ▁( ▁) ▁; ▁} ▁catch ▁( ▁NullPointer Exception ▁e ▁) ▁{ ▁return ▁1 ▁; ▁} ▁} ▁public ▁static ▁int ▁array Index OutOfBounds Exception Snippet ▁( ▁int ▁[ ▁] ▁array ▁) ▁{ ▁try ▁{ ▁return ▁array ▁[ ▁0 ▁] ▁; ▁} ▁catch ▁( ▁Array Index OutOfBounds Exception ▁e ▁) ▁{ ▁return ▁1 ▁; ▁} ▁} ▁public ▁static ▁int ▁check CastException Snippet ▁( ▁Object ▁obj ▁) ▁{ ▁try ▁{ ▁return ▁( ▁( ▁String ▁) ▁obj ▁) ▁. ▁length ▁( ▁) ▁; ▁} ▁catch ▁( ▁Class CastException ▁e ▁) ▁{ ▁return ▁1 ▁; ▁} ▁} ▁public ▁static ▁int ▁invoke WithException Snippet ▁( ▁boolean ▁doThrow ▁) ▁{ ▁try ▁{ ▁return ▁throwException ▁( ▁doThrow ▁) ▁; ▁} ▁catch ▁( ▁IllegalArgument Exception ▁e ▁) ▁{ ▁return ▁1 ▁; ▁} ▁} ▁private ▁static ▁int ▁throwException ▁( ▁boolean ▁doThrow ▁) ▁{ ▁if ▁( ▁doThrow ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁) ▁; ▁} ▁else ▁{ ▁return ▁1 ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁testNull Seen ▁( ▁) ▁{ ▁testNull Seen ▁( ▁STR ▁) ▁; ▁testNull Seen ▁( ▁STR ▁) ▁; ▁} ▁private ▁void ▁testNull Seen ▁( ▁String ▁snippet ▁) ▁{ ▁Pro filing Info ▁info ▁= ▁profile ▁( ▁snippet ▁, ▁1 ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁TriState ▁. ▁FALSE ▁, ▁info ▁. ▁get Null Seen ▁( ▁1 ▁) ▁) ▁; ▁continue Pro filing ▁( ▁snippet ▁, ▁STR ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁TriState ▁. ▁FALSE ▁, ▁info ▁. ▁get Null Seen ▁( ▁1 ▁) ▁) ▁; ▁continue Pro filing ▁( ▁snippet ▁, ▁new ▁Object ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁TriState ▁. ▁FALSE ▁, ▁info ▁. ▁get Null Seen ▁( ▁1 ▁) ▁) ▁; ▁if ▁( ▁TriState ▁. ▁TRUE ▁== ▁info ▁. ▁get Null Seen ▁( ▁1 ▁) ▁) ▁{ ▁continue Pro filing ▁( ▁snippet ▁, ▁( ▁Object ▁) ▁null ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁TriState ▁. ▁TRUE ▁, ▁info ▁. ▁get Null Seen ▁( ▁1 ▁) ▁) ▁; ▁continue Pro filing ▁( ▁snippet ▁, ▁0.0 ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁TriState ▁. ▁TRUE ▁, ▁info ▁. ▁get Null Seen ▁( ▁1 ▁) ▁) ▁; ▁continue Pro filing ▁( ▁snippet ▁, ▁new ▁Object ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁TriState ▁. ▁TRUE ▁, ▁info ▁. ▁get Null Seen ▁( ▁1 ▁) ▁) ▁; ▁} ▁reset Profile ▁( ▁snippet ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁TriState ▁. ▁FALSE ▁, ▁info ▁. ▁get Null Seen ▁( ▁1 ▁) ▁) ▁; ▁}
▁@ ▁Window Function Signature ▁( ▁name ▁= ▁STR ▁, ▁returnType ▁= ▁STR ▁) ▁public ▁class ▁Row Number Function ▁extends ▁Rank ingWindow Function ▁{ ▁@ ▁Override ▁public ▁void ▁process Row ▁( ▁BlockBuilder ▁output ▁, ▁boolean ▁new Peer Group ▁, ▁int ▁peer Group Count ▁, ▁int ▁current Position ▁) ▁{ ▁BIGINT ▁. ▁writeLong ▁( ▁output ▁, ▁current Position ▁+ ▁1 ▁) ▁; ▁} ▁}
▁DataSource ▁< ▁Tuple 3 ▁< ▁Long ▁, ▁Some Pojo ▁, ▁String ▁> ▁> ▁data ▁= ▁env ▁. ▁from Collection ▁( ▁tuple 3 Pojo Data ▁, ▁tuple 3 Pojo Type ▁) ▁; ▁data ▁. ▁getSplit Data Properties ▁( ▁) ▁. ▁splits Partition ed By ▁( ▁STR ▁) ▁; ▁data ▁. ▁output ▁( ▁new ▁Discarding OutputFormat ▁< ▁Tuple 3 ▁< ▁Long ▁, ▁Some Pojo ▁, ▁String ▁> ▁> ▁( ▁) ▁) ▁; ▁Plan ▁plan ▁= ▁env ▁. ▁create Program Plan ▁( ▁) ▁; ▁Optimized Plan ▁o Plan ▁= ▁compile No Stats ▁( ▁plan ▁) ▁; ▁Sink PlanNode ▁sink Node ▁= ▁o Plan ▁. ▁getData Sink s ▁( ▁) ▁. ▁iterator ▁( ▁) ▁. ▁next ▁( ▁) ▁; ▁Source PlanNode ▁source Node ▁= ▁( ▁Source PlanNode ▁) ▁sink Node ▁. ▁getPre decessor ▁( ▁) ▁; ▁Global Properties ▁g pro ps ▁= ▁source Node ▁. ▁getGlobal Properties ▁( ▁) ▁; ▁LocalProperties ▁l pro ps ▁= ▁source Node ▁. ▁getLocal Properties ▁( ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁( ▁new ▁FieldSet ▁( ▁g pro ps ▁. ▁getPartition ing Fields ▁( ▁) ▁. ▁toArray ▁( ▁) ▁) ▁) ▁. ▁equals ▁( ▁new ▁FieldSet ▁( ▁1 ▁, ▁2 ▁, ▁3 ▁) ▁) ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁g pro ps ▁. ▁getPartition ing ▁( ▁) ▁== ▁Partition ing Property ▁. ▁ANY _ PARTITION ING ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁l pro ps ▁. ▁getGroup ed Fields ▁( ▁) ▁== ▁null ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁l pro ps ▁. ▁getOrder ing ▁( ▁) ▁== ▁null ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁check Single Partition ed Source 5 ▁( ▁) ▁{ ▁Execution Environment ▁env ▁= ▁Execution Environment ▁. ▁createLocal Environment ▁( ▁) ▁; ▁env ▁. ▁setParallelism ▁( ▁DEFAULT _ PAR ALLELISM ▁) ▁; ▁DataSource ▁< ▁Tuple 3 ▁< ▁Long ▁, ▁Some Pojo ▁, ▁String ▁> ▁> ▁data ▁= ▁env ▁. ▁from Collection ▁( ▁tuple 3 Pojo Data ▁, ▁tuple 3 Pojo Type ▁) ▁; ▁data ▁. ▁getSplit Data Properties ▁( ▁) ▁. ▁splits Partition ed By ▁( ▁STR ▁) ▁; ▁data ▁. ▁output ▁( ▁new ▁Discarding OutputFormat ▁< ▁Tuple 3 ▁< ▁Long ▁, ▁Some Pojo ▁, ▁String ▁> ▁> ▁( ▁) ▁) ▁; ▁Plan ▁plan ▁= ▁env ▁. ▁create Program Plan ▁( ▁) ▁; ▁Optimized Plan ▁o Plan ▁= ▁compile No Stats ▁( ▁plan ▁) ▁; ▁Sink PlanNode ▁sink Node ▁= ▁o Plan ▁. ▁getData Sink s ▁( ▁) ▁. ▁iterator ▁( ▁) ▁. ▁next ▁( ▁) ▁; ▁Source PlanNode ▁source Node ▁= ▁( ▁Source PlanNode ▁) ▁sink Node ▁. ▁getPre decessor ▁( ▁) ▁; ▁Global Properties ▁g pro ps ▁= ▁source Node ▁. ▁getGlobal Properties ▁( ▁) ▁; ▁LocalProperties ▁l pro ps ▁= ▁source Node ▁. ▁getLocal Properties ▁( ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁( ▁new ▁FieldSet ▁( ▁g pro ps ▁. ▁getPartition ing Fields ▁( ▁) ▁. ▁toArray ▁( ▁) ▁) ▁) ▁. ▁equals ▁( ▁new ▁FieldSet ▁( ▁3 ▁) ▁) ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁g pro ps ▁. ▁getPartition ing ▁( ▁) ▁== ▁Partition ing Property ▁. ▁ANY _ PARTITION ING ▁) ▁;
▁@ ▁Test ▁public ▁void ▁test Cancel Reduce Task While Re ducing ▁( ▁) ▁{ ▁final ▁int ▁key Cnt ▁= ▁1000 ▁; ▁final ▁int ▁val Cnt ▁= ▁2 ▁; ▁addInput ▁( ▁new ▁Un iform Record Generator ▁( ▁key Cnt ▁, ▁val Cnt ▁, ▁true ▁) ▁) ▁; ▁add Driver Comparator ▁( ▁this ▁. ▁comparator ▁) ▁; ▁setOutput ▁( ▁new ▁N ir v ana Output List ▁( ▁) ▁) ▁; ▁getTask Config ▁( ▁) ▁. ▁setDriver Strategy ▁( ▁DriverStrategy ▁. ▁S ORTED _ GROUP _ RED UCE ▁) ▁; ▁final ▁Group Reduce Driver ▁< ▁Record ▁, ▁Record ▁> ▁test Task ▁= ▁new ▁Group Reduce Driver ▁< ▁> ▁( ▁) ▁; ▁final ▁AtomicBoolean ▁success ▁= ▁new ▁AtomicBoolean ▁( ▁false ▁) ▁; ▁Thread ▁task Runner ▁= ▁new ▁Thread ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁run ▁( ▁) ▁{ ▁try ▁{ ▁test Driver ▁( ▁test Task ▁, ▁Mock Delay ing Reduce Stub ▁. ▁class ▁) ▁; ▁success ▁. ▁set ▁( ▁true ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁ie ▁) ▁{ ▁ie ▁. ▁printStackTrace ▁( ▁) ▁; ▁} ▁} ▁} ▁; ▁task Runner ▁. ▁start ▁( ▁) ▁; ▁Task Cancel Thread ▁t ct ▁= ▁new ▁Task Cancel Thread ▁( ▁2 ▁, ▁task Runner ▁, ▁this ▁) ▁; ▁t ct ▁. ▁start ▁( ▁) ▁; ▁try ▁{ ▁t ct ▁. ▁join ▁( ▁) ▁; ▁task Runner ▁. ▁join ▁( ▁) ▁; ▁} ▁catch ▁( ▁Interrupted Exception ▁ie ▁) ▁{ ▁Assert ▁. ▁fail ▁( ▁STR ▁) ▁; ▁} ▁} ▁public ▁static ▁class ▁Mock Reduce Stub ▁extends ▁Rich Group Reduce Function ▁< ▁Record ▁, ▁Record ▁> ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁private ▁final ▁IntValue ▁key ▁= ▁new ▁IntValue ▁( ▁) ▁; ▁private ▁final ▁IntValue ▁value ▁= ▁new ▁IntValue ▁( ▁) ▁; ▁@ ▁Override ▁public ▁void ▁reduce ▁( ▁Iterable ▁< ▁Record ▁> ▁records ▁, ▁Collector ▁< ▁Record ▁> ▁out ▁) ▁{ ▁Record ▁element ▁= ▁null ▁; ▁int ▁cnt ▁= ▁0 ▁; ▁for ▁( ▁Record ▁next ▁: ▁records ▁) ▁{ ▁element ▁= ▁next ▁; ▁cnt ▁++ ▁; ▁} ▁element ▁. ▁getField ▁( ▁0 ▁, ▁this ▁. ▁key ▁) ▁; ▁this ▁. ▁value ▁. ▁setValue ▁( ▁cnt ▁- ▁this ▁. ▁key ▁. ▁getValue ▁( ▁) ▁) ▁; ▁element ▁. ▁setField ▁( ▁1 ▁, ▁this ▁. ▁value ▁) ▁; ▁out ▁. ▁collect ▁( ▁element ▁) ▁; ▁} ▁} ▁public ▁static ▁class ▁Mock Comb ining Reduce Stub ▁implements ▁Group Reduce Function ▁< ▁Record ▁, ▁Record ▁> ▁, ▁Group Combine Function ▁< ▁Record ▁, ▁Record ▁> ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁private ▁final ▁IntValue ▁key ▁= ▁new ▁IntValue ▁( ▁) ▁; ▁private ▁final ▁IntValue ▁value ▁= ▁new ▁IntValue ▁( ▁) ▁; ▁private ▁final ▁IntValue ▁combine Value ▁= ▁new ▁IntValue ▁( ▁) ▁; ▁@ ▁Override ▁public ▁void ▁reduce ▁( ▁Iterable ▁< ▁Record ▁> ▁records ▁, ▁Collector ▁< ▁Record ▁> ▁out ▁) ▁{ ▁Record ▁element ▁= ▁null ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁Record ▁next ▁: ▁records ▁) ▁{ ▁element ▁= ▁next ▁; ▁element ▁. ▁getField ▁( ▁1 ▁, ▁this ▁. ▁value ▁) ▁;
▁public ▁class ▁Put License Action ▁extends ▁ActionType ▁< ▁Put License Response ▁> ▁{ ▁public ▁static ▁final ▁Put License Action ▁INSTANCE ▁= ▁new ▁Put License Action ▁( ▁) ▁; ▁public ▁static ▁final ▁String ▁NAME ▁= ▁STR ▁; ▁private ▁Put License Action ▁( ▁) ▁{ ▁super ▁( ▁NAME ▁, ▁Put License Response ▁:: ▁new ▁) ▁; ▁} ▁}
▁secondary Rect Drawable ▁. ▁setBounds ▁( ▁temp Rect ▁) ▁; ▁secondary Rect Drawable ▁. ▁draw ▁( ▁canvas ▁) ▁; ▁temp Rect ▁. ▁left ▁= ▁( ▁int ▁) ▁( ▁Android Utilities ▁. ▁dp f 2 ▁( ▁2 ▁) ▁ * ▁scale X ▁) ▁; ▁temp Rect ▁. ▁top ▁= ▁( ▁int ▁) ▁( ▁Android Utilities ▁. ▁dp f 2 ▁( ▁6 ▁) ▁ * ▁scale Y ▁) ▁; ▁temp Rect ▁. ▁right ▁= ▁bounds ▁. ▁right ▁- ▁temp Rect ▁. ▁left ▁; ▁temp Rect ▁. ▁bottom ▁= ▁temp Rect ▁. ▁top ▁+ ▁( ▁int ▁) ▁( ▁Android Utilities ▁. ▁dp f 2 ▁( ▁4 ▁) ▁ * ▁scale Y ▁) ▁; ▁temp Rect ▁. ▁offset ▁( ▁0 ▁, ▁Android Utilities ▁. ▁dp ▁( ▁8 ▁) ▁) ▁; ▁primary Rect Drawable ▁. ▁setBounds ▁( ▁temp Rect ▁) ▁; ▁primary Rect Drawable ▁. ▁setAlpha ▁( ▁( ▁int ▁) ▁Android Utilities ▁. ▁l er p ▁( ▁255 ▁, ▁128 ▁, ▁progress ▁) ▁) ▁; ▁primary Rect Drawable ▁. ▁draw ▁( ▁canvas ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setAlpha ▁( ▁int ▁alpha ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁setColor Filter ▁( ▁@ ▁Nullable ▁Color Filter ▁color Filter ▁) ▁{ ▁primary Rect Drawable ▁. ▁setColor Filter ▁( ▁color Filter ▁) ▁; ▁secondary Rect Drawable ▁. ▁setColor Filter ▁( ▁color Filter ▁) ▁; ▁invalidate Self ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getOp acity ▁( ▁) ▁{ ▁return ▁P ixel Format ▁. ▁TRANS LU CENT ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getIntrinsic Width ▁( ▁) ▁{ ▁return ▁in trinsic Width ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getIntrinsic Height ▁( ▁) ▁{ ▁return ▁in trinsic Height ▁; ▁} ▁protected ▁static ▁class ▁Rect Drawable ▁extends ▁Drawable ▁{ ▁private ▁final ▁RectF ▁temp Rect ▁= ▁new ▁RectF ▁( ▁) ▁; ▁private ▁final ▁Paint ▁paint ▁= ▁new ▁Paint ▁( ▁Paint ▁. ▁ANT I _ ALIAS _ FLAG ▁) ▁; ▁@ ▁Override ▁public ▁void ▁draw ▁( ▁@ ▁NonNull ▁Canvas ▁canvas ▁) ▁{ ▁temp Rect ▁. ▁set ▁( ▁getBounds ▁( ▁) ▁) ▁; ▁final ▁float ▁radius ▁= ▁temp Rect ▁. ▁height ▁( ▁) ▁ * ▁0.2 f ▁; ▁canvas ▁. ▁draw Round Rect ▁( ▁temp Rect ▁, ▁radius ▁, ▁radius ▁, ▁paint ▁) ▁; ▁} ▁public ▁void ▁setColor ▁( ▁int ▁color ▁) ▁{ ▁paint ▁. ▁setColor ▁( ▁color ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setAlpha ▁( ▁int ▁alpha ▁) ▁{ ▁paint ▁. ▁setAlpha ▁( ▁alpha ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setColor Filter ▁( ▁@ ▁Nullable ▁Color Filter ▁color Filter ▁) ▁{ ▁paint ▁. ▁setColor Filter ▁( ▁color Filter ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getOp acity ▁( ▁) ▁{ ▁return ▁P ixel Format ▁. ▁TRANS LU CENT ▁; ▁} ▁} ▁}
▁@ ▁RunWith ▁( ▁Robolectric TestRunner ▁. ▁class ▁) ▁@ ▁Config ▁( ▁manifest ▁= ▁Config ▁. ▁NONE ▁) ▁public ▁class ▁Iterative Box Bl ur FilterTest ▁{ ▁private ▁final ▁int ▁B IT MAP _ SI Z E ▁= ▁( ▁int ▁) ▁Bitmap Util ▁. ▁MAX _ BIT MAP _ SI Z E ▁; ▁private ▁final ▁Bitmap ▁m Bitmap ▁= ▁Bitmap ▁. ▁create Bitmap ▁( ▁B IT MAP _ SI Z E ▁, ▁B IT MAP _ SI Z E ▁, ▁Bitmap ▁. ▁Config ▁. ▁ARG B _8 88 8 ▁) ▁; ▁@ ▁Test ▁public ▁void ▁test Bitmap Bl ur In Place ▁( ▁) ▁{ ▁Iterative Box Bl ur Filter ▁. ▁box Bl ur Bitmap In Place ▁( ▁m Bitmap ▁, ▁1 ▁, ▁4 ▁) ▁; ▁assertNotNull ▁( ▁m Bitmap ▁) ▁; ▁assertEquals ▁( ▁m Bitmap ▁. ▁getWidth ▁( ▁) ▁, ▁B IT MAP _ SI Z E ▁) ▁; ▁assertEquals ▁( ▁m Bitmap ▁. ▁getHeight ▁( ▁) ▁, ▁B IT MAP _ SI Z E ▁) ▁; ▁assertEquals ▁( ▁m Bitmap ▁. ▁getConfig ▁( ▁) ▁, ▁Bitmap ▁. ▁Config ▁. ▁ARG B _8 88 8 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁max Radius Bitmap Bl ur In Place ▁( ▁) ▁{ ▁Iterative Box Bl ur Filter ▁. ▁box Bl ur Bitmap In Place ▁( ▁m Bitmap ▁, ▁1 ▁, ▁Render Script Bl ur Filter ▁. ▁BL UR _ MAX _ R AD I US ▁) ▁; ▁assertNotNull ▁( ▁m Bitmap ▁) ▁; ▁assertEquals ▁( ▁m Bitmap ▁. ▁getWidth ▁( ▁) ▁, ▁B IT MAP _ SI Z E ▁) ▁; ▁assertEquals ▁( ▁m Bitmap ▁. ▁getHeight ▁( ▁) ▁, ▁B IT MAP _ SI Z E ▁) ▁; ▁assertEquals ▁( ▁m Bitmap ▁. ▁getConfig ▁( ▁) ▁, ▁Bitmap ▁. ▁Config ▁. ▁ARG B _8 88 8 ▁) ▁; ▁} ▁@ ▁Test ▁( ▁expected ▁= ▁IllegalArgument Exception ▁. ▁class ▁) ▁public ▁void ▁invalid Negative Radius Bl ur In Place ▁( ▁) ▁{ ▁Iterative Box Bl ur Filter ▁. ▁box Bl ur Bitmap In Place ▁( ▁m Bitmap ▁, ▁1 ▁, ▁- ▁1 ▁) ▁; ▁} ▁@ ▁Test ▁( ▁expected ▁= ▁IllegalArgument Exception ▁. ▁class ▁) ▁public ▁void ▁invalid Z ero Radius Bl ur In Place ▁( ▁) ▁{ ▁Iterative Box Bl ur Filter ▁. ▁box Bl ur Bitmap In Place ▁( ▁m Bitmap ▁, ▁1 ▁, ▁0 ▁) ▁; ▁} ▁@ ▁Test ▁( ▁expected ▁= ▁IllegalArgument Exception ▁. ▁class ▁) ▁public ▁void ▁invalid Big Radius Bl ur In Place ▁( ▁) ▁{ ▁Iterative Box Bl ur Filter ▁. ▁box Bl ur Bitmap In Place ▁( ▁m Bitmap ▁, ▁1 ▁, ▁Render Script Bl ur Filter ▁. ▁BL UR _ MAX _ R AD I US ▁+ ▁1 ▁) ▁; ▁} ▁}
▁parser ▁. ▁declareString ▁( ▁Abstract Sql Request ▁:: ▁clientId ▁, ▁CLIENT _ ID ▁) ▁; ▁parser ▁. ▁declareString ▁( ▁Abstract Sql Request ▁:: ▁version ▁, ▁VERSION ▁) ▁; ▁parser ▁. ▁declareField ▁( ▁Abstract Sql Query Request ▁:: ▁params ▁, ▁Abstract Sql Query Request ▁:: ▁parse Params ▁, ▁PARAM S ▁, ▁ValueType ▁. ▁VALUE _ ARRAY ▁) ▁; ▁parser ▁. ▁declareString ▁( ▁( ▁request ▁, ▁zoneId ▁) ▁-> ▁request ▁. ▁zoneId ▁( ▁ Z oneId ▁. ▁of ▁( ▁zoneId ▁) ▁) ▁, ▁TIME _ Z ONE ▁) ▁; ▁parser ▁. ▁declare Int ▁( ▁Abstract Sql Query Request ▁:: ▁fetch Size ▁, ▁F ETCH _ SI Z E ▁) ▁; ▁parser ▁. ▁declareString ▁( ▁( ▁request ▁, ▁timeout ▁) ▁-> ▁request ▁. ▁request Timeout ▁( ▁TimeValue ▁. ▁parse TimeValue ▁( ▁timeout ▁, ▁Protocol ▁. ▁REQUEST _ TIMEOUT ▁, ▁REQUEST _ TIMEOUT _ NAME ▁) ▁) ▁, ▁REQUEST _ TIMEOUT ▁) ▁; ▁parser ▁. ▁declareString ▁( ▁( ▁request ▁, ▁timeout ▁) ▁-> ▁request ▁. ▁page Timeout ▁( ▁TimeValue ▁. ▁parse TimeValue ▁( ▁timeout ▁, ▁Protocol ▁. ▁PAGE _ TIMEOUT ▁, ▁PAGE _ TIMEOUT _ NAME ▁) ▁) ▁, ▁PAGE _ TIMEOUT ▁) ▁; ▁parser ▁. ▁declareObject ▁( ▁Abstract Sql Query Request ▁:: ▁filter ▁, ▁( ▁p ▁, ▁c ▁) ▁-> ▁Abstract QueryBuilder ▁. ▁parse Inner QueryBuilder ▁( ▁p ▁) ▁, ▁FILTER ▁) ▁; ▁parser ▁. ▁declareObject ▁( ▁Abstract Sql Query Request ▁:: ▁runtime Mappings ▁, ▁( ▁p ▁, ▁c ▁) ▁-> ▁p ▁. ▁map ▁( ▁) ▁, ▁Search SourceBuilder ▁. ▁RUNTIME _ MAPPING S _ FIELD ▁) ▁; ▁return ▁parser ▁; ▁} ▁public ▁String ▁query ▁( ▁) ▁{ ▁return ▁query ▁; ▁} ▁public ▁Abstract Sql Query Request ▁query ▁( ▁String ▁query ▁) ▁{ ▁if ▁( ▁query ▁== ▁null ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁this ▁. ▁query ▁= ▁query ▁; ▁return ▁this ▁; ▁} ▁public ▁List ▁< ▁Sql Typed Param Value ▁> ▁params ▁( ▁) ▁{ ▁return ▁params ▁; ▁} ▁public ▁Abstract Sql Query Request ▁params ▁( ▁List ▁< ▁Sql Typed Param Value ▁> ▁params ▁) ▁{ ▁if ▁( ▁params ▁== ▁null ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁this ▁. ▁params ▁= ▁params ▁; ▁return ▁this ▁; ▁} ▁private ▁static ▁List ▁< ▁Sql Typed Param Value ▁> ▁parse Params ▁( ▁XContentParser ▁p ▁) ▁throws ▁IOException ▁{ ▁List ▁< ▁Sql Typed Param Value ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁Token ▁token ▁= ▁p ▁. ▁currentToken ▁( ▁) ▁; ▁if ▁( ▁token ▁== ▁Token ▁. ▁START _ ARRAY ▁) ▁{ ▁Object ▁value ▁= ▁null ▁; ▁String ▁type ▁= ▁null ▁; ▁Sql Typed Param Value ▁previous Param ▁= ▁null ▁; ▁Sql Typed Param Value ▁current Param ▁= ▁null ▁; ▁while ▁( ▁( ▁token ▁= ▁p ▁. ▁nextToken ▁( ▁) ▁) ▁!= ▁Token ▁. ▁END _ ARRAY ▁) ▁{ ▁XContent Location ▁loc ▁= ▁p ▁. ▁getToken Location ▁( ▁) ▁; ▁if ▁( ▁token ▁== ▁Token ▁. ▁START _ OBJECT ▁) ▁{ ▁current Param ▁= ▁Sql Typed Param Value ▁. ▁fromXContent ▁( ▁p ▁) ▁;
▁i ▁++ ▁) ▁{ ▁last Time ▁= ▁Job Schedule Helper ▁. ▁generate Next Valid Time ▁( ▁param X xlJob Info ▁, ▁last Time ▁) ▁; ▁if ▁( ▁last Time ▁!= ▁null ▁) ▁{ ▁result ▁. ▁add ▁( ▁DateUtil ▁. ▁format DateTime ▁( ▁last Time ▁) ▁) ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁} ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁logger ▁. ▁error ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁e ▁) ▁; ▁return ▁new ▁ReturnT ▁< ▁List ▁< ▁String ▁> ▁> ▁( ▁ReturnT ▁. ▁FAIL _ CODE ▁, ▁( ▁I 18 n Util ▁. ▁getString ▁( ▁STR ▁) ▁+ ▁I 18 n Util ▁. ▁getString ▁( ▁STR ▁) ▁) ▁+ ▁e ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁} ▁return ▁new ▁ReturnT ▁< ▁List ▁< ▁String ▁> ▁> ▁( ▁result ▁) ▁; ▁} ▁}
▁else ▁{ ▁fixed Replacement ▁= ▁graph ▁. ▁add ▁( ▁new ▁ Resolve Constant Node ▁( ▁node ▁) ▁) ▁; ▁} ▁insert Replacement ▁( ▁graph ▁, ▁state Mapper ▁, ▁node ▁, ▁fixed Replacement ▁) ▁; ▁node ▁. ▁replace At Usages ▁( ▁fixed Replacement ▁, ▁n ▁-> ▁! ▁is Replacement Node ▁( ▁n ▁) ▁) ▁; ▁} ▁private ▁static ▁boolean ▁replace With Load ▁( ▁StructuredGraph ▁graph ▁, ▁ConstantNode ▁node ▁, ▁Class Info ▁class Info ▁) ▁{ ▁HotSpot Metas pace Constant ▁met as pace Constant ▁= ▁( ▁HotSpot Metas pace Constant ▁) ▁node ▁. ▁as Constant ▁( ▁) ▁; ▁HotSpot Resolved JavaType ▁type ▁= ▁( ▁HotSpot Resolved JavaType ▁) ▁met as pace Constant ▁. ▁as Resolved JavaType ▁( ▁) ▁; ▁ResolvedJava Type ▁top Method Holder ▁= ▁graph ▁. ▁method ▁( ▁) ▁. ▁getDecl aringClass ▁( ▁) ▁; ▁ValueNode ▁replacement ▁= ▁null ▁; ▁if ▁( ▁( ▁type ▁. ▁isArray ▁( ▁) ▁&& ▁type ▁. ▁getComponent Type ▁( ▁) ▁. ▁isPrimitive ▁( ▁) ▁) ▁|| ▁type ▁. ▁equals ▁( ▁class Info ▁. ▁reference Type ▁) ▁) ▁{ ▁replacement ▁= ▁graph ▁. ▁addOr Unique ▁( ▁new ▁Load Constant In direct ly Node ▁( ▁node ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁type ▁. ▁equals ▁( ▁top Method Holder ▁) ▁|| ▁( ▁type ▁. ▁isAssignable From ▁( ▁top Method Holder ▁) ▁&& ▁! ▁type ▁. ▁isInterface ▁( ▁) ▁) ▁) ▁{ ▁replacement ▁= ▁graph ▁. ▁addOr Unique ▁( ▁new ▁Load Constant In direct ly Node ▁( ▁node ▁) ▁) ▁; ▁} ▁if ▁( ▁replacement ▁!= ▁null ▁) ▁{ ▁node ▁. ▁replace At Usages ▁( ▁replacement ▁, ▁n ▁-> ▁! ▁is Replacement Node ▁( ▁n ▁) ▁) ▁; ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁private ▁void ▁verify Fingerprint ▁( ▁ConstantNode ▁node ▁) ▁{ ▁HotSpot Metas pace Constant ▁met as pace Constant ▁= ▁( ▁HotSpot Metas pace Constant ▁) ▁node ▁. ▁as Constant ▁( ▁) ▁; ▁HotSpot Resolved JavaType ▁type ▁= ▁( ▁HotSpot Resolved JavaType ▁) ▁met as pace Constant ▁. ▁as Resolved JavaType ▁( ▁) ▁; ▁if ▁( ▁type ▁!= ▁null ▁) ▁{ ▁assert ▁! ▁met as pace Constant ▁. ▁is Compressed ▁( ▁) ▁: ▁STR ▁; ▁if ▁( ▁verify Fingerprint s ▁&& ▁checkFor Bad Fingerprint ▁( ▁type ▁) ▁) ▁{ ▁throw ▁new ▁GraalError ▁( ▁STR ▁+ ▁type ▁) ▁; ▁} ▁} ▁} ▁private ▁static ▁void ▁handle HotSpot Metas pace Constant ▁( ▁StructuredGraph ▁graph ▁, ▁FrameState Mapper Closure ▁state Mapper ▁, ▁ConstantNode ▁node ▁, ▁Class Info ▁class Info ▁) ▁{ ▁HotSpot Metas pace Constant ▁met as pace Constant ▁= ▁( ▁HotSpot Metas pace Constant ▁) ▁node ▁. ▁as Constant ▁( ▁) ▁; ▁HotSpot Resolved JavaType ▁type ▁= ▁( ▁HotSpot Resolved JavaType ▁) ▁met as pace Constant ▁. ▁as Resolved JavaType ▁( ▁) ▁; ▁if ▁( ▁type ▁!= ▁null ▁) ▁{ ▁if ▁( ▁! ▁try To Replace With Existing ▁( ▁graph ▁, ▁node ▁) ▁&& ▁! ▁replace With Load ▁( ▁graph ▁, ▁node ▁, ▁class Info ▁) ▁) ▁{ ▁replace With Resolution ▁( ▁graph ▁, ▁state Mapper ▁, ▁node ▁, ▁class Info ▁) ▁; ▁} ▁} ▁else ▁{ ▁throw ▁new ▁GraalError ▁( ▁STR ▁+ ▁type ▁) ▁;
▁public ▁class ▁Decompiler View Component ▁{ ▁private ▁final ▁String ▁name ▁; ▁private ▁final ▁J Menu ▁menu ▁; ▁private ▁final ▁Decompiler Component Type ▁type ▁; ▁private ▁final ▁Decompiler ▁[ ▁] ▁decomp il ers ▁; ▁private ▁final ▁JR adioButton MenuItem ▁java ▁; ▁private ▁final ▁JR adioButton MenuItem ▁bytecode ▁; ▁private ▁final ▁J CheckBox MenuItem ▁editable ▁; ▁public ▁Decompiler View Component ▁( ▁String ▁name ▁, ▁Decompiler Component Type ▁type ▁, ▁Decompiler ▁... ▁decomp il ers ▁) ▁{ ▁this ▁. ▁name ▁= ▁name ▁; ▁this ▁. ▁menu ▁= ▁new ▁J Menu ▁( ▁name ▁) ▁; ▁this ▁. ▁type ▁= ▁type ▁; ▁this ▁. ▁decomp il ers ▁= ▁decomp il ers ▁; ▁this ▁. ▁java ▁= ▁new ▁Translated J R adioButton MenuItem ▁( ▁STR ▁, ▁Translated Components ▁. ▁JAVA ▁) ▁; ▁this ▁. ▁bytecode ▁= ▁new ▁Translated J R adioButton MenuItem ▁( ▁STR ▁, ▁Translated Components ▁. ▁BYTE CODE ▁) ▁; ▁this ▁. ▁editable ▁= ▁new ▁Translated J CheckBox MenuItem ▁( ▁STR ▁, ▁Translated Components ▁. ▁ED IT ABLE ▁) ▁; ▁create Menu ▁( ▁) ▁; ▁} ▁private ▁void ▁create Menu ▁( ▁) ▁{ ▁if ▁( ▁type ▁== ▁JAVA ▁|| ▁type ▁== ▁JAVA _ AND _ BYTE CODE ▁) ▁menu ▁. ▁add ▁( ▁java ▁) ▁; ▁if ▁( ▁type ▁== ▁BYTE CODE ▁|| ▁type ▁== ▁JAVA _ AND _ BYTE CODE ▁|| ▁type ▁== ▁BYTE CODE _ NON _ ED IT ABLE ▁) ▁menu ▁. ▁add ▁( ▁bytecode ▁) ▁; ▁if ▁( ▁type ▁!= ▁BYTE CODE _ NON _ ED IT ABLE ▁) ▁{ ▁menu ▁. ▁add ▁( ▁new ▁J Separator ▁( ▁) ▁) ▁; ▁menu ▁. ▁add ▁( ▁editable ▁) ▁; ▁} ▁java ▁. ▁addAction Listener ▁( ▁new ▁Workspace Refresh Event ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁addTo Group ▁( ▁Button Group ▁group ▁) ▁{ ▁if ▁( ▁type ▁== ▁JAVA ▁|| ▁type ▁== ▁JAVA _ AND _ BYTE CODE ▁) ▁group ▁. ▁add ▁( ▁java ▁) ▁; ▁if ▁( ▁type ▁== ▁BYTE CODE ▁|| ▁type ▁== ▁JAVA _ AND _ BYTE CODE ▁|| ▁type ▁== ▁BYTE CODE _ NON _ ED IT ABLE ▁) ▁group ▁. ▁add ▁( ▁bytecode ▁) ▁; ▁} ▁public ▁J Menu ▁getMenu ▁( ▁) ▁{ ▁return ▁menu ▁; ▁} ▁public ▁JR adioButton MenuItem ▁getJava ▁( ▁) ▁{ ▁return ▁java ▁; ▁} ▁public ▁JR adioButton MenuItem ▁getByte code ▁( ▁) ▁{ ▁return ▁bytecode ▁; ▁} ▁public ▁J CheckBox MenuItem ▁get Editable ▁( ▁) ▁{ ▁return ▁editable ▁; ▁} ▁public ▁Decompiler Component Type ▁getType ▁( ▁) ▁{ ▁return ▁type ▁; ▁} ▁public ▁Decompiler ▁[ ▁] ▁get Decomp il ers ▁( ▁) ▁{ ▁return ▁decomp il ers ▁; ▁} ▁public ▁enum ▁Decompiler Component Type ▁{ ▁JAVA ▁, ▁BYTE CODE ▁, ▁BYTE CODE _ NON _ ED IT ABLE ▁, ▁JAVA _ AND _ BYTE CODE ▁} ▁}
▁@ ▁GwtCompatible ▁( ▁emulated ▁= ▁true ▁) ▁public ▁class ▁Immutable Enum Map Test ▁extends ▁TestCase ▁{ ▁public ▁static ▁class ▁Immutable Enum Map Generator ▁extends ▁Test Enum Map Generator ▁{ ▁@ ▁Override ▁protected ▁Map ▁< ▁AnEnum ▁, ▁String ▁> ▁create ▁( ▁Entry ▁< ▁AnEnum ▁, ▁String ▁> ▁[ ▁] ▁entries ▁) ▁{ ▁Map ▁< ▁AnEnum ▁, ▁String ▁> ▁map ▁= ▁Maps ▁. ▁newHashMap ▁( ▁) ▁; ▁for ▁( ▁Entry ▁< ▁AnEnum ▁, ▁String ▁> ▁entry ▁: ▁entries ▁) ▁{ ▁map ▁. ▁put ▁( ▁entry ▁. ▁getKey ▁( ▁) ▁, ▁entry ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁return ▁Maps ▁. ▁immutable Enum Map ▁( ▁map ▁) ▁; ▁} ▁} ▁@ ▁GwtIncompatible ▁public ▁static ▁Test ▁suite ▁( ▁) ▁{ ▁TestSuite ▁suite ▁= ▁new ▁TestSuite ▁( ▁) ▁; ▁suite ▁. ▁addTest ▁( ▁Map TestSuiteBuilder ▁. ▁using ▁( ▁new ▁Immutable Enum Map Generator ▁( ▁) ▁) ▁. ▁named ▁( ▁STR ▁) ▁. ▁withFeatures ▁( ▁CollectionSize ▁. ▁ANY ▁, ▁SERIALI Z ABLE ▁, ▁ALLOWS _ NULL _ QUERIES ▁) ▁. ▁createTest Suite ▁( ▁) ▁) ▁; ▁suite ▁. ▁add TestSuite ▁( ▁Immutable Enum Map Test ▁. ▁class ▁) ▁; ▁return ▁suite ▁; ▁} ▁public ▁void ▁test Iter ates Once ▁( ▁) ▁{ ▁Map ▁< ▁AnEnum ▁, ▁AnEnum ▁> ▁map ▁= ▁Maps ▁. ▁asMap ▁( ▁ImmutableSet ▁. ▁of ▁( ▁AnEnum ▁. ▁A ▁) ▁, ▁new ▁Function ▁< ▁AnEnum ▁, ▁AnEnum ▁> ▁( ▁) ▁{ ▁boolean ▁used ▁= ▁false ▁; ▁@ ▁Override ▁public ▁AnEnum ▁apply ▁( ▁AnEnum ▁a e ▁) ▁{ ▁checkState ▁( ▁! ▁used ▁, ▁STR ▁) ▁; ▁used ▁= ▁true ▁; ▁return ▁a e ▁; ▁} ▁} ▁) ▁; ▁ImmutableMap ▁< ▁AnEnum ▁, ▁AnEnum ▁> ▁copy ▁= ▁Maps ▁. ▁immutable Enum Map ▁( ▁map ▁) ▁; ▁assertThat ▁( ▁copy ▁. ▁entrySet ▁( ▁) ▁) ▁. ▁containsExactly ▁( ▁Helpers ▁. ▁mapEntry ▁( ▁AnEnum ▁. ▁A ▁, ▁AnEnum ▁. ▁A ▁) ▁) ▁; ▁} ▁public ▁void ▁testEmpty Immutable Enum Map ▁( ▁) ▁{ ▁ImmutableMap ▁< ▁AnEnum ▁, ▁String ▁> ▁map ▁= ▁Maps ▁. ▁immutable Enum Map ▁( ▁ImmutableMap ▁. ▁< ▁AnEnum ▁, ▁String ▁> ▁of ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁ImmutableMap ▁. ▁of ▁( ▁) ▁, ▁map ▁) ▁; ▁} ▁public ▁void ▁test Immutable Enum Map Ordering ▁( ▁) ▁{ ▁ImmutableMap ▁< ▁AnEnum ▁, ▁String ▁> ▁map ▁= ▁Maps ▁. ▁immutable Enum Map ▁( ▁ImmutableMap ▁. ▁of ▁( ▁AnEnum ▁. ▁C ▁, ▁STR ▁, ▁AnEnum ▁. ▁A ▁, ▁STR ▁, ▁AnEnum ▁. ▁E ▁, ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁map ▁. ▁entrySet ▁( ▁) ▁) ▁. ▁containsExactly ▁( ▁Helpers ▁. ▁mapEntry ▁( ▁AnEnum ▁. ▁A ▁, ▁STR ▁) ▁, ▁Helpers ▁. ▁mapEntry ▁( ▁AnEnum ▁. ▁C ▁, ▁STR ▁) ▁, ▁Helpers ▁. ▁mapEntry ▁( ▁AnEnum ▁. ▁E ▁, ▁STR ▁) ▁) ▁. ▁inOrder ▁( ▁) ▁; ▁} ▁public ▁void ▁testTo Immutable Enum Map ▁( ▁) ▁{ ▁Collector ▁< ▁Entry ▁< ▁AnEnum ▁, ▁Integer ▁> ▁, ▁? ▁, ▁ImmutableMap ▁< ▁AnEnum ▁, ▁Integer ▁> ▁> ▁collector ▁= ▁Maps ▁. ▁toImmutable Enum Map ▁( ▁Entry ▁:: ▁getKey ▁, ▁Entry ▁:: ▁getValue ▁) ▁;
▁public ▁class ▁Transport Bulk Action In gest Tests ▁extends ▁ESTestCase ▁{ ▁private ▁static ▁final ▁String ▁W ITH _ DEFAULT _ PI PE LINE ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁W ITH _ DEFAULT _ PI PE LINE _ ALIAS ▁= ▁STR ▁; ▁private ▁static ▁final ▁Settings ▁SETTINGS ▁= ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁Auto Create Index ▁. ▁AUTO _ CREATE _ INDEX _ SETTING ▁. ▁getKey ▁( ▁) ▁, ▁true ▁) ▁. ▁build ▁( ▁) ▁; ▁private ▁static ▁final ▁Thread ▁DUMMY _ WRITE _ THREAD ▁= ▁new ▁Thread ▁( ▁ThreadPool ▁. ▁Names ▁. ▁WRITE ▁) ▁; ▁Transport Service ▁transport Service ▁; ▁ClusterService ▁clusterService ▁; ▁Ingest Service ▁ingest Service ▁; ▁ThreadPool ▁threadPool ▁; ▁@ ▁C aptor ▁ArgumentCaptor ▁< ▁BiConsumer ▁< ▁Integer ▁, ▁Exception ▁> ▁> ▁failure Handler ▁; ▁@ ▁C aptor ▁ArgumentCaptor ▁< ▁BiConsumer ▁< ▁Thread ▁, ▁Exception ▁> ▁> ▁completion Handler ▁; ▁@ ▁C aptor ▁ArgumentCaptor ▁< ▁Transport ResponseHandler ▁< ▁Bulk Response ▁> ▁> ▁remote ResponseHandler ▁; ▁@ ▁C aptor ▁ArgumentCaptor ▁< ▁Iterable ▁< ▁Doc WriteRequest ▁< ▁? ▁> ▁> ▁> ▁bulk Docs I tr ▁; ▁Test Transport Bulk Action ▁action ▁; ▁Test Single Item Bulk Write Action ▁single Item Bulk Write Action ▁; ▁boolean ▁local In gest ▁; ▁DiscoveryNodes ▁nodes ▁; ▁DiscoveryNode ▁remote Node 1 ▁; ▁DiscoveryNode ▁remote Node 2 ▁; ▁class ▁Test Transport Bulk Action ▁extends ▁Transport Bulk Action ▁{ ▁boolean ▁is Executed ▁= ▁false ▁; ▁boolean ▁need To Check ▁; ▁boolean ▁index Created ▁= ▁true ▁; ▁Test Transport Bulk Action ▁( ▁) ▁{ ▁super ▁( ▁threadPool ▁, ▁transport Service ▁, ▁clusterService ▁, ▁ingest Service ▁, ▁null ▁, ▁new ▁ActionFilters ▁( ▁Collections ▁. ▁emptySet ▁( ▁) ▁) ▁, ▁Test IndexName Expression Resolver ▁. ▁newInstance ▁( ▁) ▁, ▁new ▁Index ing Press ure ▁( ▁SETTINGS ▁) ▁, ▁Empty System Indices ▁. ▁INSTANCE ▁) ▁; ▁} ▁@ ▁Override ▁void ▁execute Bulk ▁( ▁Task ▁task ▁, ▁final ▁Bulk Request ▁bulk Request ▁, ▁final ▁long ▁startTime Nanos ▁, ▁final ▁ActionListener ▁< ▁Bulk Response ▁> ▁listener ▁, ▁final ▁Atomic Array ▁< ▁Bulk ItemResponse ▁> ▁responses ▁, ▁Map ▁< ▁String ▁, ▁Index Not FoundException ▁> ▁indices That C annot Be Created ▁) ▁{ ▁assertTrue ▁( ▁index Created ▁) ▁; ▁is Executed ▁= ▁true ▁; ▁} ▁@ ▁Override ▁void ▁createIndex ▁( ▁String ▁index ▁, ▁TimeValue ▁timeout ▁, ▁Version ▁min Node Version ▁, ▁ActionListener ▁< ▁Create IndexResponse ▁> ▁listener ▁) ▁{ ▁index Created ▁= ▁true ▁; ▁listener ▁. ▁onResponse ▁( ▁null ▁) ▁; ▁} ▁} ▁class ▁Test Single Item Bulk Write Action ▁extends ▁Transport Single Item Bulk Write Action ▁< ▁IndexRequest ▁, ▁Index Response ▁> ▁{ ▁Test Single Item Bulk Write Action ▁( ▁Test Transport Bulk Action ▁bulk Action ▁) ▁{ ▁super ▁( ▁Index Action ▁. ▁NAME ▁, ▁Transport Bulk Action In gest Tests ▁. ▁this ▁. ▁transport Service ▁, ▁new ▁ActionFilters ▁( ▁Collections ▁. ▁emptySet ▁( ▁) ▁) ▁, ▁IndexRequest ▁:: ▁new ▁, ▁bulk Action ▁) ▁; ▁} ▁} ▁@ ▁Before ▁public ▁void ▁setup Action ▁( ▁) ▁{ ▁threadPool ▁= ▁mock ▁( ▁ThreadPool ▁. ▁class ▁) ▁;
▁class ▁WebRtc Audio Effect s ▁{ ▁private ▁static ▁final ▁boolean ▁DEBUG ▁= ▁false ▁; ▁private ▁static ▁final ▁String ▁TAG ▁= ▁STR ▁; ▁private ▁static ▁final ▁UUID ▁A O SP _ AC OU ST IC _ E CH O _ C ANCE LER ▁= ▁UUID ▁. ▁fromString ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁UUID ▁A O SP _ NO I SE _ SUPP RESS OR ▁= ▁UUID ▁. ▁fromString ▁( ▁STR ▁) ▁; ▁private ▁static ▁@ ▁Nullable ▁Descriptor ▁[ ▁] ▁cached Effect s ▁; ▁private ▁@ ▁Nullable ▁A co ust ic Echo C ance ler ▁a ec ▁; ▁private ▁@ ▁Nullable ▁No ise Sup press or ▁ns ▁; ▁private ▁boolean ▁should Enable A ec ▁; ▁private ▁boolean ▁should Enable Ns ▁; ▁public ▁static ▁boolean ▁isA co ust ic Echo C ance ler Supported ▁( ▁) ▁{ ▁if ▁( ▁Build ▁. ▁VERSION ▁. ▁SDK _ INT ▁< ▁18 ▁) ▁return ▁false ▁; ▁return ▁isE ffect Type Available ▁( ▁Audio Effect ▁. ▁E FF E CT _ TYPE _ A EC ▁, ▁A O SP _ AC OU ST IC _ E CH O _ C ANCE LER ▁) ▁; ▁} ▁public ▁static ▁boolean ▁is No ise Sup press or Supported ▁( ▁) ▁{ ▁if ▁( ▁Build ▁. ▁VERSION ▁. ▁SDK _ INT ▁< ▁18 ▁) ▁return ▁false ▁; ▁return ▁isE ffect Type Available ▁( ▁Audio Effect ▁. ▁E FF E CT _ TYPE _ NS ▁, ▁A O SP _ NO I SE _ SUPP RESS OR ▁) ▁; ▁} ▁public ▁WebRtc Audio Effect s ▁( ▁) ▁{ ▁Logging ▁. ▁d ▁( ▁TAG ▁, ▁STR ▁+ ▁WebRtc Audio Utils ▁. ▁getThread Info ▁( ▁) ▁) ▁; ▁} ▁public ▁boolean ▁setA EC ▁( ▁boolean ▁enable ▁) ▁{ ▁Logging ▁. ▁d ▁( ▁TAG ▁, ▁STR ▁+ ▁enable ▁+ ▁STR ▁) ▁; ▁if ▁( ▁! ▁isA co ust ic Echo C ance ler Supported ▁( ▁) ▁) ▁{ ▁Logging ▁. ▁w ▁( ▁TAG ▁, ▁STR ▁) ▁; ▁should Enable A ec ▁= ▁false ▁; ▁return ▁false ▁; ▁} ▁if ▁( ▁a ec ▁!= ▁null ▁&& ▁( ▁enable ▁!= ▁should Enable A ec ▁) ▁) ▁{ ▁Logging ▁. ▁e ▁( ▁TAG ▁, ▁STR ▁) ▁; ▁return ▁false ▁; ▁} ▁should Enable A ec ▁= ▁enable ▁; ▁return ▁true ▁; ▁} ▁public ▁boolean ▁set NS ▁( ▁boolean ▁enable ▁) ▁{ ▁Logging ▁. ▁d ▁( ▁TAG ▁, ▁STR ▁+ ▁enable ▁+ ▁STR ▁) ▁; ▁if ▁( ▁! ▁is No ise Sup press or Supported ▁( ▁) ▁) ▁{ ▁Logging ▁. ▁w ▁( ▁TAG ▁, ▁STR ▁) ▁; ▁should Enable Ns ▁= ▁false ▁; ▁return ▁false ▁; ▁} ▁if ▁( ▁ns ▁!= ▁null ▁&& ▁( ▁enable ▁!= ▁should Enable Ns ▁) ▁) ▁{ ▁Logging ▁. ▁e ▁( ▁TAG ▁, ▁STR ▁) ▁; ▁return ▁false ▁; ▁} ▁should Enable Ns ▁= ▁enable ▁; ▁return ▁true ▁; ▁} ▁public ▁void ▁enable ▁( ▁int ▁audio Session ▁) ▁{ ▁Logging ▁. ▁d ▁( ▁TAG ▁, ▁STR ▁+ ▁audio Session ▁+ ▁STR ▁) ▁; ▁assertTrue ▁( ▁a ec ▁== ▁null ▁) ▁; ▁assertTrue ▁( ▁ns ▁== ▁null ▁) ▁;
▁final ▁StringBuilder ▁sb ▁= ▁new ▁StringBuilder ▁( ▁128 ▁) ▁; ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁sb ▁. ▁append ▁( ▁account ▁) ▁; ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁URL ▁url ▁; ▁try ▁{ ▁url ▁= ▁new ▁URL ▁( ▁sb ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁Malformed URLException ▁ex ▁) ▁{ ▁throw ▁new ▁Invalid Uri Exception ▁( ▁sb ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁List ▁< ▁Abfs Http Header ▁> ▁request Headers ▁= ▁new ▁ArrayList ▁< ▁Abfs Http Header ▁> ▁( ▁) ▁; ▁request Headers ▁. ▁add ▁( ▁new ▁Abfs Http Header ▁( ▁HttpHeader Configurations ▁. ▁X _ MS _ VERSION ▁, ▁sk v ▁) ▁) ▁; ▁request Headers ▁. ▁add ▁( ▁new ▁Abfs Http Header ▁( ▁HttpHeader Configurations ▁. ▁CONTENT _ TYPE ▁, ▁STR ▁) ▁) ▁; ▁request Headers ▁. ▁add ▁( ▁new ▁Abfs Http Header ▁( ▁HttpHeader Configurations ▁. ▁AUTH ORI Z ATION ▁, ▁getAuth orization Header ▁( ▁account ▁, ▁app ID ▁, ▁app Secret ▁, ▁sk t id ▁) ▁) ▁) ▁; ▁final ▁StringBuilder ▁requestBody ▁= ▁new ▁StringBuilder ▁( ▁512 ▁) ▁; ▁requestBody ▁. ▁append ▁( ▁STR ▁) ▁; ▁requestBody ▁. ▁append ▁( ▁sk t ▁) ▁; ▁requestBody ▁. ▁append ▁( ▁STR ▁) ▁; ▁requestBody ▁. ▁append ▁( ▁sk e ▁) ▁; ▁requestBody ▁. ▁append ▁( ▁STR ▁) ▁; ▁Abfs Http Operation ▁op ▁= ▁new ▁Abfs Http Operation ▁( ▁url ▁, ▁method ▁, ▁request Headers ▁) ▁; ▁byte ▁[ ▁] ▁request Buffer ▁= ▁requestBody ▁. ▁toString ▁( ▁) ▁. ▁getBytes ▁( ▁Standard Charsets ▁. ▁UTF _8 ▁. ▁toString ▁( ▁) ▁) ▁; ▁op ▁. ▁send Request ▁( ▁request Buffer ▁, ▁0 ▁, ▁request Buffer ▁. ▁length ▁) ▁; ▁byte ▁[ ▁] ▁response Buffer ▁= ▁new ▁byte ▁[ ▁4 ▁ * ▁1024 ▁] ▁; ▁op ▁. ▁process Response ▁( ▁response Buffer ▁, ▁0 ▁, ▁response Buffer ▁. ▁length ▁) ▁; ▁String ▁responseBody ▁= ▁new ▁String ▁( ▁response Buffer ▁, ▁0 ▁, ▁( ▁int ▁) ▁op ▁. ▁getBytes Received ▁( ▁) ▁, ▁Standard Charsets ▁. ▁UTF _8 ▁) ▁; ▁int ▁begin Index ▁= ▁responseBody ▁. ▁indexOf ▁( ▁STR ▁) ▁+ ▁STR ▁. ▁length ▁( ▁) ▁; ▁int ▁endIndex ▁= ▁responseBody ▁. ▁indexOf ▁( ▁STR ▁) ▁; ▁String ▁value ▁= ▁responseBody ▁. ▁substring ▁( ▁begin Index ▁, ▁endIndex ▁) ▁; ▁return ▁Base 64 ▁. ▁decode ▁( ▁value ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getS AS Token ▁( ▁String ▁account Name ▁, ▁String ▁fileSystem ▁, ▁String ▁path ▁, ▁String ▁operation ▁) ▁throws ▁IOException ▁, ▁AccessControl Exception ▁{ ▁String ▁sa oid ▁= ▁null ▁; ▁String ▁su oid ▁= ▁null ▁; ▁if ▁( ▁path ▁== ▁null ▁|| ▁! ▁path ▁. ▁endsWith ▁( ▁NO _ AGENT _ PATH ▁) ▁) ▁{ ▁sa oid ▁= ▁( ▁operation ▁== ▁S AS Token Provider ▁. ▁CHECK _ ACCESS _ OPERATION ▁) ▁? ▁null ▁: ▁TEST _ O WNER ▁; ▁su oid ▁= ▁( ▁operation ▁== ▁S AS Token Provider ▁. ▁CHECK _ ACCESS _ OPERATION ▁) ▁? ▁TEST _ O WNER ▁: ▁null ▁; ▁}
▁options ▁. ▁register Option ▁( ▁Ghidra Options ▁. ▁OPTION _ F OL LOW _ COMP U TED _ J U MP ▁, ▁false ▁, ▁help ▁, ▁STR ▁+ ▁STR ▁) ▁; ▁options ▁. ▁register Option ▁( ▁Ghidra Options ▁. ▁OPTION _ F OL LOW _ COND ITION AL _ J U MP ▁, ▁true ▁, ▁help ▁, ▁STR ▁+ ▁STR ▁) ▁; ▁options ▁. ▁register Option ▁( ▁Ghidra Options ▁. ▁OPTION _ F OL LOW _ UN COND ITION AL _ J U MP ▁, ▁true ▁, ▁help ▁, ▁STR ▁+ ▁STR ▁) ▁; ▁options ▁. ▁register Option ▁( ▁Ghidra Options ▁. ▁OPTION _ F OL LOW _ PO INTER S ▁, ▁false ▁, ▁help ▁, ▁STR ▁+ ▁STR ▁) ▁; ▁setOptions ▁( ▁options ▁) ▁; ▁options ▁. ▁add Options ChangeListener ▁( ▁this ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁init ▁( ▁) ▁{ ▁block Model Service ▁= ▁tool ▁. ▁getService ▁( ▁Block Model Service ▁. ▁class ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁options Changed ▁( ▁ToolOptions ▁options ▁, ▁String ▁option Name ▁, ▁Object ▁oldValue ▁, ▁Object ▁newValue ▁) ▁{ ▁setOptions ▁( ▁options ▁) ▁; ▁} ▁private ▁void ▁setOptions ▁( ▁Options ▁options ▁) ▁{ ▁follow Comp uted Call ▁= ▁options ▁. ▁getBoolean ▁( ▁Ghidra Options ▁. ▁OPTION _ F OL LOW _ COMP U TED _ CALL ▁, ▁false ▁) ▁; ▁follow Conditional Call ▁= ▁options ▁. ▁getBoolean ▁( ▁Ghidra Options ▁. ▁OPTION _ F OL LOW _ COND ITION AL _ CALL ▁, ▁false ▁) ▁; ▁follow Un con ditional Call ▁= ▁options ▁. ▁getBoolean ▁( ▁Ghidra Options ▁. ▁OPTION _ F OL LOW _ UN COND ITION AL _ CALL ▁, ▁false ▁) ▁; ▁follow Comp uted J ump ▁= ▁options ▁. ▁getBoolean ▁( ▁Ghidra Options ▁. ▁OPTION _ F OL LOW _ COMP U TED _ J U MP ▁, ▁false ▁) ▁; ▁follow Conditional J ump ▁= ▁options ▁. ▁getBoolean ▁( ▁Ghidra Options ▁. ▁OPTION _ F OL LOW _ COND ITION AL _ J U MP ▁, ▁true ▁) ▁; ▁follow Un con ditional J ump ▁= ▁options ▁. ▁getBoolean ▁( ▁Ghidra Options ▁. ▁OPTION _ F OL LOW _ UN COND ITION AL _ J U MP ▁, ▁true ▁) ▁; ▁follow Pointer s ▁= ▁options ▁. ▁getBoolean ▁( ▁Ghidra Options ▁. ▁OPTION _ F OL LOW _ PO INTER S ▁, ▁false ▁) ▁; ▁} ▁void ▁select ▁( ▁Navigatable ActionContext ▁context ▁, ▁int ▁selection Type ▁) ▁{ ▁try ▁{ ▁Select By Flow Task ▁task ▁= ▁new ▁Select By Flow Task ▁( ▁context ▁, ▁selection Type ▁) ▁; ▁tool ▁. ▁execute ▁( ▁task ▁, ▁7 50 ▁) ▁; ▁} ▁catch ▁( ▁Invalid InputException ▁e ▁) ▁{ ▁tool ▁. ▁setStatus Info ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁true ▁) ▁; ▁} ▁} ▁void ▁perform Selection ▁( ▁TaskMonitor ▁monitor ▁, ▁Navigatable ActionContext ▁context ▁, ▁int ▁selection Type ▁, ▁AddressSet ▁address Set ▁) ▁{ ▁Program ▁program ▁= ▁context ▁. ▁getProgram ▁( ▁) ▁; ▁AddressSet ▁selection AddressSet ▁= ▁null ▁; ▁if ▁( ▁monitor ▁== ▁null ▁) ▁{ ▁monitor ▁= ▁TaskMonitor Adapter ▁. ▁DUMMY _ MONITOR ▁;
▁public ▁class ▁Mock De legation S AS Token Provider ▁implements ▁S AS Token Provider ▁{ ▁private ▁De legation S AS Generator ▁generator ▁; ▁public ▁static ▁final ▁String ▁TEST _ O WNER ▁= ▁STR ▁; ▁public ▁static ▁final ▁String ▁C OR REL ATION _ ID ▁= ▁STR ▁; ▁public ▁static ▁final ▁String ▁NO _ AGENT _ PATH ▁= ▁STR ▁; ▁@ ▁Override ▁public ▁void ▁initialize ▁( ▁Configuration ▁configuration ▁, ▁String ▁account Name ▁) ▁throws ▁IOException ▁{ ▁String ▁app ID ▁= ▁configuration ▁. ▁get ▁( ▁Test Configuration Keys ▁. ▁FS _ A Z URE _ TEST _ APP _ ID ▁) ▁; ▁String ▁app Secret ▁= ▁configuration ▁. ▁get ▁( ▁Test Configuration Keys ▁. ▁FS _ A Z URE _ TEST _ APP _ SE CRET ▁) ▁; ▁String ▁sk t id ▁= ▁configuration ▁. ▁get ▁( ▁Test Configuration Keys ▁. ▁FS _ A Z URE _ TEST _ APP _ SERVICE _ PR INC IP AL _ T EN ANT _ ID ▁) ▁; ▁String ▁sk oid ▁= ▁configuration ▁. ▁get ▁( ▁Test Configuration Keys ▁. ▁FS _ A Z URE _ TEST _ APP _ SERVICE _ PR INC IP AL _ OBJECT _ ID ▁) ▁; ▁String ▁sk t ▁= ▁S AS Generator ▁. ▁ISO _8 60 1_ FORMAT TER ▁. ▁format ▁( ▁Instant ▁. ▁now ▁( ▁) ▁. ▁minus ▁( ▁S AS Generator ▁. ▁FI VE _ MIN UTE S ▁) ▁) ▁; ▁String ▁sk e ▁= ▁S AS Generator ▁. ▁ISO _8 60 1_ FORMAT TER ▁. ▁format ▁( ▁Instant ▁. ▁now ▁( ▁) ▁. ▁plus ▁( ▁S AS Generator ▁. ▁ONE _ DAY ▁) ▁) ▁; ▁String ▁sk v ▁= ▁S AS Generator ▁. ▁Authentication Version ▁. ▁Dec 19 ▁. ▁toString ▁( ▁) ▁; ▁byte ▁[ ▁] ▁key ▁= ▁getUser De legation Key ▁( ▁account Name ▁, ▁app ID ▁, ▁app Secret ▁, ▁sk t id ▁, ▁sk t ▁, ▁sk e ▁, ▁sk v ▁) ▁; ▁generator ▁= ▁new ▁De legation S AS Generator ▁( ▁key ▁, ▁sk oid ▁, ▁sk t id ▁, ▁sk t ▁, ▁sk e ▁, ▁sk v ▁) ▁; ▁} ▁private ▁String ▁getAuth orization Header ▁( ▁String ▁account Name ▁, ▁String ▁app ID ▁, ▁String ▁app Secret ▁, ▁String ▁sk t id ▁) ▁throws ▁IOException ▁{ ▁String ▁auth End Point ▁= ▁String ▁. ▁format ▁( ▁STR ▁, ▁sk t id ▁) ▁; ▁Client C red s Token Provider ▁provider ▁= ▁new ▁Client C red s Token Provider ▁( ▁auth End Point ▁, ▁app ID ▁, ▁app Secret ▁) ▁; ▁return ▁STR ▁+ ▁provider ▁. ▁getToken ▁( ▁) ▁. ▁getAccess Token ▁( ▁) ▁; ▁} ▁private ▁byte ▁[ ▁] ▁getUser De legation Key ▁( ▁String ▁account Name ▁, ▁String ▁app ID ▁, ▁String ▁app Secret ▁, ▁String ▁sk t id ▁, ▁String ▁sk t ▁, ▁String ▁sk e ▁, ▁String ▁sk v ▁) ▁throws ▁IOException ▁{ ▁String ▁method ▁= ▁STR ▁; ▁String ▁account ▁= ▁account Name ▁. ▁substring ▁( ▁0 ▁, ▁account Name ▁. ▁indexOf ▁( ▁Abfs Http Constants ▁. ▁DOT ▁) ▁) ▁;
▁public ▁final ▁class ▁Sharding SpringBoot Condition ▁extends ▁SpringBoot Condition ▁{ ▁private ▁static ▁final ▁String ▁SHAR DING _ PREFIX ▁= ▁STR ▁; ▁@ ▁Override ▁public ▁Condition Outcome ▁getMatch Outcome ▁( ▁final ▁Condition Context ▁condition Context ▁, ▁final ▁AnnotatedType Metadata ▁annotated Type Metadata ▁) ▁{ ▁return ▁Property Util ▁. ▁contain Property Prefix ▁( ▁condition Context ▁. ▁getEnvironment ▁( ▁) ▁, ▁SHAR DING _ PREFIX ▁) ▁? ▁Condition Outcome ▁. ▁match ▁( ▁) ▁: ▁Condition Outcome ▁. ▁no Match ▁( ▁STR ▁) ▁; ▁} ▁}
▁Version ExceptionHandler ▁. ▁show Version Error ▁( ▁null ▁, ▁filename ▁, ▁contentType ▁, ▁STR ▁, ▁e ▁) ▁; ▁} ▁catch ▁( ▁Cancelled Exception ▁e ▁) ▁{ ▁} ▁catch ▁( ▁Language Not FoundException ▁e ▁) ▁{ ▁Msg ▁. ▁showError ▁( ▁this ▁, ▁null ▁, ▁STR ▁+ ▁filename ▁, ▁e ▁. ▁getMessage ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁if ▁( ▁domainFile ▁. ▁isIn Writable Project ▁( ▁) ▁&& ▁( ▁e ▁instanceof ▁IOException ▁) ▁) ▁{ ▁Repository Adapter ▁repo ▁= ▁domainFile ▁. ▁getParent ▁( ▁) ▁. ▁getProject Data ▁( ▁) ▁. ▁getRepository ▁( ▁) ▁; ▁Client Util ▁. ▁handleException ▁( ▁repo ▁, ▁e ▁, ▁STR ▁, ▁null ▁) ▁; ▁} ▁else ▁{ ▁Msg ▁. ▁showError ▁( ▁this ▁, ▁null ▁, ▁STR ▁+ ▁filename ▁, ▁STR ▁+ ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁e ▁) ▁; ▁} ▁} ▁} ▁private ▁void ▁open File Maybe U grade ▁( ▁DomainFile ▁domainFile ▁) ▁throws ▁IOException ▁, ▁Cancelled Exception ▁, ▁Version Exception ▁{ ▁boolean ▁recover File ▁= ▁false ▁; ▁if ▁( ▁! ▁s ilent ▁&& ▁domainFile ▁. ▁isIn Writable Project ▁( ▁) ▁&& ▁domainFile ▁. ▁can Recover ▁( ▁) ▁) ▁{ ▁recover File ▁= ▁ask Recover File ▁( ▁domainFile ▁. ▁getName ▁( ▁) ▁) ▁; ▁} ▁try ▁{ ▁Program ▁program ▁= ▁( ▁Program ▁) ▁domainFile ▁. ▁getDomain Object ▁( ▁consumer ▁, ▁false ▁, ▁recover File ▁, ▁task Monitor ▁) ▁; ▁if ▁( ▁program ▁!= ▁null ▁) ▁{ ▁program List ▁. ▁add ▁( ▁program ▁) ▁; ▁} ▁} ▁catch ▁( ▁Version Exception ▁e ▁) ▁{ ▁if ▁( ▁Version ExceptionHandler ▁. ▁is Upgrade OK ▁( ▁null ▁, ▁domainFile ▁, ▁open Pro mpt Text ▁, ▁e ▁) ▁) ▁{ ▁Program ▁program ▁= ▁( ▁Program ▁) ▁domainFile ▁. ▁getDomain Object ▁( ▁consumer ▁, ▁true ▁, ▁recover File ▁, ▁task Monitor ▁) ▁; ▁if ▁( ▁program ▁!= ▁null ▁) ▁{ ▁program List ▁. ▁add ▁( ▁program ▁) ▁; ▁} ▁} ▁} ▁} ▁private ▁boolean ▁ask Recover File ▁( ▁final ▁String ▁filename ▁) ▁{ ▁int ▁option ▁= ▁OptionDialog ▁. ▁show Y es No Dialog ▁( ▁null ▁, ▁STR ▁, ▁STR ▁+ ▁HTML Utilities ▁. ▁escape HTML ▁( ▁filename ▁) ▁+ ▁STR ▁+ ▁STR ▁) ▁; ▁return ▁option ▁== ▁OptionDialog ▁. ▁OPTION _ ONE ▁; ▁} ▁private ▁void ▁perform Optional Checkout ▁( ▁DomainFile ▁domainFile ▁) ▁{ ▁if ▁( ▁s ilent ▁|| ▁no Checkout ▁|| ▁! ▁domainFile ▁. ▁can Checkout ▁( ▁) ▁) ▁{ ▁return ▁; ▁} ▁User ▁user ▁= ▁domainFile ▁. ▁getParent ▁( ▁) ▁. ▁getProject Data ▁( ▁) ▁. ▁getUser ▁( ▁) ▁; ▁Check out Dialog ▁dialog ▁= ▁new ▁Check out Dialog ▁( ▁domainFile ▁, ▁user ▁) ▁; ▁if ▁( ▁dialog ▁. ▁showDialog ▁( ▁) ▁== ▁Check out Dialog ▁. ▁CHECK OUT ▁) ▁{ ▁try ▁{ ▁task Monitor ▁. ▁setMessage ▁( ▁STR ▁+ ▁domainFile ▁. ▁getName ▁( ▁) ▁) ▁; ▁if ▁( ▁domainFile ▁. ▁checkout ▁( ▁dialog ▁. ▁exclusive Checkout ▁( ▁) ▁, ▁task Monitor ▁) ▁) ▁{ ▁return ▁; ▁} ▁Msg ▁. ▁showError ▁( ▁this ▁, ▁null ▁, ▁STR ▁, ▁STR ▁+ ▁domainFile ▁. ▁getName ▁( ▁) ▁+ ▁STR ▁) ▁; ▁}
▁public ▁class ▁Mutable Long ▁extends ▁Number ▁implements ▁Comparable ▁< ▁Mutable Long ▁> ▁, ▁Mutable ▁< ▁Number ▁> ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁private ▁long ▁value ▁; ▁public ▁Mutable Long ▁( ▁) ▁{ ▁} ▁public ▁Mutable Long ▁( ▁final ▁long ▁value ▁) ▁{ ▁this ▁. ▁value ▁= ▁value ▁; ▁} ▁public ▁Mutable Long ▁( ▁final ▁Number ▁value ▁) ▁{ ▁this ▁( ▁value ▁. ▁longValue ▁( ▁) ▁) ▁; ▁} ▁public ▁Mutable Long ▁( ▁final ▁String ▁value ▁) ▁throws ▁Number FormatException ▁{ ▁this ▁. ▁value ▁= ▁Long ▁. ▁parseLong ▁( ▁value ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Long ▁get ▁( ▁) ▁{ ▁return ▁this ▁. ▁value ▁; ▁} ▁public ▁void ▁set ▁( ▁final ▁long ▁value ▁) ▁{ ▁this ▁. ▁value ▁= ▁value ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set ▁( ▁final ▁Number ▁value ▁) ▁{ ▁this ▁. ▁value ▁= ▁value ▁. ▁longValue ▁( ▁) ▁; ▁} ▁public ▁Mutable Long ▁increment ▁( ▁) ▁{ ▁value ▁++ ▁; ▁return ▁this ▁; ▁} ▁public ▁Mutable Long ▁decrement ▁( ▁) ▁{ ▁value ▁-- ▁; ▁return ▁this ▁; ▁} ▁public ▁Mutable Long ▁add ▁( ▁final ▁long ▁operand ▁) ▁{ ▁this ▁. ▁value ▁+= ▁operand ▁; ▁return ▁this ▁; ▁} ▁public ▁Mutable Long ▁add ▁( ▁final ▁Number ▁operand ▁) ▁{ ▁this ▁. ▁value ▁+= ▁operand ▁. ▁longValue ▁( ▁) ▁; ▁return ▁this ▁; ▁} ▁public ▁Mutable Long ▁subtract ▁( ▁final ▁long ▁operand ▁) ▁{ ▁this ▁. ▁value ▁-= ▁operand ▁; ▁return ▁this ▁; ▁} ▁public ▁Mutable Long ▁subtract ▁( ▁final ▁Number ▁operand ▁) ▁{ ▁this ▁. ▁value ▁-= ▁operand ▁. ▁longValue ▁( ▁) ▁; ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁int ▁intValue ▁( ▁) ▁{ ▁return ▁( ▁int ▁) ▁value ▁; ▁} ▁@ ▁Override ▁public ▁long ▁longValue ▁( ▁) ▁{ ▁return ▁value ▁; ▁} ▁@ ▁Override ▁public ▁float ▁floatValue ▁( ▁) ▁{ ▁return ▁value ▁; ▁} ▁@ ▁Override ▁public ▁double ▁doubleValue ▁( ▁) ▁{ ▁return ▁value ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁final ▁Object ▁obj ▁) ▁{ ▁if ▁( ▁obj ▁instanceof ▁Mutable Long ▁) ▁{ ▁return ▁value ▁== ▁( ▁( ▁Mutable Long ▁) ▁obj ▁) ▁. ▁longValue ▁( ▁) ▁; ▁} ▁return ▁false ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁( ▁int ▁) ▁( ▁value ▁ ^ ▁( ▁value ▁>>> ▁32 ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁compareTo ▁( ▁final ▁Mutable Long ▁other ▁) ▁{ ▁return ▁Number Util ▁. ▁compare ▁( ▁this ▁. ▁value ▁, ▁other ▁. ▁value ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁String ▁. ▁valueOf ▁( ▁value ▁) ▁; ▁} ▁}
▁public ▁class ▁Mock Terminal ▁extends ▁Terminal ▁{ ▁private ▁final ▁ByteArray OutputStream ▁stdout Buffer ▁= ▁new ▁ByteArray OutputStream ▁( ▁) ▁; ▁private ▁final ▁ByteArray OutputStream ▁stderr Buffer ▁= ▁new ▁ByteArray OutputStream ▁( ▁) ▁; ▁private ▁final ▁PrintWriter ▁writer ▁= ▁new ▁PrintWriter ▁( ▁new ▁OutputStream Writer ▁( ▁stdout Buffer ▁, ▁Standard Charsets ▁. ▁UTF _8 ▁) ▁) ▁; ▁private ▁final ▁PrintWriter ▁error Writer ▁= ▁new ▁PrintWriter ▁( ▁new ▁OutputStream Writer ▁( ▁stderr Buffer ▁, ▁Standard Charsets ▁. ▁UTF _8 ▁) ▁) ▁; ▁private ▁final ▁List ▁< ▁String ▁> ▁text Input ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁private ▁int ▁text Index ▁= ▁0 ▁; ▁private ▁final ▁List ▁< ▁String ▁> ▁secret Input ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁private ▁int ▁secret Index ▁= ▁0 ▁; ▁public ▁Mock Terminal ▁( ▁) ▁{ ▁super ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁read Text ▁( ▁String ▁prompt ▁) ▁{ ▁if ▁( ▁text Index ▁>= ▁text Input ▁. ▁size ▁( ▁) ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁+ ▁prompt ▁+ ▁STR ▁) ▁; ▁} ▁return ▁text Input ▁. ▁get ▁( ▁text Index ▁++ ▁) ▁; ▁} ▁@ ▁Override ▁public ▁char ▁[ ▁] ▁read Secret ▁( ▁String ▁prompt ▁) ▁{ ▁if ▁( ▁secret Index ▁>= ▁secret Input ▁. ▁size ▁( ▁) ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁+ ▁prompt ▁+ ▁STR ▁) ▁; ▁} ▁return ▁secret Input ▁. ▁get ▁( ▁secret Index ▁++ ▁) ▁. ▁toCharArray ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁PrintWriter ▁getWriter ▁( ▁) ▁{ ▁return ▁writer ▁; ▁} ▁@ ▁Override ▁public ▁PrintWriter ▁getError Writer ▁( ▁) ▁{ ▁return ▁error Writer ▁; ▁} ▁public ▁void ▁add Text Input ▁( ▁String ▁input ▁) ▁{ ▁text Input ▁. ▁add ▁( ▁input ▁) ▁; ▁} ▁public ▁void ▁add Secret Input ▁( ▁String ▁input ▁) ▁{ ▁secret Input ▁. ▁add ▁( ▁input ▁) ▁; ▁} ▁public ▁String ▁getOutput ▁( ▁) ▁throws ▁Unsupported Encoding Exception ▁{ ▁return ▁stdout Buffer ▁. ▁toString ▁( ▁STR ▁) ▁; ▁} ▁public ▁String ▁getError Output ▁( ▁) ▁throws ▁Unsupported Encoding Exception ▁{ ▁return ▁stderr Buffer ▁. ▁toString ▁( ▁STR ▁) ▁; ▁} ▁public ▁void ▁reset ▁( ▁) ▁{ ▁stdout Buffer ▁. ▁reset ▁( ▁) ▁; ▁stderr Buffer ▁. ▁reset ▁( ▁) ▁; ▁text Index ▁= ▁0 ▁; ▁text Input ▁. ▁clear ▁( ▁) ▁; ▁secret Index ▁= ▁0 ▁; ▁secret Input ▁. ▁clear ▁( ▁) ▁; ▁} ▁}
▁process Snapshot MetaInfo For All States ▁( ▁meta Info Snapshots ▁, ▁c ow State Stable Snapshots ▁, ▁state Names To Id ▁, ▁registered PQ States ▁, ▁State MetaInfo Snapshot ▁. ▁Backend State Type ▁. ▁PRI ORITY _ QUEUE ▁) ▁; ▁return ▁new ▁Heap Snapshot Resources ▁< ▁> ▁( ▁meta Info Snapshots ▁, ▁c ow State Stable Snapshots ▁, ▁stream Compression Decorator ▁, ▁state Names To Id ▁, ▁keyGroupRange ▁, ▁keySerializer ▁, ▁total Key Groups ▁) ▁; ▁} ▁private ▁static ▁void ▁process Snapshot MetaInfo For All States ▁( ▁List ▁< ▁State MetaInfo Snapshot ▁> ▁meta Info Snapshots ▁, ▁Map ▁< ▁State UID ▁, ▁State Snapshot ▁> ▁c ow State Stable Snapshots ▁, ▁Map ▁< ▁State UID ▁, ▁Integer ▁> ▁state Names To Id ▁, ▁Map ▁< ▁String ▁, ▁? ▁extends ▁State Snapshot Restore ▁> ▁register edState s ▁, ▁State MetaInfo Snapshot ▁. ▁Backend State Type ▁state Type ▁) ▁{ ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁? ▁extends ▁State Snapshot Restore ▁> ▁kvState ▁: ▁register edState s ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁final ▁State UID ▁state Uid ▁= ▁State UID ▁. ▁of ▁( ▁kvState ▁. ▁getKey ▁( ▁) ▁, ▁state Type ▁) ▁; ▁state Names To Id ▁. ▁put ▁( ▁state Uid ▁, ▁state Names To Id ▁. ▁size ▁( ▁) ▁) ▁; ▁State Snapshot Restore ▁state ▁= ▁kvState ▁. ▁getValue ▁( ▁) ▁; ▁if ▁( ▁null ▁!= ▁state ▁) ▁{ ▁final ▁State Snapshot ▁state Snapshot ▁= ▁state ▁. ▁state Snapshot ▁( ▁) ▁; ▁meta Info Snapshots ▁. ▁add ▁( ▁state Snapshot ▁. ▁getMeta Info Snapshot ▁( ▁) ▁) ▁; ▁c ow State Stable Snapshots ▁. ▁put ▁( ▁state Uid ▁, ▁state Snapshot ▁) ▁; ▁} ▁} ▁} ▁@ ▁Override ▁public ▁void ▁release ▁( ▁) ▁{ ▁for ▁( ▁State Snapshot ▁state Snapshot ▁: ▁c ow State Stable Snapshots ▁. ▁values ▁( ▁) ▁) ▁{ ▁state Snapshot ▁. ▁release ▁( ▁) ▁; ▁} ▁} ▁public ▁List ▁< ▁State MetaInfo Snapshot ▁> ▁getMeta Info Snapshots ▁( ▁) ▁{ ▁return ▁meta Info Snapshots ▁; ▁} ▁@ ▁Override ▁public ▁KeyValue State Iterator ▁create KV State Iterator ▁( ▁) ▁throws ▁IOException ▁{ ▁return ▁new ▁Heap KeyValue State Iterator ▁( ▁keyGroupRange ▁, ▁keySerializer ▁, ▁total Key Groups ▁, ▁state Names To Id ▁, ▁c ow State Stable Snapshots ▁) ▁; ▁} ▁@ ▁Override ▁public ▁KeyGroupRange ▁getKey GroupRange ▁( ▁) ▁{ ▁return ▁keyGroupRange ▁; ▁} ▁@ ▁Override ▁public ▁TypeSerializer ▁< ▁K ▁> ▁getKey Serializer ▁( ▁) ▁{ ▁return ▁keySerializer ▁; ▁} ▁@ ▁Override ▁public ▁Stream Compression Decorator ▁getStream Compression Decorator ▁( ▁) ▁{ ▁return ▁stream Compression Decorator ▁; ▁} ▁public ▁Map ▁< ▁State UID ▁, ▁State Snapshot ▁> ▁getCo w State Stable Snapshots ▁( ▁) ▁{ ▁return ▁c ow State Stable Snapshots ▁; ▁} ▁public ▁Map ▁< ▁State UID ▁, ▁Integer ▁> ▁getState Names To Id ▁( ▁) ▁{ ▁return ▁state Names To Id ▁; ▁} ▁}
▁if ▁( ▁first Margin Provider ▁. ▁is Resize able ▁( ▁) ▁) ▁{ ▁return ▁margin Providers ▁. ▁subList ▁( ▁1 ▁, ▁margin Providers ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁return ▁margin Providers ▁; ▁} ▁private ▁JComponent ▁build Center Component ▁( ▁) ▁{ ▁JComponent ▁center Component ▁= ▁sc rol ler ▁; ▁M argin Provider ▁resize able Margin Provider ▁= ▁get Resize able Margin Provider ▁( ▁) ▁; ▁if ▁( ▁resize able Margin Provider ▁!= ▁null ▁) ▁{ ▁if ▁( ▁split Pane ▁!= ▁null ▁) ▁{ ▁split Pane Divider Location ▁= ▁split Pane ▁. ▁getD ivider Location ▁( ▁) ▁; ▁} ▁JPanel ▁resize able Panel ▁= ▁new ▁JPanel ▁( ▁new ▁Scroll panel Resize able Panel Layout ▁( ▁sc rol ler ▁) ▁) ▁; ▁resize able Panel ▁. ▁setBackground ▁( ▁Color ▁. ▁WHITE ▁) ▁; ▁resize able Panel ▁. ▁add ▁( ▁resize able Margin Provider ▁. ▁getComponent ▁( ▁) ▁) ▁; ▁split Pane ▁= ▁new ▁J Split Pane ▁( ▁J Split Pane ▁. ▁H ORI Z ONTAL _ SPLIT ▁, ▁resize able Panel ▁, ▁sc rol ler ▁) ▁; ▁split Pane ▁. ▁setD ivider Size ▁( ▁4 ▁) ▁; ▁split Pane ▁. ▁setD ivider Location ▁( ▁split Pane Divider Location ▁) ▁; ▁split Pane ▁. ▁set Cont inu ous Layout ▁( ▁true ▁) ▁; ▁split Pane ▁. ▁setBorder ▁( ▁null ▁) ▁; ▁center Component ▁= ▁split Pane ▁; ▁} ▁if ▁( ▁header Panel ▁!= ▁null ▁) ▁{ ▁header Panel ▁. ▁setView Component ▁( ▁center Component ▁) ▁; ▁center Component ▁= ▁header Panel ▁; ▁} ▁return ▁center Component ▁; ▁} ▁private ▁M argin Provider ▁get Resize able Margin Provider ▁( ▁) ▁{ ▁if ▁( ▁margin Providers ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁M argin Provider ▁margin Provider ▁= ▁margin Providers ▁. ▁get ▁( ▁0 ▁) ▁; ▁return ▁margin Provider ▁. ▁is Resize able ▁( ▁) ▁? ▁margin Provider ▁: ▁null ▁; ▁} ▁public ▁void ▁add IndexMap ChangeListener ▁( ▁ChangeListener ▁listener ▁) ▁{ ▁index Map Change Listeners ▁. ▁add ▁( ▁listener ▁) ▁; ▁} ▁public ▁void ▁remove IndexMap ChangeListener ▁( ▁ChangeListener ▁listener ▁) ▁{ ▁index Map Change Listeners ▁. ▁remove ▁( ▁listener ▁) ▁; ▁} ▁public ▁void ▁remove Margin Provider ▁( ▁M argin Provider ▁provider ▁) ▁{ ▁margin Providers ▁. ▁remove ▁( ▁provider ▁) ▁; ▁build Panel s ▁( ▁) ▁; ▁} ▁public ▁void ▁add Overview Provider ▁( ▁Over view Provider ▁provider ▁) ▁{ ▁over view Providers ▁. ▁add ▁( ▁provider ▁) ▁; ▁provider ▁. ▁setAddress IndexMap ▁( ▁layout Model ▁. ▁getAddress IndexMap ▁( ▁) ▁) ▁; ▁build Panel s ▁( ▁) ▁; ▁} ▁public ▁void ▁remove Overview Provider ▁( ▁Over view Provider ▁provider ▁) ▁{ ▁over view Providers ▁. ▁remove ▁( ▁provider ▁) ▁; ▁build Panel s ▁( ▁) ▁; ▁} ▁public ▁void ▁add Button Pressed Listener ▁( ▁Button Pressed Listener ▁listener ▁) ▁{ ▁List ▁< ▁Button Pressed Listener ▁> ▁list ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁Arrays ▁. ▁asList ▁( ▁button Listeners ▁) ▁) ▁; ▁list ▁. ▁add ▁( ▁listener ▁) ▁;
▁if ▁( ▁! ▁ws f ▁. ▁has Found Work set ▁( ▁) ▁) ▁{ ▁throw ▁new ▁Compiler Exception ▁( ▁STR ▁+ ▁STR ▁) ▁; ▁} ▁} ▁HashMap ▁< ▁Operator ▁< ▁? ▁> ▁, ▁Optimizer Node ▁> ▁c losure ▁= ▁new ▁HashMap ▁< ▁Operator ▁< ▁? ▁> ▁, ▁Optimizer Node ▁> ▁( ▁con 2 node ▁) ▁; ▁final ▁Graph Cre ating Visitor ▁recursive Creator ▁= ▁new ▁Graph Cre ating Visitor ▁( ▁this ▁, ▁true ▁, ▁iter Node ▁. ▁getParallelism ▁( ▁) ▁, ▁default Data ExchangeMode ▁, ▁c losure ▁) ▁; ▁iter ▁. ▁getS ol ution Set Delta ▁( ▁) ▁. ▁accept ▁( ▁recursive Creator ▁) ▁; ▁final ▁Work set Node ▁work set Node ▁= ▁( ▁Work set Node ▁) ▁recursive Creator ▁. ▁con 2 node ▁. ▁get ▁( ▁iter ▁. ▁getWork set ▁( ▁) ▁) ▁; ▁if ▁( ▁work set Node ▁== ▁null ▁) ▁{ ▁throw ▁new ▁Compiler Exception ▁( ▁STR ▁+ ▁STR ▁) ▁; ▁} ▁iter ▁. ▁getNext Work set ▁( ▁) ▁. ▁accept ▁( ▁recursive Creator ▁) ▁; ▁Sol ution Set Node ▁sol ution Set Node ▁= ▁( ▁Sol ution Set Node ▁) ▁recursive Creator ▁. ▁con 2 node ▁. ▁get ▁( ▁iter ▁. ▁getS ol ution Set ▁( ▁) ▁) ▁; ▁if ▁( ▁sol ution Set Node ▁== ▁null ▁|| ▁sol ution Set Node ▁. ▁getOut going Connections ▁( ▁) ▁== ▁null ▁|| ▁sol ution Set Node ▁. ▁getOut going Connections ▁( ▁) ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁sol ution Set Node ▁= ▁new ▁Sol ution Set Node ▁( ▁( ▁Delta Iteration Base ▁. ▁Sol ution Set Place Holder ▁< ▁? ▁> ▁) ▁iter ▁. ▁getS ol ution Set ▁( ▁) ▁, ▁iter Node ▁) ▁; ▁} ▁else ▁{ ▁for ▁( ▁D ag Connection ▁conn ▁: ▁sol ution Set Node ▁. ▁getOut going Connections ▁( ▁) ▁) ▁{ ▁Optimizer Node ▁successor ▁= ▁conn ▁. ▁getTarget ▁( ▁) ▁; ▁if ▁( ▁successor ▁. ▁getClass ▁( ▁) ▁== ▁Join Node ▁. ▁class ▁) ▁{ ▁Join Node ▁m n ▁= ▁( ▁Join Node ▁) ▁successor ▁; ▁if ▁( ▁m n ▁. ▁getFirst Pre decessor Node ▁( ▁) ▁== ▁sol ution Set Node ▁) ▁{ ▁m n ▁. ▁make Join With Sol ution Set ▁( ▁0 ▁) ▁; ▁} ▁else ▁if ▁( ▁m n ▁. ▁getSecond Pre decessor Node ▁( ▁) ▁== ▁sol ution Set Node ▁) ▁{ ▁m n ▁. ▁make Join With Sol ution Set ▁( ▁1 ▁) ▁; ▁} ▁else ▁{ ▁throw ▁new ▁Compiler Exception ▁( ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁successor ▁. ▁getClass ▁( ▁) ▁== ▁Co Group Node ▁. ▁class ▁) ▁{ ▁Co Group Node ▁cg ▁= ▁( ▁Co Group Node ▁) ▁successor ▁; ▁if ▁( ▁cg ▁. ▁getFirst Pre decessor Node ▁( ▁) ▁== ▁sol ution Set Node ▁) ▁{ ▁cg ▁. ▁make Co Group With Sol ution Set ▁( ▁0 ▁) ▁; ▁} ▁else ▁if ▁( ▁cg ▁. ▁getSecond Pre decessor Node ▁( ▁) ▁== ▁sol ution Set Node ▁) ▁{ ▁cg ▁. ▁make Co Group With Sol ution Set ▁( ▁1 ▁) ▁; ▁}
▁protected ▁Message ▁< ▁? ▁> ▁do Convert ▁( ▁Object ▁payload ▁, ▁@ ▁Nullable ▁Map ▁< ▁String ▁, ▁Object ▁> ▁headers ▁, ▁@ ▁Nullable ▁Message PostProcessor ▁post Processor ▁) ▁{ ▁MessageHeaders ▁message Headers ▁= ▁null ▁; ▁Object ▁conversion Hint ▁= ▁( ▁headers ▁!= ▁null ▁? ▁headers ▁. ▁get ▁( ▁CON VERSION _ H INT _ HEADER ▁) ▁: ▁null ▁) ▁; ▁Map ▁< ▁String ▁, ▁Object ▁> ▁headers ToUse ▁= ▁process Headers To Send ▁( ▁headers ▁) ▁; ▁if ▁( ▁headers ToUse ▁!= ▁null ▁) ▁{ ▁if ▁( ▁headers ToUse ▁instanceof ▁MessageHeaders ▁) ▁{ ▁message Headers ▁= ▁( ▁MessageHeaders ▁) ▁headers ToUse ▁; ▁} ▁else ▁{ ▁message Headers ▁= ▁new ▁MessageHeaders ▁( ▁headers ToUse ▁) ▁; ▁} ▁} ▁Message Converter ▁converter ▁= ▁getMessage Converter ▁( ▁) ▁; ▁Message ▁< ▁? ▁> ▁message ▁= ▁( ▁converter ▁instanceof ▁Smart MessageConverter ▁? ▁( ▁( ▁Smart MessageConverter ▁) ▁converter ▁) ▁. ▁to Message ▁( ▁payload ▁, ▁message Headers ▁, ▁conversion Hint ▁) ▁: ▁converter ▁. ▁to Message ▁( ▁payload ▁, ▁message Headers ▁) ▁) ▁; ▁if ▁( ▁message ▁== ▁null ▁) ▁{ ▁String ▁payload Type ▁= ▁payload ▁. ▁getClass ▁( ▁) ▁. ▁getName ▁( ▁) ▁; ▁Object ▁contentType ▁= ▁( ▁message Headers ▁!= ▁null ▁? ▁message Headers ▁. ▁get ▁( ▁MessageHeaders ▁. ▁CONTENT _ TYPE ▁) ▁: ▁null ▁) ▁; ▁throw ▁new ▁Message Conversion Exception ▁( ▁STR ▁+ ▁payload Type ▁+ ▁STR ▁+ ▁contentType ▁+ ▁STR ▁+ ▁getMessage Converter ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁if ▁( ▁post Processor ▁!= ▁null ▁) ▁{ ▁message ▁= ▁post Processor ▁. ▁postProcess Message ▁( ▁message ▁) ▁; ▁} ▁return ▁message ▁; ▁} ▁@ ▁Nullable ▁protected ▁Map ▁< ▁String ▁, ▁Object ▁> ▁process Headers To Send ▁( ▁@ ▁Nullable ▁Map ▁< ▁String ▁, ▁Object ▁> ▁headers ▁) ▁{ ▁return ▁headers ▁; ▁} ▁}
▁public ▁class ▁Int Action ▁extends ▁Temporal Action ▁{ ▁private ▁int ▁start ▁, ▁end ▁; ▁private ▁int ▁value ▁; ▁public ▁Int Action ▁( ▁) ▁{ ▁start ▁= ▁0 ▁; ▁end ▁= ▁1 ▁; ▁} ▁public ▁Int Action ▁( ▁int ▁start ▁, ▁int ▁end ▁) ▁{ ▁this ▁. ▁start ▁= ▁start ▁; ▁this ▁. ▁end ▁= ▁end ▁; ▁} ▁public ▁Int Action ▁( ▁int ▁start ▁, ▁int ▁end ▁, ▁float ▁duration ▁) ▁{ ▁super ▁( ▁duration ▁) ▁; ▁this ▁. ▁start ▁= ▁start ▁; ▁this ▁. ▁end ▁= ▁end ▁; ▁} ▁public ▁Int Action ▁( ▁int ▁start ▁, ▁int ▁end ▁, ▁float ▁duration ▁, ▁@ ▁Null ▁Inter polation ▁inter polation ▁) ▁{ ▁super ▁( ▁duration ▁, ▁inter polation ▁) ▁; ▁this ▁. ▁start ▁= ▁start ▁; ▁this ▁. ▁end ▁= ▁end ▁; ▁} ▁protected ▁void ▁begin ▁( ▁) ▁{ ▁value ▁= ▁start ▁; ▁} ▁protected ▁void ▁update ▁( ▁float ▁percent ▁) ▁{ ▁if ▁( ▁percent ▁== ▁0 ▁) ▁value ▁= ▁start ▁; ▁else ▁if ▁( ▁percent ▁== ▁1 ▁) ▁value ▁= ▁end ▁; ▁else ▁value ▁= ▁( ▁int ▁) ▁( ▁start ▁+ ▁( ▁end ▁- ▁start ▁) ▁ * ▁percent ▁) ▁; ▁} ▁public ▁int ▁getValue ▁( ▁) ▁{ ▁return ▁value ▁; ▁} ▁public ▁void ▁setValue ▁( ▁int ▁value ▁) ▁{ ▁this ▁. ▁value ▁= ▁value ▁; ▁} ▁public ▁int ▁getStart ▁( ▁) ▁{ ▁return ▁start ▁; ▁} ▁public ▁void ▁setStart ▁( ▁int ▁start ▁) ▁{ ▁this ▁. ▁start ▁= ▁start ▁; ▁} ▁public ▁int ▁getEnd ▁( ▁) ▁{ ▁return ▁end ▁; ▁} ▁public ▁void ▁setEnd ▁( ▁int ▁end ▁) ▁{ ▁this ▁. ▁end ▁= ▁end ▁; ▁} ▁}
▁class ▁Load Image Update Event Tests ▁extends ▁Progress Update Event Tests ▁< ▁Load Image Update Event ▁> ▁{ ▁@ ▁Test ▁void ▁getStream Returns Stream ▁( ▁) ▁{ ▁Load Image Update Event ▁event ▁= ▁create Event ▁( ▁) ▁; ▁assertThat ▁( ▁event ▁. ▁getStream ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Load Image Update Event ▁create Event ▁( ▁String ▁status ▁, ▁Progress Detail ▁progress Detail ▁, ▁String ▁progress ▁) ▁{ ▁return ▁new ▁Load Image Update Event ▁( ▁STR ▁, ▁status ▁, ▁progress Detail ▁, ▁progress ▁) ▁; ▁} ▁}
▁assertEquals ▁( ▁1 ▁, ▁getOrder ▁( ▁ACT I VATE _ D UR ING _ DIS PO SE ▁) ▁. ▁initialize Thread ▁) ▁; ▁assertEquals ▁( ▁2 ▁, ▁getOrder ▁( ▁ACT I VATE _ D UR ING _ DIS PO SE ▁) ▁. ▁initialize Context ▁) ▁; ▁context ▁. ▁close ▁( ▁) ▁; ▁assertEquals ▁( ▁3 ▁, ▁getOrder ▁( ▁ACT I VATE _ D UR ING _ DIS PO SE ▁) ▁. ▁finalize Context ▁) ▁; ▁assertEquals ▁( ▁4 ▁, ▁getOrder ▁( ▁ACT I VATE _ D UR ING _ DIS PO SE ▁) ▁. ▁dispose Thread ▁) ▁; ▁assertEquals ▁( ▁5 ▁, ▁getOrder ▁( ▁ACT I VATE _ D UR ING _ DIS PO SE ▁) ▁. ▁dispose Context ▁) ▁; ▁} ▁static ▁class ▁Order Context ▁{ ▁TruffleLanguage ▁. ▁Env ▁env ▁; ▁int ▁createContext ▁= ▁- ▁1 ▁; ▁int ▁initialize Context ▁= ▁- ▁1 ▁; ▁int ▁initialize Thread ▁= ▁- ▁1 ▁; ▁int ▁finalize Context ▁= ▁- ▁1 ▁; ▁int ▁dispose Thread ▁= ▁- ▁1 ▁; ▁int ▁dispose Context ▁= ▁- ▁1 ▁; ▁} ▁static ▁class ▁Base Lang ▁extends ▁TruffleLanguage ▁< ▁Order Context ▁> ▁{ ▁@ ▁Override ▁protected ▁Order Context ▁createContext ▁( ▁TruffleLanguage ▁. ▁Env ▁env ▁) ▁{ ▁Order Context ▁context ▁= ▁new ▁Order Context ▁( ▁) ▁; ▁context ▁. ▁env ▁= ▁env ▁; ▁context ▁. ▁createContext ▁= ▁nextId ▁( ▁) ▁; ▁String ▁language Id ▁= ▁new ▁RootNode ▁( ▁this ▁) ▁{ ▁@ ▁Override ▁public ▁Object ▁execute ▁( ▁VirtualFrame ▁frame ▁) ▁{ ▁return ▁null ▁; ▁} ▁} ▁. ▁getLanguage Info ▁( ▁) ▁. ▁getId ▁( ▁) ▁; ▁if ▁( ▁current Context ▁. ▁containsKey ▁( ▁language Id ▁) ▁) ▁{ ▁throw ▁new ▁AssertionError ▁( ▁STR ▁+ ▁language Id ▁) ▁; ▁} ▁current Context ▁. ▁put ▁( ▁language Id ▁, ▁context ▁) ▁; ▁return ▁context ▁; ▁} ▁private ▁static ▁int ▁nextId ▁( ▁) ▁{ ▁int ▁id ▁= ▁N EXT _ ORDER _ INDEX ▁. ▁getAndIncrement ▁( ▁) ▁; ▁return ▁id ▁; ▁} ▁@ ▁Override ▁protected ▁CallTarget ▁parse ▁( ▁com ▁. ▁oracle ▁. ▁truffle ▁. ▁api ▁. ▁TruffleLanguage ▁. ▁Parsing Request ▁request ▁) ▁throws ▁Exception ▁{ ▁return ▁Truffle ▁. ▁getRuntime ▁( ▁) ▁. ▁create CallTarget ▁( ▁RootNode ▁. ▁create Constant Node ▁( ▁42 ▁) ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁initialize Context ▁( ▁Order Context ▁context ▁) ▁throws ▁Exception ▁{ ▁context ▁. ▁initialize Context ▁= ▁nextId ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁initialize Thread ▁( ▁Order Context ▁context ▁, ▁Thread ▁thread ▁) ▁{ ▁context ▁. ▁initialize Thread ▁= ▁nextId ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁finalize Context ▁( ▁Order Context ▁context ▁) ▁{ ▁context ▁. ▁finalize Context ▁= ▁nextId ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁dispose Thread ▁( ▁Order Context ▁context ▁, ▁Thread ▁thread ▁) ▁{ ▁context ▁. ▁dispose Thread ▁= ▁nextId ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁dispose Context ▁( ▁Order Context ▁context ▁) ▁{ ▁context ▁. ▁dispose Context ▁= ▁nextId ▁( ▁) ▁; ▁}
▁public ▁class ▁H yper parameters Tests ▁extends ▁Abstract B WC Serialization TestCase ▁< ▁H yper parameters ▁> ▁{ ▁private ▁boolean ▁lenient ▁; ▁@ ▁Before ▁public ▁void ▁choose Len ient ▁( ▁) ▁{ ▁lenient ▁= ▁randomBoolean ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁boolean ▁supports UnknownFields ▁( ▁) ▁{ ▁return ▁lenient ▁; ▁} ▁@ ▁Override ▁protected ▁H yper parameters ▁mutateInstance For Version ▁( ▁H yper parameters ▁instance ▁, ▁Version ▁version ▁) ▁{ ▁return ▁instance ▁; ▁} ▁@ ▁Override ▁protected ▁H yper parameters ▁doParseInstance ▁( ▁XContentParser ▁parser ▁) ▁throws ▁IOException ▁{ ▁return ▁H yper parameters ▁. ▁fromXContent ▁( ▁parser ▁, ▁lenient ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Writeable ▁. ▁Reader ▁< ▁H yper parameters ▁> ▁instanceReader ▁( ▁) ▁{ ▁return ▁H yper parameters ▁:: ▁new ▁; ▁} ▁@ ▁Override ▁protected ▁H yper parameters ▁createTest Instance ▁( ▁) ▁{ ▁return ▁createRandom ▁( ▁) ▁; ▁} ▁public ▁static ▁H yper parameters ▁createRandom ▁( ▁) ▁{ ▁return ▁new ▁H yper parameters ▁( ▁randomDouble ▁( ▁) ▁, ▁randomDouble ▁( ▁) ▁, ▁randomDouble ▁( ▁) ▁, ▁randomDouble ▁( ▁) ▁, ▁randomDouble ▁( ▁) ▁, ▁randomDouble ▁( ▁) ▁, ▁randomDouble ▁( ▁) ▁, ▁randomInt Between ▁( ▁0 ▁, ▁Integer ▁. ▁MAX _ VALUE ▁) ▁, ▁randomInt Between ▁( ▁0 ▁, ▁Integer ▁. ▁MAX _ VALUE ▁) ▁, ▁randomInt Between ▁( ▁0 ▁, ▁Integer ▁. ▁MAX _ VALUE ▁) ▁, ▁randomInt Between ▁( ▁0 ▁, ▁Integer ▁. ▁MAX _ VALUE ▁) ▁, ▁randomInt Between ▁( ▁0 ▁, ▁Integer ▁. ▁MAX _ VALUE ▁) ▁, ▁randomDouble ▁( ▁) ▁, ▁randomDouble ▁( ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁Named Internal Test ▁{ ▁private ▁static ▁final ▁String ▁TEST _ PREFIX ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁TEST _ VALUE ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁TEST _ SUFFIX ▁= ▁STR ▁; ▁private ▁static ▁class ▁Test Name Provider ▁implements ▁Internal Name Provider ▁{ ▁int ▁index ▁= ▁0 ▁; ▁@ ▁Override ▁public ▁String ▁new Processor Name ▁( ▁final ▁String ▁prefix ▁) ▁{ ▁return ▁prefix ▁+ ▁STR ▁+ ▁index ▁++ ▁; ▁} ▁@ ▁Override ▁public ▁String ▁new Store Name ▁( ▁final ▁String ▁prefix ▁) ▁{ ▁return ▁prefix ▁+ ▁STR ▁+ ▁index ▁++ ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁should Suffix Name Or Return Provider Value ▁( ▁) ▁{ ▁final ▁String ▁name ▁= ▁STR ▁; ▁final ▁Test Name Provider ▁provider ▁= ▁new ▁Test Name Provider ▁( ▁) ▁; ▁assertEquals ▁( ▁name ▁+ ▁TEST _ SUFFIX ▁, ▁Named Internal ▁. ▁with ▁( ▁name ▁) ▁. ▁suffix With Or Else Get ▁( ▁TEST _ SUFFIX ▁, ▁provider ▁, ▁TEST _ PREFIX ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁Named Internal ▁. ▁with ▁( ▁null ▁) ▁. ▁suffix With Or Else Get ▁( ▁TEST _ SUFFIX ▁, ▁provider ▁, ▁TEST _ PREFIX ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁should Generate With Prefix Given Empty Name ▁( ▁) ▁{ ▁final ▁String ▁prefix ▁= ▁STR ▁; ▁assertEquals ▁( ▁prefix ▁+ ▁STR ▁, ▁Named Internal ▁. ▁with ▁( ▁null ▁) ▁. ▁orElse Generate With Prefix ▁( ▁new ▁Test Name Provider ▁( ▁) ▁, ▁prefix ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁shouldNot Generate With Prefix Given Valid Name ▁( ▁) ▁{ ▁final ▁String ▁valid Name ▁= ▁STR ▁; ▁assertEquals ▁( ▁valid Name ▁, ▁Named Internal ▁. ▁with ▁( ▁valid Name ▁) ▁. ▁orElse Generate With Prefix ▁( ▁new ▁Test Name Provider ▁( ▁) ▁, ▁STR ▁) ▁) ▁; ▁} ▁}
▁@ ▁Functional Interface ▁public ▁interface ▁Application Listener ▁< ▁E ▁extends ▁Application Event ▁> ▁extends ▁EventListener ▁{ ▁void ▁on ApplicationEvent ▁( ▁E ▁event ▁) ▁; ▁static ▁< ▁T ▁> ▁Application Listener ▁< ▁Payload ApplicationEvent ▁< ▁T ▁> ▁> ▁for Payload ▁( ▁Consumer ▁< ▁T ▁> ▁consumer ▁) ▁{ ▁return ▁event ▁-> ▁consumer ▁. ▁accept ▁( ▁event ▁. ▁getPayload ▁( ▁) ▁) ▁; ▁} ▁}
▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁class ▁Local Container Entity ManagerFactory Bean ▁extends ▁Abstract Entity ManagerFactory Bean ▁implements ▁ResourceLoader Aware ▁, ▁Load TimeWeaver Aware ▁{ ▁@ ▁Nullable ▁private ▁Persistence Unit Manager ▁persist ence Unit Manager ▁; ▁private ▁final ▁Default Persistence Unit Manager ▁internal Persistence Unit Manager ▁= ▁new ▁Default Persistence Unit Manager ▁( ▁) ▁; ▁@ ▁Nullable ▁private ▁Persistence Unit Info ▁persist ence Unit Info ▁; ▁public ▁void ▁set Persistence Unit Manager ▁( ▁Persistence Unit Manager ▁persist ence Unit Manager ▁) ▁{ ▁this ▁. ▁persist ence Unit Manager ▁= ▁persist ence Unit Manager ▁; ▁} ▁public ▁void ▁set Persistence Xml Location ▁( ▁String ▁persist ence Xml Location ▁) ▁{ ▁this ▁. ▁internal Persistence Unit Manager ▁. ▁set Persistence Xml Location ▁( ▁persist ence Xml Location ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Persistence Unit Name ▁( ▁@ ▁Nullable ▁String ▁persist ence Unit Name ▁) ▁{ ▁super ▁. ▁set Persistence Unit Name ▁( ▁persist ence Unit Name ▁) ▁; ▁if ▁( ▁persist ence Unit Name ▁!= ▁null ▁) ▁{ ▁this ▁. ▁internal Persistence Unit Manager ▁. ▁setDefault Persistence Unit Name ▁( ▁persist ence Unit Name ▁) ▁; ▁} ▁} ▁public ▁void ▁set Persistence Unit Root Location ▁( ▁String ▁default Persistence Unit Root Location ▁) ▁{ ▁this ▁. ▁internal Persistence Unit Manager ▁. ▁setDefault Persistence Unit Root Location ▁( ▁default Persistence Unit Root Location ▁) ▁; ▁} ▁public ▁void ▁set Packages To Scan ▁( ▁String ▁... ▁packages To Scan ▁) ▁{ ▁this ▁. ▁internal Persistence Unit Manager ▁. ▁set Packages To Scan ▁( ▁packages To Scan ▁) ▁; ▁} ▁public ▁void ▁set Mapping Resources ▁( ▁String ▁... ▁mapping Resources ▁) ▁{ ▁this ▁. ▁internal Persistence Unit Manager ▁. ▁set Mapping Resources ▁( ▁mapping Resources ▁) ▁; ▁} ▁public ▁void ▁set SharedCache Mode ▁( ▁Shared Cache Mode ▁shared Cache Mode ▁) ▁{ ▁this ▁. ▁internal Persistence Unit Manager ▁. ▁set SharedCache Mode ▁( ▁shared Cache Mode ▁) ▁; ▁} ▁public ▁void ▁set Validation Mode ▁( ▁Validation Mode ▁validation Mode ▁) ▁{ ▁this ▁. ▁internal Persistence Unit Manager ▁. ▁set Validation Mode ▁( ▁validation Mode ▁) ▁; ▁} ▁public ▁void ▁setDataSource ▁( ▁DataSource ▁dataSource ▁) ▁{ ▁this ▁. ▁internal Persistence Unit Manager ▁. ▁setDataSource Lookup ▁( ▁new ▁Single DataSource Lookup ▁( ▁dataSource ▁) ▁) ▁; ▁this ▁. ▁internal Persistence Unit Manager ▁. ▁setDefault DataSource ▁( ▁dataSource ▁) ▁; ▁} ▁public ▁void ▁set J ta DataSource ▁( ▁DataSource ▁j ta DataSource ▁) ▁{ ▁this ▁. ▁internal Persistence Unit Manager ▁. ▁setDataSource Lookup ▁( ▁new ▁Single DataSource Lookup ▁( ▁j ta DataSource ▁) ▁) ▁; ▁this ▁. ▁internal Persistence Unit Manager ▁. ▁setDefault J ta DataSource ▁( ▁j ta DataSource ▁) ▁; ▁} ▁public ▁void ▁set Persistence Unit PostProcessor s ▁( ▁Persistence Unit PostProcessor ▁... ▁post Processors ▁) ▁{ ▁this ▁. ▁internal Persistence Unit Manager ▁. ▁set Persistence Unit PostProcessor s ▁( ▁post Processors ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Load TimeWeaver ▁( ▁Load TimeWeaver ▁load TimeWeaver ▁) ▁{ ▁this ▁. ▁internal Persistence Unit Manager ▁. ▁set Load TimeWeaver ▁( ▁load TimeWeaver ▁) ▁; ▁}
▁for ▁( ▁int ▁ex ponent ▁: ▁asList ▁( ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁9 ▁, ▁15 ▁, ▁16 ▁, ▁17 ▁, ▁24 ▁, ▁25 ▁, ▁30 ▁) ▁) ▁{ ▁int ▁x ▁= ▁1 ▁<< ▁ex ponent ▁; ▁int Values ▁. ▁add ▁( ▁x ▁, ▁x ▁+ ▁1 ▁, ▁x ▁- ▁1 ▁) ▁; ▁} ▁int Values ▁. ▁add ▁( ▁9999 ▁) ▁. ▁add ▁( ▁10000 ▁) ▁. ▁add ▁( ▁1000 1 ▁) ▁. ▁add ▁( ▁1000000 ▁) ▁; ▁int Values ▁. ▁add ▁( ▁5 79 2 ▁) ▁. ▁add ▁( ▁5 79 3 ▁) ▁; ▁POSITIVE _ IN TEGER _ C AND ID ATE S ▁= ▁int Values ▁. ▁build ▁( ▁) ▁; ▁NEGATIVE _ IN TEGER _ C AND ID ATE S ▁= ▁ImmutableList ▁. ▁copyOf ▁( ▁Iterables ▁. ▁concat ▁( ▁Iterables ▁. ▁transform ▁( ▁POSITIVE _ IN TEGER _ C AND ID ATE S ▁, ▁NE G ATE _ INT ▁) ▁, ▁ImmutableList ▁. ▁of ▁( ▁Integer ▁. ▁MIN _ VALUE ▁) ▁) ▁) ▁; ▁NON Z ERO _ IN TEGER _ C AND ID ATE S ▁= ▁ImmutableList ▁. ▁copyOf ▁( ▁Iterables ▁. ▁concat ▁( ▁POSITIVE _ IN TEGER _ C AND ID ATE S ▁, ▁NEGATIVE _ IN TEGER _ C AND ID ATE S ▁) ▁) ▁; ▁ALL _ IN TEGER _ C AND ID ATE S ▁= ▁Iterables ▁. ▁concat ▁( ▁NON Z ERO _ IN TEGER _ C AND ID ATE S ▁, ▁ImmutableList ▁. ▁of ▁( ▁0 ▁) ▁) ▁; ▁} ▁static ▁final ▁ImmutableSet ▁< ▁Long ▁> ▁POSITIVE _ LONG _ C AND ID ATE S ▁; ▁static ▁final ▁Iterable ▁< ▁Long ▁> ▁NEGATIVE _ LONG _ C AND ID ATE S ▁; ▁static ▁final ▁Iterable ▁< ▁Long ▁> ▁NON Z ERO _ LONG _ C AND ID ATE S ▁; ▁static ▁final ▁Iterable ▁< ▁Long ▁> ▁ALL _ LONG _ C AND ID ATE S ▁; ▁static ▁{ ▁ImmutableSet ▁. ▁Builder ▁< ▁Long ▁> ▁long Values ▁= ▁ImmutableSet ▁. ▁builder ▁( ▁) ▁; ▁long Values ▁. ▁addAll ▁( ▁Iterables ▁. ▁transform ▁( ▁POSITIVE _ IN TEGER _ C AND ID ATE S ▁, ▁TO _ LONG ▁) ▁) ▁; ▁long Values ▁. ▁add ▁( ▁Integer ▁. ▁MAX _ VALUE ▁+ ▁1 L ▁, ▁Long ▁. ▁MAX _ VALUE ▁- ▁1 L ▁, ▁Long ▁. ▁MAX _ VALUE ▁) ▁; ▁for ▁( ▁int ▁ex ponent ▁: ▁asList ▁( ▁32 ▁, ▁33 ▁, ▁3 9 ▁, ▁40 ▁, ▁41 ▁, ▁4 7 ▁, ▁48 ▁, ▁4 9 ▁, ▁55 ▁, ▁56 ▁, ▁5 7 ▁) ▁) ▁{ ▁long ▁x ▁= ▁1 L ▁<< ▁ex ponent ▁; ▁long Values ▁. ▁add ▁( ▁x ▁, ▁x ▁+ ▁1 ▁, ▁x ▁- ▁1 ▁) ▁; ▁} ▁long Values ▁. ▁add ▁( ▁1 94 36 80 3 19 98 L ▁) ▁. ▁add ▁( ▁1 94 36 80 3 19 99 L ▁) ▁; ▁POSITIVE _ LONG _ C AND ID ATE S ▁= ▁long Values ▁. ▁build ▁( ▁) ▁;
▁class ▁Spring Profile Action Tests ▁{ ▁private ▁final ▁Environment ▁environment ▁= ▁mock ▁( ▁Environment ▁. ▁class ▁) ▁; ▁private ▁final ▁Spring Profile Action ▁action ▁= ▁new ▁Spring Profile Action ▁( ▁this ▁. ▁environment ▁) ▁; ▁private ▁final ▁Context ▁context ▁= ▁new ▁Context Base ▁( ▁) ▁; ▁private ▁final ▁Inter pr et ation Context ▁inter pr et ation Context ▁= ▁new ▁Inter pr et ation Context ▁( ▁this ▁. ▁context ▁, ▁null ▁) ▁; ▁private ▁final ▁Attributes ▁attributes ▁= ▁mock ▁( ▁Attributes ▁. ▁class ▁) ▁; ▁@ ▁BeforeEach ▁void ▁setUp ▁( ▁) ▁{ ▁this ▁. ▁action ▁. ▁setContext ▁( ▁this ▁. ▁context ▁) ▁; ▁} ▁@ ▁Test ▁void ▁environment Is Qu er ied With Profile From Name Attribute ▁( ▁) ▁throws ▁Action Exception ▁{ ▁given ▁( ▁this ▁. ▁attributes ▁. ▁getValue ▁( ▁Action ▁. ▁NAME _ ATTRIBUTE ▁) ▁) ▁. ▁willReturn ▁( ▁STR ▁) ▁; ▁this ▁. ▁action ▁. ▁begin ▁( ▁this ▁. ▁inter pr et ation Context ▁, ▁null ▁, ▁this ▁. ▁attributes ▁) ▁; ▁ArgumentCaptor ▁< ▁Profile s ▁> ▁profile s ▁= ▁ArgumentCaptor ▁. ▁forClass ▁( ▁Profile s ▁. ▁class ▁) ▁; ▁verify ▁( ▁this ▁. ▁environment ▁) ▁. ▁accepts Profiles ▁( ▁profile s ▁. ▁capture ▁( ▁) ▁) ▁; ▁List ▁< ▁String ▁> ▁profile Names ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁profile s ▁. ▁getValue ▁( ▁) ▁. ▁matches ▁( ▁( ▁profile ▁) ▁-> ▁{ ▁profile Names ▁. ▁add ▁( ▁profile ▁) ▁; ▁return ▁false ▁; ▁} ▁) ▁; ▁assertThat ▁( ▁profile Names ▁) ▁. ▁containsExactly ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁void ▁environment Is Qu er ied With Multiple Profiles From Comma Separ ated Name Attribute ▁( ▁) ▁throws ▁Action Exception ▁{ ▁given ▁( ▁this ▁. ▁attributes ▁. ▁getValue ▁( ▁Action ▁. ▁NAME _ ATTRIBUTE ▁) ▁) ▁. ▁willReturn ▁( ▁STR ▁) ▁; ▁this ▁. ▁action ▁. ▁begin ▁( ▁this ▁. ▁inter pr et ation Context ▁, ▁null ▁, ▁this ▁. ▁attributes ▁) ▁; ▁ArgumentCaptor ▁< ▁Profile s ▁> ▁profile s ▁= ▁ArgumentCaptor ▁. ▁forClass ▁( ▁Profile s ▁. ▁class ▁) ▁; ▁verify ▁( ▁this ▁. ▁environment ▁) ▁. ▁accepts Profiles ▁( ▁profile s ▁. ▁capture ▁( ▁) ▁) ▁; ▁List ▁< ▁String ▁> ▁profile Names ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁profile s ▁. ▁getValue ▁( ▁) ▁. ▁matches ▁( ▁( ▁profile ▁) ▁-> ▁{ ▁profile Names ▁. ▁add ▁( ▁profile ▁) ▁; ▁return ▁false ▁; ▁} ▁) ▁; ▁assertThat ▁( ▁profile Names ▁) ▁. ▁containsExactly ▁( ▁STR ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁void ▁environment Is Qu er ied With Resolved Value When Name Attribute Uses AP lace holder ▁( ▁) ▁throws ▁Action Exception ▁{ ▁given ▁( ▁this ▁. ▁attributes ▁. ▁getValue ▁( ▁Action ▁. ▁NAME _ ATTRIBUTE ▁) ▁) ▁. ▁willReturn ▁( ▁STR ▁) ▁; ▁this ▁. ▁context ▁. ▁put Property ▁( ▁STR ▁, ▁STR ▁) ▁; ▁this ▁. ▁action ▁. ▁begin ▁( ▁this ▁. ▁inter pr et ation Context ▁, ▁null ▁, ▁this ▁. ▁attributes ▁) ▁; ▁ArgumentCaptor ▁< ▁Profile s ▁> ▁profile s ▁= ▁ArgumentCaptor ▁. ▁forClass ▁( ▁Profile s ▁. ▁class ▁) ▁;
▁public ▁interface ▁Include Scanner ▁{ ▁void ▁process Async ▁( ▁Artifact ▁main Source ▁, ▁Collection ▁< ▁Artifact ▁> ▁sources ▁, ▁Include Sc anning Header Data ▁include Sc anning Header Data ▁, ▁List ▁< ▁String ▁> ▁cmd line Includes ▁, ▁Set ▁< ▁Artifact ▁> ▁includes ▁, ▁Action Execution Metadata ▁action Execution Metadata ▁, ▁Action ExecutionContext ▁action ExecutionContext ▁, ▁Artifact ▁g rep Includes ▁) ▁throws ▁IOException ▁, ▁Exec Exception ▁, ▁Interrupted Exception ▁; ▁final ▁class ▁Include Sc anning Header Data ▁{ ▁private ▁final ▁Map ▁< ▁PathFragment ▁, ▁Artifact ▁> ▁path To Declared Header ▁; ▁private ▁final ▁Set ▁< ▁Artifact ▁> ▁mod ular Headers ▁; ▁private ▁final ▁List ▁< ▁PathFragment ▁> ▁system Include Dirs ▁; ▁private ▁final ▁List ▁< ▁String ▁> ▁cmd line Includes ▁; ▁@ ▁Nullable ▁private ▁final ▁Predicate ▁< ▁Artifact ▁> ▁isValid Un de cl ared Header ▁; ▁public ▁Include Sc anning Header Data ▁( ▁Map ▁< ▁PathFragment ▁, ▁Artifact ▁> ▁path To Declared Header ▁, ▁Set ▁< ▁Artifact ▁> ▁mod ular Headers ▁, ▁List ▁< ▁PathFragment ▁> ▁system Include Dirs ▁, ▁List ▁< ▁String ▁> ▁cmd line Includes ▁, ▁@ ▁Nullable ▁Predicate ▁< ▁Artifact ▁> ▁isValid Un de cl ared Header ▁) ▁{ ▁this ▁. ▁path To Declared Header ▁= ▁path To Declared Header ▁; ▁this ▁. ▁mod ular Headers ▁= ▁mod ular Headers ▁; ▁this ▁. ▁system Include Dirs ▁= ▁system Include Dirs ▁; ▁this ▁. ▁cmd line Includes ▁= ▁cmd line Includes ▁; ▁this ▁. ▁isValid Un de cl ared Header ▁= ▁isValid Un de cl ared Header ▁; ▁} ▁public ▁boolean ▁is Declared Header ▁( ▁PathFragment ▁header ▁) ▁{ ▁return ▁path To Declared Header ▁. ▁containsKey ▁( ▁header ▁) ▁; ▁} ▁public ▁Artifact ▁getHeader Artifact ▁( ▁PathFragment ▁header ▁) ▁{ ▁return ▁path To Declared Header ▁. ▁get ▁( ▁header ▁) ▁; ▁} ▁public ▁boolean ▁is Mod ular Header ▁( ▁Artifact ▁header ▁) ▁{ ▁return ▁mod ular Headers ▁. ▁contains ▁( ▁header ▁) ▁; ▁} ▁public ▁List ▁< ▁PathFragment ▁> ▁getSystem Include Dirs ▁( ▁) ▁{ ▁return ▁system Include Dirs ▁; ▁} ▁public ▁List ▁< ▁String ▁> ▁getC md line Includes ▁( ▁) ▁{ ▁return ▁cmd line Includes ▁; ▁} ▁public ▁boolean ▁is Le gal Header ▁( ▁Artifact ▁header ▁) ▁{ ▁return ▁isValid Un de cl ared Header ▁== ▁null ▁|| ▁path To Declared Header ▁. ▁containsKey ▁( ▁header ▁. ▁getExec Path ▁( ▁) ▁) ▁|| ▁isValid Un de cl ared Header ▁. ▁test ▁( ▁header ▁) ▁; ▁} ▁public ▁static ▁class ▁Builder ▁{ ▁private ▁final ▁Map ▁< ▁PathFragment ▁, ▁Artifact ▁> ▁path To Declared Header ▁; ▁private ▁final ▁Set ▁< ▁Artifact ▁> ▁mod ular Headers ▁; ▁private ▁List ▁< ▁PathFragment ▁> ▁system Include Dirs ▁= ▁ImmutableList ▁. ▁of ▁( ▁) ▁; ▁private ▁List ▁< ▁String ▁> ▁cmd line Includes ▁= ▁ImmutableList ▁. ▁of ▁( ▁) ▁; ▁@ ▁Nullable ▁private ▁Predicate ▁< ▁Artifact ▁> ▁isValid Un de cl ared Header ▁= ▁null ▁; ▁public ▁Builder ▁( ▁Map ▁< ▁PathFragment ▁, ▁Artifact ▁> ▁path To Declared Header ▁, ▁Set ▁< ▁Artifact ▁> ▁mod ular Headers ▁) ▁{ ▁this ▁. ▁path To Declared Header ▁= ▁path To Declared Header ▁;
▁public ▁class ▁OneInputStream Operator Output ▁extends ▁Output Base ▁{ ▁private ▁final ▁OneInputStream Operator ▁< ▁RowData ▁, ▁RowData ▁> ▁operator ▁; ▁public ▁OneInputStream Operator Output ▁( ▁OneInputStream Operator ▁< ▁RowData ▁, ▁RowData ▁> ▁operator ▁) ▁{ ▁super ▁( ▁operator ▁) ▁; ▁this ▁. ▁operator ▁= ▁operator ▁; ▁} ▁@ ▁Override ▁public ▁void ▁emit Watermark ▁( ▁Watermark ▁mark ▁) ▁{ ▁try ▁{ ▁operator ▁. ▁process Watermark ▁( ▁mark ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁throw ▁new ▁Exception In Multiple Input Operator Exception ▁( ▁e ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁emit Stream Status ▁( ▁Stream Status ▁stream Status ▁) ▁{ ▁try ▁{ ▁operator ▁. ▁process Stream Status ▁( ▁stream Status ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁throw ▁new ▁Exception In Multiple Input Operator Exception ▁( ▁e ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁emit Latency Marker ▁( ▁Latency Marker ▁latency Marker ▁) ▁{ ▁try ▁{ ▁operator ▁. ▁process Latency Marker ▁( ▁latency Marker ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁throw ▁new ▁Exception In Multiple Input Operator Exception ▁( ▁e ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁collect ▁( ▁StreamRecord ▁< ▁RowData ▁> ▁record ▁) ▁{ ▁push To Operator ▁( ▁record ▁) ▁; ▁} ▁@ ▁Override ▁public ▁< ▁X ▁> ▁void ▁collect ▁( ▁Output Tag ▁< ▁X ▁> ▁output Tag ▁, ▁StreamRecord ▁< ▁X ▁> ▁record ▁) ▁{ ▁push To Operator ▁( ▁record ▁) ▁; ▁} ▁protected ▁< ▁X ▁> ▁void ▁push To Operator ▁( ▁StreamRecord ▁< ▁X ▁> ▁record ▁) ▁{ ▁try ▁{ ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁StreamRecord ▁< ▁RowData ▁> ▁cast Record ▁= ▁( ▁StreamRecord ▁< ▁RowData ▁> ▁) ▁record ▁; ▁operator ▁. ▁processElement ▁( ▁cast Record ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁throw ▁new ▁Exception In Multiple Input Operator Exception ▁( ▁e ▁) ▁; ▁} ▁} ▁}
▁@ ▁RunWith ▁( ▁AndroidJUnit 4 ▁. ▁class ▁) ▁public ▁class ▁Default Extractor Input Test ▁{ ▁private ▁static ▁final ▁String ▁TEST _ URI ▁= ▁STR ▁; ▁private ▁static ▁final ▁byte ▁[ ▁] ▁TEST _ DATA ▁= ▁new ▁byte ▁[ ▁] ▁{ ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁, ▁6 ▁, ▁7 ▁, ▁8 ▁} ▁; ▁private ▁static ▁final ▁int ▁L ARGE _ TEST _ DATA _ LENGTH ▁= ▁8192 ▁; ▁@ ▁Test ▁public ▁void ▁initial Position ▁( ▁) ▁throws ▁Exception ▁{ ▁Fake DataSource ▁test DataSource ▁= ▁build DataSource ▁( ▁) ▁; ▁Default Extractor Input ▁input ▁= ▁new ▁Default Extractor Input ▁( ▁test DataSource ▁, ▁123 ▁, ▁C ▁. ▁LENGTH _ UNSET ▁) ▁; ▁assertThat ▁( ▁input ▁. ▁getPosition ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁123 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁read Multiple Times ▁( ▁) ▁throws ▁Exception ▁{ ▁Default Extractor Input ▁input ▁= ▁createDefault Extractor Input ▁( ▁) ▁; ▁byte ▁[ ▁] ▁target ▁= ▁new ▁byte ▁[ ▁TEST _ DATA ▁. ▁length ▁] ▁; ▁int ▁bytesRead ▁= ▁0 ▁; ▁bytesRead ▁+= ▁input ▁. ▁read ▁( ▁target ▁, ▁0 ▁, ▁TEST _ DATA ▁. ▁length ▁) ▁; ▁assertThat ▁( ▁bytesRead ▁) ▁. ▁isEqualTo ▁( ▁3 ▁) ▁; ▁bytesRead ▁+= ▁input ▁. ▁read ▁( ▁target ▁, ▁3 ▁, ▁TEST _ DATA ▁. ▁length ▁) ▁; ▁assertThat ▁( ▁bytesRead ▁) ▁. ▁isEqualTo ▁( ▁6 ▁) ▁; ▁bytesRead ▁+= ▁input ▁. ▁read ▁( ▁target ▁, ▁6 ▁, ▁TEST _ DATA ▁. ▁length ▁) ▁; ▁assertThat ▁( ▁bytesRead ▁) ▁. ▁isEqualTo ▁( ▁9 ▁) ▁; ▁assertThat ▁( ▁input ▁. ▁getPosition ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁9 ▁) ▁; ▁assertThat ▁( ▁TEST _ DATA ▁) ▁. ▁isEqualTo ▁( ▁target ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁read Already Peek ed ▁( ▁) ▁throws ▁Exception ▁{ ▁Default Extractor Input ▁input ▁= ▁createDefault Extractor Input ▁( ▁) ▁; ▁byte ▁[ ▁] ▁target ▁= ▁new ▁byte ▁[ ▁TEST _ DATA ▁. ▁length ▁] ▁; ▁input ▁. ▁advance Peek Position ▁( ▁TEST _ DATA ▁. ▁length ▁) ▁; ▁int ▁bytesRead ▁= ▁input ▁. ▁read ▁( ▁target ▁, ▁0 ▁, ▁TEST _ DATA ▁. ▁length ▁- ▁1 ▁) ▁; ▁assertThat ▁( ▁bytesRead ▁) ▁. ▁isEqualTo ▁( ▁TEST _ DATA ▁. ▁length ▁- ▁1 ▁) ▁; ▁assertThat ▁( ▁input ▁. ▁getPosition ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁TEST _ DATA ▁. ▁length ▁- ▁1 ▁) ▁; ▁assertThat ▁( ▁Arrays ▁. ▁copyOf ▁( ▁TEST _ DATA ▁, ▁TEST _ DATA ▁. ▁length ▁- ▁1 ▁) ▁) ▁. ▁isEqualTo ▁( ▁Arrays ▁. ▁copyOf ▁( ▁target ▁, ▁TEST _ DATA ▁. ▁length ▁- ▁1 ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁read Partial ly Peek ed ▁( ▁) ▁throws ▁Exception ▁{ ▁Default Extractor Input ▁input ▁= ▁createDefault Extractor Input ▁( ▁) ▁; ▁byte ▁[ ▁] ▁target ▁= ▁new ▁byte ▁[ ▁TEST _ DATA ▁. ▁length ▁] ▁; ▁input ▁. ▁advance Peek Position ▁( ▁TEST _ DATA ▁. ▁length ▁- ▁1 ▁) ▁; ▁int ▁bytesRead ▁= ▁input ▁. ▁read ▁( ▁target ▁, ▁0 ▁, ▁TEST _ DATA ▁. ▁length ▁) ▁;
▁public ▁class ▁Test Short Decimal Max Aggregation ▁extends ▁AbstractTest Aggregation Function ▁{ ▁public ▁static ▁final ▁DecimalType ▁SHORT _ DE CIMAL ▁= ▁DecimalType ▁. ▁create Decimal Type ▁( ▁10 ▁, ▁5 ▁) ▁; ▁@ ▁Override ▁public ▁Block ▁[ ▁] ▁getSequence Blocks ▁( ▁int ▁start ▁, ▁int ▁length ▁) ▁{ ▁BlockBuilder ▁blockBuilder ▁= ▁SHORT _ DE CIMAL ▁. ▁create BlockBuilder ▁( ▁null ▁, ▁length ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁start ▁; ▁i ▁< ▁start ▁+ ▁length ▁; ▁i ▁++ ▁) ▁{ ▁SHORT _ DE CIMAL ▁. ▁writeLong ▁( ▁blockBuilder ▁, ▁i ▁) ▁; ▁} ▁return ▁new ▁Block ▁[ ▁] ▁{ ▁blockBuilder ▁. ▁build ▁( ▁) ▁} ▁; ▁} ▁@ ▁Override ▁public ▁Sql Decimal ▁getExpected Value ▁( ▁int ▁start ▁, ▁int ▁length ▁) ▁{ ▁if ▁( ▁length ▁== ▁0 ▁) ▁{ ▁return ▁null ▁; ▁} ▁return ▁Sql Decimal ▁. ▁of ▁( ▁start ▁+ ▁length ▁- ▁1 ▁, ▁10 ▁, ▁5 ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁String ▁getFunction Name ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁protected ▁List ▁< ▁String ▁> ▁getFunction ParameterTypes ▁( ▁) ▁{ ▁return ▁ImmutableList ▁. ▁of ▁( ▁SHORT _ DE CIMAL ▁. ▁getType Signature ▁( ▁) ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁Del imiter Based Frame Decoder Test ▁{ ▁@ ▁Test ▁public ▁void ▁test Multiple Lines Strip ped Del imit ers ▁( ▁) ▁{ ▁EmbeddedChannel ▁ch ▁= ▁new ▁EmbeddedChannel ▁( ▁new ▁Del imiter Based Frame Decoder ▁( ▁8192 ▁, ▁true ▁, ▁Del imit ers ▁. ▁line Delimiter ▁( ▁) ▁) ▁) ▁; ▁ch ▁. ▁writeInbound ▁( ▁Unpooled ▁. ▁copied Buffer ▁( ▁STR ▁, ▁Charset ▁. ▁defaultCharset ▁( ▁) ▁) ▁) ▁; ▁ByteBuf ▁buf ▁= ▁ch ▁. ▁readInbound ▁( ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁buf ▁. ▁toString ▁( ▁Charset ▁. ▁defaultCharset ▁( ▁) ▁) ▁) ▁; ▁ByteBuf ▁buf 2 ▁= ▁ch ▁. ▁readInbound ▁( ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁buf 2 ▁. ▁toString ▁( ▁Charset ▁. ▁defaultCharset ▁( ▁) ▁) ▁) ▁; ▁assertNull ▁( ▁ch ▁. ▁readInbound ▁( ▁) ▁) ▁; ▁ch ▁. ▁finish ▁( ▁) ▁; ▁buf ▁. ▁release ▁( ▁) ▁; ▁buf 2 ▁. ▁release ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test In complete Lines Strip ped Del imit ers ▁( ▁) ▁{ ▁EmbeddedChannel ▁ch ▁= ▁new ▁EmbeddedChannel ▁( ▁new ▁Del imiter Based Frame Decoder ▁( ▁8192 ▁, ▁true ▁, ▁Del imit ers ▁. ▁line Delimiter ▁( ▁) ▁) ▁) ▁; ▁ch ▁. ▁writeInbound ▁( ▁Unpooled ▁. ▁copied Buffer ▁( ▁STR ▁, ▁Charset ▁. ▁defaultCharset ▁( ▁) ▁) ▁) ▁; ▁assertNull ▁( ▁ch ▁. ▁readInbound ▁( ▁) ▁) ▁; ▁ch ▁. ▁writeInbound ▁( ▁Unpooled ▁. ▁copied Buffer ▁( ▁STR ▁, ▁Charset ▁. ▁defaultCharset ▁( ▁) ▁) ▁) ▁; ▁ByteBuf ▁buf ▁= ▁ch ▁. ▁readInbound ▁( ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁buf ▁. ▁toString ▁( ▁Charset ▁. ▁defaultCharset ▁( ▁) ▁) ▁) ▁; ▁ByteBuf ▁buf 2 ▁= ▁ch ▁. ▁readInbound ▁( ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁buf 2 ▁. ▁toString ▁( ▁Charset ▁. ▁defaultCharset ▁( ▁) ▁) ▁) ▁; ▁assertNull ▁( ▁ch ▁. ▁readInbound ▁( ▁) ▁) ▁; ▁ch ▁. ▁finish ▁( ▁) ▁; ▁buf ▁. ▁release ▁( ▁) ▁; ▁buf 2 ▁. ▁release ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Multiple Lines ▁( ▁) ▁{ ▁EmbeddedChannel ▁ch ▁= ▁new ▁EmbeddedChannel ▁( ▁new ▁Del imiter Based Frame Decoder ▁( ▁8192 ▁, ▁false ▁, ▁Del imit ers ▁. ▁line Delimiter ▁( ▁) ▁) ▁) ▁; ▁ch ▁. ▁writeInbound ▁( ▁Unpooled ▁. ▁copied Buffer ▁( ▁STR ▁, ▁Charset ▁. ▁defaultCharset ▁( ▁) ▁) ▁) ▁; ▁ByteBuf ▁buf ▁= ▁ch ▁. ▁readInbound ▁( ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁buf ▁. ▁toString ▁( ▁Charset ▁. ▁defaultCharset ▁( ▁) ▁) ▁) ▁; ▁ByteBuf ▁buf 2 ▁= ▁ch ▁. ▁readInbound ▁( ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁buf 2 ▁. ▁toString ▁( ▁Charset ▁. ▁defaultCharset ▁( ▁) ▁) ▁) ▁; ▁assertNull ▁( ▁ch ▁. ▁readInbound ▁( ▁) ▁) ▁; ▁ch ▁. ▁finish ▁( ▁) ▁; ▁buf ▁. ▁release ▁( ▁) ▁; ▁buf 2 ▁. ▁release ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test In complete Lines ▁( ▁) ▁{ ▁EmbeddedChannel ▁ch ▁= ▁new ▁EmbeddedChannel ▁( ▁new ▁Del imiter Based Frame Decoder ▁( ▁8192 ▁, ▁false ▁, ▁Del imit ers ▁. ▁line Delimiter ▁( ▁) ▁) ▁) ▁;
▁public ▁class ▁Object T ▁{ ▁private ▁int ▁a ▁= ▁0 ▁; ▁private ▁int ▁b ▁= ▁0 ▁; ▁private ▁int ▁c ▁= ▁0 ▁; ▁private ▁List ▁< ▁Object T _ A ▁> ▁d ▁; ▁private ▁int ▁e ▁= ▁0 ▁; ▁private ▁int ▁f ▁; ▁private ▁int ▁g ▁; ▁private ▁int ▁h ▁; ▁private ▁int ▁i ▁; ▁private ▁int ▁j ▁; ▁private ▁boolean ▁k ▁= ▁false ▁; ▁public ▁int ▁getA ▁( ▁) ▁{ ▁return ▁a ▁; ▁} ▁public ▁void ▁setA ▁( ▁int ▁a ▁) ▁{ ▁this ▁. ▁a ▁= ▁a ▁; ▁} ▁public ▁int ▁getB ▁( ▁) ▁{ ▁return ▁b ▁; ▁} ▁public ▁void ▁setB ▁( ▁int ▁b ▁) ▁{ ▁this ▁. ▁b ▁= ▁b ▁; ▁} ▁public ▁int ▁getC ▁( ▁) ▁{ ▁return ▁c ▁; ▁} ▁public ▁void ▁setC ▁( ▁int ▁c ▁) ▁{ ▁this ▁. ▁c ▁= ▁c ▁; ▁} ▁public ▁List ▁< ▁Object T _ A ▁> ▁getD ▁( ▁) ▁{ ▁return ▁d ▁; ▁} ▁public ▁void ▁setD ▁( ▁List ▁< ▁Object T _ A ▁> ▁d ▁) ▁{ ▁this ▁. ▁d ▁= ▁d ▁; ▁} ▁public ▁int ▁getE ▁( ▁) ▁{ ▁return ▁e ▁; ▁} ▁public ▁void ▁set E ▁( ▁int ▁e ▁) ▁{ ▁this ▁. ▁e ▁= ▁e ▁; ▁} ▁public ▁int ▁getF ▁( ▁) ▁{ ▁return ▁f ▁; ▁} ▁public ▁void ▁setF ▁( ▁int ▁f ▁) ▁{ ▁this ▁. ▁f ▁= ▁f ▁; ▁} ▁public ▁int ▁getG ▁( ▁) ▁{ ▁return ▁g ▁; ▁} ▁public ▁void ▁setG ▁( ▁int ▁g ▁) ▁{ ▁this ▁. ▁g ▁= ▁g ▁; ▁} ▁public ▁int ▁getH ▁( ▁) ▁{ ▁return ▁h ▁; ▁} ▁public ▁void ▁setH ▁( ▁int ▁h ▁) ▁{ ▁this ▁. ▁h ▁= ▁h ▁; ▁} ▁public ▁int ▁getI ▁( ▁) ▁{ ▁return ▁i ▁; ▁} ▁public ▁void ▁set I ▁( ▁int ▁i ▁) ▁{ ▁this ▁. ▁i ▁= ▁i ▁; ▁} ▁public ▁int ▁getJ ▁( ▁) ▁{ ▁return ▁j ▁; ▁} ▁public ▁void ▁set J ▁( ▁int ▁j ▁) ▁{ ▁this ▁. ▁j ▁= ▁j ▁; ▁} ▁public ▁boolean ▁is K ▁( ▁) ▁{ ▁return ▁k ▁; ▁} ▁public ▁void ▁set K ▁( ▁boolean ▁k ▁) ▁{ ▁this ▁. ▁k ▁= ▁k ▁; ▁} ▁}
▁@ ▁SpringBoot Application ▁public ▁class ▁My Application ▁{ ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Spring Application ▁application ▁= ▁new ▁Spring Application ▁( ▁My Application ▁. ▁class ▁) ▁; ▁application ▁. ▁setB anner Mode ▁( ▁B anner ▁. ▁Mode ▁. ▁OFF ▁) ▁; ▁application ▁. ▁run ▁( ▁args ▁) ▁; ▁} ▁}
▁z os ▁. ▁put NextEntry ▁( ▁z e ▁) ▁; ▁z os ▁. ▁write ▁( ▁input ▁. ▁getBytes ▁( ▁STR ▁) ▁) ▁; ▁z os ▁. ▁closeEntry ▁( ▁) ▁; ▁z os ▁. ▁close ▁( ▁) ▁; ▁} ▁protected ▁String ▁[ ▁] ▁gen Args ▁( ▁) ▁{ ▁String ▁work Dir ▁= ▁file Sys ▁. ▁getWork ingDirectory ▁( ▁) ▁. ▁toString ▁( ▁) ▁+ ▁STR ▁; ▁String ▁cache 1 ▁= ▁work Dir ▁+ ▁CACHE _ ARCHIVE _1 ▁+ ▁STR ▁; ▁String ▁cache 2 ▁= ▁work Dir ▁+ ▁CACHE _ ARCHIVE _2 ▁+ ▁STR ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁String ▁> ▁entry ▁: ▁mr ▁. ▁createJob Conf ▁( ▁) ▁) ▁{ ▁args ▁. ▁add ▁( ▁STR ▁) ▁; ▁args ▁. ▁add ▁( ▁entry ▁. ▁getKey ▁( ▁) ▁+ ▁STR ▁+ ▁entry ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁args ▁. ▁add ▁( ▁STR ▁) ▁; ▁args ▁. ▁add ▁( ▁STR ▁) ▁; ▁args ▁. ▁add ▁( ▁STR ▁) ▁; ▁args ▁. ▁add ▁( ▁cache 1 ▁) ▁; ▁args ▁. ▁add ▁( ▁STR ▁) ▁; ▁args ▁. ▁add ▁( ▁cache 2 ▁) ▁; ▁args ▁. ▁add ▁( ▁STR ▁) ▁; ▁args ▁. ▁add ▁( ▁STR ▁+ ▁STREAM ING _ JAR ▁) ▁; ▁return ▁super ▁. ▁gen Args ▁( ▁) ▁; ▁} ▁protected ▁void ▁check Output ▁( ▁) ▁throws ▁IOException ▁{ ▁StringBuffer ▁output ▁= ▁new ▁StringBuffer ▁( ▁256 ▁) ▁; ▁Path ▁[ ▁] ▁file List ▁= ▁FileUtil ▁. ▁stat 2 Paths ▁( ▁file Sys ▁. ▁listStatus ▁( ▁new ▁Path ▁( ▁OUTPUT _ DIR ▁) ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁file List ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁LOG ▁. ▁info ▁( ▁STR ▁+ ▁file List ▁[ ▁i ▁] ▁) ▁; ▁output ▁. ▁append ▁( ▁Stream Util ▁. ▁sl ur p Hadoop ▁( ▁file List ▁[ ▁i ▁] ▁, ▁file Sys ▁) ▁) ▁; ▁} ▁assertOutput ▁( ▁expectedOutput ▁, ▁output ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁}
▁@ ▁No ArgsConstructor ▁( ▁access ▁= ▁AccessLevel ▁. ▁PRIVATE ▁) ▁public ▁final ▁class ▁Set Variable Statement Assert ▁{ ▁public ▁static ▁void ▁assertIs ▁( ▁final ▁SQLCase AssertContext ▁assertContext ▁, ▁final ▁Set Statement ▁actual ▁, ▁final ▁Set Variable Statement TestCase ▁expected ▁) ▁{ ▁assertThat ▁( ▁assertContext ▁. ▁getText ▁( ▁STR ▁) ▁, ▁actual ▁. ▁getVariable Assign s ▁( ▁) ▁. ▁size ▁( ▁) ▁, ▁is ▁( ▁expected ▁. ▁getValue Assign s ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁) ▁; ▁if ▁( ▁! ▁expected ▁. ▁getValue Assign s ▁( ▁) ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁expected ▁. ▁getValue Assign s ▁( ▁) ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁assert Variable ▁( ▁assertContext ▁, ▁actual ▁. ▁getVariable Assign s ▁( ▁) ▁. ▁get ▁( ▁i ▁) ▁. ▁getVariable ▁( ▁) ▁, ▁expected ▁. ▁getValue Assign s ▁( ▁) ▁. ▁get ▁( ▁i ▁) ▁. ▁getVariable ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁assertContext ▁. ▁getText ▁( ▁STR ▁) ▁, ▁actual ▁. ▁getVariable Assign s ▁( ▁) ▁. ▁get ▁( ▁i ▁) ▁. ▁getAss ign Value ▁( ▁) ▁, ▁is ▁( ▁expected ▁. ▁getValue Assign s ▁( ▁) ▁. ▁get ▁( ▁i ▁) ▁. ▁getValue ▁( ▁) ▁) ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁void ▁assert Variable ▁( ▁final ▁SQLCase AssertContext ▁assertContext ▁, ▁final ▁Variable Segment ▁actual ▁, ▁final ▁Expected Variable ▁expected ▁) ▁{ ▁assertThat ▁( ▁assertContext ▁. ▁getText ▁( ▁STR ▁) ▁, ▁actual ▁. ▁getVariable ▁( ▁) ▁, ▁is ▁( ▁expected ▁. ▁getName ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁assertContext ▁. ▁getText ▁( ▁STR ▁) ▁, ▁actual ▁. ▁getScope ▁( ▁) ▁, ▁is ▁( ▁expected ▁. ▁getScope ▁( ▁) ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁S te mm er Token FilterFactory Tests ▁extends ▁ES TokenStream TestCase ▁{ ▁private ▁static ▁final ▁Common Analysis Plugin ▁P LUGIN ▁= ▁new ▁Common Analysis Plugin ▁( ▁) ▁; ▁public ▁void ▁test En gl ish FilterFactory ▁( ▁) ▁throws ▁IOException ▁{ ▁int ▁iter s ▁= ▁scaled Random Int Between ▁( ▁20 ▁, ▁100 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁iter s ▁; ▁i ▁++ ▁) ▁{ ▁Version ▁v ▁= ▁Version Utils ▁. ▁random Version ▁( ▁random ▁( ▁) ▁) ▁; ▁Settings ▁settings ▁= ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁. ▁put ▁( ▁SETTING _ VERSION _ CREATED ▁, ▁v ▁) ▁. ▁put ▁( ▁Environment ▁. ▁PATH _ HOME _ SETTING ▁. ▁getKey ▁( ▁) ▁, ▁createTempDir ▁( ▁) ▁. ▁toString ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁ESTestCase ▁. ▁Test Analysis ▁analysis ▁= ▁Analysis Tests Helper ▁. ▁createTest Analysis From Settings ▁( ▁settings ▁, ▁P LUGIN ▁) ▁; ▁Token FilterFactory ▁token Filter ▁= ▁analysis ▁. ▁token Filter ▁. ▁get ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁token Filter ▁, ▁instanceOf ▁( ▁S te mm er Token FilterFactory ▁. ▁class ▁) ▁) ▁; ▁Tokenizer ▁tokenizer ▁= ▁new ▁White space Tokenizer ▁( ▁) ▁; ▁tokenizer ▁. ▁set Reader ▁( ▁new ▁StringReader ▁( ▁STR ▁) ▁) ▁; ▁TokenStream ▁create ▁= ▁token Filter ▁. ▁create ▁( ▁tokenizer ▁) ▁; ▁Index Analyzers ▁index Analyzers ▁= ▁analysis ▁. ▁index Analyzers ▁; ▁Named Analyzer ▁analyzer ▁= ▁index Analyzers ▁. ▁get ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁create ▁, ▁instanceOf ▁( ▁P orter S tem Filter ▁. ▁class ▁) ▁) ▁; ▁assert Analyz es To ▁( ▁analyzer ▁, ▁STR ▁, ▁new ▁String ▁[ ▁] ▁{ ▁STR ▁} ▁) ▁; ▁} ▁} ▁public ▁void ▁test P orter 2 FilterFactory ▁( ▁) ▁throws ▁IOException ▁{ ▁int ▁iter s ▁= ▁scaled Random Int Between ▁( ▁20 ▁, ▁100 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁iter s ▁; ▁i ▁++ ▁) ▁{ ▁Version ▁v ▁= ▁Version Utils ▁. ▁random Version ▁( ▁random ▁( ▁) ▁) ▁; ▁Settings ▁settings ▁= ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁. ▁put ▁( ▁SETTING _ VERSION _ CREATED ▁, ▁v ▁) ▁. ▁put ▁( ▁Environment ▁. ▁PATH _ HOME _ SETTING ▁. ▁getKey ▁( ▁) ▁, ▁createTempDir ▁( ▁) ▁. ▁toString ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁ESTestCase ▁. ▁Test Analysis ▁analysis ▁= ▁Analysis Tests Helper ▁. ▁createTest Analysis From Settings ▁( ▁settings ▁, ▁P LUGIN ▁) ▁; ▁Token FilterFactory ▁token Filter ▁= ▁analysis ▁. ▁token Filter ▁. ▁get ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁token Filter ▁, ▁instanceOf ▁( ▁S te mm er Token FilterFactory ▁. ▁class ▁) ▁) ▁; ▁Tokenizer ▁tokenizer ▁= ▁new ▁White space Tokenizer ▁( ▁) ▁;
▁@ ▁Override ▁public ▁void ▁append Fields ▁( ▁StringBuilder ▁sb ▁) ▁{ ▁sb ▁. ▁append ▁( ▁STR ▁) ▁. ▁append ▁( ▁value ▁) ▁. ▁append ▁( ▁STR ▁) ▁; ▁super ▁. ▁append Fields ▁( ▁sb ▁) ▁; ▁} ▁} ▁public ▁void ▁test Sub Interfaces Of Collection Serialization ▁( ▁) ▁throws ▁Exception ▁{ ▁List ▁< ▁Integer ▁> ▁list ▁= ▁new ▁LinkedList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁list ▁. ▁add ▁( ▁0 ▁) ▁; ▁list ▁. ▁add ▁( ▁1 ▁) ▁; ▁list ▁. ▁add ▁( ▁2 ▁) ▁; ▁list ▁. ▁add ▁( ▁3 ▁) ▁; ▁Queue ▁< ▁Long ▁> ▁queue ▁= ▁new ▁LinkedList ▁< ▁Long ▁> ▁( ▁) ▁; ▁queue ▁. ▁add ▁( ▁0 L ▁) ▁; ▁queue ▁. ▁add ▁( ▁1 L ▁) ▁; ▁queue ▁. ▁add ▁( ▁2 L ▁) ▁; ▁queue ▁. ▁add ▁( ▁3 L ▁) ▁; ▁Set ▁< ▁Float ▁> ▁set ▁= ▁new ▁TreeSet ▁< ▁Float ▁> ▁( ▁) ▁; ▁set ▁. ▁add ▁( ▁0.1 F ▁) ▁; ▁set ▁. ▁add ▁( ▁0.2 F ▁) ▁; ▁set ▁. ▁add ▁( ▁0.3 F ▁) ▁; ▁set ▁. ▁add ▁( ▁0. 4 F ▁) ▁; ▁SortedSet ▁< ▁Character ▁> ▁sorted Set ▁= ▁new ▁TreeSet ▁< ▁Character ▁> ▁( ▁) ▁; ▁sorted Set ▁. ▁add ▁( ▁CHAR ▁) ▁; ▁sorted Set ▁. ▁add ▁( ▁CHAR ▁) ▁; ▁sorted Set ▁. ▁add ▁( ▁CHAR ▁) ▁; ▁sorted Set ▁. ▁add ▁( ▁CHAR ▁) ▁; ▁Class With Sub Interfaces Of Collection ▁target ▁= ▁new ▁Class With Sub Interfaces Of Collection ▁( ▁list ▁, ▁queue ▁, ▁set ▁, ▁sorted Set ▁) ▁; ▁assertEquals ▁( ▁target ▁. ▁getExpected Json ▁( ▁) ▁, ▁gson ▁. ▁toJson ▁( ▁target ▁) ▁) ▁; ▁} ▁public ▁void ▁test Sub Interfaces Of Collection Deserialization ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁json ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁; ▁Class With Sub Interfaces Of Collection ▁target ▁= ▁gson ▁. ▁fromJson ▁( ▁json ▁, ▁Class With Sub Interfaces Of Collection ▁. ▁class ▁) ▁; ▁assertTrue ▁( ▁target ▁. ▁list Contains ▁( ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁) ▁) ▁; ▁assertTrue ▁( ▁target ▁. ▁queue Contains ▁( ▁0 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁) ▁) ▁; ▁assertTrue ▁( ▁target ▁. ▁set Contains ▁( ▁0.1 F ▁, ▁0.2 F ▁, ▁0.3 F ▁, ▁0. 4 F ▁) ▁) ▁; ▁assertTrue ▁( ▁target ▁. ▁sorted Set Contains ▁( ▁CHAR ▁, ▁CHAR ▁, ▁CHAR ▁, ▁CHAR ▁) ▁) ▁; ▁} ▁private ▁static ▁class ▁Class With Sub Interfaces Of Collection ▁{ ▁private ▁List ▁< ▁Integer ▁> ▁list ▁; ▁private ▁Queue ▁< ▁Long ▁> ▁queue ▁; ▁private ▁Set ▁< ▁Float ▁> ▁set ▁; ▁private ▁SortedSet ▁< ▁Character ▁> ▁sorted Set ▁; ▁public ▁Class With Sub Interfaces Of Collection ▁( ▁List ▁< ▁Integer ▁> ▁list ▁, ▁Queue ▁< ▁Long ▁> ▁queue ▁, ▁Set ▁< ▁Float ▁> ▁set ▁, ▁SortedSet ▁< ▁Character ▁> ▁sorted Set ▁) ▁{ ▁this ▁. ▁list ▁= ▁list ▁; ▁this ▁. ▁queue ▁= ▁queue ▁; ▁this ▁. ▁set ▁= ▁set ▁; ▁this ▁. ▁sorted Set ▁= ▁sorted Set ▁; ▁}
▁public ▁class ▁Jndi Re disson Region Factory ▁extends ▁Redisson Region Factory ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁- ▁48 14 50 26 7 50 83 32 5 56 7 L ▁; ▁public ▁static ▁final ▁String ▁J N DI _ NAME ▁= ▁CONFIG _ PREFIX ▁+ ▁STR ▁; ▁@ ▁Override ▁protected ▁RedissonClient ▁create Re disson Client ▁( ▁Properties ▁properties ▁) ▁{ ▁String ▁jndi Name ▁= ▁Configuration Helper ▁. ▁getString ▁( ▁J N DI _ NAME ▁, ▁properties ▁) ▁; ▁if ▁( ▁jndi Name ▁== ▁null ▁) ▁{ ▁throw ▁new ▁CacheException ▁( ▁J N DI _ NAME ▁+ ▁STR ▁) ▁; ▁} ▁Properties ▁jndi Properties ▁= ▁Jndi ServiceImpl ▁. ▁extract J ndi Properties ▁( ▁properties ▁) ▁; ▁Initial Context ▁context ▁= ▁null ▁; ▁try ▁{ ▁context ▁= ▁new ▁Initial Context ▁( ▁jndi Properties ▁) ▁; ▁return ▁( ▁RedissonClient ▁) ▁context ▁. ▁lookup ▁( ▁jndi Name ▁) ▁; ▁} ▁catch ▁( ▁NamingException ▁e ▁) ▁{ ▁throw ▁new ▁CacheException ▁( ▁STR ▁+ ▁jndi Name ▁, ▁e ▁) ▁; ▁} ▁finally ▁{ ▁if ▁( ▁context ▁!= ▁null ▁) ▁{ ▁try ▁{ ▁context ▁. ▁close ▁( ▁) ▁; ▁} ▁catch ▁( ▁NamingException ▁e ▁) ▁{ ▁throw ▁new ▁CacheException ▁( ▁STR ▁, ▁e ▁) ▁; ▁} ▁} ▁} ▁} ▁@ ▁Override ▁public ▁void ▁stop ▁( ▁) ▁{ ▁} ▁}
▁public ▁class ▁Standard ize ▁extends ▁DynamicCustomOp ▁{ ▁public ▁Standard ize ▁( ▁SameDiff ▁sameDiff ▁, ▁SDVariable ▁i _ v ▁, ▁int ▁... ▁dimensions ▁) ▁{ ▁super ▁( ▁null ▁, ▁sameDiff ▁, ▁new ▁SDVariable ▁[ ▁] ▁{ ▁i _ v ▁} ▁, ▁false ▁) ▁; ▁setD im ensions ▁( ▁dimensions ▁) ▁; ▁} ▁public ▁Standard ize ▁( ▁INDArray ▁input ▁, ▁int ▁... ▁dimensions ▁) ▁{ ▁this ▁( ▁input ▁, ▁null ▁, ▁dimensions ▁) ▁; ▁} ▁public ▁Standard ize ▁( ▁INDArray ▁input ▁, ▁INDArray ▁result ▁, ▁int ▁... ▁dimensions ▁) ▁{ ▁super ▁( ▁STR ▁, ▁new ▁INDArray ▁[ ▁] ▁{ ▁input ▁} ▁, ▁wrap OrNull ▁( ▁result ▁) ▁) ▁; ▁setD im ensions ▁( ▁dimensions ▁) ▁; ▁} ▁public ▁Standard ize ▁( ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁setD im ensions ▁( ▁int ▁[ ▁] ▁dimensions ▁) ▁{ ▁Preconditions ▁. ▁checkArgument ▁( ▁dimensions ▁!= ▁null ▁, ▁STR ▁) ▁; ▁Preconditions ▁. ▁checkArgument ▁( ▁dimensions ▁. ▁length ▁> ▁0 ▁, ▁STR ▁) ▁; ▁this ▁. ▁dimensions ▁= ▁dimensions ▁; ▁addIArgument ▁( ▁dimensions ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁opName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁SDVariable ▁> ▁doDiff ▁( ▁List ▁< ▁SDVariable ▁> ▁grad ▁) ▁{ ▁return ▁new ▁Standard ize Bp ▁( ▁sameDiff ▁, ▁arg ▁( ▁0 ▁) ▁, ▁grad ▁. ▁get ▁( ▁0 ▁) ▁, ▁dimensions ▁) ▁. ▁outputs ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁DataType ▁> ▁calculateOutput DataTypes ▁( ▁List ▁< ▁DataType ▁> ▁dataTypes ▁) ▁{ ▁Preconditions ▁. ▁checkState ▁( ▁dataTypes ▁!= ▁null ▁&& ▁dataTypes ▁. ▁size ▁( ▁) ▁== ▁1 ▁, ▁STR ▁, ▁getClass ▁( ▁) ▁, ▁dataTypes ▁) ▁; ▁Preconditions ▁. ▁checkState ▁( ▁dataTypes ▁. ▁get ▁( ▁0 ▁) ▁. ▁isF P Type ▁( ▁) ▁, ▁STR ▁, ▁dataTypes ▁. ▁get ▁( ▁0 ▁) ▁) ▁; ▁return ▁Collections ▁. ▁singletonList ▁( ▁dataTypes ▁. ▁get ▁( ▁0 ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁MySqlSelectTest _8 ▁extends ▁MysqlTest ▁{ ▁public ▁void ▁test _0 ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁MySql StatementParser ▁parser ▁= ▁new ▁MySql StatementParser ▁( ▁sql ▁) ▁; ▁List ▁< ▁SQLStatement ▁> ▁statementList ▁= ▁parser ▁. ▁parseStatement List ▁( ▁) ▁; ▁SQLStatement ▁stmt ▁= ▁statementList ▁. ▁get ▁( ▁0 ▁) ▁; ▁SQLSelect Statement ▁select Stmt ▁= ▁( ▁SQLSelect Statement ▁) ▁stmt ▁; ▁SQLSelect ▁select ▁= ▁select Stmt ▁. ▁getSelect ▁( ▁) ▁; ▁Assert ▁. ▁assertNotNull ▁( ▁select ▁. ▁getQuery ▁( ▁) ▁) ▁; ▁MySql Select QueryBlock ▁queryBlock ▁= ▁( ▁MySql Select QueryBlock ▁) ▁select ▁. ▁getQuery ▁( ▁) ▁; ▁Assert ▁. ▁assertNull ▁( ▁queryBlock ▁. ▁getOrderBy ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁1 ▁, ▁statementList ▁. ▁size ▁( ▁) ▁) ▁; ▁MySqlSchema StatVisitor ▁visitor ▁= ▁new ▁MySqlSchema StatVisitor ▁( ▁) ▁; ▁stmt ▁. ▁accept ▁( ▁visitor ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁0 ▁, ▁visitor ▁. ▁getTables ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁0 ▁, ▁visitor ▁. ▁getColumns ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁0 ▁, ▁visitor ▁. ▁getConditions ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁0 ▁, ▁visitor ▁. ▁getOrderBy Columns ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁}
▁DiscoveryNodes ▁. ▁Builder ▁dis co Builder ▁= ▁DiscoveryNodes ▁. ▁builder ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁numberOf Nodes ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁final ▁DiscoveryNode ▁node ▁= ▁newNode ▁( ▁i ▁) ▁; ▁dis co Builder ▁= ▁dis co Builder ▁. ▁add ▁( ▁node ▁) ▁; ▁} ▁dis co Builder ▁. ▁local NodeId ▁( ▁newNode ▁( ▁0 ▁) ▁. ▁getId ▁( ▁) ▁) ▁; ▁dis co Builder ▁. ▁master NodeId ▁( ▁newNode ▁( ▁1 ▁) ▁. ▁getId ▁( ▁) ▁) ▁; ▁IndexMetadata ▁indexMetadata ▁= ▁IndexMetadata ▁. ▁builder ▁( ▁index ▁) ▁. ▁settings ▁( ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁SETTING _ VERSION _ CREATED ▁, ▁Version ▁. ▁CURRENT ▁) ▁. ▁put ▁( ▁SETTING _ NUMBER _ OF _ SHAR DS ▁, ▁numberOf Shards ▁) ▁. ▁put ▁( ▁SETTING _ NUMBER _ OF _ REP LIC AS ▁, ▁1 ▁) ▁. ▁put ▁( ▁SETTING _ CRE ATION _ DATE ▁, ▁System ▁. ▁current TimeMillis ▁( ▁) ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁ClusterState ▁. ▁Builder ▁state ▁= ▁ClusterState ▁. ▁builder ▁( ▁new ▁ClusterName ▁( ▁STR ▁) ▁) ▁; ▁state ▁. ▁nodes ▁( ▁dis co Builder ▁) ▁; ▁state ▁. ▁metadata ▁( ▁Metadata ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁indexMetadata ▁, ▁false ▁) ▁. ▁generate Cluster Uuid IfNeeded ▁( ▁) ▁) ▁; ▁Index Routing Table ▁. ▁Builder ▁index Routing Table Builder ▁= ▁Index Routing Table ▁. ▁builder ▁( ▁indexMetadata ▁. ▁getIndex ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁numberOf Shards ▁; ▁i ▁++ ▁) ▁{ ▁final ▁ShardId ▁shardId ▁= ▁new ▁ShardId ▁( ▁index ▁, ▁STR ▁, ▁i ▁) ▁; ▁IndexShard Routing Table ▁. ▁Builder ▁index Shard Routing Builder ▁= ▁new ▁IndexShard Routing Table ▁. ▁Builder ▁( ▁shardId ▁) ▁; ▁index Shard Routing Builder ▁. ▁add Shard ▁( ▁Test Shard Routing ▁. ▁new Shard Routing ▁( ▁index ▁, ▁i ▁, ▁newNode ▁( ▁0 ▁) ▁. ▁getId ▁( ▁) ▁, ▁null ▁, ▁true ▁, ▁ShardRouting State ▁. ▁STARTED ▁) ▁) ▁; ▁index Shard Routing Builder ▁. ▁add Shard ▁( ▁Test Shard Routing ▁. ▁new Shard Routing ▁( ▁index ▁, ▁i ▁, ▁newNode ▁( ▁1 ▁) ▁. ▁getId ▁( ▁) ▁, ▁null ▁, ▁false ▁, ▁ShardRouting State ▁. ▁STARTED ▁) ▁) ▁; ▁index Routing Table Builder ▁. ▁add Index Shard ▁( ▁index Shard Routing Builder ▁. ▁build ▁( ▁) ▁) ▁; ▁} ▁state ▁. ▁routingTable ▁( ▁Routing Table ▁. ▁builder ▁( ▁) ▁. ▁add ▁( ▁index Routing Table Builder ▁. ▁build ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁return ▁state ▁. ▁build ▁( ▁) ▁; ▁} ▁public ▁static ▁ClusterState ▁state With Assigned P rim aries And Replicas ▁( ▁String ▁[ ▁] ▁indices ▁, ▁int ▁numberOf Shards ▁, ▁int ▁numberOf Replicas ▁) ▁{ ▁int ▁numberOf DataNodes ▁= ▁numberOf Replicas ▁+ ▁1 ▁; ▁DiscoveryNodes ▁. ▁Builder ▁dis co Builder ▁= ▁DiscoveryNodes ▁. ▁builder ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁numberOf DataNodes ▁+ ▁1 ▁; ▁i ▁++ ▁) ▁{ ▁final ▁DiscoveryNode ▁node ▁= ▁newNode ▁( ▁i ▁) ▁;
▁public ▁abstract ▁class ▁Abstract SQL Editor Text Hover ▁implements ▁I Text Hover ▁, ▁I Text Hover Extension ▁{ ▁public ▁Abstract SQL Editor Text Hover ▁( ▁) ▁{ ▁} ▁public ▁abstract ▁void ▁set Editor ▁( ▁IEditor Part ▁editor ▁) ▁; ▁@ ▁Override ▁public ▁I Information Control Creator ▁getH over Control Creator ▁( ▁) ▁{ ▁return ▁new ▁I Information Control Creator ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁I Information Control ▁create Information Control ▁( ▁Shell ▁parent ▁) ▁{ ▁Default Information Control ▁control ▁= ▁new ▁Default Information Control ▁( ▁parent ▁, ▁true ▁) ▁; ▁control ▁. ▁setSize Constraints ▁( ▁60 ▁, ▁10 ▁) ▁; ▁return ▁control ▁; ▁} ▁} ▁; ▁} ▁@ ▁Override ▁public ▁I Region ▁getH over Region ▁( ▁I Text Viewer ▁text Viewer ▁, ▁int ▁offset ▁) ▁{ ▁return ▁SQL Word Finder ▁. ▁find Word ▁( ▁text Viewer ▁. ▁getDocument ▁( ▁) ▁, ▁offset ▁) ▁; ▁} ▁}
▁public ▁class ▁MQ Version ▁{ ▁public ▁static ▁final ▁int ▁CURRENT _ VERSION ▁= ▁Version ▁. ▁V 4 _9 _0 ▁. ▁ordinal ▁( ▁) ▁; ▁public ▁static ▁String ▁getVersion Desc ▁( ▁int ▁value ▁) ▁{ ▁int ▁length ▁= ▁Version ▁. ▁values ▁( ▁) ▁. ▁length ▁; ▁if ▁( ▁value ▁>= ▁length ▁) ▁{ ▁return ▁Version ▁. ▁values ▁( ▁) ▁[ ▁length ▁- ▁1 ▁] ▁. ▁name ▁( ▁) ▁; ▁} ▁return ▁Version ▁. ▁values ▁( ▁) ▁[ ▁value ▁] ▁. ▁name ▁( ▁) ▁; ▁} ▁public ▁static ▁Version ▁value 2 Version ▁( ▁int ▁value ▁) ▁{ ▁int ▁length ▁= ▁Version ▁. ▁values ▁( ▁) ▁. ▁length ▁; ▁if ▁( ▁value ▁>= ▁length ▁) ▁{ ▁return ▁Version ▁. ▁values ▁( ▁) ▁[ ▁length ▁- ▁1 ▁] ▁; ▁} ▁return ▁Version ▁. ▁values ▁( ▁) ▁[ ▁value ▁] ▁; ▁}
▁public ▁class ▁DruidDataSource Test _ or acle 3 ▁extends ▁TestCase ▁{ ▁private ▁DruidDataSource ▁dataSource ▁; ▁protected ▁void ▁setUp ▁( ▁) ▁throws ▁Exception ▁{ ▁dataSource ▁= ▁new ▁DruidDataSource ▁( ▁) ▁; ▁dataSource ▁. ▁setUrl ▁( ▁STR ▁) ▁; ▁dataSource ▁. ▁setUsername ▁( ▁STR ▁) ▁; ▁dataSource ▁. ▁setPassword ▁( ▁STR ▁) ▁; ▁dataSource ▁. ▁setInitial Size ▁( ▁1 ▁) ▁; ▁dataSource ▁. ▁setMax Active ▁( ▁14 ▁) ▁; ▁dataSource ▁. ▁setMin Idle ▁( ▁1 ▁) ▁; ▁dataSource ▁. ▁setMin Ev ic table Idle TimeMillis ▁( ▁300 ▁ * ▁1000 ▁) ▁; ▁dataSource ▁. ▁setTime Between Eviction Runs Millis ▁( ▁180 ▁ * ▁1000 ▁) ▁; ▁dataSource ▁. ▁setTest While Idle ▁( ▁false ▁) ▁; ▁dataSource ▁. ▁setTestOnBorrow ▁( ▁false ▁) ▁; ▁dataSource ▁. ▁set Validation Query ▁( ▁STR ▁) ▁; ▁dataSource ▁. ▁setFilters ▁( ▁STR ▁) ▁; ▁} ▁protected ▁void ▁tearDown ▁( ▁) ▁throws ▁Exception ▁{ ▁dataSource ▁. ▁close ▁( ▁) ▁; ▁} ▁public ▁void ▁test _ error ▁( ▁) ▁throws ▁Exception ▁{ ▁dataSource ▁. ▁init ▁( ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁dataSource ▁. ▁is Oracle ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁dataSource ▁. ▁get Valid Connection Checker ▁( ▁) ▁instanceof ▁Oracle Valid Connection Checker ▁) ▁; ▁try ▁{ ▁Connection ▁conn ▁= ▁dataSource ▁. ▁getConnection ▁( ▁) ▁; ▁Statement ▁stmt ▁= ▁conn ▁. ▁createStatement ▁( ▁) ▁; ▁ResultSet ▁rs ▁= ▁stmt ▁. ▁executeQuery ▁( ▁STR ▁) ▁; ▁while ▁( ▁rs ▁. ▁next ▁( ▁) ▁) ▁{ ▁} ▁rs ▁. ▁close ▁( ▁) ▁; ▁stmt ▁. ▁close ▁( ▁) ▁; ▁conn ▁. ▁close ▁( ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁e ▁. ▁printStackTrace ▁( ▁) ▁; ▁} ▁try ▁{ ▁Connection ▁conn ▁= ▁dataSource ▁. ▁getConnection ▁( ▁) ▁; ▁Statement ▁stmt ▁= ▁conn ▁. ▁createStatement ▁( ▁) ▁; ▁ResultSet ▁rs ▁= ▁stmt ▁. ▁executeQuery ▁( ▁STR ▁) ▁; ▁while ▁( ▁rs ▁. ▁next ▁( ▁) ▁) ▁{ ▁} ▁rs ▁. ▁close ▁( ▁) ▁; ▁stmt ▁. ▁close ▁( ▁) ▁; ▁conn ▁. ▁close ▁( ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁e ▁. ▁printStackTrace ▁( ▁) ▁; ▁} ▁try ▁{ ▁Connection ▁conn ▁= ▁dataSource ▁. ▁getConnection ▁( ▁) ▁; ▁Statement ▁stmt ▁= ▁conn ▁. ▁createStatement ▁( ▁) ▁; ▁ResultSet ▁rs ▁= ▁stmt ▁. ▁executeQuery ▁( ▁STR ▁) ▁; ▁while ▁( ▁rs ▁. ▁next ▁( ▁) ▁) ▁{ ▁} ▁rs ▁. ▁close ▁( ▁) ▁; ▁stmt ▁. ▁close ▁( ▁) ▁; ▁conn ▁. ▁close ▁( ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁e ▁. ▁printStackTrace ▁( ▁) ▁; ▁} ▁} ▁}
▁public ▁class ▁JSON Config ▁implements ▁Serializable ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 19 73 03 55 20 47 38 2 78 L ▁; ▁private ▁boolean ▁order ▁; ▁private ▁boolean ▁ignore Error ▁; ▁private ▁boolean ▁ignore Case ▁; ▁private ▁String ▁dateFormat ▁; ▁private ▁boolean ▁ignore NullValue ▁= ▁true ▁; ▁private ▁boolean ▁transient Support ▁= ▁true ▁; ▁private ▁boolean ▁strip Trailing Z eros ▁= ▁true ▁; ▁public ▁static ▁JSON Config ▁create ▁( ▁) ▁{ ▁return ▁new ▁JSON Config ▁( ▁) ▁; ▁} ▁public ▁boolean ▁is Order ▁( ▁) ▁{ ▁return ▁order ▁; ▁} ▁public ▁JSON Config ▁setOrder ▁( ▁boolean ▁order ▁) ▁{ ▁this ▁. ▁order ▁= ▁order ▁; ▁return ▁this ▁; ▁} ▁public ▁boolean ▁is Ignore Error ▁( ▁) ▁{ ▁return ▁ignore Error ▁; ▁} ▁public ▁JSON Config ▁set Ignore Error ▁( ▁boolean ▁ignore Error ▁) ▁{ ▁this ▁. ▁ignore Error ▁= ▁ignore Error ▁; ▁return ▁this ▁; ▁} ▁public ▁boolean ▁is IgnoreCase ▁( ▁) ▁{ ▁return ▁ignore Case ▁; ▁} ▁public ▁JSON Config ▁set IgnoreCase ▁( ▁boolean ▁ignore Case ▁) ▁{ ▁this ▁. ▁ignore Case ▁= ▁ignore Case ▁; ▁return ▁this ▁; ▁} ▁public ▁String ▁get DateFormat ▁( ▁) ▁{ ▁return ▁dateFormat ▁; ▁} ▁public ▁JSON Config ▁set DateFormat ▁( ▁String ▁dateFormat ▁) ▁{ ▁this ▁. ▁dateFormat ▁= ▁dateFormat ▁; ▁return ▁this ▁; ▁} ▁public ▁boolean ▁is Ignore NullValue ▁( ▁) ▁{ ▁return ▁this ▁. ▁ignore NullValue ▁; ▁} ▁public ▁JSON Config ▁set Ignore NullValue ▁( ▁boolean ▁ignore NullValue ▁) ▁{ ▁this ▁. ▁ignore NullValue ▁= ▁ignore NullValue ▁; ▁return ▁this ▁; ▁} ▁public ▁boolean ▁is Transient Support ▁( ▁) ▁{ ▁return ▁this ▁. ▁transient Support ▁; ▁} ▁public ▁JSON Config ▁set Transient Support ▁( ▁boolean ▁transient Support ▁) ▁{ ▁this ▁. ▁transient Support ▁= ▁transient Support ▁; ▁return ▁this ▁; ▁} ▁public ▁boolean ▁is Strip Trailing Z eros ▁( ▁) ▁{ ▁return ▁strip Trailing Z eros ▁; ▁} ▁public ▁JSON Config ▁set Strip Trailing Z eros ▁( ▁boolean ▁strip Trailing Z eros ▁) ▁{ ▁this ▁. ▁strip Trailing Z eros ▁= ▁strip Trailing Z eros ▁; ▁return ▁this ▁; ▁} ▁}
▁} ▁} ▁@ ▁Override ▁protected ▁void ▁launch ▁( ▁Context ▁. ▁Builder ▁context Builder ▁) ▁{ ▁System ▁. ▁exit ▁( ▁execute ▁( ▁context Builder ▁) ▁) ▁; ▁} ▁private ▁int ▁execute ▁( ▁Context ▁. ▁Builder ▁context Builder ▁) ▁{ ▁context Builder ▁. ▁arguments ▁( ▁getLanguage Id ▁( ▁) ▁, ▁program Arguments ▁) ▁; ▁try ▁( ▁Context ▁context ▁= ▁context Builder ▁. ▁build ▁( ▁) ▁) ▁{ ▁run Version Action ▁( ▁version Action ▁, ▁context ▁. ▁getEngine ▁( ▁) ▁) ▁; ▁context ▁. ▁eval ▁( ▁Source ▁. ▁newBuilder ▁( ▁getLanguage Id ▁( ▁) ▁, ▁file ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁Value ▁entry Point ▁= ▁detect EntryPoint ▁( ▁context ▁) ▁; ▁if ▁( ▁entry Point ▁== ▁null ▁) ▁{ ▁throw ▁abort ▁( ▁STR ▁) ▁; ▁} ▁entry Point ▁. ▁execute ▁( ▁) ▁; ▁return ▁0 ▁; ▁} ▁catch ▁( ▁Polyglot Exception ▁e ▁) ▁{ ▁if ▁( ▁e ▁. ▁is Exit ▁( ▁) ▁) ▁{ ▁return ▁e ▁. ▁get Exit Status ▁( ▁) ▁; ▁} ▁throw ▁e ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁throw ▁abort ▁( ▁String ▁. ▁format ▁( ▁STR ▁, ▁file ▁, ▁e ▁. ▁getMessage ▁( ▁) ▁) ▁) ▁; ▁} ▁finally ▁{ ▁System ▁. ▁out ▁. ▁flush ▁( ▁) ▁; ▁System ▁. ▁err ▁. ▁flush ▁( ▁) ▁; ▁} ▁} ▁private ▁Value ▁detect EntryPoint ▁( ▁Context ▁context ▁) ▁{ ▁if ▁( ▁custom EntryPoint ▁!= ▁null ▁) ▁{ ▁return ▁context ▁. ▁getBind ings ▁( ▁getLanguage Id ▁( ▁) ▁) ▁. ▁getMember ▁( ▁STR ▁) ▁. ▁getMember ▁( ▁custom EntryPoint ▁) ▁; ▁} ▁Value ▁candidate ▁= ▁context ▁. ▁getBind ings ▁( ▁getLanguage Id ▁( ▁) ▁) ▁. ▁getMember ▁( ▁STR ▁) ▁. ▁getMember ▁( ▁STR ▁) ▁; ▁if ▁( ▁candidate ▁== ▁null ▁) ▁{ ▁candidate ▁= ▁context ▁. ▁getBind ings ▁( ▁getLanguage Id ▁( ▁) ▁) ▁. ▁getMember ▁( ▁STR ▁) ▁. ▁getMember ▁( ▁STR ▁) ▁; ▁} ▁return ▁candidate ▁; ▁} ▁@ ▁Override ▁protected ▁String ▁getLanguage Id ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁print Help ▁( ▁Option Category ▁max Category ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁collect Arguments ▁( ▁Set ▁< ▁String ▁> ▁options ▁) ▁{ ▁} ▁}
▁Arrays ▁. ▁fill ▁( ▁m Prefetch Array ▁, ▁- ▁1 ▁) ▁; ▁} ▁else ▁if ▁( ▁storage Position ▁>= ▁m Prefetch Array ▁. ▁length ▁) ▁{ ▁final ▁int ▁[ ▁] ▁old Array ▁= ▁m Prefetch Array ▁; ▁m Prefetch Array ▁= ▁new ▁int ▁[ ▁storage Position ▁ * ▁2 ▁] ▁; ▁System ▁. ▁arraycopy ▁( ▁old Array ▁, ▁0 ▁, ▁m Prefetch Array ▁, ▁0 ▁, ▁old Array ▁. ▁length ▁) ▁; ▁} ▁m Prefetch Array ▁[ ▁storage Position ▁] ▁= ▁layout Position ▁; ▁m Prefetch Array ▁[ ▁storage Position ▁+ ▁1 ▁] ▁= ▁pixel Distance ▁; ▁m Count ▁++ ▁; ▁} ▁boolean ▁last Prefetch In cluded Position ▁( ▁int ▁position ▁) ▁{ ▁if ▁( ▁m Prefetch Array ▁!= ▁null ▁) ▁{ ▁final ▁int ▁count ▁= ▁m Count ▁ * ▁2 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁count ▁; ▁i ▁+= ▁2 ▁) ▁{ ▁if ▁( ▁m Prefetch Array ▁[ ▁i ▁] ▁== ▁position ▁) ▁return ▁true ▁; ▁} ▁} ▁return ▁false ▁; ▁} ▁void ▁clear Prefetch Positions ▁( ▁) ▁{ ▁if ▁( ▁m Prefetch Array ▁!= ▁null ▁) ▁{ ▁Arrays ▁. ▁fill ▁( ▁m Prefetch Array ▁, ▁- ▁1 ▁) ▁; ▁} ▁m Count ▁= ▁0 ▁; ▁} ▁} ▁public ▁void ▁add ▁( ▁RecyclerView ▁recyclerView ▁) ▁{ ▁if ▁( ▁RecyclerView ▁. ▁DEBUG ▁&& ▁m Rec yclerView s ▁. ▁contains ▁( ▁recyclerView ▁) ▁) ▁{ ▁return ▁; ▁} ▁m Rec yclerView s ▁. ▁add ▁( ▁recyclerView ▁) ▁; ▁} ▁public ▁void ▁remove ▁( ▁RecyclerView ▁recyclerView ▁) ▁{ ▁boolean ▁remove Success ▁= ▁m Rec yclerView s ▁. ▁remove ▁( ▁recyclerView ▁) ▁; ▁if ▁( ▁RecyclerView ▁. ▁DEBUG ▁&& ▁! ▁remove Success ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁} ▁} ▁void ▁post From Traversal ▁( ▁RecyclerView ▁recyclerView ▁, ▁int ▁prefetch D x ▁, ▁int ▁prefetch D y ▁) ▁{ ▁if ▁( ▁recyclerView ▁. ▁isA tt ached To Window ▁( ▁) ▁) ▁{ ▁if ▁( ▁RecyclerView ▁. ▁DEBUG ▁&& ▁! ▁m Rec yclerView s ▁. ▁contains ▁( ▁recyclerView ▁) ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁} ▁if ▁( ▁m Post Time Ns ▁== ▁0 ▁) ▁{ ▁m Post Time Ns ▁= ▁recyclerView ▁. ▁getN ano Time ▁( ▁) ▁; ▁recyclerView ▁. ▁post ▁( ▁this ▁) ▁; ▁} ▁} ▁recyclerView ▁. ▁m Prefetch Registry ▁. ▁set Prefetch Vector ▁( ▁prefetch D x ▁, ▁prefetch D y ▁) ▁; ▁} ▁static ▁Comparator ▁< ▁Task ▁> ▁s Task Comparator ▁= ▁new ▁Comparator ▁< ▁Task ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁int ▁compare ▁( ▁Task ▁lhs ▁, ▁Task ▁rhs ▁) ▁{ ▁if ▁( ▁( ▁lhs ▁. ▁view ▁== ▁null ▁) ▁!= ▁( ▁rhs ▁. ▁view ▁== ▁null ▁) ▁) ▁{ ▁return ▁lhs ▁. ▁view ▁== ▁null ▁? ▁1 ▁: ▁- ▁1 ▁; ▁} ▁if ▁( ▁lhs ▁. ▁immediate ▁!= ▁rhs ▁. ▁immediate ▁) ▁{ ▁return ▁lhs ▁. ▁immediate ▁? ▁- ▁1 ▁: ▁1 ▁; ▁} ▁int ▁delta View V elocity ▁= ▁rhs ▁. ▁view V elocity ▁- ▁lhs ▁. ▁view V elocity ▁;
▁public ▁class ▁Field Error VM ▁implements ▁Serializable ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁private ▁final ▁String ▁objectName ▁; ▁private ▁final ▁String ▁field ▁; ▁private ▁final ▁String ▁message ▁; ▁public ▁Field Error VM ▁( ▁String ▁dto ▁, ▁String ▁field ▁, ▁String ▁message ▁) ▁{ ▁this ▁. ▁objectName ▁= ▁dto ▁; ▁this ▁. ▁field ▁= ▁field ▁; ▁this ▁. ▁message ▁= ▁message ▁; ▁} ▁public ▁String ▁getObjectName ▁( ▁) ▁{ ▁return ▁objectName ▁; ▁} ▁public ▁String ▁getField ▁( ▁) ▁{ ▁return ▁field ▁; ▁} ▁public ▁String ▁getMessage ▁( ▁) ▁{ ▁return ▁message ▁; ▁} ▁}
▁class ▁Sp ir al Matrix ▁{ ▁public ▁List ▁< ▁Integer ▁> ▁sp ir al Order ▁( ▁int ▁[ ▁] ▁[ ▁] ▁matrix ▁) ▁{ ▁List ▁< ▁Integer ▁> ▁result ▁= ▁new ▁ArrayList ▁< ▁Integer ▁> ▁( ▁) ▁; ▁if ▁( ▁matrix ▁== ▁null ▁|| ▁matrix ▁. ▁length ▁== ▁0 ▁) ▁{ ▁return ▁result ▁; ▁} ▁int ▁row Start ▁= ▁0 ▁; ▁int ▁row End ▁= ▁matrix ▁. ▁length ▁- ▁1 ▁; ▁int ▁col Start ▁= ▁0 ▁; ▁int ▁col End ▁= ▁matrix ▁[ ▁0 ▁] ▁. ▁length ▁- ▁1 ▁; ▁while ▁( ▁row Start ▁<= ▁row End ▁&& ▁col Start ▁<= ▁col End ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁col Start ▁; ▁i ▁<= ▁col End ▁; ▁i ▁++ ▁) ▁{ ▁result ▁. ▁add ▁( ▁matrix ▁[ ▁row Start ▁] ▁[ ▁i ▁] ▁) ▁; ▁} ▁row Start ▁++ ▁; ▁for ▁( ▁int ▁i ▁= ▁row Start ▁; ▁i ▁<= ▁row End ▁; ▁i ▁++ ▁) ▁{ ▁result ▁. ▁add ▁( ▁matrix ▁[ ▁i ▁] ▁[ ▁col End ▁] ▁) ▁; ▁} ▁col End ▁-- ▁; ▁if ▁( ▁row Start ▁<= ▁row End ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁col End ▁; ▁i ▁>= ▁col Start ▁; ▁i ▁-- ▁) ▁{ ▁result ▁. ▁add ▁( ▁matrix ▁[ ▁row End ▁] ▁[ ▁i ▁] ▁) ▁; ▁} ▁} ▁row End ▁-- ▁; ▁if ▁( ▁col Start ▁<= ▁col End ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁row End ▁; ▁i ▁>= ▁row Start ▁; ▁i ▁-- ▁) ▁{ ▁result ▁. ▁add ▁( ▁matrix ▁[ ▁i ▁] ▁[ ▁col Start ▁] ▁) ▁; ▁} ▁} ▁col Start ▁++ ▁; ▁} ▁return ▁result ▁; ▁} ▁}
▁Action ▁action ▁= ▁action Factory ▁. ▁create ▁( ▁action Input ▁, ▁action Output ▁, ▁execution Counter ▁) ▁; ▁register Action ▁( ▁action ▁) ▁; ▁builder ▁. ▁build Artifacts ▁( ▁reporter ▁, ▁ImmutableSet ▁. ▁of ▁( ▁action Output ▁) ▁, ▁null ▁, ▁null ▁, ▁null ▁, ▁null ▁, ▁null ▁, ▁executor ▁, ▁null ▁, ▁null ▁, ▁options ▁, ▁null ▁, ▁null ▁, ▁false ▁) ▁; ▁SkyKey ▁action Key ▁= ▁Action Lookup Data ▁. ▁create ▁( ▁ACTION _ LOOKUP _ KEY ▁, ▁0 ▁) ▁; ▁Track ing Evaluation Progress Receiver ▁. ▁Evalu ated Entry ▁evalu ated Action ▁= ▁progress Receiver ▁. ▁getE val uted Entry ▁( ▁action Key ▁) ▁; ▁assertThat ▁( ▁evalu ated Action ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁maybe Change File ▁( ▁action Input ▁, ▁change Action Input ▁) ▁; ▁between Build s ▁. ▁call ▁( ▁) ▁; ▁progress Receiver ▁. ▁reset ▁( ▁) ▁; ▁builder ▁. ▁build Artifacts ▁( ▁reporter ▁, ▁ImmutableSet ▁. ▁of ▁( ▁action Output ▁) ▁, ▁null ▁, ▁null ▁, ▁null ▁, ▁null ▁, ▁null ▁, ▁executor ▁, ▁null ▁, ▁null ▁, ▁options ▁, ▁null ▁, ▁null ▁, ▁false ▁) ▁; ▁if ▁( ▁expect Action Is ▁. ▁d irt ied ▁( ▁) ▁) ▁{ ▁assertThat ▁( ▁progress Receiver ▁. ▁was Invalid ated ▁( ▁action Key ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁Track ing Evaluation Progress Receiver ▁. ▁Evalu ated Entry ▁new Entry ▁= ▁progress Receiver ▁. ▁getE val uted Entry ▁( ▁action Key ▁) ▁; ▁assertThat ▁( ▁new Entry ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁if ▁( ▁expect Action Is ▁. ▁act ually Clean ▁( ▁) ▁) ▁{ ▁assertThat ▁( ▁new Entry ▁. ▁state ▁) ▁. ▁isEqualTo ▁( ▁Evaluation State ▁. ▁C LEAN ▁) ▁; ▁} ▁else ▁{ ▁assertThat ▁( ▁new Entry ▁. ▁state ▁) ▁. ▁isEqualTo ▁( ▁Evaluation State ▁. ▁BUIL T ▁) ▁; ▁} ▁} ▁else ▁{ ▁assertThat ▁( ▁progress Receiver ▁. ▁was Invalid ated ▁( ▁action Key ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁} ▁assertThat ▁( ▁execution Counter ▁. ▁get ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁expect Action Is ▁. ▁re ex ecute d ▁( ▁) ▁? ▁2 ▁: ▁1 ▁) ▁; ▁} ▁private ▁RootedPath ▁create Sky frame Dep Of Action ▁( ▁) ▁throws ▁Exception ▁{ ▁scratch ▁. ▁file ▁( ▁root Directory ▁. ▁getRelative ▁( ▁STR ▁) ▁. ▁getPath String ▁( ▁) ▁, ▁STR ▁) ▁; ▁return ▁RootedPath ▁. ▁to R ootedPath ▁( ▁Root ▁. ▁from Path ▁( ▁root Directory ▁) ▁, ▁PathFragment ▁. ▁create ▁( ▁STR ▁) ▁) ▁; ▁} ▁private ▁static ▁void ▁appendTo File ▁( ▁Path ▁path ▁) ▁throws ▁Exception ▁{ ▁try ▁( ▁OutputStream ▁st m ▁= ▁path ▁. ▁getOutputStream ▁( ▁true ▁) ▁) ▁{ ▁st m ▁. ▁write ▁( ▁STR ▁. ▁getBytes ▁( ▁Standard Charsets ▁. ▁UTF _8 ▁) ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Cache Check ingAction With Content Ch ang ing Input ▁( ▁) ▁throws ▁Exception ▁{ ▁assert Action With Content Ch ang ing Input ▁( ▁false ▁) ▁; ▁}
▁return ▁new ▁Gson ▁( ▁ex clu der ▁, ▁field Naming Policy ▁, ▁instance Creator s ▁, ▁serialize Nulls ▁, ▁comp lex Map Key Serialization ▁, ▁generate Non Executable Json ▁, ▁escape Html Chars ▁, ▁prettyPrint ing ▁, ▁lenient ▁, ▁serialize Special Floating Point Values ▁, ▁long Serialization Policy ▁, ▁date Pattern ▁, ▁date Style ▁, ▁time Style ▁, ▁this ▁. ▁factories ▁, ▁this ▁. ▁h ierarchy Factories ▁, ▁factories ▁) ▁; ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁private ▁void ▁add Type Adapt ers For Date ▁( ▁String ▁date Pattern ▁, ▁int ▁date Style ▁, ▁int ▁time Style ▁, ▁List ▁< ▁Type AdapterFactory ▁> ▁factories ▁) ▁{ ▁Default Date TypeAdapter ▁date TypeAdapter ▁; ▁Type Adapter ▁< ▁Timestamp ▁> ▁timestamp TypeAdapter ▁; ▁Type Adapter ▁< ▁java ▁. ▁sql ▁. ▁Date ▁> ▁java Sql Date TypeAdapter ▁; ▁if ▁( ▁date Pattern ▁!= ▁null ▁&& ▁! ▁STR ▁. ▁equals ▁( ▁date Pattern ▁. ▁trim ▁( ▁) ▁) ▁) ▁{ ▁date TypeAdapter ▁= ▁new ▁Default Date TypeAdapter ▁( ▁Date ▁. ▁class ▁, ▁date Pattern ▁) ▁; ▁timestamp TypeAdapter ▁= ▁( ▁Type Adapter ▁) ▁new ▁Default Date TypeAdapter ▁( ▁Timestamp ▁. ▁class ▁, ▁date Pattern ▁) ▁; ▁java Sql Date TypeAdapter ▁= ▁( ▁Type Adapter ▁) ▁new ▁Default Date TypeAdapter ▁( ▁java ▁. ▁sql ▁. ▁Date ▁. ▁class ▁, ▁date Pattern ▁) ▁; ▁} ▁else ▁if ▁( ▁date Style ▁!= ▁DateFormat ▁. ▁DEFAULT ▁&& ▁time Style ▁!= ▁DateFormat ▁. ▁DEFAULT ▁) ▁{ ▁date TypeAdapter ▁= ▁new ▁Default Date TypeAdapter ▁( ▁Date ▁. ▁class ▁, ▁date Style ▁, ▁time Style ▁) ▁; ▁timestamp TypeAdapter ▁= ▁( ▁Type Adapter ▁) ▁new ▁Default Date TypeAdapter ▁( ▁Timestamp ▁. ▁class ▁, ▁date Style ▁, ▁time Style ▁) ▁; ▁java Sql Date TypeAdapter ▁= ▁( ▁Type Adapter ▁) ▁new ▁Default Date TypeAdapter ▁( ▁java ▁. ▁sql ▁. ▁Date ▁. ▁class ▁, ▁date Style ▁, ▁time Style ▁) ▁; ▁} ▁else ▁{ ▁return ▁; ▁} ▁factories ▁. ▁add ▁( ▁Type Adapt ers ▁. ▁new Factory ▁( ▁Date ▁. ▁class ▁, ▁date TypeAdapter ▁) ▁) ▁; ▁factories ▁. ▁add ▁( ▁Type Adapt ers ▁. ▁new Factory ▁( ▁Timestamp ▁. ▁class ▁, ▁timestamp TypeAdapter ▁) ▁) ▁; ▁factories ▁. ▁add ▁( ▁Type Adapt ers ▁. ▁new Factory ▁( ▁java ▁. ▁sql ▁. ▁Date ▁. ▁class ▁, ▁java Sql Date TypeAdapter ▁) ▁) ▁; ▁} ▁}
▁return ▁format ▁( ▁STR ▁, ▁typeName ▁, ▁enum Map ▁. ▁entrySet ▁( ▁) ▁. ▁stream ▁( ▁) ▁. ▁sorted ▁( ▁Comparator ▁. ▁comparing ▁( ▁Map ▁. ▁Entry ▁:: ▁getKey ▁) ▁) ▁. ▁map ▁( ▁e ▁-> ▁format ▁( ▁STR ▁, ▁e ▁. ▁getKey ▁( ▁) ▁. ▁replaceAll ▁( ▁STR ▁, ▁STR ▁) ▁, ▁base 32 ▁. ▁encode AsString ▁( ▁e ▁. ▁getValue ▁( ▁) ▁. ▁getBytes ▁( ▁) ▁) ▁) ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁joining ▁( ▁STR ▁) ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁Objects ▁. ▁hash ▁( ▁typeName ▁, ▁enum Map ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁Objects ▁. ▁hash ▁( ▁getType Signature ▁( ▁) ▁. ▁getBase ▁( ▁) ▁, ▁enum Map ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁o ▁) ▁{ ▁if ▁( ▁this ▁== ▁o ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁o ▁== ▁null ▁|| ▁getClass ▁( ▁) ▁!= ▁o ▁. ▁getClass ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁V archar Enum Type ▁other ▁= ▁( ▁V archar Enum Type ▁) ▁o ▁; ▁return ▁Objects ▁. ▁equals ▁( ▁getType Signature ▁( ▁) ▁. ▁getBase ▁( ▁) ▁, ▁other ▁. ▁getType Signature ▁( ▁) ▁. ▁getBase ▁( ▁) ▁) ▁&& ▁Objects ▁. ▁equals ▁( ▁getEnum Map ▁( ▁) ▁, ▁other ▁. ▁getEnum Map ▁( ▁) ▁) ▁; ▁} ▁}
▁Package Info ▁pi ▁= ▁pm ▁. ▁getPackage Info ▁( ▁packageName ▁, ▁0 ▁) ▁; ▁return ▁pi ▁== ▁null ▁? ▁STR ▁: ▁pi ▁. ▁version Name ▁; ▁} ▁catch ▁( ▁Package Manager ▁. ▁Name Not FoundException ▁e ▁) ▁{ ▁e ▁. ▁printStackTrace ▁( ▁) ▁; ▁return ▁STR ▁; ▁} ▁} ▁public ▁static ▁int ▁getApp Version Code ▁( ▁) ▁{ ▁return ▁getApp Version Code ▁( ▁Utils ▁. ▁getApp ▁( ▁) ▁. ▁getPackageName ▁( ▁) ▁) ▁; ▁} ▁public ▁static ▁int ▁getApp Version Code ▁( ▁final ▁String ▁packageName ▁) ▁{ ▁if ▁( ▁Utils Bridge ▁. ▁is Space ▁( ▁packageName ▁) ▁) ▁return ▁- ▁1 ▁; ▁try ▁{ ▁Package Manager ▁pm ▁= ▁Utils ▁. ▁getApp ▁( ▁) ▁. ▁getPackage Manager ▁( ▁) ▁; ▁Package Info ▁pi ▁= ▁pm ▁. ▁getPackage Info ▁( ▁packageName ▁, ▁0 ▁) ▁; ▁return ▁pi ▁== ▁null ▁? ▁- ▁1 ▁: ▁pi ▁. ▁version Code ▁; ▁} ▁catch ▁( ▁Package Manager ▁. ▁Name Not FoundException ▁e ▁) ▁{ ▁e ▁. ▁printStackTrace ▁( ▁) ▁; ▁return ▁- ▁1 ▁; ▁} ▁} ▁@ ▁Nullable ▁public ▁static ▁Signature ▁[ ▁] ▁getApp Signature s ▁( ▁) ▁{ ▁return ▁getApp Signature s ▁( ▁Utils ▁. ▁getApp ▁( ▁) ▁. ▁getPackageName ▁( ▁) ▁) ▁; ▁} ▁@ ▁Nullable ▁public ▁static ▁Signature ▁[ ▁] ▁getApp Signature s ▁( ▁final ▁String ▁packageName ▁) ▁{ ▁if ▁( ▁Utils Bridge ▁. ▁is Space ▁( ▁packageName ▁) ▁) ▁return ▁null ▁; ▁try ▁{ ▁Package Manager ▁pm ▁= ▁Utils ▁. ▁getApp ▁( ▁) ▁. ▁getPackage Manager ▁( ▁) ▁; ▁if ▁( ▁Build ▁. ▁VERSION ▁. ▁SDK _ INT ▁>= ▁Build ▁. ▁VERSION _ CODES ▁. ▁P ▁) ▁{ ▁Package Info ▁pi ▁= ▁pm ▁. ▁getPackage Info ▁( ▁packageName ▁, ▁Package Manager ▁. ▁GET _ SIGN ING _ CER T IFI C ATE S ▁) ▁; ▁if ▁( ▁pi ▁== ▁null ▁) ▁return ▁null ▁; ▁Sign ing Info ▁sign ing Info ▁= ▁pi ▁. ▁sign ing Info ▁; ▁if ▁( ▁sign ing Info ▁. ▁has Multiple Sign ers ▁( ▁) ▁) ▁{ ▁return ▁sign ing Info ▁. ▁get Apk Contents Sign ers ▁( ▁) ▁; ▁} ▁else ▁{ ▁return ▁sign ing Info ▁. ▁getS ign ing Certificate History ▁( ▁) ▁; ▁} ▁} ▁else ▁{ ▁Package Info ▁pi ▁= ▁pm ▁. ▁getPackage Info ▁( ▁packageName ▁, ▁Package Manager ▁. ▁GET _ SIGNATURE S ▁) ▁; ▁if ▁( ▁pi ▁== ▁null ▁) ▁return ▁null ▁; ▁return ▁pi ▁. ▁signature s ▁; ▁} ▁} ▁catch ▁( ▁Package Manager ▁. ▁Name Not FoundException ▁e ▁) ▁{ ▁e ▁. ▁printStackTrace ▁( ▁) ▁; ▁return ▁null ▁; ▁} ▁} ▁@ ▁Nullable ▁public ▁static ▁Signature ▁[ ▁] ▁getApp Signature s ▁( ▁final ▁File ▁file ▁) ▁{ ▁if ▁( ▁file ▁== ▁null ▁) ▁return ▁null ▁; ▁Package Manager ▁pm ▁= ▁Utils ▁. ▁getApp ▁( ▁) ▁. ▁getPackage Manager ▁( ▁) ▁;
▁return ▁append ▁( ▁new ▁Array Iter ▁< ▁> ▁( ▁array ▁) ▁) ▁; ▁} ▁public ▁< ▁T ▁> ▁Str Joiner ▁append ▁( ▁Iterator ▁< ▁T ▁> ▁iterator ▁) ▁{ ▁if ▁( ▁null ▁== ▁iterator ▁) ▁{ ▁return ▁this ▁; ▁} ▁return ▁append ▁( ▁iterator ▁, ▁( ▁t ▁) ▁-> ▁Str Joiner ▁. ▁of ▁( ▁this ▁. ▁delimiter ▁) ▁. ▁append ▁( ▁t ▁) ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁public ▁< ▁T ▁> ▁Str Joiner ▁append ▁( ▁T ▁[ ▁] ▁array ▁, ▁Function ▁< ▁T ▁, ▁? ▁extends ▁CharSequence ▁> ▁to Str Func ▁) ▁{ ▁return ▁append ▁( ▁( ▁Iterator ▁< ▁T ▁> ▁) ▁new ▁Array Iter ▁< ▁> ▁( ▁array ▁) ▁, ▁to Str Func ▁) ▁; ▁} ▁public ▁< ▁T ▁> ▁Str Joiner ▁append ▁( ▁Iterable ▁< ▁T ▁> ▁iterable ▁, ▁Function ▁< ▁T ▁, ▁? ▁extends ▁CharSequence ▁> ▁to Str Func ▁) ▁{ ▁return ▁append ▁( ▁Iter Util ▁. ▁get Iter ▁( ▁iterable ▁) ▁, ▁to Str Func ▁) ▁; ▁} ▁public ▁< ▁T ▁> ▁Str Joiner ▁append ▁( ▁Iterator ▁< ▁T ▁> ▁iterator ▁, ▁Function ▁< ▁T ▁, ▁? ▁extends ▁CharSequence ▁> ▁to Str Func ▁) ▁{ ▁if ▁( ▁null ▁!= ▁iterator ▁) ▁{ ▁while ▁( ▁iterator ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁append ▁( ▁to Str Func ▁. ▁apply ▁( ▁iterator ▁. ▁next ▁( ▁) ▁) ▁) ▁; ▁} ▁} ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁Str Joiner ▁append ▁( ▁CharSequence ▁cs q ▁) ▁{ ▁if ▁( ▁null ▁== ▁cs q ▁) ▁{ ▁switch ▁( ▁this ▁. ▁null Mode ▁) ▁{ ▁case ▁IGNORE ▁: ▁return ▁this ▁; ▁case ▁TO _ E MPTY ▁: ▁cs q ▁= ▁StrUtil ▁. ▁EMPTY ▁; ▁break ▁; ▁case ▁NULL _ STRING ▁: ▁cs q ▁= ▁StrUtil ▁. ▁NULL ▁; ▁} ▁} ▁try ▁{ ▁final ▁Appendable ▁append able ▁= ▁prepare ▁( ▁) ▁; ▁if ▁( ▁wrap Element ▁&& ▁StrUtil ▁. ▁isNotEmpty ▁( ▁this ▁. ▁prefix ▁) ▁) ▁{ ▁append able ▁. ▁append ▁( ▁prefix ▁) ▁; ▁} ▁append able ▁. ▁append ▁( ▁cs q ▁) ▁; ▁if ▁( ▁wrap Element ▁&& ▁StrUtil ▁. ▁isNotEmpty ▁( ▁this ▁. ▁suffix ▁) ▁) ▁{ ▁append able ▁. ▁append ▁( ▁suffix ▁) ▁; ▁} ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁throw ▁new ▁IO RuntimeException ▁( ▁e ▁) ▁; ▁} ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁Str Joiner ▁append ▁( ▁CharSequence ▁cs q ▁, ▁int ▁start Include ▁, ▁int ▁end Exclude ▁) ▁{ ▁return ▁append ▁( ▁StrUtil ▁. ▁sub ▁( ▁cs q ▁, ▁start Include ▁, ▁end Exclude ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Str Joiner ▁append ▁( ▁char ▁c ▁) ▁{ ▁return ▁append ▁( ▁String ▁. ▁valueOf ▁( ▁c ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁if ▁( ▁null ▁== ▁this ▁. ▁append able ▁) ▁{ ▁return ▁empty Result ▁; ▁} ▁if ▁( ▁false ▁== ▁wrap Element ▁&& ▁StrUtil ▁. ▁isNotEmpty ▁( ▁this ▁. ▁suffix ▁) ▁) ▁{ ▁try ▁{ ▁this ▁. ▁append able ▁. ▁append ▁( ▁this ▁. ▁suffix ▁) ▁; ▁}
▁@ ▁XmlRootElement ▁( ▁name ▁= ▁STR ▁) ▁@ ▁Xml AccessorType ▁( ▁Xml AccessType ▁. ▁FIELD ▁) ▁public ▁class ▁Conf Info ▁{ ▁protected ▁String ▁path ▁; ▁protected ▁ArrayList ▁< ▁Conf Entry Info ▁> ▁property ▁; ▁public ▁Conf Info ▁( ▁) ▁{ ▁} ▁public ▁Conf Info ▁( ▁Job ▁job ▁) ▁throws ▁IOException ▁{ ▁this ▁. ▁property ▁= ▁new ▁ArrayList ▁< ▁Conf Entry Info ▁> ▁( ▁) ▁; ▁Configuration ▁jobConf ▁= ▁job ▁. ▁load Conf File ▁( ▁) ▁; ▁this ▁. ▁path ▁= ▁job ▁. ▁getConf File ▁( ▁) ▁. ▁toString ▁( ▁) ▁; ▁MR Job Conf Util ▁. ▁red act ▁( ▁jobConf ▁) ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁String ▁> ▁entry ▁: ▁jobConf ▁) ▁{ ▁this ▁. ▁property ▁. ▁add ▁( ▁new ▁Conf Entry Info ▁( ▁entry ▁. ▁getKey ▁( ▁) ▁, ▁entry ▁. ▁getValue ▁( ▁) ▁, ▁jobConf ▁. ▁getProperty Sources ▁( ▁entry ▁. ▁getKey ▁( ▁) ▁) ▁) ▁) ▁; ▁} ▁} ▁public ▁ArrayList ▁< ▁Conf Entry Info ▁> ▁getProperties ▁( ▁) ▁{ ▁return ▁this ▁. ▁property ▁; ▁} ▁public ▁String ▁getPath ▁( ▁) ▁{ ▁return ▁this ▁. ▁path ▁; ▁} ▁}
▁@ ▁RunWith ▁( ▁JUnit 4 ▁. ▁class ▁) ▁public ▁class ▁Action Execution In activity Watch dog Test ▁{ ▁private ▁static ▁void ▁assert In activity Watch dog Reports ▁( ▁final ▁boolean ▁should Report ▁) ▁throws ▁Exception ▁{ ▁final ▁int ▁[ ▁] ▁monitor State ▁= ▁new ▁int ▁[ ▁] ▁{ ▁0 ▁} ▁; ▁final ▁Object ▁monitor Finished Indicator ▁= ▁new ▁Object ▁( ▁) ▁; ▁final ▁int ▁[ ▁] ▁action Complet ions ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁0 ▁, ▁3 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁2 ▁} ▁; ▁final ▁int ▁[ ▁] ▁wait s ▁= ▁new ▁int ▁[ ▁] ▁{ ▁5 ▁, ▁10 ▁, ▁3 ▁, ▁10 ▁, ▁30 ▁, ▁60 ▁, ▁60 ▁, ▁1 ▁} ▁; ▁final ▁List ▁< ▁String ▁> ▁s lee ps And Wait s ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁In activity Monitor ▁monitor ▁= ▁new ▁In activity Monitor ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁int ▁waitFor Next Completion ▁( ▁int ▁timeout Seconds ▁) ▁throws ▁Interrupted Exception ▁{ ▁synchronized ▁( ▁monitor Finished Indicator ▁) ▁{ ▁if ▁( ▁monitor State ▁[ ▁0 ▁] ▁>= ▁action Complet ions ▁. ▁length ▁) ▁{ ▁monitor Finished Indicator ▁. ▁notify ▁( ▁) ▁; ▁return ▁1 ▁; ▁} ▁else ▁{ ▁int ▁index ▁= ▁monitor State ▁[ ▁0 ▁] ▁; ▁s lee ps And Wait s ▁. ▁add ▁( ▁STR ▁+ ▁wait s ▁[ ▁index ▁] ▁) ▁; ▁++ ▁monitor State ▁[ ▁0 ▁] ▁; ▁return ▁action Complet ions ▁[ ▁index ▁] ▁; ▁} ▁} ▁} ▁@ ▁Override ▁public ▁boolean ▁has Started ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getPending ▁( ▁) ▁{ ▁int ▁index ▁= ▁monitor State ▁[ ▁0 ▁] ▁; ▁if ▁( ▁index ▁>= ▁action Complet ions ▁. ▁length ▁) ▁{ ▁return ▁0 ▁; ▁} ▁int ▁result ▁= ▁action Complet ions ▁[ ▁index ▁] ▁; ▁while ▁( ▁result ▁== ▁0 ▁) ▁{ ▁++ ▁index ▁; ▁result ▁= ▁action Complet ions ▁[ ▁index ▁] ▁; ▁} ▁return ▁result ▁; ▁} ▁} ▁; ▁final ▁boolean ▁[ ▁] ▁did Report In activity ▁= ▁new ▁boolean ▁[ ▁] ▁{ ▁false ▁} ▁; ▁In activity Reporter ▁reporter ▁= ▁new ▁In activity Reporter ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁maybe Report In activity ▁( ▁) ▁{ ▁if ▁( ▁should Report ▁) ▁{ ▁did Report In activity ▁[ ▁0 ▁] ▁= ▁true ▁; ▁} ▁} ▁} ▁; ▁Action Execution In activity Watch dog ▁. ▁S leep ▁sleep ▁= ▁new ▁Action Execution In activity Watch dog ▁. ▁S leep ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁sleep ▁( ▁int ▁duration Milliseconds ▁) ▁throws ▁Interrupted Exception ▁{ ▁if ▁( ▁monitor State ▁[ ▁0 ▁] ▁< ▁action Complet ions ▁. ▁length ▁) ▁{ ▁s lee ps And Wait s ▁. ▁add ▁( ▁STR ▁+ ▁duration Milliseconds ▁) ▁; ▁} ▁} ▁} ▁; ▁Action Execution In activity Watch dog ▁watch dog ▁= ▁new ▁Action Execution In activity Watch dog ▁( ▁monitor ▁, ▁reporter ▁, ▁0 ▁, ▁sleep ▁) ▁; ▁try ▁{ ▁synchronized ▁( ▁monitor Finished Indicator ▁) ▁{ ▁watch dog ▁. ▁start ▁( ▁) ▁;
▁return ▁new ▁Path ▁( ▁basePath ▁, ▁bucket Id ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁on ProcessingTime ▁( ▁long ▁time ▁) ▁throws ▁IOException ▁{ ▁for ▁( ▁FileWriter Bucket ▁< ▁IN ▁> ▁bucket ▁: ▁active Buckets ▁. ▁values ▁( ▁) ▁) ▁{ ▁bucket ▁. ▁on ProcessingTime ▁( ▁time ▁) ▁; ▁} ▁register Next Bucket Ins pection Timer ▁( ▁) ▁; ▁} ▁private ▁void ▁register Next Bucket Ins pection Timer ▁( ▁) ▁{ ▁final ▁long ▁next Ins pection Time ▁= ▁processing TimeService ▁. ▁getCurrent ProcessingTime ▁( ▁) ▁+ ▁bucket Check Interval ▁; ▁processing TimeService ▁. ▁register Processing Timer ▁( ▁next Ins pection Time ▁, ▁this ▁) ▁; ▁} ▁private ▁static ▁final ▁class ▁Bucket er Context ▁implements ▁Bucket Assigner ▁. ▁Context ▁{ ▁@ ▁Nullable ▁private ▁Long ▁element Timestamp ▁; ▁private ▁long ▁current Watermark ▁; ▁private ▁long ▁current ProcessingTime ▁; ▁private ▁Bucket er Context ▁( ▁) ▁{ ▁this ▁. ▁element Timestamp ▁= ▁null ▁; ▁this ▁. ▁current Watermark ▁= ▁Long ▁. ▁MIN _ VALUE ▁; ▁this ▁. ▁current ProcessingTime ▁= ▁Long ▁. ▁MIN _ VALUE ▁; ▁} ▁void ▁update ▁( ▁@ ▁Nullable ▁Long ▁element Timestamp ▁, ▁long ▁watermark ▁, ▁long ▁current ProcessingTime ▁) ▁{ ▁this ▁. ▁element Timestamp ▁= ▁element Timestamp ▁; ▁this ▁. ▁current Watermark ▁= ▁watermark ▁; ▁this ▁. ▁current ProcessingTime ▁= ▁current ProcessingTime ▁; ▁} ▁@ ▁Override ▁public ▁long ▁current ProcessingTime ▁( ▁) ▁{ ▁return ▁current ProcessingTime ▁; ▁} ▁@ ▁Override ▁public ▁long ▁current Watermark ▁( ▁) ▁{ ▁return ▁current Watermark ▁; ▁} ▁@ ▁Override ▁@ ▁Nullable ▁public ▁Long ▁timestamp ▁( ▁) ▁{ ▁return ▁element Timestamp ▁; ▁} ▁} ▁@ ▁Visible ForTesting ▁Map ▁< ▁String ▁, ▁FileWriter Bucket ▁< ▁IN ▁> ▁> ▁getActive Buckets ▁( ▁) ▁{ ▁return ▁active Buckets ▁; ▁} ▁}
▁public ▁class ▁Remove Variable Action ▁extends ▁Action ▁{ ▁static ▁protected ▁final ▁Log ▁log ▁= ▁Log ▁. ▁getLog ▁( ▁Remove Variable Action ▁. ▁class ▁) ▁; ▁private ▁final ▁SQLEditor ▁editor ▁; ▁private ▁final ▁String ▁var Name ▁; ▁public ▁Remove Variable Action ▁( ▁SQLEditor ▁editor ▁, ▁String ▁var Name ▁) ▁{ ▁super ▁( ▁SQLEditor Messages ▁. ▁action _ result _ tab s _ assign _ v ariable ▁) ▁; ▁this ▁. ▁editor ▁= ▁editor ▁; ▁this ▁. ▁var Name ▁= ▁var Name ▁; ▁} ▁@ ▁Override ▁public ▁void ▁run ▁( ▁) ▁{ ▁if ▁( ▁UIUtils ▁. ▁confirm Action ▁( ▁editor ▁. ▁getS ite ▁( ▁) ▁. ▁get Shell ▁( ▁) ▁, ▁STR ▁+ ▁var Name ▁+ ▁STR ▁, ▁STR ▁+ ▁var Name ▁+ ▁STR ▁) ▁) ▁{ ▁editor ▁. ▁getGlobal Script Context ▁( ▁) ▁. ▁remove Variable ▁( ▁var Name ▁) ▁; ▁} ▁} ▁}
▁public ▁class ▁Count ▁< ▁T ▁> ▁extends ▁DataSet Analy t ic Base ▁< ▁T ▁, ▁Long ▁> ▁{ ▁private ▁static ▁final ▁String ▁COUNT ▁= ▁STR ▁; ▁private ▁Count Helper ▁< ▁T ▁> ▁count Helper ▁; ▁@ ▁Override ▁public ▁Count ▁< ▁T ▁> ▁run ▁( ▁DataSet ▁< ▁T ▁> ▁input ▁) ▁throws ▁Exception ▁{ ▁super ▁. ▁run ▁( ▁input ▁) ▁; ▁count Helper ▁= ▁new ▁Count Helper ▁< ▁> ▁( ▁) ▁; ▁input ▁. ▁output ▁( ▁count Helper ▁) ▁. ▁name ▁( ▁STR ▁) ▁; ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁Long ▁getResult ▁( ▁) ▁{ ▁return ▁count Helper ▁. ▁getA cc umulator ▁( ▁env ▁, ▁COUNT ▁) ▁; ▁} ▁private ▁static ▁class ▁Count Helper ▁< ▁U ▁> ▁extends ▁Analy t ic Helper ▁< ▁U ▁> ▁{ ▁private ▁long ▁count ▁; ▁@ ▁Override ▁public ▁void ▁write Record ▁( ▁U ▁record ▁) ▁throws ▁IOException ▁{ ▁count ▁++ ▁; ▁} ▁@ ▁Override ▁public ▁void ▁close ▁( ▁) ▁throws ▁IOException ▁{ ▁add Accumulator ▁( ▁COUNT ▁, ▁new ▁Long Counter ▁( ▁count ▁) ▁) ▁; ▁} ▁} ▁}
▁public ▁final ▁class ▁V archar Operators ▁{ ▁private ▁V archar Operators ▁( ▁) ▁{ ▁} ▁@ ▁Literal Parameters ▁( ▁STR ▁) ▁@ ▁Scalar Operator ▁( ▁EQUAL ▁) ▁@ ▁SqlType ▁( ▁StandardTypes ▁. ▁BOOLEAN ▁) ▁@ ▁Sql Nullable ▁public ▁static ▁Boolean ▁equal ▁( ▁@ ▁SqlType ▁( ▁STR ▁) ▁Slice ▁left ▁, ▁@ ▁SqlType ▁( ▁STR ▁) ▁Slice ▁right ▁) ▁{ ▁return ▁left ▁. ▁equals ▁( ▁right ▁) ▁; ▁} ▁@ ▁Literal Parameters ▁( ▁STR ▁) ▁@ ▁Scalar Operator ▁( ▁NOT _ EQUAL ▁) ▁@ ▁SqlType ▁( ▁StandardTypes ▁. ▁BOOLEAN ▁) ▁@ ▁Sql Nullable ▁public ▁static ▁Boolean ▁not Equal ▁( ▁@ ▁SqlType ▁( ▁STR ▁) ▁Slice ▁left ▁, ▁@ ▁SqlType ▁( ▁STR ▁) ▁Slice ▁right ▁) ▁{ ▁return ▁! ▁left ▁. ▁equals ▁( ▁right ▁) ▁; ▁} ▁@ ▁Literal Parameters ▁( ▁STR ▁) ▁@ ▁Scalar Operator ▁( ▁LE SS _ THAN ▁) ▁@ ▁SqlType ▁( ▁StandardTypes ▁. ▁BOOLEAN ▁) ▁public ▁static ▁boolean ▁lessThan ▁( ▁@ ▁SqlType ▁( ▁STR ▁) ▁Slice ▁left ▁, ▁@ ▁SqlType ▁( ▁STR ▁) ▁Slice ▁right ▁) ▁{ ▁return ▁left ▁. ▁compareTo ▁( ▁right ▁) ▁< ▁0 ▁; ▁} ▁@ ▁Literal Parameters ▁( ▁STR ▁) ▁@ ▁Scalar Operator ▁( ▁LE SS _ THAN _ OR _ EQUAL ▁) ▁@ ▁SqlType ▁( ▁StandardTypes ▁. ▁BOOLEAN ▁) ▁public ▁static ▁boolean ▁lessThan OrEqual ▁( ▁@ ▁SqlType ▁( ▁STR ▁) ▁Slice ▁left ▁, ▁@ ▁SqlType ▁( ▁STR ▁) ▁Slice ▁right ▁) ▁{ ▁return ▁left ▁. ▁compareTo ▁( ▁right ▁) ▁<= ▁0 ▁; ▁} ▁@ ▁Literal Parameters ▁( ▁STR ▁) ▁@ ▁Scalar Operator ▁( ▁GRE ATER _ THAN ▁) ▁@ ▁SqlType ▁( ▁StandardTypes ▁. ▁BOOLEAN ▁) ▁public ▁static ▁boolean ▁greaterThan ▁( ▁@ ▁SqlType ▁( ▁STR ▁) ▁Slice ▁left ▁, ▁@ ▁SqlType ▁( ▁STR ▁) ▁Slice ▁right ▁) ▁{ ▁return ▁left ▁. ▁compareTo ▁( ▁right ▁) ▁> ▁0 ▁; ▁} ▁@ ▁Literal Parameters ▁( ▁STR ▁) ▁@ ▁Scalar Operator ▁( ▁GRE ATER _ THAN _ OR _ EQUAL ▁) ▁@ ▁SqlType ▁( ▁StandardTypes ▁. ▁BOOLEAN ▁) ▁public ▁static ▁boolean ▁greaterThan OrEqual ▁( ▁@ ▁SqlType ▁( ▁STR ▁) ▁Slice ▁left ▁, ▁@ ▁SqlType ▁( ▁STR ▁) ▁Slice ▁right ▁) ▁{ ▁return ▁left ▁. ▁compareTo ▁( ▁right ▁) ▁>= ▁0 ▁; ▁} ▁@ ▁Literal Parameters ▁( ▁STR ▁) ▁@ ▁Scalar Operator ▁( ▁B ET WE EN ▁) ▁@ ▁SqlType ▁( ▁StandardTypes ▁. ▁BOOLEAN ▁) ▁public ▁static ▁boolean ▁between ▁( ▁@ ▁SqlType ▁( ▁STR ▁) ▁Slice ▁value ▁, ▁@ ▁SqlType ▁( ▁STR ▁) ▁Slice ▁min ▁, ▁@ ▁SqlType ▁( ▁STR ▁) ▁Slice ▁max ▁) ▁{ ▁return ▁min ▁. ▁compareTo ▁( ▁value ▁) ▁<= ▁0 ▁&& ▁value ▁. ▁compareTo ▁( ▁max ▁) ▁<= ▁0 ▁; ▁} ▁@ ▁Literal Parameters ▁( ▁STR ▁) ▁@ ▁Scalar Operator ▁( ▁C AST ▁) ▁@ ▁SqlType ▁( ▁StandardTypes ▁. ▁BOOLEAN ▁) ▁public ▁static ▁boolean ▁castTo Boolean ▁( ▁@ ▁SqlType ▁( ▁STR ▁) ▁Slice ▁value ▁) ▁{ ▁if ▁( ▁value ▁. ▁length ▁( ▁) ▁== ▁1 ▁) ▁{ ▁byte ▁character ▁= ▁toUpperCase ▁( ▁value ▁. ▁getByte ▁( ▁0 ▁) ▁) ▁; ▁if ▁( ▁character ▁== ▁CHAR ▁|| ▁character ▁== ▁CHAR ▁) ▁{ ▁return ▁true ▁; ▁}
▁public ▁int ▁run ▁( ▁int ▁perform ance Id ▁) ▁{ ▁return ▁update ▁( ▁perform ance Id ▁) ▁; ▁} ▁} ▁private ▁class ▁Int Int Updater ▁extends ▁Sql Update ▁{ ▁public ▁Int Int Updater ▁( ▁) ▁{ ▁set Sql ▁( ▁UPDATE _ INT _ INT ▁) ▁; ▁setDataSource ▁( ▁dataSource ▁) ▁; ▁declare Parameter ▁( ▁new ▁Sql Parameter ▁( ▁Types ▁. ▁NUMERIC ▁) ▁) ▁; ▁declare Parameter ▁( ▁new ▁Sql Parameter ▁( ▁Types ▁. ▁NUMERIC ▁) ▁) ▁; ▁compile ▁( ▁) ▁; ▁} ▁public ▁int ▁run ▁( ▁int ▁perform ance Id ▁, ▁int ▁type ▁) ▁{ ▁return ▁update ▁( ▁perform ance Id ▁, ▁type ▁) ▁; ▁} ▁} ▁private ▁class ▁String Updater ▁extends ▁Sql Update ▁{ ▁public ▁String Updater ▁( ▁) ▁{ ▁set Sql ▁( ▁UPDATE _ STRING ▁) ▁; ▁setDataSource ▁( ▁dataSource ▁) ▁; ▁declare Parameter ▁( ▁new ▁Sql Parameter ▁( ▁Types ▁. ▁VARCHAR ▁) ▁) ▁; ▁compile ▁( ▁) ▁; ▁} ▁public ▁int ▁run ▁( ▁String ▁name ▁) ▁{ ▁return ▁update ▁( ▁name ▁) ▁; ▁} ▁} ▁private ▁class ▁Mix ed Updater ▁extends ▁Sql Update ▁{ ▁public ▁Mix ed Updater ▁( ▁) ▁{ ▁set Sql ▁( ▁UPDATE _ OBJECT S ▁) ▁; ▁setDataSource ▁( ▁dataSource ▁) ▁; ▁declare Parameter ▁( ▁new ▁Sql Parameter ▁( ▁Types ▁. ▁NUMERIC ▁) ▁) ▁; ▁declare Parameter ▁( ▁new ▁Sql Parameter ▁( ▁Types ▁. ▁NUMERIC ▁, ▁2 ▁) ▁) ▁; ▁declare Parameter ▁( ▁new ▁Sql Parameter ▁( ▁Types ▁. ▁VARCHAR ▁) ▁) ▁; ▁declare Parameter ▁( ▁new ▁Sql Parameter ▁( ▁Types ▁. ▁BOOLEAN ▁) ▁) ▁; ▁compile ▁( ▁) ▁; ▁} ▁public ▁int ▁run ▁( ▁int ▁perform ance Id ▁, ▁int ▁type ▁, ▁String ▁name ▁, ▁boolean ▁confirm ed ▁) ▁{ ▁return ▁update ▁( ▁perform ance Id ▁, ▁type ▁, ▁name ▁, ▁confirm ed ▁) ▁; ▁} ▁} ▁private ▁class ▁Generated Keys Updater ▁extends ▁Sql Update ▁{ ▁public ▁Generated Keys Updater ▁( ▁) ▁{ ▁set Sql ▁( ▁INSERT _ GENER ATE _ KEYS ▁) ▁; ▁setDataSource ▁( ▁dataSource ▁) ▁; ▁declare Parameter ▁( ▁new ▁Sql Parameter ▁( ▁Types ▁. ▁VARCHAR ▁) ▁) ▁; ▁set Return Generated Keys ▁( ▁true ▁) ▁; ▁compile ▁( ▁) ▁; ▁} ▁public ▁int ▁run ▁( ▁String ▁name ▁, ▁Key Holder ▁generated Key Holder ▁) ▁{ ▁return ▁update ▁( ▁new ▁Object ▁[ ▁] ▁{ ▁name ▁} ▁, ▁generated Key Holder ▁) ▁; ▁} ▁} ▁private ▁class ▁Constructor Updater ▁extends ▁Sql Update ▁{ ▁public ▁Constructor Updater ▁( ▁) ▁{ ▁super ▁( ▁dataSource ▁, ▁UPDATE _ OBJECT S ▁, ▁new ▁int ▁[ ▁] ▁{ ▁Types ▁. ▁NUMERIC ▁, ▁Types ▁. ▁NUMERIC ▁, ▁Types ▁. ▁VARCHAR ▁, ▁Types ▁. ▁BOOLEAN ▁} ▁) ▁; ▁compile ▁( ▁) ▁; ▁} ▁public ▁int ▁run ▁( ▁int ▁perform ance Id ▁, ▁int ▁type ▁, ▁String ▁name ▁, ▁boolean ▁confirm ed ▁) ▁{ ▁return ▁update ▁( ▁perform ance Id ▁, ▁type ▁, ▁name ▁, ▁confirm ed ▁) ▁; ▁} ▁} ▁private ▁class ▁Max Rows Updater ▁extends ▁Sql Update ▁{ ▁public ▁Max Rows Updater ▁( ▁) ▁{ ▁set Sql ▁( ▁UPDATE ▁) ▁; ▁setDataSource ▁( ▁dataSource ▁) ▁; ▁setMax Rows A ffected ▁( ▁5 ▁) ▁;
▁loader ▁. ▁execute ▁( ▁format ▁( ▁STR ▁, ▁new ▁Qualified ObjectName ▁( ▁TP CH _ SCHEMA ▁, ▁TINY _ SCHEMA _ NAME ▁, ▁table ▁. ▁getTableName ▁( ▁) ▁. ▁toLowerCase ▁( ▁ENGLISH ▁) ▁) ▁) ▁) ▁; ▁LOG ▁. ▁info ▁( ▁STR ▁, ▁table ▁. ▁getTableName ▁( ▁) ▁, ▁nanos Since ▁( ▁start ▁) ▁. ▁convertTo Most Su cc inct TimeUnit ▁( ▁) ▁) ▁; ▁} ▁public ▁static ▁Session ▁create Session ▁( ▁) ▁{ ▁return ▁test SessionBuilder ▁( ▁) ▁. ▁set Catalog ▁( ▁STR ▁) ▁. ▁setSchema ▁( ▁TP CH _ SCHEMA ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁throws ▁Exception ▁{ ▁Logging ▁. ▁initialize ▁( ▁) ▁; ▁Distributed QueryRunner ▁queryRunner ▁= ▁create Elasticsearch QueryRunner ▁( ▁Embedded Elasticsearch Node ▁. ▁create Embedded Elasticsearch Node ▁( ▁) ▁, ▁Tpch Table ▁. ▁getTables ▁( ▁) ▁) ▁; ▁Thread ▁. ▁sleep ▁( ▁10 ▁) ▁; ▁Logger ▁log ▁= ▁Logger ▁. ▁get ▁( ▁Elasticsearch QueryRunner ▁. ▁class ▁) ▁; ▁log ▁. ▁info ▁( ▁STR ▁) ▁; ▁log ▁. ▁info ▁( ▁STR ▁, ▁queryRunner ▁. ▁get Coordinator ▁( ▁) ▁. ▁getBase Url ▁( ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁WebServer Port FileWriter ▁implements ▁Application Listener ▁< ▁WebServer Initialized Event ▁> ▁{ ▁private ▁static ▁final ▁String ▁DEFAULT _ FILE _ NAME ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁[ ▁] ▁PROPERTY _ VARIABLE S ▁= ▁{ ▁STR ▁, ▁STR ▁} ▁; ▁private ▁static ▁final ▁Log ▁logger ▁= ▁LogFactory ▁. ▁getLog ▁( ▁WebServer Port FileWriter ▁. ▁class ▁) ▁; ▁private ▁final ▁File ▁file ▁; ▁public ▁WebServer Port FileWriter ▁( ▁) ▁{ ▁this ▁( ▁new ▁File ▁( ▁DEFAULT _ FILE _ NAME ▁) ▁) ▁; ▁} ▁public ▁WebServer Port FileWriter ▁( ▁String ▁filename ▁) ▁{ ▁this ▁( ▁new ▁File ▁( ▁filename ▁) ▁) ▁; ▁} ▁public ▁WebServer Port FileWriter ▁( ▁File ▁file ▁) ▁{ ▁Assert ▁. ▁notNull ▁( ▁file ▁, ▁STR ▁) ▁; ▁String ▁override ▁= ▁System Properties ▁. ▁get ▁( ▁PROPERTY _ VARIABLE S ▁) ▁; ▁if ▁( ▁override ▁!= ▁null ▁) ▁{ ▁this ▁. ▁file ▁= ▁new ▁File ▁( ▁override ▁) ▁; ▁} ▁else ▁{ ▁this ▁. ▁file ▁= ▁file ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁on ApplicationEvent ▁( ▁WebServer Initialized Event ▁event ▁) ▁{ ▁File ▁port File ▁= ▁getPort File ▁( ▁event ▁. ▁getApplication Context ▁( ▁) ▁) ▁; ▁try ▁{ ▁String ▁port ▁= ▁String ▁. ▁valueOf ▁( ▁event ▁. ▁get WebServer ▁( ▁) ▁. ▁getPort ▁( ▁) ▁) ▁; ▁create Parent Directory ▁( ▁port File ▁) ▁; ▁FileCopyUtils ▁. ▁copy ▁( ▁port ▁. ▁getBytes ▁( ▁) ▁, ▁port File ▁) ▁; ▁port File ▁. ▁deleteOnExit ▁( ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁ex ▁) ▁{ ▁logger ▁. ▁warn ▁( ▁Log Message ▁. ▁format ▁( ▁STR ▁, ▁this ▁. ▁file ▁) ▁) ▁; ▁} ▁} ▁protected ▁File ▁getPort File ▁( ▁Application Context ▁application Context ▁) ▁{ ▁String ▁namespace ▁= ▁getServer Namespace ▁( ▁application Context ▁) ▁; ▁if ▁( ▁! ▁StringUtils ▁. ▁hasLength ▁( ▁namespace ▁) ▁) ▁{ ▁return ▁this ▁. ▁file ▁; ▁} ▁String ▁name ▁= ▁this ▁. ▁file ▁. ▁getName ▁( ▁) ▁; ▁String ▁extension ▁= ▁StringUtils ▁. ▁getFilename Extension ▁( ▁this ▁. ▁file ▁. ▁getName ▁( ▁) ▁) ▁; ▁name ▁= ▁name ▁. ▁substring ▁( ▁0 ▁, ▁name ▁. ▁length ▁( ▁) ▁- ▁extension ▁. ▁length ▁( ▁) ▁- ▁1 ▁) ▁; ▁if ▁( ▁is UpperCase ▁( ▁name ▁) ▁) ▁{ ▁name ▁= ▁name ▁+ ▁STR ▁+ ▁namespace ▁. ▁toUpperCase ▁( ▁Locale ▁. ▁ENGLISH ▁) ▁; ▁} ▁else ▁{ ▁name ▁= ▁name ▁+ ▁STR ▁+ ▁namespace ▁. ▁toLowerCase ▁( ▁Locale ▁. ▁ENGLISH ▁) ▁; ▁} ▁if ▁( ▁StringUtils ▁. ▁hasLength ▁( ▁extension ▁) ▁) ▁{ ▁name ▁= ▁name ▁+ ▁STR ▁+ ▁extension ▁; ▁} ▁return ▁new ▁File ▁( ▁this ▁. ▁file ▁. ▁getParentFile ▁( ▁) ▁, ▁name ▁) ▁; ▁} ▁private ▁String ▁getServer Namespace ▁( ▁Application Context ▁application Context ▁) ▁{ ▁if ▁( ▁application Context ▁instanceof ▁WebServer Application Context ▁) ▁{ ▁return ▁( ▁( ▁WebServer Application Context ▁) ▁application Context ▁) ▁. ▁getServer Namespace ▁( ▁) ▁; ▁} ▁return ▁null ▁; ▁} ▁private ▁boolean ▁is UpperCase ▁( ▁String ▁name ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁name ▁. ▁length ▁( ▁) ▁;
▁public ▁class ▁Object Identifier Json Serializer ▁extends ▁Std Serializer ▁< ▁Object Identifier ▁> ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁public ▁static ▁final ▁String ▁FIELD _ NAME _ C ATALOG _ NAME ▁= ▁STR ▁; ▁public ▁static ▁final ▁String ▁FIELD _ NAME _ DATABASE _ NAME ▁= ▁STR ▁; ▁public ▁static ▁final ▁String ▁FIELD _ NAME _ TABLE _ NAME ▁= ▁STR ▁; ▁public ▁Object Identifier Json Serializer ▁( ▁) ▁{ ▁super ▁( ▁Object Identifier ▁. ▁class ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁serialize ▁( ▁Object Identifier ▁object Identifier ▁, ▁JsonGenerator ▁jsonGenerator ▁, ▁Serializer Provider ▁serializer Provider ▁) ▁throws ▁IOException ▁{ ▁jsonGenerator ▁. ▁writeStart Object ▁( ▁) ▁; ▁jsonGenerator ▁. ▁writeString Field ▁( ▁FIELD _ NAME _ C ATALOG _ NAME ▁, ▁object Identifier ▁. ▁getCatalog Name ▁( ▁) ▁) ▁; ▁jsonGenerator ▁. ▁writeString Field ▁( ▁FIELD _ NAME _ DATABASE _ NAME ▁, ▁object Identifier ▁. ▁getDatabase Name ▁( ▁) ▁) ▁; ▁jsonGenerator ▁. ▁writeString Field ▁( ▁FIELD _ NAME _ TABLE _ NAME ▁, ▁object Identifier ▁. ▁getObjectName ▁( ▁) ▁) ▁; ▁jsonGenerator ▁. ▁writeEndObject ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁On Error Not Implemented Exception Test ▁extends ▁RxJavaTest ▁{ ▁List ▁< ▁Throwable ▁> ▁errors ▁; ▁@ ▁Before ▁public ▁void ▁before ▁( ▁) ▁{ ▁errors ▁= ▁TestHelper ▁. ▁track Plugin Errors ▁( ▁) ▁; ▁} ▁@ ▁After ▁public ▁void ▁after ▁( ▁) ▁{ ▁RxJavaPlugins ▁. ▁reset ▁( ▁) ▁; ▁assertFalse ▁( ▁STR ▁+ ▁errors ▁, ▁errors ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁TestHelper ▁. ▁assertError ▁( ▁errors ▁, ▁0 ▁, ▁On Error Not Implemented Exception ▁. ▁class ▁) ▁; ▁Throwable ▁c ▁= ▁errors ▁. ▁get ▁( ▁0 ▁) ▁. ▁getCause ▁( ▁) ▁; ▁assertTrue ▁( ▁STR ▁+ ▁c ▁, ▁c ▁instanceof ▁TestException ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁flowable Subscribe 0 ▁( ▁) ▁{ ▁Flowable ▁. ▁error ▁( ▁new ▁TestException ▁( ▁) ▁) ▁. ▁subscribe ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁flowable Subscribe 1 ▁( ▁) ▁{ ▁Flowable ▁. ▁error ▁( ▁new ▁TestException ▁( ▁) ▁) ▁. ▁subscribe ▁( ▁Functions ▁. ▁empty Consumer ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁flowable ForEach While ▁( ▁) ▁{ ▁Flowable ▁. ▁error ▁( ▁new ▁TestException ▁( ▁) ▁) ▁. ▁forEach While ▁( ▁Functions ▁. ▁always True ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁flowable Blocking Subscribe 1 ▁( ▁) ▁{ ▁Flowable ▁. ▁error ▁( ▁new ▁TestException ▁( ▁) ▁) ▁. ▁blocking Subscribe ▁( ▁Functions ▁. ▁empty Consumer ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁flowable Bounded Blocking Subscribe 1 ▁( ▁) ▁{ ▁Flowable ▁. ▁error ▁( ▁new ▁TestException ▁( ▁) ▁) ▁. ▁blocking Subscribe ▁( ▁Functions ▁. ▁empty Consumer ▁( ▁) ▁, ▁128 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁observable Subscribe 0 ▁( ▁) ▁{ ▁Observable ▁. ▁error ▁( ▁new ▁TestException ▁( ▁) ▁) ▁. ▁subscribe ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁observable Subscribe 1 ▁( ▁) ▁{ ▁Observable ▁. ▁error ▁( ▁new ▁TestException ▁( ▁) ▁) ▁. ▁subscribe ▁( ▁Functions ▁. ▁empty Consumer ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁observable ForEach While ▁( ▁) ▁{ ▁Observable ▁. ▁error ▁( ▁new ▁TestException ▁( ▁) ▁) ▁. ▁forEach While ▁( ▁Functions ▁. ▁always True ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁observable Blocking Subscribe 1 ▁( ▁) ▁{ ▁Observable ▁. ▁error ▁( ▁new ▁TestException ▁( ▁) ▁) ▁. ▁blocking Subscribe ▁( ▁Functions ▁. ▁empty Consumer ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁single Subscribe 0 ▁( ▁) ▁{ ▁Single ▁. ▁error ▁( ▁new ▁TestException ▁( ▁) ▁) ▁. ▁subscribe ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁single Subscribe 1 ▁( ▁) ▁{ ▁Single ▁. ▁error ▁( ▁new ▁TestException ▁( ▁) ▁) ▁. ▁subscribe ▁( ▁Functions ▁. ▁empty Consumer ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁maybe Subscribe 0 ▁( ▁) ▁{ ▁Maybe ▁. ▁error ▁( ▁new ▁TestException ▁( ▁) ▁) ▁. ▁subscribe ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁maybe Subscribe 1 ▁( ▁) ▁{ ▁Maybe ▁. ▁error ▁( ▁new ▁TestException ▁( ▁) ▁) ▁. ▁subscribe ▁( ▁Functions ▁. ▁empty Consumer ▁( ▁) ▁) ▁; ▁}
▁public ▁class ▁Get Datafeed ResponseTests ▁extends ▁Abstract XContentTestCase ▁< ▁Get Datafeed Response ▁> ▁{ ▁@ ▁Override ▁protected ▁Get Datafeed Response ▁createTest Instance ▁( ▁) ▁{ ▁int ▁count ▁= ▁randomInt Between ▁( ▁1 ▁, ▁5 ▁) ▁; ▁List ▁< ▁DatafeedConfig ▁. ▁Builder ▁> ▁results ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁count ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁count ▁; ▁i ▁++ ▁) ▁{ ▁Datafeed ConfigTests ▁. ▁createRandom Builder ▁( ▁) ▁; ▁results ▁. ▁add ▁( ▁Datafeed ConfigTests ▁. ▁createRandom Builder ▁( ▁) ▁) ▁; ▁} ▁return ▁new ▁Get Datafeed Response ▁( ▁results ▁, ▁count ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Get Datafeed Response ▁doParseInstance ▁( ▁XContentParser ▁parser ▁) ▁throws ▁IOException ▁{ ▁return ▁Get Datafeed Response ▁. ▁fromXContent ▁( ▁parser ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Predicate ▁< ▁String ▁> ▁getRandom Fields ExcludeFilter ▁( ▁) ▁{ ▁return ▁field ▁-> ▁field ▁. ▁isEmpty ▁( ▁) ▁== ▁false ▁; ▁} ▁@ ▁Override ▁protected ▁boolean ▁supports UnknownFields ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁}
▁@ ▁Deprecated ▁public ▁class ▁Named Parameter Jdbc Operations Dep endsOn PostProcessor ▁extends ▁Abstract Dep endsOn BeanFactory PostProcessor ▁{ ▁public ▁Named Parameter Jdbc Operations Dep endsOn PostProcessor ▁( ▁String ▁... ▁dependsOn ▁) ▁{ ▁super ▁( ▁Named Parameter Jdbc Operations ▁. ▁class ▁, ▁dependsOn ▁) ▁; ▁} ▁public ▁Named Parameter Jdbc Operations Dep endsOn PostProcessor ▁( ▁Class ▁< ▁? ▁> ▁... ▁dependsOn ▁) ▁{ ▁super ▁( ▁Named Parameter Jdbc Operations ▁. ▁class ▁, ▁dependsOn ▁) ▁; ▁} ▁}
▁public ▁class ▁S te w Test ▁{ ▁private ▁InMemory Appender ▁appender ▁; ▁@ ▁BeforeEach ▁public ▁void ▁setUp ▁( ▁) ▁{ ▁appender ▁= ▁new ▁InMemory Appender ▁( ▁) ▁; ▁} ▁@ ▁AfterEach ▁public ▁void ▁tearDown ▁( ▁) ▁{ ▁appender ▁. ▁stop ▁( ▁) ▁; ▁} ▁@ ▁Test ▁void ▁test Mix ▁( ▁) ▁{ ▁final ▁var ▁st ew ▁= ▁new ▁Immutable Ste w ▁( ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁) ▁; ▁final ▁var ▁expected Message ▁= ▁STR ▁+ ▁STR ▁; ▁for ▁( ▁var ▁i ▁= ▁0 ▁; ▁i ▁< ▁20 ▁; ▁i ▁++ ▁) ▁{ ▁st ew ▁. ▁m ix ▁( ▁) ▁; ▁assertEquals ▁( ▁expected Message ▁, ▁appender ▁. ▁getLast Message ▁( ▁) ▁) ▁; ▁} ▁assertEquals ▁( ▁20 ▁, ▁appender ▁. ▁getLog Size ▁( ▁) ▁) ▁; ▁} ▁}
▁output Frame Holder ▁= ▁new ▁Output Frame Holder ▁( ▁ByteBuffer ▁. ▁wrap ▁( ▁output Buffer ▁. ▁getData ▁( ▁) ▁) ▁) ▁; ▁binarySearch Seek er ▁= ▁output Seek Map ▁( ▁fl ac Decoder J ni ▁, ▁stream Metadata ▁, ▁input ▁. ▁getLength ▁( ▁) ▁, ▁extractor Output ▁, ▁output Frame Holder ▁) ▁; ▁@ ▁Nullable ▁Metadata ▁metadata ▁= ▁stream Metadata ▁. ▁getMetadata Copy With App ended Entries From ▁( ▁id 3 Metadata ▁) ▁; ▁output Format ▁( ▁stream Metadata ▁, ▁metadata ▁, ▁track Output ▁) ▁; ▁} ▁} ▁@ ▁Requires NonNull ▁( ▁STR ▁) ▁private ▁int ▁handle Pending Seek ▁( ▁Extractor Input ▁input ▁, ▁Position Holder ▁seek Position ▁, ▁Parsable ByteArray ▁output Buffer ▁, ▁Output Frame Holder ▁output Frame Holder ▁, ▁Track Output ▁track Output ▁) ▁throws ▁IOException ▁{ ▁int ▁seek Result ▁= ▁binarySearch Seek er ▁. ▁handle Pending Seek ▁( ▁input ▁, ▁seek Position ▁) ▁; ▁ByteBuffer ▁output ByteBuffer ▁= ▁output Frame Holder ▁. ▁byteBuffer ▁; ▁if ▁( ▁seek Result ▁== ▁RESULT _ CON TINUE ▁&& ▁output ByteBuffer ▁. ▁limit ▁( ▁) ▁> ▁0 ▁) ▁{ ▁output Sample ▁( ▁output Buffer ▁, ▁output ByteBuffer ▁. ▁limit ▁( ▁) ▁, ▁output Frame Holder ▁. ▁timeUs ▁, ▁track Output ▁) ▁; ▁} ▁return ▁seek Result ▁; ▁} ▁@ ▁Nullable ▁private ▁static ▁Flac Binary Search Seek er ▁output Seek Map ▁( ▁Flac Decoder J ni ▁decoder J ni ▁, ▁Flac StreamMetadata ▁stream Metadata ▁, ▁long ▁stream Length ▁, ▁Extractor Output ▁output ▁, ▁Output Frame Holder ▁output Frame Holder ▁) ▁{ ▁boolean ▁have Seek Table ▁= ▁decoder J ni ▁. ▁get Seek Points ▁( ▁0 ▁) ▁!= ▁null ▁; ▁Flac Binary Search Seek er ▁binarySearch Seek er ▁= ▁null ▁; ▁Seek Map ▁seek Map ▁; ▁if ▁( ▁have Seek Table ▁) ▁{ ▁seek Map ▁= ▁new ▁Flac Seek Map ▁( ▁stream Metadata ▁. ▁getDuration Us ▁( ▁) ▁, ▁decoder J ni ▁) ▁; ▁} ▁else ▁if ▁( ▁stream Length ▁!= ▁C ▁. ▁LENGTH _ UNSET ▁&& ▁stream Metadata ▁. ▁total Samples ▁> ▁0 ▁) ▁{ ▁long ▁first Frame Position ▁= ▁decoder J ni ▁. ▁get Decode Position ▁( ▁) ▁; ▁binarySearch Seek er ▁= ▁new ▁Flac Binary Search Seek er ▁( ▁stream Metadata ▁, ▁first Frame Position ▁, ▁stream Length ▁, ▁decoder J ni ▁, ▁output Frame Holder ▁) ▁; ▁seek Map ▁= ▁binarySearch Seek er ▁. ▁get Seek Map ▁( ▁) ▁; ▁} ▁else ▁{ ▁seek Map ▁= ▁new ▁Seek Map ▁. ▁Un se ek able ▁( ▁stream Metadata ▁. ▁getDuration Us ▁( ▁) ▁) ▁; ▁} ▁output ▁. ▁seek Map ▁( ▁seek Map ▁) ▁; ▁return ▁binarySearch Seek er ▁; ▁}
▁public ▁class ▁ Z Standard Compressor ▁implements ▁Comp ressor ▁{ ▁private ▁static ▁final ▁Logger ▁LOG ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁ Z Standard Compressor ▁. ▁class ▁) ▁; ▁private ▁long ▁stream ▁; ▁private ▁int ▁level ▁; ▁private ▁int ▁direct BufferSize ▁; ▁private ▁byte ▁[ ▁] ▁user Buf ▁= ▁null ▁; ▁private ▁int ▁user Buf Off ▁= ▁0 ▁, ▁user Buf Len ▁= ▁0 ▁; ▁private ▁ByteBuffer ▁uncompressed Direct Buf ▁= ▁null ▁; ▁private ▁int ▁uncompressed Direct Buf Off ▁= ▁0 ▁, ▁uncompressed Direct Buf Len ▁= ▁0 ▁; ▁private ▁boolean ▁keep Un compressed Buf ▁= ▁false ▁; ▁private ▁ByteBuffer ▁compressed Direct Buf ▁= ▁null ▁; ▁private ▁boolean ▁finish ▁, ▁finished ▁; ▁private ▁long ▁bytesRead ▁= ▁0 ▁; ▁private ▁long ▁bytes Written ▁= ▁0 ▁; ▁private ▁static ▁boolean ▁native Z Standard Loaded ▁= ▁false ▁; ▁static ▁{ ▁if ▁( ▁Native Code Loader ▁. ▁isNative Code Loaded ▁( ▁) ▁) ▁{ ▁try ▁{ ▁init IDs ▁( ▁) ▁; ▁native Z Standard Loaded ▁= ▁true ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁LOG ▁. ▁warn ▁( ▁STR ▁+ ▁t ▁) ▁; ▁} ▁} ▁} ▁public ▁static ▁boolean ▁isNative Code Loaded ▁( ▁) ▁{ ▁return ▁native Z Standard Loaded ▁; ▁} ▁public ▁static ▁int ▁getRe comm ended BufferSize ▁( ▁) ▁{ ▁return ▁getStream Size ▁( ▁) ▁; ▁} ▁@ ▁Visible ForTesting ▁ Z Standard Compressor ▁( ▁) ▁{ ▁this ▁( ▁Common Configuration Keys ▁. ▁IO _ COMP RESSION _ CODEC _ Z ST D _ LEVEL _ DEFAULT ▁, ▁Common Configuration Keys Public ▁. ▁IO _ FILE _ BUFFER _ SI Z E _ DEFAULT ▁) ▁; ▁} ▁public ▁ Z Standard Compressor ▁( ▁int ▁level ▁, ▁int ▁bufferSize ▁) ▁{ ▁this ▁( ▁level ▁, ▁bufferSize ▁, ▁bufferSize ▁) ▁; ▁} ▁@ ▁Visible ForTesting ▁ Z Standard Compressor ▁( ▁int ▁level ▁, ▁int ▁input BufferSize ▁, ▁int ▁output BufferSize ▁) ▁{ ▁this ▁. ▁level ▁= ▁level ▁; ▁stream ▁= ▁create ▁( ▁) ▁; ▁this ▁. ▁direct BufferSize ▁= ▁output BufferSize ▁; ▁uncompressed Direct Buf ▁= ▁ByteBuffer ▁. ▁allocate Direct ▁( ▁input BufferSize ▁) ▁; ▁compressed Direct Buf ▁= ▁ByteBuffer ▁. ▁allocate Direct ▁( ▁output BufferSize ▁) ▁; ▁compressed Direct Buf ▁. ▁position ▁( ▁output BufferSize ▁) ▁; ▁reset ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁re init ▁( ▁Configuration ▁conf ▁) ▁{ ▁if ▁( ▁conf ▁== ▁null ▁) ▁{ ▁return ▁; ▁} ▁level ▁= ▁ Z Standard Codec ▁. ▁get Compression Level ▁( ▁conf ▁) ▁; ▁reset ▁( ▁) ▁; ▁LOG ▁. ▁debug ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setInput ▁( ▁byte ▁[ ▁] ▁b ▁, ▁int ▁off ▁, ▁int ▁len ▁) ▁{ ▁if ▁( ▁b ▁== ▁null ▁) ▁{ ▁throw ▁new ▁NullPointer Exception ▁( ▁) ▁; ▁} ▁if ▁( ▁off ▁< ▁0 ▁|| ▁len ▁< ▁0 ▁|| ▁off ▁> ▁b ▁. ▁length ▁- ▁len ▁) ▁{ ▁throw ▁new ▁Array Index OutOfBounds Exception ▁( ▁) ▁; ▁} ▁this ▁. ▁user Buf ▁= ▁b ▁; ▁this ▁. ▁user Buf Off ▁= ▁off ▁; ▁this ▁. ▁user Buf Len ▁= ▁len ▁; ▁uncompressed Direct Buf Off ▁= ▁0 ▁;
▁public ▁class ▁Oracle CreateTableTest 84 ▁extends ▁OracleTest ▁{ ▁public ▁void ▁test _ types ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁sql ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁; ▁List ▁< ▁SQLStatement ▁> ▁statementList ▁= ▁SQLUtils ▁. ▁parseStatements ▁( ▁sql ▁, ▁JdbcConstants ▁. ▁ORACLE ▁) ▁; ▁SQLCreateTable Statement ▁stmt ▁= ▁( ▁SQLCreateTable Statement ▁) ▁statementList ▁. ▁get ▁( ▁0 ▁) ▁; ▁print ▁( ▁statementList ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁statementList ▁. ▁size ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁, ▁SQLUtils ▁. ▁toSQLString ▁( ▁stmt ▁, ▁JdbcConstants ▁. ▁ORACLE ▁) ▁) ▁; ▁stmt ▁. ▁rename Column ▁( ▁STR ▁, ▁STR ▁) ▁; ▁assertEquals ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁, ▁SQLUtils ▁. ▁toSQLString ▁( ▁stmt ▁, ▁JdbcConstants ▁. ▁ORACLE ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁Storage Util ▁{ ▁private ▁static ▁final ▁String ▁PRODU CTION _ PACKAGE _ ID ▁= ▁STR ▁; ▁public ▁static ▁File ▁getOrCreate Backup Directory ▁( ▁) ▁throws ▁NoExternal Storage Exception ▁{ ▁File ▁storage ▁= ▁Environment ▁. ▁getExternal Storage Directory ▁( ▁) ▁; ▁if ▁( ▁! ▁storage ▁. ▁can Write ▁( ▁) ▁) ▁{ ▁throw ▁new ▁NoExternal Storage Exception ▁( ▁) ▁; ▁} ▁File ▁backup s ▁= ▁get Backup Directory ▁( ▁) ▁; ▁if ▁( ▁! ▁backup s ▁. ▁exists ▁( ▁) ▁) ▁{ ▁if ▁( ▁! ▁backup s ▁. ▁mkdirs ▁( ▁) ▁) ▁{ ▁throw ▁new ▁NoExternal Storage Exception ▁( ▁STR ▁) ▁; ▁} ▁} ▁return ▁backup s ▁; ▁} ▁public ▁static ▁File ▁get Backup Directory ▁( ▁) ▁throws ▁NoExternal Storage Exception ▁{ ▁File ▁storage ▁= ▁Environment ▁. ▁getExternal Storage Directory ▁( ▁) ▁; ▁File ▁signal ▁= ▁new ▁File ▁( ▁storage ▁, ▁STR ▁) ▁; ▁File ▁backup s ▁= ▁new ▁File ▁( ▁signal ▁, ▁STR ▁) ▁; ▁if ▁( ▁Build Config ▁. ▁APPLICATION _ ID ▁. ▁startsWith ▁( ▁PRODU CTION _ PACKAGE _ ID ▁+ ▁STR ▁) ▁) ▁{ ▁backup s ▁= ▁new ▁File ▁( ▁backup s ▁, ▁Build Config ▁. ▁APPLICATION _ ID ▁. ▁substring ▁( ▁PRODU CTION _ PACKAGE _ ID ▁. ▁length ▁( ▁) ▁+ ▁1 ▁) ▁) ▁; ▁} ▁return ▁backup s ▁; ▁} ▁@ ▁RequiresApi ▁( ▁24 ▁) ▁public ▁static ▁@ ▁NonNull ▁String ▁getDisplay Path ▁( ▁@ ▁NonNull ▁Context ▁context ▁, ▁@ ▁NonNull ▁Uri ▁uri ▁) ▁{ ▁String ▁last Path Segment ▁= ▁Objects ▁. ▁requireNonNull ▁( ▁uri ▁. ▁getLast Path Segment ▁( ▁) ▁) ▁; ▁String ▁backup Volume ▁= ▁last Path Segment ▁. ▁replace First ▁( ▁STR ▁, ▁STR ▁) ▁; ▁String ▁backup Name ▁= ▁last Path Segment ▁. ▁replace First ▁( ▁STR ▁, ▁STR ▁) ▁; ▁Storage Manager ▁storage Manager ▁= ▁Service Util ▁. ▁getStorage Manager ▁( ▁context ▁) ▁; ▁List ▁< ▁Storage Volume ▁> ▁storage V ol umes ▁= ▁storage Manager ▁. ▁getStorage V ol umes ▁( ▁) ▁; ▁Storage Volume ▁storage Volume ▁= ▁null ▁; ▁for ▁( ▁Storage Volume ▁volume ▁: ▁storage V ol umes ▁) ▁{ ▁if ▁( ▁Objects ▁. ▁equals ▁( ▁volume ▁. ▁get Uuid ▁( ▁) ▁, ▁backup Volume ▁) ▁) ▁{ ▁storage Volume ▁= ▁volume ▁; ▁break ▁; ▁} ▁} ▁if ▁( ▁storage Volume ▁== ▁null ▁) ▁{ ▁return ▁backup Name ▁; ▁} ▁else ▁{ ▁return ▁context ▁. ▁getString ▁( ▁R ▁. ▁string ▁. ▁Storage Util __ s _ s ▁, ▁storage Volume ▁. ▁getDescription ▁( ▁context ▁) ▁, ▁backup Name ▁) ▁; ▁} ▁} ▁public ▁static ▁File ▁get Backup Cache Directory ▁( ▁Context ▁context ▁) ▁{ ▁return ▁context ▁. ▁getExternal CacheDir ▁( ▁) ▁; ▁} ▁private ▁static ▁File ▁getS ignal Storage Dir ▁( ▁) ▁throws ▁NoExternal Storage Exception ▁{ ▁final ▁File ▁storage ▁= ▁Environment ▁. ▁getExternal Storage Directory ▁( ▁) ▁; ▁if ▁( ▁! ▁storage ▁. ▁can Write ▁( ▁) ▁) ▁{ ▁throw ▁new ▁NoExternal Storage Exception ▁( ▁) ▁; ▁} ▁return ▁storage ▁; ▁} ▁public ▁static ▁boolean ▁can Write In Signal Storage Dir ▁( ▁) ▁{ ▁File ▁storage ▁;
▁public ▁void ▁setUsername ▁( ▁String ▁username ▁) ▁{ ▁this ▁. ▁username ▁= ▁username ▁; ▁} ▁public ▁String ▁getPassword ▁( ▁) ▁{ ▁return ▁password ▁; ▁} ▁public ▁void ▁setPassword ▁( ▁String ▁password ▁) ▁{ ▁this ▁. ▁password ▁= ▁password ▁; ▁} ▁public ▁Integer ▁getTimeout ▁( ▁) ▁{ ▁return ▁timeout ▁; ▁} ▁public ▁void ▁setTimeout ▁( ▁Integer ▁timeout ▁) ▁{ ▁this ▁. ▁timeout ▁= ▁timeout ▁; ▁} ▁public ▁Map ▁< ▁String ▁, ▁String ▁> ▁getParameters ▁( ▁) ▁{ ▁return ▁parameters ▁; ▁} ▁public ▁void ▁setParameters ▁( ▁Map ▁< ▁String ▁, ▁String ▁> ▁parameters ▁) ▁{ ▁this ▁. ▁parameters ▁= ▁parameters ▁; ▁} ▁@ ▁Parameter ▁( ▁key ▁= ▁STR ▁) ▁public ▁Integer ▁get Retry Times ▁( ▁) ▁{ ▁return ▁retry Times ▁; ▁} ▁public ▁void ▁set Retry Times ▁( ▁Integer ▁retry Times ▁) ▁{ ▁this ▁. ▁retry Times ▁= ▁retry Times ▁; ▁} ▁@ ▁Parameter ▁( ▁key ▁= ▁STR ▁) ▁public ▁Integer ▁get Retry Period ▁( ▁) ▁{ ▁return ▁retry Period ▁; ▁} ▁public ▁void ▁set Retry Period ▁( ▁Integer ▁retry Period ▁) ▁{ ▁this ▁. ▁retry Period ▁= ▁retry Period ▁; ▁} ▁@ ▁Parameter ▁( ▁key ▁= ▁STR ▁) ▁public ▁Boolean ▁getC ycle Report ▁( ▁) ▁{ ▁return ▁cycle Report ▁; ▁} ▁public ▁void ▁set Cycle Report ▁( ▁Boolean ▁cycle Report ▁) ▁{ ▁this ▁. ▁cycle Report ▁= ▁cycle Report ▁; ▁} ▁@ ▁Parameter ▁( ▁key ▁= ▁STR ▁) ▁public ▁Boolean ▁getS ync Report ▁( ▁) ▁{ ▁return ▁sync Report ▁; ▁} ▁public ▁void ▁setS ync Report ▁( ▁Boolean ▁sync Report ▁) ▁{ ▁this ▁. ▁sync Report ▁= ▁sync Report ▁; ▁} ▁@ ▁Override ▁@ ▁Parameter ▁( ▁excluded ▁= ▁true ▁, ▁attribute ▁= ▁false ▁) ▁public ▁boolean ▁isValid ▁( ▁) ▁{ ▁return ▁StringUtils ▁. ▁isNotEmpty ▁( ▁address ▁) ▁; ▁} ▁public ▁String ▁getGroup ▁( ▁) ▁{ ▁return ▁group ▁; ▁} ▁public ▁void ▁setGroup ▁( ▁String ▁group ▁) ▁{ ▁this ▁. ▁group ▁= ▁group ▁; ▁} ▁public ▁Boolean ▁getCluster ▁( ▁) ▁{ ▁return ▁cluster ▁; ▁} ▁public ▁void ▁setCluster ▁( ▁Boolean ▁cluster ▁) ▁{ ▁this ▁. ▁cluster ▁= ▁cluster ▁; ▁} ▁public ▁String ▁getRegistry ▁( ▁) ▁{ ▁return ▁registry ▁; ▁} ▁public ▁void ▁set Registry ▁( ▁String ▁registry ▁) ▁{ ▁this ▁. ▁registry ▁= ▁registry ▁; ▁} ▁public ▁String ▁getFile ▁( ▁) ▁{ ▁return ▁file ▁; ▁} ▁public ▁void ▁setFile ▁( ▁String ▁file ▁) ▁{ ▁this ▁. ▁file ▁= ▁file ▁; ▁} ▁public ▁void ▁update Parameters ▁( ▁Map ▁< ▁String ▁, ▁String ▁> ▁parameters ▁) ▁{ ▁if ▁( ▁CollectionUtils ▁. ▁isEmpty Map ▁( ▁parameters ▁) ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁this ▁. ▁parameters ▁== ▁null ▁) ▁{ ▁this ▁. ▁parameters ▁= ▁parameters ▁; ▁} ▁else ▁{ ▁this ▁. ▁parameters ▁. ▁putAll ▁( ▁parameters ▁) ▁; ▁} ▁} ▁}
▁final ▁class ▁State UID ▁{ ▁@ ▁Nonnull ▁private ▁final ▁String ▁state Name ▁; ▁@ ▁Nonnull ▁private ▁final ▁State MetaInfo Snapshot ▁. ▁Backend State Type ▁state Type ▁; ▁State UID ▁( ▁@ ▁Nonnull ▁String ▁state Name ▁, ▁@ ▁Nonnull ▁State MetaInfo Snapshot ▁. ▁Backend State Type ▁state Type ▁) ▁{ ▁this ▁. ▁state Name ▁= ▁state Name ▁; ▁this ▁. ▁state Type ▁= ▁state Type ▁; ▁} ▁@ ▁Nonnull ▁public ▁String ▁getState Name ▁( ▁) ▁{ ▁return ▁state Name ▁; ▁} ▁@ ▁Nonnull ▁public ▁State MetaInfo Snapshot ▁. ▁Backend State Type ▁getState Type ▁( ▁) ▁{ ▁return ▁state Type ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁o ▁) ▁{ ▁if ▁( ▁this ▁== ▁o ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁o ▁== ▁null ▁|| ▁getClass ▁( ▁) ▁!= ▁o ▁. ▁getClass ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁State UID ▁uid ▁= ▁( ▁State UID ▁) ▁o ▁; ▁return ▁Objects ▁. ▁equals ▁( ▁getState Name ▁( ▁) ▁, ▁uid ▁. ▁getState Name ▁( ▁) ▁) ▁&& ▁getState Type ▁( ▁) ▁== ▁uid ▁. ▁getState Type ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁Objects ▁. ▁hash ▁( ▁getState Name ▁( ▁) ▁, ▁getState Type ▁( ▁) ▁) ▁; ▁} ▁public ▁static ▁State UID ▁of ▁( ▁@ ▁Nonnull ▁String ▁state Name ▁, ▁@ ▁Nonnull ▁State MetaInfo Snapshot ▁. ▁Backend State Type ▁state Type ▁) ▁{ ▁return ▁new ▁State UID ▁( ▁state Name ▁, ▁state Type ▁) ▁; ▁} ▁}
▁if ▁( ▁v AB B C ▁>= ▁0.1 f ▁) ▁{ ▁continue ▁; ▁} ▁float ▁d C py ▁= ▁( ▁float ▁) ▁Math ▁. ▁sqrt ▁( ▁( ▁double ▁) ▁d A ▁ * ▁d A ▁+ ▁( ▁double ▁) ▁d B ▁ * ▁d B ▁) ▁; ▁float ▁v P y C ▁= ▁Math ▁. ▁abs ▁( ▁( ▁d C ▁- ▁d C py ▁) ▁ / ▁Math ▁. ▁min ▁( ▁d C ▁, ▁d C py ▁) ▁) ▁; ▁if ▁( ▁v P y C ▁>= ▁0.1 f ▁) ▁{ ▁continue ▁; ▁} ▁results ▁. ▁add ▁( ▁test ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁! ▁results ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁return ▁results ▁. ▁toArray ▁( ▁EMPTY _ F P _2 D _ ARRAY ▁) ▁; ▁} ▁throw ▁Not FoundException ▁. ▁get NotFound Instance ▁( ▁) ▁; ▁} ▁public ▁F inder Pattern Info ▁[ ▁] ▁find Multi ▁( ▁Map ▁< ▁Decode Hint Type ▁, ▁? ▁> ▁hints ▁) ▁throws ▁Not FoundException ▁{ ▁boolean ▁try H ar der ▁= ▁hints ▁!= ▁null ▁&& ▁hints ▁. ▁containsKey ▁( ▁Decode Hint Type ▁. ▁TR Y _ HAR DER ▁) ▁; ▁BitMatrix ▁image ▁= ▁getImage ▁( ▁) ▁; ▁int ▁max I ▁= ▁image ▁. ▁getHeight ▁( ▁) ▁; ▁int ▁max J ▁= ▁image ▁. ▁getWidth ▁( ▁) ▁; ▁int ▁i Skip ▁= ▁( ▁3 ▁ * ▁max I ▁) ▁ / ▁( ▁4 ▁ * ▁MAX _ MO DU LES ▁) ▁; ▁if ▁( ▁i Skip ▁< ▁MIN _ S KIP ▁|| ▁try H ar der ▁) ▁{ ▁i Skip ▁= ▁MIN _ S KIP ▁; ▁} ▁int ▁[ ▁] ▁state Count ▁= ▁new ▁int ▁[ ▁5 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁i Skip ▁- ▁1 ▁; ▁i ▁< ▁max I ▁; ▁i ▁+= ▁i Skip ▁) ▁{ ▁do Clear Counts ▁( ▁state Count ▁) ▁; ▁int ▁currentState ▁= ▁0 ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁max J ▁; ▁j ▁++ ▁) ▁{ ▁if ▁( ▁image ▁. ▁get ▁( ▁j ▁, ▁i ▁) ▁) ▁{ ▁if ▁( ▁( ▁currentState ▁& ▁1 ▁) ▁== ▁1 ▁) ▁{ ▁currentState ▁++ ▁; ▁} ▁state Count ▁[ ▁currentState ▁] ▁++ ▁; ▁} ▁else ▁{ ▁if ▁( ▁( ▁currentState ▁& ▁1 ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁currentState ▁== ▁4 ▁) ▁{ ▁if ▁( ▁found Pattern Cross ▁( ▁state Count ▁) ▁&& ▁handle Possible Center ▁( ▁state Count ▁, ▁i ▁, ▁j ▁) ▁) ▁{ ▁currentState ▁= ▁0 ▁; ▁do Clear Counts ▁( ▁state Count ▁) ▁; ▁} ▁else ▁{ ▁do Shift Counts 2 ▁( ▁state Count ▁) ▁; ▁currentState ▁= ▁3 ▁; ▁} ▁} ▁else ▁{ ▁state Count ▁[ ▁++ ▁currentState ▁] ▁++ ▁; ▁} ▁} ▁else ▁{ ▁state Count ▁[ ▁currentState ▁] ▁++ ▁; ▁} ▁} ▁} ▁if ▁( ▁found Pattern Cross ▁( ▁state Count ▁) ▁) ▁{ ▁handle Possible Center ▁( ▁state Count ▁, ▁i ▁, ▁max J ▁) ▁; ▁} ▁} ▁F inder Pattern ▁[ ▁] ▁[ ▁] ▁pattern Info ▁= ▁select Multiple B est Patterns ▁( ▁) ▁;
▁if ▁( ▁matching Methods ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁mapped Name ▁+ ▁STR ▁+ ▁clazz ▁. ▁getName ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁for ▁( ▁Method ▁method ▁: ▁matching Methods ▁) ▁{ ▁String ▁reg MethodName ▁= ▁this ▁. ▁methodName Map ▁. ▁get ▁( ▁method ▁) ▁; ▁if ▁( ▁reg MethodName ▁== ▁null ▁|| ▁( ▁! ▁reg MethodName ▁. ▁equals ▁( ▁name ▁) ▁&& ▁reg MethodName ▁. ▁length ▁( ▁) ▁<= ▁name ▁. ▁length ▁( ▁) ▁) ▁) ▁{ ▁if ▁( ▁logger ▁. ▁isDebugEnabled ▁( ▁) ▁&& ▁reg MethodName ▁!= ▁null ▁) ▁{ ▁logger ▁. ▁debug ▁( ▁STR ▁+ ▁method ▁+ ▁STR ▁+ ▁name ▁+ ▁STR ▁+ ▁reg MethodName ▁+ ▁STR ▁) ▁; ▁} ▁this ▁. ▁methodName Map ▁. ▁put ▁( ▁method ▁, ▁name ▁) ▁; ▁add Transactional Method ▁( ▁method ▁, ▁attr ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁logger ▁. ▁isDebugEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁debug ▁( ▁STR ▁+ ▁method ▁+ ▁STR ▁+ ▁name ▁+ ▁STR ▁+ ▁reg MethodName ▁+ ▁STR ▁) ▁; ▁} ▁} ▁} ▁} ▁public ▁void ▁add Transactional Method ▁( ▁Method ▁method ▁, ▁Transaction Attribute ▁attr ▁) ▁{ ▁Assert ▁. ▁notNull ▁( ▁method ▁, ▁STR ▁) ▁; ▁Assert ▁. ▁notNull ▁( ▁attr ▁, ▁STR ▁) ▁; ▁if ▁( ▁logger ▁. ▁isDebugEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁debug ▁( ▁STR ▁+ ▁method ▁+ ▁STR ▁+ ▁attr ▁+ ▁STR ▁) ▁; ▁} ▁if ▁( ▁this ▁. ▁embedded Value Resolver ▁!= ▁null ▁&& ▁attr ▁instanceof ▁Default Transaction Attribute ▁) ▁{ ▁( ▁( ▁Default Transaction Attribute ▁) ▁attr ▁) ▁. ▁resolve Attribute Strings ▁( ▁this ▁. ▁embedded Value Resolver ▁) ▁; ▁} ▁this ▁. ▁transaction Attribute Map ▁. ▁put ▁( ▁method ▁, ▁attr ▁) ▁; ▁} ▁protected ▁boolean ▁isMatch ▁( ▁String ▁methodName ▁, ▁String ▁mapped Name ▁) ▁{ ▁return ▁Pattern Match Utils ▁. ▁simple Match ▁( ▁mapped Name ▁, ▁methodName ▁) ▁; ▁} ▁@ ▁Override ▁@ ▁Nullable ▁public ▁Transaction Attribute ▁getTransaction Attribute ▁( ▁Method ▁method ▁, ▁@ ▁Nullable ▁Class ▁< ▁? ▁> ▁targetClass ▁) ▁{ ▁if ▁( ▁this ▁. ▁e ager ly Initialized ▁) ▁{ ▁return ▁this ▁. ▁transaction Attribute Map ▁. ▁get ▁( ▁method ▁) ▁; ▁} ▁else ▁{ ▁synchronized ▁( ▁this ▁. ▁transaction Attribute Map ▁) ▁{ ▁if ▁( ▁! ▁this ▁. ▁initialized ▁) ▁{ ▁init Method Map ▁( ▁this ▁. ▁method Map ▁) ▁; ▁this ▁. ▁initialized ▁= ▁true ▁; ▁} ▁return ▁this ▁. ▁transaction Attribute Map ▁. ▁get ▁( ▁method ▁) ▁; ▁} ▁} ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁@ ▁Nullable ▁Object ▁other ▁) ▁{ ▁if ▁( ▁this ▁== ▁other ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁! ▁( ▁other ▁instanceof ▁Method Map Transaction AttributeSource ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁Method Map Transaction AttributeSource ▁other T as ▁= ▁( ▁Method Map Transaction AttributeSource ▁) ▁other ▁; ▁return ▁ObjectUtils ▁. ▁nullSafeEquals ▁( ▁this ▁. ▁method Map ▁, ▁other T as ▁. ▁method Map ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁Method Map Transaction AttributeSource ▁. ▁class ▁. ▁hashCode ▁( ▁) ▁; ▁}
▁@ ▁GwtIncompatible ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁class ▁Map Maker Internal Map ▁< ▁K ▁, ▁V ▁, ▁E ▁extends ▁Map Maker Internal Map ▁. ▁Internal Entry ▁< ▁K ▁, ▁V ▁, ▁E ▁> ▁, ▁S ▁extends ▁Map Maker Internal Map ▁. ▁Segment ▁< ▁K ▁, ▁V ▁, ▁E ▁, ▁S ▁> ▁> ▁extends ▁AbstractMap ▁< ▁K ▁, ▁V ▁> ▁implements ▁ConcurrentMap ▁< ▁K ▁, ▁V ▁> ▁, ▁Serializable ▁{ ▁static ▁final ▁int ▁MAX IMUM _ CAPACITY ▁= ▁Ints ▁. ▁MAX _ POWER _ OF _ T WO ▁; ▁static ▁final ▁int ▁MAX _ SEGMENT S ▁= ▁1 ▁<< ▁16 ▁; ▁static ▁final ▁int ▁CON TA INS _ VALUE _ RE TRIES ▁= ▁3 ▁; ▁static ▁final ▁int ▁DR AIN _ THRESHOLD ▁= ▁0 x 3 F ▁; ▁static ▁final ▁int ▁DR AIN _ MAX ▁= ▁16 ▁; ▁static ▁final ▁long ▁C LEAN UP _ EXECUTOR _ DELAY _ SE CS ▁= ▁60 ▁; ▁final ▁transient ▁int ▁segment Mask ▁; ▁final ▁transient ▁int ▁segment Shift ▁; ▁final ▁transient ▁Segment ▁< ▁K ▁, ▁V ▁, ▁E ▁, ▁S ▁> ▁[ ▁] ▁segments ▁; ▁final ▁int ▁concurrency Level ▁; ▁final ▁Equivalence ▁< ▁Object ▁> ▁key Equivalence ▁; ▁final ▁transient ▁Internal Entry Helper ▁< ▁K ▁, ▁V ▁, ▁E ▁, ▁S ▁> ▁entry Helper ▁; ▁private ▁Map Maker Internal Map ▁( ▁Map Maker ▁builder ▁, ▁Internal Entry Helper ▁< ▁K ▁, ▁V ▁, ▁E ▁, ▁S ▁> ▁entry Helper ▁) ▁{ ▁concurrency Level ▁= ▁Math ▁. ▁min ▁( ▁builder ▁. ▁getCon currency Level ▁( ▁) ▁, ▁MAX _ SEGMENT S ▁) ▁; ▁key Equivalence ▁= ▁builder ▁. ▁getKey Equivalence ▁( ▁) ▁; ▁this ▁. ▁entry Helper ▁= ▁entry Helper ▁; ▁int ▁initialCapacity ▁= ▁Math ▁. ▁min ▁( ▁builder ▁. ▁getInitial Capacity ▁( ▁) ▁, ▁MAX IMUM _ CAPACITY ▁) ▁; ▁int ▁segment Shift ▁= ▁0 ▁; ▁int ▁segment Count ▁= ▁1 ▁; ▁while ▁( ▁segment Count ▁< ▁concurrency Level ▁) ▁{ ▁++ ▁segment Shift ▁; ▁segment Count ▁<<= ▁1 ▁; ▁} ▁this ▁. ▁segment Shift ▁= ▁32 ▁- ▁segment Shift ▁; ▁segment Mask ▁= ▁segment Count ▁- ▁1 ▁; ▁this ▁. ▁segments ▁= ▁new Segment Array ▁( ▁segment Count ▁) ▁; ▁int ▁segment Capacity ▁= ▁initialCapacity ▁ / ▁segment Count ▁; ▁if ▁( ▁segment Capacity ▁ * ▁segment Count ▁< ▁initialCapacity ▁) ▁{ ▁++ ▁segment Capacity ▁; ▁} ▁int ▁segment Size ▁= ▁1 ▁; ▁while ▁( ▁segment Size ▁< ▁segment Capacity ▁) ▁{ ▁segment Size ▁<<= ▁1 ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁this ▁. ▁segments ▁. ▁length ▁; ▁++ ▁i ▁) ▁{ ▁this ▁. ▁segments ▁[ ▁i ▁] ▁= ▁create Segment ▁( ▁segment Size ▁, ▁Map Maker ▁. ▁UN SET _ INT ▁) ▁; ▁} ▁}
▁@ ▁Component ▁public ▁class ▁Photo Tag Direct ive ▁implements ▁Template Direct ive Model ▁{ ▁private ▁final ▁Photo Service ▁photo Service ▁; ▁public ▁Photo Tag Direct ive ▁( ▁Configuration ▁configuration ▁, ▁Photo Service ▁photo Service ▁) ▁{ ▁this ▁. ▁photo Service ▁= ▁photo Service ▁; ▁configuration ▁. ▁set Shared Variable ▁( ▁STR ▁, ▁this ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁Environment ▁env ▁, ▁Map ▁params ▁, ▁Template Model ▁[ ▁] ▁loop Vars ▁, ▁Template Direct ive Body ▁body ▁) ▁throws ▁Template Exception ▁, ▁IOException ▁{ ▁final ▁Default ObjectWrapper Builder ▁builder ▁= ▁new ▁Default ObjectWrapper Builder ▁( ▁Configuration ▁. ▁VERSION _2 _3 _25 ▁) ▁; ▁if ▁( ▁params ▁. ▁containsKey ▁( ▁Hal o Const ▁. ▁METHOD _ KEY ▁) ▁) ▁{ ▁String ▁method ▁= ▁params ▁. ▁get ▁( ▁Hal o Const ▁. ▁METHOD _ KEY ▁) ▁. ▁toString ▁( ▁) ▁; ▁switch ▁( ▁method ▁) ▁{ ▁case ▁STR ▁: ▁env ▁. ▁setVariable ▁( ▁STR ▁, ▁builder ▁. ▁build ▁( ▁) ▁. ▁wrap ▁( ▁photo Service ▁. ▁list All ▁( ▁) ▁) ▁) ▁; ▁break ▁; ▁case ▁STR ▁: ▁env ▁. ▁setVariable ▁( ▁STR ▁, ▁builder ▁. ▁build ▁( ▁) ▁. ▁wrap ▁( ▁photo Service ▁. ▁list Te am V os ▁( ▁Sort ▁. ▁by ▁( ▁DESC ▁, ▁STR ▁) ▁) ▁) ▁) ▁; ▁break ▁; ▁case ▁STR ▁: ▁String ▁te am ▁= ▁params ▁. ▁get ▁( ▁STR ▁) ▁. ▁toString ▁( ▁) ▁; ▁env ▁. ▁setVariable ▁( ▁STR ▁, ▁builder ▁. ▁build ▁( ▁) ▁. ▁wrap ▁( ▁photo Service ▁. ▁list By Te am ▁( ▁te am ▁, ▁Sort ▁. ▁by ▁( ▁DESC ▁, ▁STR ▁) ▁) ▁) ▁) ▁; ▁break ▁; ▁case ▁STR ▁: ▁env ▁. ▁setVariable ▁( ▁STR ▁, ▁builder ▁. ▁build ▁( ▁) ▁. ▁wrap ▁( ▁photo Service ▁. ▁count ▁( ▁) ▁) ▁) ▁; ▁break ▁; ▁default ▁: ▁break ▁; ▁} ▁} ▁body ▁. ▁render ▁( ▁env ▁. ▁getOut ▁( ▁) ▁) ▁; ▁} ▁}
▁@ ▁Interface Audience ▁. ▁Private ▁@ ▁Interface Stability ▁. ▁Unstable ▁public ▁final ▁class ▁Slow Peer Reports ▁{ ▁@ ▁Nonnull ▁private ▁final ▁Map ▁< ▁String ▁, ▁Double ▁> ▁slow Pe ers ▁; ▁public ▁static ▁final ▁Slow Peer Reports ▁EMPTY _ RE PORT ▁= ▁new ▁Slow Peer Reports ▁( ▁ImmutableMap ▁. ▁of ▁( ▁) ▁) ▁; ▁private ▁Slow Peer Reports ▁( ▁Map ▁< ▁String ▁, ▁Double ▁> ▁slow Pe ers ▁) ▁{ ▁this ▁. ▁slow Pe ers ▁= ▁slow Pe ers ▁; ▁} ▁public ▁static ▁Slow Peer Reports ▁create ▁( ▁@ ▁Nullable ▁Map ▁< ▁String ▁, ▁Double ▁> ▁slow Pe ers ▁) ▁{ ▁if ▁( ▁slow Pe ers ▁== ▁null ▁|| ▁slow Pe ers ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁return ▁EMPTY _ RE PORT ▁; ▁} ▁return ▁new ▁Slow Peer Reports ▁( ▁slow Pe ers ▁) ▁; ▁} ▁public ▁Map ▁< ▁String ▁, ▁Double ▁> ▁getS low Pe ers ▁( ▁) ▁{ ▁return ▁slow Pe ers ▁; ▁} ▁public ▁boolean ▁have Slow Pe ers ▁( ▁) ▁{ ▁return ▁slow Pe ers ▁. ▁size ▁( ▁) ▁> ▁0 ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁o ▁) ▁{ ▁if ▁( ▁this ▁== ▁o ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁! ▁( ▁o ▁instanceof ▁Slow Peer Reports ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁Slow Peer Reports ▁that ▁= ▁( ▁Slow Peer Reports ▁) ▁o ▁; ▁return ▁slow Pe ers ▁. ▁equals ▁( ▁that ▁. ▁slow Pe ers ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁slow Pe ers ▁. ▁hashCode ▁( ▁) ▁; ▁} ▁}
▁if ▁( ▁i ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁+ ▁decode Str ▁+ ▁STR ▁) ▁; ▁} ▁protocol ▁= ▁decode Str ▁. ▁substring ▁( ▁0 ▁, ▁i ▁) ▁; ▁decode Str ▁= ▁decode Str ▁. ▁substring ▁( ▁i ▁+ ▁3 ▁) ▁; ▁} ▁else ▁{ ▁i ▁= ▁decode Str ▁. ▁indexOf ▁( ▁STR ▁) ▁; ▁if ▁( ▁i ▁>= ▁0 ▁) ▁{ ▁if ▁( ▁i ▁== ▁0 ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁+ ▁decode Str ▁+ ▁STR ▁) ▁; ▁} ▁protocol ▁= ▁decode Str ▁. ▁substring ▁( ▁0 ▁, ▁i ▁) ▁; ▁decode Str ▁= ▁decode Str ▁. ▁substring ▁( ▁i ▁+ ▁1 ▁) ▁; ▁} ▁} ▁i ▁= ▁decode Str ▁. ▁indexOf ▁( ▁CHAR ▁) ▁; ▁if ▁( ▁i ▁>= ▁0 ▁) ▁{ ▁path ▁= ▁decode Str ▁. ▁substring ▁( ▁i ▁+ ▁1 ▁) ▁; ▁decode Str ▁= ▁decode Str ▁. ▁substring ▁( ▁0 ▁, ▁i ▁) ▁; ▁} ▁i ▁= ▁decode Str ▁. ▁lastIndexOf ▁( ▁CHAR ▁) ▁; ▁if ▁( ▁i ▁>= ▁0 ▁) ▁{ ▁username ▁= ▁decode Str ▁. ▁substring ▁( ▁0 ▁, ▁i ▁) ▁; ▁int ▁j ▁= ▁username ▁. ▁indexOf ▁( ▁CHAR ▁) ▁; ▁if ▁( ▁j ▁>= ▁0 ▁) ▁{ ▁password ▁= ▁username ▁. ▁substring ▁( ▁j ▁+ ▁1 ▁) ▁; ▁username ▁= ▁username ▁. ▁substring ▁( ▁0 ▁, ▁j ▁) ▁; ▁} ▁decode Str ▁= ▁decode Str ▁. ▁substring ▁( ▁i ▁+ ▁1 ▁) ▁; ▁} ▁i ▁= ▁decode Str ▁. ▁lastIndexOf ▁( ▁CHAR ▁) ▁; ▁if ▁( ▁i ▁>= ▁0 ▁&& ▁i ▁< ▁decode Str ▁. ▁length ▁( ▁) ▁- ▁1 ▁) ▁{ ▁if ▁( ▁decode Str ▁. ▁lastIndexOf ▁( ▁CHAR ▁) ▁> ▁i ▁) ▁{ ▁} ▁else ▁{ ▁port ▁= ▁Integer ▁. ▁parseInt ▁( ▁decode Str ▁. ▁substring ▁( ▁i ▁+ ▁1 ▁) ▁) ▁; ▁host ▁= ▁decode Str ▁. ▁substring ▁( ▁0 ▁, ▁i ▁) ▁; ▁} ▁} ▁protocol ▁= ▁URL Item Cache ▁. ▁intern ▁( ▁protocol ▁) ▁; ▁path ▁= ▁URL Item Cache ▁. ▁check Path ▁( ▁path ▁) ▁; ▁return ▁new ▁Path URL Address ▁( ▁protocol ▁, ▁username ▁, ▁password ▁, ▁path ▁, ▁host ▁, ▁port ▁, ▁raw Address ▁) ▁; ▁} ▁}
▁private ▁native ▁void ▁native Set Audio Output G ain Control Enabled ▁( ▁long ▁inst ▁, ▁boolean ▁enabled ▁) ▁; ▁private ▁native ▁void ▁native Set Echo Cancellation Str ength ▁( ▁long ▁inst ▁, ▁int ▁str ength ▁) ▁; ▁private ▁native ▁String ▁nativeGet Debug Log ▁( ▁long ▁inst ▁) ▁; ▁private ▁native ▁int ▁nativeGet Peer Capabilities ▁( ▁long ▁inst ▁) ▁; ▁private ▁native ▁void ▁native Request Call Upgrade ▁( ▁long ▁inst ▁) ▁; ▁private ▁static ▁native ▁boolean ▁native Need Rate ▁( ▁long ▁inst ▁) ▁; ▁public ▁static ▁native ▁int ▁getConnection Max Layer ▁( ▁) ▁; ▁public ▁interface ▁Connection State Listener ▁{ ▁void ▁on Connection StateChanged ▁( ▁int ▁newState ▁, ▁boolean ▁in Transition ▁) ▁; ▁void ▁on Signal Bar Count Changed ▁( ▁int ▁new Count ▁) ▁; ▁} ▁public ▁static ▁class ▁Stats ▁{ ▁public ▁long ▁bytes Sent W ifi ▁; ▁public ▁long ▁bytes Recv d W ifi ▁; ▁public ▁long ▁bytes Sent M obile ▁; ▁public ▁long ▁bytes Recv d M obile ▁; ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁STR ▁+ ▁bytes Recv d M obile ▁+ ▁STR ▁+ ▁bytes Sent W ifi ▁+ ▁STR ▁+ ▁bytes Recv d W ifi ▁+ ▁STR ▁+ ▁bytes Sent M obile ▁+ ▁CHAR ▁; ▁} ▁} ▁}
▁@ ▁Deprecated ▁public ▁final ▁class ▁OpenSsl N p n Application Protocol Negot iator ▁implements ▁OpenSsl Application Protocol Negot iator ▁{ ▁private ▁final ▁List ▁< ▁String ▁> ▁protocols ▁; ▁public ▁OpenSsl N p n Application Protocol Negot iator ▁( ▁Iterable ▁< ▁String ▁> ▁protocols ▁) ▁{ ▁this ▁. ▁protocols ▁= ▁checkNotNull ▁( ▁toList ▁( ▁protocols ▁) ▁, ▁STR ▁) ▁; ▁} ▁public ▁OpenSsl N p n Application Protocol Negot iator ▁( ▁String ▁... ▁protocols ▁) ▁{ ▁this ▁. ▁protocols ▁= ▁checkNotNull ▁( ▁toList ▁( ▁protocols ▁) ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Application Protocol Config ▁. ▁Protocol ▁protocol ▁( ▁) ▁{ ▁return ▁Application Protocol Config ▁. ▁Protocol ▁. ▁N P N ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁String ▁> ▁protocols ▁( ▁) ▁{ ▁return ▁protocols ▁; ▁} ▁@ ▁Override ▁public ▁Application Protocol Config ▁. ▁Selector Failure Behavior ▁selector Failure Behavior ▁( ▁) ▁{ ▁return ▁Application Protocol Config ▁. ▁Selector Failure Behavior ▁. ▁CH O O SE _ MY _ LAST _ PROTOCOL ▁; ▁} ▁@ ▁Override ▁public ▁Application Protocol Config ▁. ▁Selected Listener Failure Behavior ▁selected Listener Failure Behavior ▁( ▁) ▁{ ▁return ▁Application Protocol Config ▁. ▁Selected Listener Failure Behavior ▁. ▁ACCEPT ▁; ▁} ▁}
▁catch ▁( ▁final ▁Interrupted Exception ▁e ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁name ▁+ ▁STR ▁+ ▁e ▁) ▁; ▁e ▁. ▁printStackTrace ▁( ▁System ▁. ▁out ▁) ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁name ▁+ ▁STR ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁name ▁+ ▁STR ▁+ ▁Instant ▁. ▁now ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁close Async ▁( ▁) ▁{ ▁streams ▁. ▁close ▁( ▁Duration ▁. ▁ Z ERO ▁) ▁; ▁} ▁public ▁void ▁close ▁( ▁) ▁{ ▁final ▁boolean ▁closed ▁= ▁streams ▁. ▁close ▁( ▁Duration ▁. ▁of Minutes ▁( ▁1 ▁) ▁) ▁; ▁if ▁( ▁closed ▁&& ▁! ▁un caught Exception ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁name ▁+ ▁STR ▁) ▁; ▁} ▁else ▁if ▁( ▁closed ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁name ▁+ ▁STR ▁) ▁; ▁} ▁else ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁name ▁+ ▁STR ▁) ▁; ▁} ▁} ▁private ▁Properties ▁get Streams Config ▁( ▁final ▁Properties ▁props ▁) ▁{ ▁final ▁Properties ▁full Props ▁= ▁new ▁Properties ▁( ▁props ▁) ▁; ▁full Props ▁. ▁put ▁( ▁StreamsConfig ▁. ▁APPLICATION _ ID _ CONFIG ▁, ▁STR ▁) ▁; ▁full Props ▁. ▁put ▁( ▁StreamsConfig ▁. ▁CLIENT _ ID _ CONFIG ▁, ▁STR ▁+ ▁name ▁) ▁; ▁full Props ▁. ▁put ▁( ▁StreamsConfig ▁. ▁STATE _ DIR _ CONFIG ▁, ▁tempDirectory ▁( ▁) ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁; ▁full Props ▁. ▁putAll ▁( ▁props ▁) ▁; ▁return ▁full Props ▁; ▁} ▁public ▁Topology ▁get Topology ▁( ▁) ▁{ ▁final ▁StreamsBuilder ▁builder ▁= ▁new ▁StreamsBuilder ▁( ▁) ▁; ▁final ▁Con sumed ▁< ▁String ▁, ▁Integer ▁> ▁string Int Consumed ▁= ▁Con sumed ▁. ▁with ▁( ▁string Serde ▁, ▁int Serde ▁) ▁; ▁final ▁KStream ▁< ▁String ▁, ▁Integer ▁> ▁source ▁= ▁builder ▁. ▁stream ▁( ▁STR ▁, ▁string Int Consumed ▁) ▁; ▁source ▁. ▁filter Not ▁( ▁( ▁k ▁, ▁v ▁) ▁-> ▁k ▁. ▁equals ▁( ▁STR ▁) ▁) ▁. ▁to ▁( ▁STR ▁, ▁Pro duced ▁. ▁with ▁( ▁string Serde ▁, ▁int Serde ▁) ▁) ▁; ▁final ▁KStream ▁< ▁String ▁, ▁Integer ▁> ▁data ▁= ▁source ▁. ▁filter ▁( ▁( ▁key ▁, ▁value ▁) ▁-> ▁value ▁== ▁null ▁|| ▁value ▁!= ▁END ▁) ▁; ▁data ▁. ▁process ▁( ▁S moke TestUtil ▁. ▁print Processor Supplier ▁( ▁STR ▁, ▁name ▁) ▁) ▁; ▁final ▁K Grouped Stream ▁< ▁String ▁, ▁Integer ▁> ▁group edData ▁= ▁data ▁. ▁groupBy Key ▁( ▁Grouped ▁. ▁with ▁( ▁string Serde ▁, ▁int Serde ▁) ▁) ▁;
▁public ▁class ▁Producer Operation Handler Interceptor ▁implements ▁InstanceMethods A roundInterceptor ▁{ ▁@ ▁Override ▁public ▁void ▁beforeMethod ▁( ▁En hancedInstance ▁objInst ▁, ▁Method ▁method ▁, ▁Object ▁[ ▁] ▁allArguments ▁, ▁Class ▁< ▁? ▁> ▁[ ▁] ▁argumentsTypes ▁, ▁Method InterceptResult ▁result ▁) ▁throws ▁Throwable ▁{ ▁Invocation ▁invocation ▁= ▁( ▁Invocation ▁) ▁allArguments ▁[ ▁0 ▁] ▁; ▁ContextCarrier ▁contextCarrier ▁= ▁new ▁ContextCarrier ▁( ▁) ▁; ▁C arrier Item ▁next ▁= ▁contextCarrier ▁. ▁items ▁( ▁) ▁; ▁while ▁( ▁next ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁next ▁= ▁next ▁. ▁next ▁( ▁) ▁; ▁next ▁. ▁set Head Value ▁( ▁invocation ▁. ▁getContext ▁( ▁) ▁. ▁get ▁( ▁next ▁. ▁getHead Key ▁( ▁) ▁) ▁) ▁; ▁} ▁String ▁operationName ▁= ▁invocation ▁. ▁getM ic ro service QualifiedName ▁( ▁) ▁; ▁AbstractSpan ▁span ▁= ▁ContextManager ▁. ▁create Entry Span ▁( ▁operationName ▁, ▁contextCarrier ▁) ▁; ▁String ▁url ▁= ▁invocation ▁. ▁getOperation Meta ▁( ▁) ▁. ▁getOperation Path ▁( ▁) ▁; ▁Tags ▁. ▁URL ▁. ▁set ▁( ▁span ▁, ▁url ▁) ▁; ▁span ▁. ▁setComponent ▁( ▁Components Define ▁. ▁SERVICE COM B ▁) ▁; ▁SpanLayer ▁. ▁as RPC Framework ▁( ▁span ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁afterMethod ▁( ▁En hancedInstance ▁objInst ▁, ▁Method ▁method ▁, ▁Object ▁[ ▁] ▁allArguments ▁, ▁Class ▁< ▁? ▁> ▁[ ▁] ▁argumentsTypes ▁, ▁Object ▁ret ▁) ▁throws ▁Throwable ▁{ ▁Invocation ▁invocation ▁= ▁( ▁Invocation ▁) ▁allArguments ▁[ ▁0 ▁] ▁; ▁AbstractSpan ▁span ▁= ▁ContextManager ▁. ▁activeSpan ▁( ▁) ▁; ▁int ▁statusCode ▁= ▁invocation ▁. ▁getStatus ▁( ▁) ▁. ▁getStatusCode ▁( ▁) ▁; ▁if ▁( ▁statusCode ▁>= ▁400 ▁) ▁{ ▁span ▁. ▁error Occurred ▁( ▁) ▁; ▁Tags ▁. ▁STATUS _ CODE ▁. ▁set ▁( ▁span ▁, ▁Integer ▁. ▁toString ▁( ▁statusCode ▁) ▁) ▁; ▁} ▁ContextManager ▁. ▁stopSpan ▁( ▁) ▁; ▁return ▁ret ▁; ▁} ▁@ ▁Override ▁public ▁void ▁handle MethodException ▁( ▁En hancedInstance ▁objInst ▁, ▁Method ▁method ▁, ▁Object ▁[ ▁] ▁allArguments ▁, ▁Class ▁< ▁? ▁> ▁[ ▁] ▁argumentsTypes ▁, ▁Throwable ▁t ▁) ▁{ ▁AbstractSpan ▁span ▁= ▁ContextManager ▁. ▁activeSpan ▁( ▁) ▁; ▁span ▁. ▁log ▁( ▁t ▁) ▁; ▁} ▁}
▁public ▁class ▁M ass ive StringValue Sort ing ▁{ ▁private ▁static ▁final ▁long ▁SE ED ▁= ▁34 7 56 9 78 46 59 2 78 34 6 L ▁; ▁public ▁void ▁test StringValue Sort ing ▁( ▁) ▁{ ▁File ▁input ▁= ▁null ▁; ▁File ▁sorted ▁= ▁null ▁; ▁try ▁{ ▁input ▁= ▁generate File With Strings ▁( ▁300000 ▁, ▁STR ▁) ▁; ▁sorted ▁= ▁File ▁. ▁createTempFile ▁( ▁STR ▁, ▁STR ▁) ▁; ▁String ▁[ ▁] ▁command ▁= ▁{ ▁STR ▁, ▁STR ▁, ▁STR ▁+ ▁input ▁. ▁getAbsolutePath ▁( ▁) ▁+ ▁STR ▁+ ▁sorted ▁. ▁getAbsolutePath ▁( ▁) ▁+ ▁STR ▁} ▁; ▁Process ▁p ▁= ▁null ▁; ▁try ▁{ ▁p ▁= ▁Runtime ▁. ▁getRuntime ▁( ▁) ▁. ▁exec ▁( ▁command ▁) ▁; ▁int ▁ret Code ▁= ▁p ▁. ▁waitFor ▁( ▁) ▁; ▁if ▁( ▁ret Code ▁!= ▁0 ▁) ▁{ ▁throw ▁new ▁Exception ▁( ▁STR ▁+ ▁ret Code ▁) ▁; ▁} ▁p ▁= ▁null ▁; ▁} ▁finally ▁{ ▁if ▁( ▁p ▁!= ▁null ▁) ▁{ ▁p ▁. ▁destroy ▁( ▁) ▁; ▁} ▁} ▁S orter ▁< ▁StringValue ▁> ▁s orter ▁= ▁null ▁; ▁BufferedReader ▁reader ▁= ▁null ▁; ▁BufferedReader ▁verify Reader ▁= ▁null ▁; ▁MemoryManager ▁mm ▁= ▁null ▁; ▁try ▁( ▁IO Manager ▁io Man ▁= ▁new ▁IO Manager Async ▁( ▁) ▁) ▁{ ▁mm ▁= ▁MemoryManager Builder ▁. ▁newBuilder ▁( ▁) ▁. ▁set MemorySize ▁( ▁1024 ▁ * ▁1024 ▁) ▁. ▁build ▁( ▁) ▁; ▁TypeSerializer ▁< ▁StringValue ▁> ▁serializer ▁= ▁new ▁Copy able Value Serializer ▁< ▁StringValue ▁> ▁( ▁StringValue ▁. ▁class ▁) ▁; ▁TypeComparator ▁< ▁StringValue ▁> ▁comparator ▁= ▁new ▁Copy able Value Comparator ▁< ▁StringValue ▁> ▁( ▁true ▁, ▁StringValue ▁. ▁class ▁) ▁; ▁reader ▁= ▁new ▁BufferedReader ▁( ▁new ▁FileReader ▁( ▁input ▁) ▁) ▁; ▁Mutable ObjectIterator ▁< ▁StringValue ▁> ▁input Iterator ▁= ▁new ▁StringValue Reader Mutable ObjectIterator ▁( ▁reader ▁) ▁; ▁s orter ▁= ▁External Sorter ▁. ▁newBuilder ▁( ▁mm ▁, ▁new ▁Dummy Invokable ▁( ▁) ▁, ▁serializer ▁, ▁comparator ▁) ▁. ▁maxNum File Handles ▁( ▁128 ▁) ▁. ▁enable Spill ing ▁( ▁io Man ▁, ▁0.8 f ▁) ▁. ▁memory Fraction ▁( ▁1.0 ▁) ▁. ▁object Reuse ▁( ▁true ▁) ▁. ▁l arge Records ▁( ▁true ▁) ▁. ▁build ▁( ▁input Iterator ▁) ▁; ▁Mutable ObjectIterator ▁< ▁StringValue ▁> ▁sorted Data ▁= ▁s orter ▁. ▁get Iterator ▁( ▁) ▁; ▁reader ▁. ▁close ▁( ▁) ▁; ▁verify Reader ▁= ▁new ▁BufferedReader ▁( ▁new ▁FileReader ▁( ▁sorted ▁) ▁) ▁; ▁String ▁next Verify ▁; ▁StringValue ▁next From Flink Sort ▁= ▁new ▁StringValue ▁( ▁) ▁; ▁while ▁( ▁( ▁next Verify ▁= ▁verify Reader ▁. ▁readLine ▁( ▁) ▁) ▁!= ▁null ▁) ▁{ ▁next From Flink Sort ▁= ▁sorted Data ▁. ▁next ▁( ▁next From Flink Sort ▁) ▁; ▁Assert ▁. ▁assertNotNull ▁( ▁next From Flink Sort ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁next Verify ▁, ▁next From Flink Sort ▁. ▁getValue ▁( ▁) ▁) ▁; ▁} ▁} ▁finally ▁{ ▁if ▁( ▁reader ▁!= ▁null ▁) ▁{ ▁reader ▁. ▁close ▁( ▁) ▁; ▁}
▁Keyed Stream ▁< ▁Tuple 2 ▁< ▁String ▁, ▁Integer ▁> ▁, ▁String ▁> ▁stream One ▁= ▁env ▁. ▁fromElements ▁( ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁0 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁1 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁2 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁3 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁4 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁5 ▁) ▁) ▁. ▁assign Timestamp sAnd Watermarks ▁( ▁new ▁Asc ending Tuple 2 Timestamp Extractor ▁( ▁) ▁) ▁. ▁key By ▁( ▁new ▁Tuple 2 Key Extractor ▁( ▁) ▁) ▁; ▁Keyed Stream ▁< ▁Tuple 2 ▁< ▁String ▁, ▁Integer ▁> ▁, ▁String ▁> ▁stream Two ▁= ▁env ▁. ▁fromElements ▁( ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁0 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁1 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁2 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁3 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁4 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁5 ▁) ▁) ▁. ▁assign Timestamp sAnd Watermarks ▁( ▁new ▁Asc ending Tuple 2 Timestamp Extractor ▁( ▁) ▁) ▁. ▁key By ▁( ▁new ▁Tuple 2 Key Extractor ▁( ▁) ▁) ▁; ▁stream One ▁. ▁interval Join ▁( ▁stream Two ▁) ▁. ▁between ▁( ▁Time ▁. ▁milliseconds ▁( ▁0 ▁) ▁, ▁Time ▁. ▁milliseconds ▁( ▁1 ▁) ▁) ▁. ▁process ▁( ▁new ▁Combine ToString Join Function ▁( ▁) ▁) ▁. ▁add Sink ▁( ▁new ▁Result Sink ▁( ▁) ▁) ▁; ▁env ▁. ▁execute ▁( ▁) ▁; ▁expect InAnyOrder ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Bounded Un ordered Streams St ill Join Correct ly ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁StreamExecution Environment ▁env ▁= ▁StreamExecution Environment ▁. ▁getExecution Environment ▁( ▁) ▁; ▁env ▁. ▁setParallelism ▁( ▁1 ▁) ▁; ▁DataStream ▁< ▁Tuple 2 ▁< ▁String ▁, ▁Integer ▁> ▁> ▁stream One ▁= ▁env ▁. ▁addSource ▁( ▁new ▁Source Function ▁< ▁Tuple 2 ▁< ▁String ▁, ▁Integer ▁> ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁run ▁( ▁Source Context ▁< ▁Tuple 2 ▁< ▁String ▁, ▁Integer ▁> ▁> ▁ctx ▁) ▁{ ▁ctx ▁. ▁collect With Timestamp ▁( ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁5 ▁) ▁, ▁5 L ▁) ▁; ▁ctx ▁. ▁collect With Timestamp ▁( ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁1 ▁) ▁, ▁1 L ▁) ▁; ▁ctx ▁. ▁collect With Timestamp ▁( ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁4 ▁) ▁, ▁4 L ▁) ▁; ▁ctx ▁. ▁collect With Timestamp ▁( ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁3 ▁) ▁, ▁3 L ▁) ▁; ▁ctx ▁. ▁collect With Timestamp ▁( ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁2 ▁) ▁, ▁2 L ▁) ▁; ▁ctx ▁. ▁emit Watermark ▁( ▁new ▁Watermark ▁( ▁5 ▁) ▁) ▁;
▁public ▁class ▁AV R 8_ x m eg a _ GC C _ O 3_ EmulatorTest ▁extends ▁Processor EmulatorTest Adapter ▁{ ▁private ▁static ▁final ▁String ▁LANGUAGE _ ID ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁COMP ILER _ SPEC _ ID ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁[ ▁] ▁REG _ DUMP _ SET ▁= ▁new ▁String ▁[ ▁] ▁{ ▁} ▁; ▁public ▁AV R 8_ x m eg a _ GC C _ O 3_ EmulatorTest ▁( ▁String ▁name ▁) ▁throws ▁Exception ▁{ ▁super ▁( ▁name ▁, ▁LANGUAGE _ ID ▁, ▁COMP ILER _ SPEC _ ID ▁, ▁REG _ DUMP _ SET ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁String ▁getProcessor Des ign ator ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁initialize State ▁( ▁E m ulator TestRunner ▁test Runner ▁, ▁Program ▁program ▁) ▁throws ▁Exception ▁{ ▁test Runner ▁. ▁set Register ▁( ▁STR ▁, ▁0 x 0 ▁) ▁; ▁test Runner ▁. ▁set Register ▁( ▁STR ▁, ▁0 x 0 ▁) ▁; ▁test Runner ▁. ▁set Register ▁( ▁STR ▁, ▁0 x 0 ▁) ▁; ▁test Runner ▁. ▁set Register ▁( ▁STR ▁, ▁0 x 0 ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁set Analysis Options ▁( ▁Options ▁analysis Options ▁) ▁{ ▁super ▁. ▁set Analysis Options ▁( ▁analysis Options ▁) ▁; ▁analysis Options ▁. ▁setBoolean ▁( ▁STR ▁, ▁false ▁) ▁; ▁analysis Options ▁. ▁setBoolean ▁( ▁STR ▁, ▁false ▁) ▁; ▁} ▁public ▁static ▁Test ▁suite ▁( ▁) ▁{ ▁return ▁Processor EmulatorTest Adapter ▁. ▁build Emulator TestSuite ▁( ▁AV R 8_ x m eg a _ GC C _ O 3_ EmulatorTest ▁. ▁class ▁) ▁; ▁} ▁}
▁public ▁class ▁Con sumed Internal ▁< ▁K ▁, ▁V ▁> ▁extends ▁Con sumed ▁< ▁K ▁, ▁V ▁> ▁{ ▁public ▁Con sumed Internal ▁( ▁final ▁Con sumed ▁< ▁K ▁, ▁V ▁> ▁consumed ▁) ▁{ ▁super ▁( ▁consumed ▁) ▁; ▁} ▁public ▁Con sumed Internal ▁( ▁final ▁Serde ▁< ▁K ▁> ▁keySerde ▁, ▁final ▁Serde ▁< ▁V ▁> ▁valueSerde ▁, ▁final ▁Timestamp Extractor ▁timestamp Extractor ▁, ▁final ▁Topology ▁. ▁Auto Offset Reset ▁offset Reset ▁) ▁{ ▁this ▁( ▁Con sumed ▁. ▁with ▁( ▁keySerde ▁, ▁valueSerde ▁, ▁timestamp Extractor ▁, ▁offset Reset ▁) ▁) ▁; ▁} ▁public ▁Con sumed Internal ▁( ▁) ▁{ ▁this ▁( ▁Con sumed ▁. ▁with ▁( ▁null ▁, ▁null ▁) ▁) ▁; ▁} ▁public ▁Serde ▁< ▁K ▁> ▁keySerde ▁( ▁) ▁{ ▁return ▁keySerde ▁; ▁} ▁public ▁Deserializer ▁< ▁K ▁> ▁key Deserializer ▁( ▁) ▁{ ▁return ▁keySerde ▁== ▁null ▁? ▁null ▁: ▁keySerde ▁. ▁deserializer ▁( ▁) ▁; ▁} ▁public ▁Serde ▁< ▁V ▁> ▁valueSerde ▁( ▁) ▁{ ▁return ▁valueSerde ▁; ▁} ▁public ▁Deserializer ▁< ▁V ▁> ▁value Deserializer ▁( ▁) ▁{ ▁return ▁valueSerde ▁== ▁null ▁? ▁null ▁: ▁valueSerde ▁. ▁deserializer ▁( ▁) ▁; ▁} ▁public ▁Timestamp Extractor ▁timestamp Extractor ▁( ▁) ▁{ ▁return ▁timestamp Extractor ▁; ▁} ▁public ▁Topology ▁. ▁Auto Offset Reset ▁offset Reset Policy ▁( ▁) ▁{ ▁return ▁reset Policy ▁; ▁} ▁public ▁String ▁name ▁( ▁) ▁{ ▁return ▁processor Name ▁; ▁} ▁}
▁class ▁Core Library Support ▁{ ▁private ▁static ▁final ▁Object ▁[ ▁] ▁EMPTY _ FRAME ▁= ▁new ▁Object ▁[ ▁0 ▁] ▁; ▁private ▁static ▁final ▁String ▁[ ▁] ▁EMPTY _ LIST ▁= ▁new ▁String ▁[ ▁0 ▁] ▁; ▁private ▁final ▁Core Library Rewriter ▁rew riter ▁; ▁private ▁final ▁ClassLoader ▁target Loader ▁; ▁private ▁final ▁ImmutableSet ▁< ▁String ▁> ▁r en amed Prefixes ▁; ▁private ▁final ▁ImmutableSet ▁< ▁String ▁> ▁exclude From Em ulation ▁; ▁private ▁final ▁ImmutableSet ▁< ▁Class ▁< ▁? ▁> ▁> ▁emulated Interfaces ▁; ▁private ▁final ▁Class Member Ret arget Config ▁ret arget Config ▁; ▁private ▁final ▁Re m apper ▁core Package Rem apper ▁= ▁new ▁Re m apper ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁String ▁map ▁( ▁String ▁typeName ▁) ▁{ ▁return ▁is Ren amed Core Library ▁( ▁typeName ▁) ▁? ▁rename Core Library ▁( ▁typeName ▁) ▁: ▁typeName ▁; ▁} ▁} ▁; ▁private ▁final ▁Multimap ▁< ▁String ▁, ▁E m ulated Method ▁> ▁emulated Default Methods ▁= ▁Linked Hash Multimap ▁. ▁create ▁( ▁) ▁; ▁private ▁final ▁Set ▁< ▁String ▁> ▁used Runtime Helpers ▁= ▁new ▁LinkedHashSet ▁< ▁> ▁( ▁) ▁; ▁public ▁Core Library Support ▁( ▁Core Library Rewriter ▁rew riter ▁, ▁ClassLoader ▁target Loader ▁, ▁List ▁< ▁String ▁> ▁r en amed Prefixes ▁, ▁List ▁< ▁String ▁> ▁emulated Interfaces ▁, ▁List ▁< ▁String ▁> ▁exclude From Em ulation ▁, ▁Class Member Ret arget Config ▁ret arget Config ▁) ▁{ ▁this ▁. ▁rew riter ▁= ▁rew riter ▁; ▁this ▁. ▁target Loader ▁= ▁target Loader ▁; ▁this ▁. ▁ret arget Config ▁= ▁ret arget Config ▁; ▁checkArgument ▁( ▁r en amed Prefixes ▁. ▁stream ▁( ▁) ▁. ▁allMatch ▁( ▁prefix ▁-> ▁prefix ▁. ▁startsWith ▁( ▁STR ▁) ▁|| ▁prefix ▁. ▁startsWith ▁( ▁STR ▁) ▁|| ▁prefix ▁. ▁startsWith ▁( ▁STR ▁) ▁|| ▁prefix ▁. ▁startsWith ▁( ▁STR ▁) ▁) ▁, ▁STR ▁, ▁r en amed Prefixes ▁) ▁; ▁this ▁. ▁r en amed Prefixes ▁= ▁ImmutableSet ▁. ▁copyOf ▁( ▁r en amed Prefixes ▁) ▁; ▁this ▁. ▁exclude From Em ulation ▁= ▁ImmutableSet ▁. ▁copyOf ▁( ▁exclude From Em ulation ▁) ▁; ▁ImmutableSet ▁. ▁Builder ▁< ▁Class ▁< ▁? ▁> ▁> ▁class Builder ▁= ▁ImmutableSet ▁. ▁builder ▁( ▁) ▁; ▁for ▁( ▁String ▁it f ▁: ▁emulated Interfaces ▁) ▁{ ▁checkArgument ▁( ▁it f ▁. ▁startsWith ▁( ▁STR ▁) ▁, ▁it f ▁) ▁; ▁Class ▁< ▁? ▁> ▁clazz ▁= ▁loadFrom Internal ▁( ▁rew riter ▁. ▁getPrefix ▁( ▁) ▁+ ▁it f ▁) ▁; ▁checkArgument ▁( ▁clazz ▁. ▁isInterface ▁( ▁) ▁, ▁it f ▁) ▁; ▁class Builder ▁. ▁add ▁( ▁clazz ▁) ▁; ▁} ▁this ▁. ▁emulated Interfaces ▁= ▁class Builder ▁. ▁build ▁( ▁) ▁; ▁} ▁public ▁boolean ▁is Ren amed Core Library ▁( ▁String ▁internal Name ▁) ▁{ ▁String ▁un pre fix ed Name ▁= ▁rew riter ▁. ▁un pre fix ▁( ▁internal Name ▁) ▁;
▁public ▁abstract ▁class ▁Abstract Client ThreadExecutor ▁extends ▁Abstract ExecutorService ▁{ ▁private ▁static ▁final ▁int ▁DEFAULT _ PRIORITY ▁= ▁10 ▁; ▁protected ▁Debug Client ▁client ▁; ▁protected ▁boolean ▁shut ting Down ▁= ▁false ▁; ▁protected ▁final ▁Queue ▁< ▁Entry ▁> ▁queue ▁= ▁new ▁PriorityQueue ▁< ▁> ▁( ▁) ▁; ▁protected ▁Thread ▁thread ▁= ▁new ▁Thread ▁( ▁this ▁:: ▁run ▁, ▁STR ▁) ▁; ▁protected ▁final ▁AtomicBoolean ▁wait Registered ▁= ▁new ▁AtomicBoolean ▁( ▁) ▁; ▁protected ▁abstract ▁void ▁init ▁( ▁) ▁; ▁public ▁static ▁class ▁Entry ▁implements ▁Comparable ▁< ▁Entry ▁> ▁{ ▁final ▁int ▁priority ▁; ▁public ▁final ▁Runnable ▁command ▁; ▁public ▁Entry ▁( ▁int ▁priority ▁, ▁Runnable ▁command ▁) ▁{ ▁this ▁. ▁priority ▁= ▁priority ▁; ▁this ▁. ▁command ▁= ▁command ▁; ▁} ▁@ ▁Override ▁public ▁int ▁compareTo ▁( ▁Entry ▁that ▁) ▁{ ▁return ▁Integer ▁. ▁compare ▁( ▁this ▁. ▁priority ▁, ▁that ▁. ▁priority ▁) ▁; ▁} ▁} ▁public ▁Debug Client ▁getClient ▁( ▁) ▁{ ▁if ▁( ▁thread ▁!= ▁Thread ▁. ▁currentThread ▁( ▁) ▁) ▁{ ▁} ▁return ▁client ▁; ▁} ▁public ▁void ▁cancel Wait ▁( ▁) ▁{ ▁wait Registered ▁. ▁set ▁( ▁false ▁) ▁; ▁} ▁public ▁void ▁register Wait ▁( ▁) ▁{ ▁wait Registered ▁. ▁set ▁( ▁true ▁) ▁; ▁} ▁private ▁Entry ▁poll Queue ▁( ▁) ▁{ ▁synchronized ▁( ▁queue ▁) ▁{ ▁return ▁queue ▁. ▁poll ▁( ▁) ▁; ▁} ▁} ▁private ▁void ▁run ▁( ▁) ▁{ ▁try ▁{ ▁init ▁( ▁) ▁; ▁while ▁( ▁! ▁shut ting Down ▁) ▁{ ▁Entry ▁next ▁; ▁while ▁( ▁null ▁!= ▁( ▁next ▁= ▁poll Queue ▁( ▁) ▁) ▁) ▁{ ▁if ▁( ▁shut ting Down ▁) ▁{ ▁return ▁; ▁} ▁try ▁{ ▁next ▁. ▁command ▁. ▁run ▁( ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁Msg ▁. ▁error ▁( ▁this ▁, ▁STR ▁+ ▁t ▁) ▁; ▁} ▁} ▁Debug Status ▁status ▁= ▁client ▁. ▁getControl ▁( ▁) ▁. ▁getExecution Status ▁( ▁) ▁; ▁if ▁( ▁status ▁. ▁should Wait ▁&& ▁status ▁!= ▁Debug Status ▁. ▁NO _ DEBUG GE E ▁|| ▁wait Registered ▁. ▁get ▁( ▁) ▁) ▁{ ▁wait Registered ▁. ▁set ▁( ▁false ▁) ▁; ▁try ▁{ ▁getManager ▁( ▁) ▁. ▁waitFor Event Ex ▁( ▁) ▁; ▁} ▁catch ▁( ▁COM Exception ▁e ▁) ▁{ ▁Msg ▁. ▁error ▁( ▁this ▁, ▁STR ▁+ ▁e ▁) ▁; ▁} ▁} ▁else ▁{ ▁try ▁{ ▁client ▁. ▁dispatch Callbacks ▁( ▁100 ▁) ▁; ▁} ▁catch ▁( ▁COM Exception ▁e ▁) ▁{ ▁Msg ▁. ▁error ▁( ▁this ▁, ▁STR ▁+ ▁e ▁) ▁; ▁} ▁} ▁} ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁Msg ▁. ▁error ▁( ▁this ▁, ▁STR ▁, ▁t ▁) ▁; ▁shut ting Down ▁= ▁true ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁shutdown ▁( ▁) ▁{ ▁shut ting Down ▁= ▁true ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁Runnable ▁> ▁shutdownNow ▁( ▁) ▁{ ▁shut ting Down ▁= ▁true ▁; ▁client ▁. ▁exit Dispatch ▁( ▁) ▁; ▁thread ▁. ▁interrupt ▁( ▁) ▁; ▁List ▁< ▁Runnable ▁> ▁left ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁queue ▁. ▁size ▁( ▁) ▁) ▁;
▁public ▁class ▁MR App Benchmark ▁{ ▁private ▁static ▁final ▁Record Factory ▁record Factory ▁= ▁Record FactoryProvider ▁. ▁getRecord Factory ▁( ▁null ▁) ▁; ▁public ▁void ▁run ▁( ▁MR App ▁app ▁) ▁throws ▁Exception ▁{ ▁Generic TestUtils ▁. ▁set Root LogLevel ▁( ▁Level ▁. ▁WARN ▁) ▁; ▁long ▁startTime ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁; ▁Job ▁job ▁= ▁app ▁. ▁submit ▁( ▁new ▁Configuration ▁( ▁) ▁) ▁; ▁while ▁( ▁! ▁job ▁. ▁getRe port ▁( ▁) ▁. ▁getJob State ▁( ▁) ▁. ▁equals ▁( ▁Job State ▁. ▁SU C CEEDED ▁) ▁) ▁{ ▁print Stat ▁( ▁job ▁, ▁startTime ▁) ▁; ▁Thread ▁. ▁sleep ▁( ▁2000 ▁) ▁; ▁} ▁print Stat ▁( ▁job ▁, ▁startTime ▁) ▁; ▁} ▁private ▁void ▁print Stat ▁( ▁Job ▁job ▁, ▁long ▁startTime ▁) ▁throws ▁Exception ▁{ ▁long ▁currentTime ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁; ▁Runtime ▁. ▁getRuntime ▁( ▁) ▁. ▁gc ▁( ▁) ▁; ▁long ▁mem ▁= ▁Runtime ▁. ▁getRuntime ▁( ▁) ▁. ▁total Memory ▁( ▁) ▁- ▁Runtime ▁. ▁getRuntime ▁( ▁) ▁. ▁free Memory ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁job ▁. ▁getState ▁( ▁) ▁+ ▁STR ▁+ ▁job ▁. ▁get Completed Maps ▁( ▁) ▁+ ▁STR ▁+ ▁job ▁. ▁get Completed Reduce s ▁( ▁) ▁+ ▁STR ▁+ ▁mem ▁ / ▁1024 ▁+ ▁STR ▁+ ▁( ▁currentTime ▁- ▁startTime ▁) ▁) ▁; ▁} ▁static ▁class ▁Th ro tt led MR App ▁extends ▁MR App ▁{ ▁int ▁max Concurrent Running Tasks ▁; ▁volatile ▁int ▁concurrent Running Tasks ▁; ▁Th ro tt led MR App ▁( ▁int ▁map s ▁, ▁int ▁reduce s ▁, ▁int ▁max Concurrent Running Tasks ▁) ▁{ ▁super ▁( ▁map s ▁, ▁reduce s ▁, ▁true ▁, ▁STR ▁, ▁true ▁) ▁; ▁this ▁. ▁max Concurrent Running Tasks ▁= ▁max Concurrent Running Tasks ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁attempt L aun ched ▁( ▁TaskAttemptId ▁attempt ID ▁) ▁{ ▁super ▁. ▁attempt L aun ched ▁( ▁attempt ID ▁) ▁; ▁concurrent Running Tasks ▁-- ▁; ▁} ▁@ ▁Override ▁protected ▁Container Allocator ▁create Container Allocator ▁( ▁Client Service ▁client Service ▁, ▁App Context ▁context ▁) ▁{ ▁return ▁new ▁Th ro tt led Container Allocator ▁( ▁) ▁; ▁} ▁class ▁Th ro tt led Container Allocator ▁extends ▁Abstract Service ▁implements ▁Container Allocator ▁, ▁RM Heartbeat Handler ▁{ ▁private ▁int ▁container Count ▁; ▁private ▁Thread ▁thread ▁; ▁private ▁BlockingQueue ▁< ▁Container Allocator Event ▁> ▁event Queue ▁= ▁new ▁Linked BlockingQueue ▁< ▁Container Allocator Event ▁> ▁( ▁) ▁; ▁public ▁Th ro tt led Container Allocator ▁( ▁) ▁{ ▁super ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁handle ▁( ▁Container Allocator Event ▁event ▁) ▁{ ▁try ▁{ ▁event Queue ▁. ▁put ▁( ▁event ▁) ▁; ▁} ▁catch ▁( ▁Interrupted Exception ▁e ▁) ▁{ ▁throw ▁new ▁Yarn RuntimeException ▁( ▁e ▁) ▁; ▁} ▁}
▁synchronized ▁( ▁this ▁) ▁{ ▁sub scriptions ▁= ▁sub scriptions By EventType ▁. ▁get ▁( ▁clazz ▁) ▁; ▁} ▁if ▁( ▁sub scriptions ▁!= ▁null ▁&& ▁! ▁sub scriptions ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁} ▁return ▁false ▁; ▁} ▁private ▁void ▁post Single Event ▁( ▁Object ▁event ▁, ▁Post ing Thread State ▁post ing State ▁) ▁throws ▁Error ▁{ ▁Class ▁< ▁? ▁> ▁event Class ▁= ▁event ▁. ▁getClass ▁( ▁) ▁; ▁boolean ▁subscription Found ▁= ▁false ▁; ▁if ▁( ▁event In herit ance ▁) ▁{ ▁List ▁< ▁Class ▁< ▁? ▁> ▁> ▁event Types ▁= ▁lookup All Event Types ▁( ▁event Class ▁) ▁; ▁int ▁count Types ▁= ▁event Types ▁. ▁size ▁( ▁) ▁; ▁for ▁( ▁int ▁h ▁= ▁0 ▁; ▁h ▁< ▁count Types ▁; ▁h ▁++ ▁) ▁{ ▁Class ▁< ▁? ▁> ▁clazz ▁= ▁event Types ▁. ▁get ▁( ▁h ▁) ▁; ▁subscription Found ▁|= ▁post Single Event For EventType ▁( ▁event ▁, ▁post ing State ▁, ▁clazz ▁) ▁; ▁} ▁} ▁else ▁{ ▁subscription Found ▁= ▁post Single Event For EventType ▁( ▁event ▁, ▁post ing State ▁, ▁event Class ▁) ▁; ▁} ▁if ▁( ▁! ▁subscription Found ▁) ▁{ ▁if ▁( ▁log No Subscriber Messages ▁) ▁{ ▁logger ▁. ▁log ▁( ▁Level ▁. ▁FINE ▁, ▁STR ▁+ ▁event Class ▁) ▁; ▁} ▁if ▁( ▁send No Subscriber Event ▁&& ▁event Class ▁!= ▁No Subscriber Event ▁. ▁class ▁&& ▁event Class ▁!= ▁Subscriber Exception Event ▁. ▁class ▁) ▁{ ▁post ▁( ▁new ▁No Subscriber Event ▁( ▁this ▁, ▁event ▁) ▁) ▁; ▁} ▁} ▁} ▁private ▁boolean ▁post Single Event For EventType ▁( ▁Object ▁event ▁, ▁Post ing Thread State ▁post ing State ▁, ▁Class ▁< ▁? ▁> ▁event Class ▁) ▁{ ▁CopyOnWrite ArrayList ▁< ▁Subscription ▁> ▁sub scriptions ▁; ▁synchronized ▁( ▁this ▁) ▁{ ▁sub scriptions ▁= ▁sub scriptions By EventType ▁. ▁get ▁( ▁event Class ▁) ▁; ▁} ▁if ▁( ▁sub scriptions ▁!= ▁null ▁&& ▁! ▁sub scriptions ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁for ▁( ▁Subscription ▁subscription ▁: ▁sub scriptions ▁) ▁{ ▁post ing State ▁. ▁event ▁= ▁event ▁; ▁post ing State ▁. ▁subscription ▁= ▁subscription ▁; ▁boolean ▁ab orted ▁; ▁try ▁{ ▁post To Subscription ▁( ▁subscription ▁, ▁event ▁, ▁post ing State ▁. ▁is MainThread ▁) ▁; ▁ab orted ▁= ▁post ing State ▁. ▁c anceled ▁; ▁} ▁finally ▁{ ▁post ing State ▁. ▁event ▁= ▁null ▁; ▁post ing State ▁. ▁subscription ▁= ▁null ▁; ▁post ing State ▁. ▁c anceled ▁= ▁false ▁; ▁} ▁if ▁( ▁ab orted ▁) ▁{ ▁break ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁private ▁void ▁post To Subscription ▁( ▁Subscription ▁subscription ▁, ▁Object ▁event ▁, ▁boolean ▁is MainThread ▁) ▁{ ▁switch ▁( ▁subscription ▁. ▁subscriber Method ▁. ▁thread Mode ▁) ▁{ ▁case ▁POST ING ▁: ▁invoke Subscriber ▁( ▁subscription ▁, ▁event ▁) ▁; ▁break ▁; ▁case ▁M AIN ▁: ▁if ▁( ▁is MainThread ▁) ▁{ ▁invoke Subscriber ▁( ▁subscription ▁, ▁event ▁) ▁; ▁}
▁class ▁F act orial ▁{ ▁static ▁List ▁< ▁BigInteger ▁> ▁a ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁public ▁F act orial ▁( ▁) ▁{ ▁if ▁( ▁a ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁a ▁. ▁add ▁( ▁BigInteger ▁. ▁ONE ▁) ▁; ▁a ▁. ▁add ▁( ▁BigInteger ▁. ▁ONE ▁) ▁; ▁} ▁} ▁public ▁BigInteger ▁at ▁( ▁int ▁n ▁) ▁{ ▁while ▁( ▁a ▁. ▁size ▁( ▁) ▁<= ▁n ▁) ▁{ ▁final ▁int ▁last n ▁= ▁a ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁final ▁BigInteger ▁next n ▁= ▁BigInteger ▁. ▁valueOf ▁( ▁last n ▁+ ▁1 ▁) ▁; ▁a ▁. ▁add ▁( ▁a ▁. ▁get ▁( ▁last n ▁) ▁. ▁multiply ▁( ▁next n ▁) ▁) ▁; ▁} ▁return ▁a ▁. ▁get ▁( ▁n ▁) ▁; ▁} ▁}
▁else ▁{ ▁final ▁Entry ▁matching Response ▁= ▁matches ▁. ▁get ▁( ▁elem ▁. ▁id ▁) ▁; ▁if ▁( ▁matching Response ▁== ▁null ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁elem ▁) ▁; ▁} ▁entries ▁[ ▁i ▁] ▁= ▁new ▁Entry ▁( ▁elem ▁, ▁matching Response ▁, ▁matching Response ▁. ▁id ▁) ▁; ▁} ▁} ▁if ▁( ▁next Internal Id ▁!= ▁- ▁1 ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁Entry ▁first ▁= ▁new ▁Entry ▁( ▁null ▁, ▁null ▁, ▁- ▁1 ▁) ▁; ▁Entry ▁last Entry ▁= ▁first ▁; ▁for ▁( ▁Entry ▁entry ▁: ▁entries ▁) ▁{ ▁last Entry ▁. ▁next ▁= ▁entry ▁; ▁entry ▁. ▁prev ▁= ▁last Entry ▁; ▁last Entry ▁= ▁entry ▁; ▁} ▁return ▁first ▁; ▁} ▁public ▁enum ▁EventType ▁{ ▁IN VO CATION ▁, ▁RESPONSE ▁} ▁public ▁static ▁class ▁Event ▁{ ▁public ▁final ▁EventType ▁type ▁; ▁public ▁final ▁Object ▁value ▁; ▁public ▁final ▁int ▁id ▁; ▁public ▁Event ▁( ▁EventType ▁type ▁, ▁Object ▁value ▁, ▁int ▁id ▁) ▁{ ▁this ▁. ▁type ▁= ▁type ▁; ▁this ▁. ▁value ▁= ▁value ▁; ▁this ▁. ▁id ▁= ▁id ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁STR ▁+ ▁type ▁+ ▁STR ▁+ ▁value ▁+ ▁STR ▁+ ▁id ▁+ ▁CHAR ▁; ▁} ▁} ▁static ▁class ▁Entry ▁{ ▁final ▁Event ▁event ▁; ▁final ▁Entry ▁match ▁; ▁final ▁int ▁id ▁; ▁Entry ▁prev ▁; ▁Entry ▁next ▁; ▁Entry ▁( ▁Event ▁event ▁, ▁Entry ▁match ▁, ▁int ▁id ▁) ▁{ ▁this ▁. ▁event ▁= ▁event ▁; ▁this ▁. ▁match ▁= ▁match ▁; ▁this ▁. ▁id ▁= ▁id ▁; ▁} ▁void ▁l ift ▁( ▁) ▁{ ▁prev ▁. ▁next ▁= ▁next ▁; ▁next ▁. ▁prev ▁= ▁prev ▁; ▁match ▁. ▁prev ▁. ▁next ▁= ▁match ▁. ▁next ▁; ▁if ▁( ▁match ▁. ▁next ▁!= ▁null ▁) ▁{ ▁match ▁. ▁next ▁. ▁prev ▁= ▁match ▁. ▁prev ▁; ▁} ▁} ▁void ▁un l ift ▁( ▁) ▁{ ▁match ▁. ▁prev ▁. ▁next ▁= ▁match ▁; ▁if ▁( ▁match ▁. ▁next ▁!= ▁null ▁) ▁{ ▁match ▁. ▁next ▁. ▁prev ▁= ▁match ▁; ▁} ▁prev ▁. ▁next ▁= ▁this ▁; ▁next ▁. ▁prev ▁= ▁this ▁; ▁} ▁} ▁private ▁static ▁class ▁Cache ▁{ ▁private ▁final ▁Map ▁< ▁Object ▁, ▁Set ▁< ▁Fixed BitSet ▁> ▁> ▁l arge Map ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁private ▁final ▁Long Object HashMap ▁< ▁Set ▁< ▁Object ▁> ▁> ▁small Map ▁= ▁new ▁Long Object HashMap ▁< ▁> ▁( ▁) ▁; ▁private ▁final ▁Map ▁< ▁Object ▁, ▁Object ▁> ▁internal ize State Map ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁private ▁final ▁Map ▁< ▁Set ▁< ▁Object ▁> ▁, ▁Set ▁< ▁Object ▁> ▁> ▁state Perm ut ations ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁public ▁boolean ▁add ▁( ▁Object ▁state ▁, ▁Fixed BitSet ▁bitSet ▁) ▁{ ▁return ▁add Internal ▁( ▁internal ize State Map ▁. ▁computeIfAbsent ▁( ▁state ▁, ▁k ▁-> ▁state ▁) ▁, ▁bitSet ▁) ▁; ▁}
▁class ▁Workspace Panel ▁extends ▁JPanel ▁implements ▁Workspace ChangeListener ▁{ ▁private ▁final ▁static ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁private ▁final ▁static ▁String ▁RUNNING _ TO OL S _ TITLE ▁= ▁STR ▁; ▁private ▁final ▁static ▁Border ▁ACTIVE _ WORK SPACE _ B ORDER ▁= ▁BorderFactory ▁. ▁create T it led Border ▁( ▁RUNNING _ TO OL S _ TITLE ▁) ▁; ▁private ▁final ▁static ▁String ▁NO _ ACTIVE _ WORK SPACE ▁= ▁STR ▁; ▁private ▁final ▁static ▁Border ▁IN ACTIVE _ B ORDER ▁= ▁BorderFactory ▁. ▁create T it led Border ▁( ▁RUNNING _ TO OL S _ TITLE ▁+ ▁STR ▁+ ▁NO _ ACTIVE _ WORK SPACE ▁) ▁; ▁final ▁static ▁int ▁TY P ICAL _ NUM _ R UNNING _ TO OL S ▁= ▁3 ▁; ▁private ▁J ComboBox ▁< ▁String ▁> ▁workspace Chooser ▁; ▁private ▁Default ComboBox Model ▁< ▁String ▁> ▁workspace Model ▁; ▁private ▁Card Layout ▁workspace Manager ▁; ▁private ▁JPanel ▁in active Panel ▁; ▁private ▁JPanel ▁running Tools Card Panel ▁; ▁private ▁HashMap ▁< ▁String ▁, ▁Runn ing Tools Panel ▁> ▁running Tools Map ▁; ▁private ▁Workspace ▁active Workspace ▁; ▁private ▁Front End Plugin ▁plugin ▁; ▁private ▁Project ▁active Project ▁; ▁private ▁boolean ▁value Is Adj ust ing ▁; ▁Workspace Panel ▁( ▁Front End Plugin ▁plugin ▁) ▁{ ▁super ▁( ▁new ▁BorderLayout ▁( ▁0 ▁, ▁0 ▁) ▁) ▁; ▁this ▁. ▁plugin ▁= ▁plugin ▁; ▁workspace Manager ▁= ▁new ▁Card Layout ▁( ▁) ▁; ▁running Tools Card Panel ▁= ▁new ▁JPanel ▁( ▁workspace Manager ▁) ▁; ▁running Tools Map ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁TY P ICAL _ NUM _ R UNNING _ TO OL S ▁) ▁; ▁workspace Model ▁= ▁new ▁Default ComboBox Model ▁< ▁> ▁( ▁) ▁; ▁workspace Chooser ▁= ▁new ▁G ComboBox ▁< ▁> ▁( ▁workspace Model ▁) ▁; ▁workspace Chooser ▁. ▁addItem Listener ▁( ▁e ▁-> ▁{ ▁if ▁( ▁e ▁. ▁getState Change ▁( ▁) ▁== ▁Item Event ▁. ▁SE LE CTED ▁) ▁{ ▁choose Workspace ▁( ▁( ▁String ▁) ▁workspace Model ▁. ▁getSelected Item ▁( ▁) ▁) ▁; ▁} ▁} ▁) ▁; ▁workspace Chooser ▁. ▁set Preferred Size ▁( ▁new ▁Dimension ▁( ▁200 ▁, ▁( ▁int ▁) ▁workspace Chooser ▁. ▁getPreferred Size ▁( ▁) ▁. ▁getHeight ▁( ▁) ▁) ▁) ▁; ▁setHelpLocation ▁( ▁) ▁; ▁JPanel ▁wc Panel ▁= ▁new ▁JPanel ▁( ▁) ▁; ▁wc Panel ▁. ▁add ▁( ▁workspace Chooser ▁) ▁; ▁add ▁( ▁wc Panel ▁, ▁BorderLayout ▁. ▁E AST ▁) ▁; ▁add ▁( ▁running Tools Card Panel ▁, ▁BorderLayout ▁. ▁CENTER ▁) ▁; ▁setBorder ▁( ▁IN ACTIVE _ B ORDER ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁tool Removed ▁( ▁Workspace ▁ws ▁, ▁PluginTool ▁tool ▁) ▁{ ▁remove Tool ▁( ▁ws ▁. ▁getName ▁( ▁) ▁, ▁tool ▁) ▁; ▁plugin ▁. ▁getTool Action Manager ▁( ▁) ▁. ▁enable Connect Tools ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁tool Added ▁( ▁Workspace ▁ws ▁, ▁PluginTool ▁tool ▁) ▁{ ▁add Tool ▁( ▁ws ▁. ▁getName ▁( ▁) ▁, ▁tool ▁) ▁; ▁plugin ▁. ▁getTool Action Manager ▁( ▁) ▁. ▁enable Connect Tools ▁( ▁) ▁;
▁frame ▁. ▁release ▁( ▁) ▁; ▁assertNull ▁( ▁channel ▁. ▁readInbound ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Single Frame Chunk ed ▁( ▁) ▁{ ▁EmbeddedChannel ▁channel ▁= ▁new ▁EmbeddedChannel ▁( ▁new ▁Stomp Subframe Decoder ▁( ▁10000 ▁, ▁5 ▁) ▁, ▁new ▁Stomp Subframe Aggregator ▁( ▁100000 ▁) ▁) ▁; ▁ByteBuf ▁in coming ▁= ▁Unpooled ▁. ▁buffer ▁( ▁) ▁; ▁in coming ▁. ▁writeBytes ▁( ▁Stomp Test Constants ▁. ▁S END _ FRAME _2 ▁. ▁getBytes ▁( ▁) ▁) ▁; ▁channel ▁. ▁writeInbound ▁( ▁in coming ▁) ▁; ▁Stomp Frame ▁frame ▁= ▁channel ▁. ▁readInbound ▁( ▁) ▁; ▁assertNotNull ▁( ▁frame ▁) ▁; ▁assertEquals ▁( ▁Stomp Command ▁. ▁S END ▁, ▁frame ▁. ▁command ▁( ▁) ▁) ▁; ▁frame ▁. ▁release ▁( ▁) ▁; ▁assertNull ▁( ▁channel ▁. ▁readInbound ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Multiple Frames Decoding ▁( ▁) ▁{ ▁ByteBuf ▁in coming ▁= ▁Unpooled ▁. ▁buffer ▁( ▁) ▁; ▁in coming ▁. ▁writeBytes ▁( ▁Stomp Test Constants ▁. ▁CONNECT _ FRAME ▁. ▁getBytes ▁( ▁) ▁) ▁; ▁in coming ▁. ▁writeBytes ▁( ▁Stomp Test Constants ▁. ▁CONNE CTED _ FRAME ▁. ▁getBytes ▁( ▁) ▁) ▁; ▁channel ▁. ▁writeInbound ▁( ▁in coming ▁) ▁; ▁channel ▁. ▁writeInbound ▁( ▁Unpooled ▁. ▁wrappedBuffer ▁( ▁Stomp Test Constants ▁. ▁S END _ FRAME _1 ▁. ▁getBytes ▁( ▁) ▁) ▁) ▁; ▁Stomp Frame ▁frame ▁= ▁channel ▁. ▁readInbound ▁( ▁) ▁; ▁assertEquals ▁( ▁Stomp Command ▁. ▁CONNECT ▁, ▁frame ▁. ▁command ▁( ▁) ▁) ▁; ▁frame ▁. ▁release ▁( ▁) ▁; ▁frame ▁= ▁channel ▁. ▁readInbound ▁( ▁) ▁; ▁assertEquals ▁( ▁Stomp Command ▁. ▁CONNE CTED ▁, ▁frame ▁. ▁command ▁( ▁) ▁) ▁; ▁frame ▁. ▁release ▁( ▁) ▁; ▁frame ▁= ▁channel ▁. ▁readInbound ▁( ▁) ▁; ▁assertEquals ▁( ▁Stomp Command ▁. ▁S END ▁, ▁frame ▁. ▁command ▁( ▁) ▁) ▁; ▁frame ▁. ▁release ▁( ▁) ▁; ▁assertNull ▁( ▁channel ▁. ▁readInbound ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Too Long Frame Exception ▁( ▁) ▁{ ▁final ▁EmbeddedChannel ▁channel ▁= ▁new ▁EmbeddedChannel ▁( ▁new ▁Stomp Subframe Decoder ▁( ▁) ▁, ▁new ▁Stomp Subframe Aggregator ▁( ▁10 ▁) ▁) ▁; ▁assertThrows ▁( ▁T oo Long Frame Exception ▁. ▁class ▁, ▁new ▁Executable ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁) ▁{ ▁channel ▁. ▁writeInbound ▁( ▁Unpooled ▁. ▁wrappedBuffer ▁( ▁Stomp Test Constants ▁. ▁S END _ FRAME _1 ▁. ▁getBytes ▁( ▁) ▁) ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁}
▁store s ales Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData Double ▁( ▁0.00 D ▁, ▁1 74 9 . 87 D ▁, ▁7 84 53 L ▁, ▁13 04 10 L ▁) ▁) ▁; ▁store s ales Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData Long ▁( ▁1 L ▁, ▁7 200 L ▁, ▁7 20 7 L ▁, ▁12 9 84 7 L ▁) ▁) ▁; ▁store s ales Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData Double ▁( ▁1. 12 D ▁, ▁1 99 84 . 00 D ▁, ▁5 76 6 50 L ▁, ▁12 99 33 L ▁) ▁) ▁; ▁final ▁Catalog Column Statistics ▁store s ales Catalog Column Statistics ▁= ▁new ▁Catalog Column Statistics ▁( ▁store s ales Column StatisticsData ▁) ▁; ▁final ▁CatalogTable Statistics ▁store s ales Catalog Table Statistics ▁= ▁new ▁CatalogTable Statistics ▁( ▁28 80 40 4 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁final ▁CatalogTable Stats ▁store s ales Catalog Table Stats ▁= ▁new ▁CatalogTable Stats ▁( ▁store s ales Catalog Table Statistics ▁, ▁store s ales Catalog Column Statistics ▁) ▁; ▁catalog Table Stats Map ▁. ▁put ▁( ▁STR ▁, ▁store s ales Catalog Table Stats ▁) ▁; ▁final ▁Map ▁< ▁String ▁, ▁Catalog Column StatisticsData Base ▁> ▁st orer et urn s Column StatisticsData ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁st orer et urn s Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData Long ▁( ▁28 79 9 L ▁, ▁6 1 19 9 L ▁, ▁32 5 28 L ▁, ▁9 94 6 L ▁) ▁) ▁; ▁st orer et urn s Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData Double ▁( ▁0.00 D ▁, ▁8 6 31 .0 6 D ▁, ▁8 200 7 L ▁, ▁9 87 1 L ▁) ▁) ▁; ▁st orer et urn s Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData Long ▁( ▁2 L ▁, ▁19 20 8 00 L ▁, ▁256 8 99 L ▁, ▁9 8 83 L ▁) ▁) ▁; ▁st orer et urn s Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData Double ▁( ▁0.00 D ▁, ▁1 13 58 .5 7 D ▁, ▁7 21 14 L ▁, ▁100 98 L ▁) ▁) ▁; ▁st orer et urn s Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData Double ▁( ▁0.00 D ▁, ▁17 59 3 . 80 D ▁, ▁14 19 89 L ▁, ▁99 50 L ▁) ▁) ▁; ▁st orer et urn s Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData Long ▁( ▁1 L ▁, ▁18 000 L ▁, ▁1 78 63 L ▁, ▁0 L ▁) ▁) ▁; ▁st orer et urn s Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData Long ▁( ▁1 L ▁, ▁100 L ▁, ▁100 L ▁, ▁100 63 L ▁) ▁) ▁;
▁public ▁class ▁M al ic ious Code Scanner ▁extends ▁Plugin ▁{ ▁public ▁final ▁List ▁< ▁M al ic ious Code Options ▁> ▁options ▁; ▁public ▁M al ic ious Code Scanner ▁( ▁List ▁< ▁M al ic ious Code Options ▁> ▁options ▁) ▁{ ▁this ▁. ▁options ▁= ▁options ▁; ▁} ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁ArrayList ▁< ▁ClassNode ▁> ▁classNode List ▁) ▁{ ▁Plugin Console ▁frame ▁= ▁new ▁Plugin Console ▁( ▁STR ▁) ▁; ▁StringBuilder ▁sb ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁HashSet ▁< ▁String ▁> ▁scan Options ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁M al ic ious Code Options ▁option ▁: ▁options ▁) ▁if ▁( ▁option ▁. ▁get CheckBox ▁( ▁) ▁. ▁isSelected ▁( ▁) ▁) ▁scan Options ▁. ▁add ▁( ▁option ▁. ▁getModule ▁( ▁) ▁. ▁name ▁( ▁) ▁) ▁; ▁M al ware Scan ▁scan ▁= ▁new ▁M al ware Scan ▁( ▁classNode List ▁, ▁sb ▁, ▁scan Options ▁) ▁; ▁M al ware Scan Module ▁. ▁perform Scan ▁( ▁scan ▁) ▁; ▁frame ▁. ▁appendText ▁( ▁sb ▁. ▁toString ▁( ▁) ▁) ▁; ▁frame ▁. ▁setVisible ▁( ▁true ▁) ▁; ▁} ▁}
▁public ▁class ▁Thrift Message To Result Converter ▁implements ▁Message Converter ▁< ▁Result Response ▁> ▁{ ▁@ ▁Override ▁public ▁Result Response ▁to Message ▁( ▁Object ▁object ▁) ▁{ ▁if ▁( ▁object ▁instanceof ▁Response Message ▁) ▁{ ▁final ▁Response Message ▁response Message ▁= ▁( ▁Response Message ▁) ▁object ▁; ▁final ▁byte ▁[ ▁] ▁byte Message ▁= ▁response Message ▁. ▁getMessage ▁( ▁) ▁; ▁final ▁Message ▁< ▁TBase ▁< ▁? ▁, ▁? ▁> ▁> ▁message ▁= ▁Serialization Utils ▁. ▁deserialize ▁( ▁byte Message ▁, ▁HeaderTBase Deserializer Factory ▁. ▁DEFAULT _ FACTORY ▁, ▁null ▁) ▁; ▁if ▁( ▁message ▁== ▁null ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁response Message ▁) ▁; ▁} ▁final ▁TBase ▁< ▁? ▁, ▁? ▁> ▁t base ▁= ▁message ▁. ▁getData ▁( ▁) ▁; ▁if ▁( ▁! ▁( ▁t base ▁instanceof ▁TR es ult ▁) ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁response Message ▁+ ▁STR ▁+ ▁t base ▁. ▁getClass ▁( ▁) ▁) ▁; ▁} ▁final ▁TR es ult ▁result ▁= ▁( ▁TR es ult ▁) ▁t base ▁; ▁return ▁new ▁Result Response ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁boolean ▁isSuccess ▁( ▁) ▁{ ▁return ▁result ▁. ▁isSuccess ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getMessage ▁( ▁) ▁{ ▁return ▁result ▁. ▁getMessage ▁( ▁) ▁; ▁} ▁} ▁; ▁} ▁return ▁null ▁; ▁} ▁}
▁public ▁class ▁BC _ i add _ const 1 ▁extends ▁JTTTest ▁{ ▁public ▁static ▁int ▁test ▁( ▁byte ▁a ▁, ▁byte ▁b ▁, ▁boolean ▁neg ▁) ▁{ ▁byte ▁x ▁= ▁GraalDirectives ▁. ▁opaque ▁( ▁a ▁) ▁; ▁if ▁( ▁! ▁neg ▁) ▁{ ▁return ▁x ▁+ ▁b ▁; ▁} ▁return ▁x ▁- ▁b ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 0 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁( ▁byte ▁) ▁42 ▁, ▁( ▁byte ▁) ▁1 ▁, ▁false ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 1 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁( ▁byte ▁) ▁42 ▁, ▁( ▁byte ▁) ▁- ▁1 ▁, ▁false ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 2 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁( ▁byte ▁) ▁42 ▁, ▁( ▁byte ▁) ▁1 ▁, ▁true ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 3 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁( ▁byte ▁) ▁42 ▁, ▁( ▁byte ▁) ▁- ▁1 ▁, ▁true ▁) ▁; ▁} ▁}
▁@ ▁RunWith ▁( ▁SpringRunner ▁. ▁class ▁) ▁@ ▁SpringBootTest ▁( ▁classes ▁= ▁U aa App ▁. ▁class ▁) ▁public ▁class ▁Log s Resource Int Test ▁{ ▁private ▁MockMvc ▁rest Logs MockMvc ▁; ▁@ ▁Before ▁public ▁void ▁setup ▁( ▁) ▁{ ▁Log s Resource ▁logs Resource ▁= ▁new ▁Log s Resource ▁( ▁) ▁; ▁this ▁. ▁rest Logs MockMvc ▁= ▁MockMvcBuilders ▁. ▁standalone Setup ▁( ▁logs Resource ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁getAll Logs ▁( ▁) ▁throws ▁Exception ▁{ ▁rest Logs MockMvc ▁. ▁perform ▁( ▁get ▁( ▁STR ▁) ▁) ▁. ▁andExpect ▁( ▁status ▁( ▁) ▁. ▁isOk ▁( ▁) ▁) ▁. ▁andExpect ▁( ▁content ▁( ▁) ▁. ▁contentType ▁( ▁MediaType ▁. ▁APPLICATION _ JSON _ UTF 8_ VALUE ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁change Logs ▁( ▁) ▁throws ▁Exception ▁{ ▁Logger VM ▁logger ▁= ▁new ▁Logger VM ▁( ▁) ▁; ▁logger ▁. ▁setLevel ▁( ▁STR ▁) ▁; ▁logger ▁. ▁setName ▁( ▁STR ▁) ▁; ▁rest Logs MockMvc ▁. ▁perform ▁( ▁put ▁( ▁STR ▁) ▁. ▁contentType ▁( ▁TestUtil ▁. ▁APPLICATION _ JSON _ UTF 8 ▁) ▁. ▁content ▁( ▁TestUtil ▁. ▁convert Object To Json Bytes ▁( ▁logger ▁) ▁) ▁) ▁. ▁andExpect ▁( ▁status ▁( ▁) ▁. ▁is No Content ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Log stash Appender ▁( ▁) ▁{ ▁LoggerContext ▁context ▁= ▁( ▁LoggerContext ▁) ▁LoggerFactory ▁. ▁get IL ogger Factory ▁( ▁) ▁; ▁assertThat ▁( ▁context ▁. ▁getLogger ▁( ▁STR ▁) ▁. ▁get Appender ▁( ▁STR ▁) ▁) ▁. ▁isInstanceOf ▁( ▁Async Appender ▁. ▁class ▁) ▁; ▁} ▁}
▁public ▁class ▁Integer Deserializer ▁implements ▁Deserializer ▁< ▁Integer ▁> ▁{ ▁public ▁Integer ▁deserialize ▁( ▁String ▁topic ▁, ▁byte ▁[ ▁] ▁data ▁) ▁{ ▁if ▁( ▁data ▁== ▁null ▁) ▁return ▁null ▁; ▁if ▁( ▁data ▁. ▁length ▁!= ▁4 ▁) ▁{ ▁throw ▁new ▁Serialization Exception ▁( ▁STR ▁) ▁; ▁} ▁int ▁value ▁= ▁0 ▁; ▁for ▁( ▁byte ▁b ▁: ▁data ▁) ▁{ ▁value ▁<<= ▁8 ▁; ▁value ▁|= ▁b ▁& ▁0 xFF ▁; ▁} ▁return ▁value ▁; ▁} ▁}
▁@ ▁Service ▁@ ▁Qualifier ▁( ▁STR ▁) ▁public ▁class ▁Student Repository Service ▁implements ▁Student Service ▁{ ▁private ▁Student Repository ▁repo ▁; ▁@ ▁Autowired ▁public ▁void ▁set Student Repository ▁( ▁Student Repository ▁repo ▁) ▁{ ▁this ▁. ▁repo ▁= ▁repo ▁; ▁} ▁public ▁Student ▁findOne ▁( ▁String ▁id ▁) ▁{ ▁return ▁repo ▁. ▁findOne ▁( ▁id ▁) ▁; ▁} ▁public ▁List ▁< ▁Student ▁> ▁findAll ▁( ▁) ▁{ ▁List ▁< ▁Student ▁> ▁pe ople ▁= ▁new ▁ArrayList ▁< ▁Student ▁> ▁( ▁) ▁; ▁Iterator ▁< ▁Student ▁> ▁it ▁= ▁repo ▁. ▁findAll ▁( ▁) ▁. ▁iterator ▁( ▁) ▁; ▁while ▁( ▁it ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁pe ople ▁. ▁add ▁( ▁it ▁. ▁next ▁( ▁) ▁) ▁; ▁} ▁return ▁pe ople ▁; ▁} ▁public ▁List ▁< ▁Student ▁> ▁findBy First Name ▁( ▁String ▁firstName ▁) ▁{ ▁return ▁repo ▁. ▁findBy First Name ▁( ▁firstName ▁) ▁; ▁} ▁public ▁List ▁< ▁Student ▁> ▁findBy Last Name ▁( ▁String ▁lastName ▁) ▁{ ▁return ▁repo ▁. ▁findBy Last Name ▁( ▁lastName ▁) ▁; ▁} ▁public ▁void ▁create ▁( ▁Student ▁student ▁) ▁{ ▁student ▁. ▁set Created ▁( ▁DateTime ▁. ▁now ▁( ▁) ▁) ▁; ▁repo ▁. ▁save ▁( ▁student ▁) ▁; ▁} ▁public ▁void ▁update ▁( ▁Student ▁student ▁) ▁{ ▁student ▁. ▁setUp d ated ▁( ▁DateTime ▁. ▁now ▁( ▁) ▁) ▁; ▁repo ▁. ▁save ▁( ▁student ▁) ▁; ▁} ▁public ▁void ▁delete ▁( ▁Student ▁student ▁) ▁{ ▁repo ▁. ▁delete ▁( ▁student ▁) ▁; ▁} ▁}
▁@ ▁RunWith ▁( ▁Robolectric TestRunner ▁. ▁class ▁) ▁public ▁class ▁Max Input Validator Test ▁{ ▁private ▁Edit Text ▁edit Text ▁; ▁@ ▁Before ▁public ▁void ▁setUp ▁( ▁) ▁{ ▁edit Text ▁= ▁new ▁Edit Text ▁( ▁build Activity ▁( ▁Activity ▁. ▁class ▁) ▁. ▁create ▁( ▁) ▁. ▁get ▁( ▁) ▁) ▁; ▁edit Text ▁. ▁setFilters ▁( ▁new ▁Input Filter ▁[ ▁] ▁{ ▁new ▁Max Input Validator ▁( ▁10 ▁) ▁} ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁edit Text _ h as Correct Text _ when Number Is G reater ▁( ▁) ▁{ ▁press Keys ▁( ▁KEY CODE _1 ▁, ▁KEY CODE _2 ▁) ▁; ▁assertThat ▁( ▁edit Text ▁. ▁getText ▁( ▁) ▁. ▁toString ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁edit Text _ h as Correct Text _ when Number Is Sm aller ▁( ▁) ▁{ ▁press Keys ▁( ▁KEY CODE _0 ▁, ▁KEY CODE _2 ▁) ▁; ▁assertThat ▁( ▁edit Text ▁. ▁getText ▁( ▁) ▁. ▁toString ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁edit Text _ h as Correct Text _ with Delete ▁( ▁) ▁{ ▁press Keys ▁( ▁KEY CODE _2 ▁, ▁KEY CODE _ DE L ▁, ▁KEY CODE _3 ▁) ▁; ▁assertThat ▁( ▁edit Text ▁. ▁getText ▁( ▁) ▁. ▁toString ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁} ▁private ▁void ▁press Keys ▁( ▁int ▁... ▁key code s ▁) ▁{ ▁for ▁( ▁int ▁key ▁: ▁key code s ▁) ▁{ ▁edit Text ▁. ▁dispatch Key Event ▁( ▁new ▁KeyEvent ▁( ▁0 ▁, ▁0 ▁, ▁KeyEvent ▁. ▁ACTION _ DOWN ▁, ▁key ▁, ▁0 ▁) ▁) ▁; ▁edit Text ▁. ▁dispatch Key Event ▁( ▁new ▁KeyEvent ▁( ▁0 ▁, ▁0 ▁, ▁KeyEvent ▁. ▁ACTION _ UP ▁, ▁key ▁, ▁0 ▁) ▁) ▁; ▁} ▁} ▁}
▁public ▁class ▁Date Processor Tests ▁extends ▁ESTestCase ▁{ ▁private ▁Template Script ▁. ▁Factory ▁te mpl at ize ▁( ▁Locale ▁locale ▁) ▁{ ▁return ▁new ▁TestTemplate Service ▁. ▁Mock Template Script ▁. ▁Factory ▁( ▁locale ▁. ▁getLanguage ▁( ▁) ▁) ▁; ▁} ▁private ▁Template Script ▁. ▁Factory ▁te mpl at ize ▁( ▁ Z oneId ▁time z one ▁) ▁{ ▁return ▁new ▁TestTemplate Service ▁. ▁Mock Template Script ▁. ▁Factory ▁( ▁time z one ▁. ▁getId ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁test Java Pattern ▁( ▁) ▁{ ▁Date Processor ▁date Processor ▁= ▁new ▁Date Processor ▁( ▁randomAlpha OfLength ▁( ▁10 ▁) ▁, ▁null ▁, ▁te mpl at ize ▁( ▁ Z oneId ▁. ▁of ▁( ▁STR ▁) ▁) ▁, ▁te mpl at ize ▁( ▁Locale ▁. ▁ENGLISH ▁) ▁, ▁STR ▁, ▁Collections ▁. ▁singletonList ▁( ▁STR ▁) ▁, ▁STR ▁) ▁; ▁Map ▁< ▁String ▁, ▁Object ▁> ▁document ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁document ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁; ▁IngestDocument ▁ingest Document ▁= ▁Random Document P ick s ▁. ▁random In gest Document ▁( ▁random ▁( ▁) ▁, ▁document ▁) ▁; ▁date Processor ▁. ▁execute ▁( ▁ingest Document ▁) ▁; ▁assertThat ▁( ▁ingest Document ▁. ▁getFieldValue ▁( ▁STR ▁, ▁String ▁. ▁class ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁; ▁} ▁public ▁void ▁test Java Pattern Multiple Formats ▁( ▁) ▁{ ▁List ▁< ▁String ▁> ▁match Formats ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁match Formats ▁. ▁add ▁( ▁STR ▁) ▁; ▁match Formats ▁. ▁add ▁( ▁STR ▁) ▁; ▁match Formats ▁. ▁add ▁( ▁STR ▁) ▁; ▁Date Processor ▁date Processor ▁= ▁new ▁Date Processor ▁( ▁randomAlpha OfLength ▁( ▁10 ▁) ▁, ▁null ▁, ▁te mpl at ize ▁( ▁ Z oneId ▁. ▁of ▁( ▁STR ▁) ▁) ▁, ▁te mpl at ize ▁( ▁Locale ▁. ▁ENGLISH ▁) ▁, ▁STR ▁, ▁match Formats ▁, ▁STR ▁) ▁; ▁Map ▁< ▁String ▁, ▁Object ▁> ▁document ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁document ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁; ▁IngestDocument ▁ingest Document ▁= ▁Random Document P ick s ▁. ▁random In gest Document ▁( ▁random ▁( ▁) ▁, ▁document ▁) ▁; ▁date Processor ▁. ▁execute ▁( ▁ingest Document ▁) ▁; ▁assertThat ▁( ▁ingest Document ▁. ▁getFieldValue ▁( ▁STR ▁, ▁String ▁. ▁class ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁; ▁document ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁document ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁; ▁ingest Document ▁= ▁Random Document P ick s ▁. ▁random In gest Document ▁( ▁random ▁( ▁) ▁, ▁document ▁) ▁; ▁date Processor ▁. ▁execute ▁( ▁ingest Document ▁) ▁; ▁assertThat ▁( ▁ingest Document ▁. ▁getFieldValue ▁( ▁STR ▁, ▁String ▁. ▁class ▁) ▁, ▁equalTo ▁( ▁STR ▁) ▁) ▁; ▁document ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁document ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁; ▁ingest Document ▁= ▁Random Document P ick s ▁. ▁random In gest Document ▁( ▁random ▁( ▁) ▁, ▁document ▁) ▁; ▁date Processor ▁. ▁execute ▁( ▁ingest Document ▁) ▁;
▁public ▁class ▁Up per Case Names ▁implements ▁Function ▁< ▁Boolean ▁> ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁- ▁8 94 6 29 40 32 16 56 7 76 02 L ▁; ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁Function Context ▁< ▁Boolean ▁> ▁context ▁) ▁{ ▁Region Function Context ▁region Context ▁= ▁( ▁Region Function Context ▁) ▁context ▁; ▁Region ▁< ▁Customer Key ▁, ▁Customer ▁> ▁region ▁= ▁region Context ▁. ▁getData Set ▁( ▁) ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Customer Key ▁, ▁Customer ▁> ▁entry ▁: ▁region ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁Customer ▁customer ▁= ▁entry ▁. ▁getValue ▁( ▁) ▁; ▁customer ▁. ▁setFirstName ▁( ▁customer ▁. ▁getFirstName ▁( ▁) ▁. ▁toUpperCase ▁( ▁) ▁) ▁; ▁} ▁context ▁. ▁getResult Sender ▁( ▁) ▁. ▁last Result ▁( ▁true ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getId ▁( ▁) ▁{ ▁return ▁getClass ▁( ▁) ▁. ▁getName ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁Report Multi Threaded Before OrAfter Method ▁implements ▁I Class Listener ▁{ ▁@ ▁Override ▁public ▁void ▁on Before Class ▁( ▁ITest Class ▁testClass ▁) ▁{ ▁try ▁{ ▁if ▁( ▁! ▁is Parallel ▁( ▁testClass ▁. ▁get Xml Test ▁( ▁) ▁) ▁) ▁{ ▁return ▁; ▁} ▁report Multi Threaded Before OrAfter Method ▁( ▁testClass ▁. ▁getReal Class ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁Runtime Exception ▁| ▁Error ▁e ▁) ▁{ ▁report Listener Failure ▁( ▁Report Multi Threaded Before OrAfter Method ▁. ▁class ▁, ▁STR ▁, ▁testClass ▁, ▁getStackTrace AsString ▁( ▁e ▁) ▁) ▁; ▁} ▁} ▁private ▁boolean ▁is Parallel ▁( ▁Xml Test ▁xml Test ▁) ▁{ ▁if ▁( ▁xml Test ▁. ▁get ThreadCount ▁( ▁) ▁== ▁1 ▁) ▁{ ▁return ▁false ▁; ▁} ▁Parallel Mode ▁parallel ▁= ▁xml Test ▁. ▁get Parallel ▁( ▁) ▁; ▁return ▁parallel ▁. ▁is Parallel ▁( ▁) ▁; ▁} ▁@ ▁Visible ForTesting ▁static ▁void ▁report Multi Threaded Before OrAfter Method ▁( ▁Class ▁< ▁? ▁> ▁testClass ▁) ▁{ ▁Test ▁test Annotation ▁= ▁testClass ▁. ▁getAnnotation ▁( ▁Test ▁. ▁class ▁) ▁; ▁if ▁( ▁test Annotation ▁!= ▁null ▁&& ▁test Annotation ▁. ▁single Threaded ▁( ▁) ▁) ▁{ ▁return ▁; ▁} ▁Method ▁[ ▁] ▁methods ▁= ▁testClass ▁. ▁getMethods ▁( ▁) ▁; ▁for ▁( ▁Method ▁method ▁: ▁methods ▁) ▁{ ▁if ▁( ▁method ▁. ▁getAnnotation ▁( ▁Before Method ▁. ▁class ▁) ▁!= ▁null ▁|| ▁method ▁. ▁getAnnotation ▁( ▁After Method ▁. ▁class ▁) ▁!= ▁null ▁) ▁{ ▁throw ▁new ▁Runtime Exception ▁( ▁format ▁( ▁STR ▁, ▁testClass ▁. ▁getName ▁( ▁) ▁, ▁method ▁) ▁) ▁; ▁} ▁} ▁} ▁@ ▁Override ▁public ▁void ▁on After Class ▁( ▁ITest Class ▁i TestClass ▁) ▁{ ▁} ▁}
▁final ▁boolean ▁ex ▁= ▁f ▁. ▁exists ▁( ▁) ▁; ▁if ▁( ▁do Log ▁&& ▁ex ▁) ▁{ ▁LOG ▁. ▁warn ▁( ▁STR ▁+ ▁f ▁. ▁getAbsolutePath ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁return ▁! ▁ex ▁; ▁} ▁public ▁static ▁boolean ▁fully Delete Contents ▁( ▁final ▁File ▁dir ▁) ▁{ ▁return ▁fully Delete Contents ▁( ▁dir ▁, ▁false ▁) ▁; ▁} ▁public ▁static ▁boolean ▁fully Delete Contents ▁( ▁final ▁File ▁dir ▁, ▁final ▁boolean ▁try Grant Permissions ▁) ▁{ ▁if ▁( ▁try Grant Permissions ▁) ▁{ ▁grant Permissions ▁( ▁dir ▁) ▁; ▁} ▁boolean ▁delet ion Su cceeded ▁= ▁true ▁; ▁final ▁File ▁[ ▁] ▁contents ▁= ▁dir ▁. ▁listFiles ▁( ▁) ▁; ▁if ▁( ▁contents ▁!= ▁null ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁contents ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁contents ▁[ ▁i ▁] ▁. ▁isFile ▁( ▁) ▁) ▁{ ▁if ▁( ▁! ▁delete Impl ▁( ▁contents ▁[ ▁i ▁] ▁, ▁true ▁) ▁) ▁{ ▁delet ion Su cceeded ▁= ▁false ▁; ▁continue ▁; ▁} ▁} ▁else ▁{ ▁boolean ▁b ▁= ▁false ▁; ▁b ▁= ▁delete Impl ▁( ▁contents ▁[ ▁i ▁] ▁, ▁false ▁) ▁; ▁if ▁( ▁b ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁! ▁fully Delete ▁( ▁contents ▁[ ▁i ▁] ▁, ▁try Grant Permissions ▁) ▁) ▁{ ▁delet ion Su cceeded ▁= ▁false ▁; ▁} ▁} ▁} ▁} ▁return ▁delet ion Su cceeded ▁; ▁} ▁@ ▁Deprecated ▁public ▁static ▁void ▁fully Delete ▁( ▁FileSystem ▁fs ▁, ▁Path ▁dir ▁) ▁throws ▁IOException ▁{ ▁fs ▁. ▁delete ▁( ▁dir ▁, ▁true ▁) ▁; ▁} ▁private ▁static ▁void ▁check Dependencies ▁( ▁FileSystem ▁src FS ▁, ▁Path ▁src ▁, ▁FileSystem ▁dst FS ▁, ▁Path ▁dst ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁src FS ▁== ▁dst FS ▁) ▁{ ▁String ▁src q ▁= ▁src FS ▁. ▁make Qualified ▁( ▁src ▁) ▁. ▁toString ▁( ▁) ▁+ ▁Path ▁. ▁SEPARATOR ▁; ▁String ▁dst q ▁= ▁dst FS ▁. ▁make Qualified ▁( ▁dst ▁) ▁. ▁toString ▁( ▁) ▁+ ▁Path ▁. ▁SEPARATOR ▁; ▁if ▁( ▁dst q ▁. ▁startsWith ▁( ▁src q ▁) ▁) ▁{ ▁if ▁( ▁src q ▁. ▁length ▁( ▁) ▁== ▁dst q ▁. ▁length ▁( ▁) ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁STR ▁+ ▁src ▁+ ▁STR ▁) ▁; ▁} ▁else ▁{ ▁throw ▁new ▁IOException ▁( ▁STR ▁+ ▁src ▁+ ▁STR ▁+ ▁dst ▁) ▁; ▁} ▁} ▁} ▁} ▁public ▁static ▁boolean ▁copy ▁( ▁FileSystem ▁src FS ▁, ▁Path ▁src ▁, ▁FileSystem ▁dst FS ▁, ▁Path ▁dst ▁, ▁boolean ▁delete Source ▁, ▁Configuration ▁conf ▁) ▁throws ▁IOException ▁{ ▁return ▁copy ▁( ▁src FS ▁, ▁src ▁, ▁dst FS ▁, ▁dst ▁, ▁delete Source ▁, ▁true ▁, ▁conf ▁) ▁; ▁} ▁public ▁static ▁boolean ▁copy ▁( ▁FileSystem ▁src FS ▁, ▁Path ▁[ ▁] ▁src s ▁, ▁FileSystem ▁dst FS ▁, ▁Path ▁dst ▁, ▁boolean ▁delete Source ▁, ▁boolean ▁overwrite ▁, ▁Configuration ▁conf ▁) ▁throws ▁IOException ▁{ ▁boolean ▁g ot Exception ▁= ▁false ▁; ▁boolean ▁return Val ▁= ▁true ▁; ▁StringBuilder ▁exceptions ▁= ▁new ▁StringBuilder ▁( ▁) ▁;
▁public ▁class ▁M IP SR 6_ O 3_ EmulatorTest ▁extends ▁Processor EmulatorTest Adapter ▁{ ▁private ▁static ▁final ▁String ▁LANGUAGE _ ID ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁COMP ILER _ SPEC _ ID ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁[ ▁] ▁REG _ DUMP _ SET ▁= ▁new ▁String ▁[ ▁] ▁{ ▁} ▁; ▁public ▁M IP SR 6_ O 3_ EmulatorTest ▁( ▁String ▁name ▁) ▁throws ▁Exception ▁{ ▁super ▁( ▁name ▁, ▁LANGUAGE _ ID ▁, ▁COMP ILER _ SPEC _ ID ▁, ▁REG _ DUMP _ SET ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁String ▁getProcessor Des ign ator ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁public ▁static ▁Test ▁suite ▁( ▁) ▁{ ▁return ▁Processor EmulatorTest Adapter ▁. ▁build Emulator TestSuite ▁( ▁M IP SR 6_ O 3_ EmulatorTest ▁. ▁class ▁) ▁; ▁} ▁}
▁public ▁class ▁TaskExecutor ▁extends ▁Rpc Endpoint ▁implements ▁TaskExecutor Gateway ▁{ ▁public ▁static ▁final ▁String ▁TASK _ MANAGER _ NAME ▁= ▁STR ▁; ▁private ▁final ▁High Availability Services ▁ha Services ▁; ▁private ▁final ▁TaskManager Services ▁taskExecutor Services ▁; ▁private ▁final ▁TaskManager Configuration ▁taskManager Configuration ▁; ▁private ▁final ▁F atal ErrorHandler ▁fatal ErrorHandler ▁; ▁private ▁final ▁Blob Cache Service ▁blob Cache Service ▁; ▁private ▁final ▁Library CacheManager ▁library CacheManager ▁; ▁@ ▁Nullable ▁private ▁final ▁String ▁metric QueryService Address ▁; ▁private ▁final ▁Unresolved TaskManager Location ▁unresolved TaskManager Location ▁; ▁private ▁final ▁TaskManager MetricGroup ▁taskManager MetricGroup ▁; ▁private ▁final ▁TaskExecutor Local StateStore s Manager ▁local StateStore s Manager ▁; ▁private ▁final ▁TaskExecutor State Changelog St or ages Manager ▁ch angelog St or ages Manager ▁; ▁private ▁final ▁External Resource InfoProvider ▁external Resource InfoProvider ▁; ▁private ▁final ▁Shuffle Environment ▁< ▁? ▁, ▁? ▁> ▁shuffle Environment ▁; ▁private ▁final ▁KvState Service ▁kvState Service ▁; ▁private ▁final ▁Executor ▁io Executor ▁; ▁private ▁final ▁Task Slot Table ▁< ▁Task ▁> ▁task Slot Table ▁; ▁private ▁final ▁Map ▁< ▁JobID ▁, ▁UUID ▁> ▁current Slot Offer Per Job ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁private ▁final ▁Job Table ▁job Table ▁; ▁private ▁final ▁Job Leader Service ▁job Leader Service ▁; ▁private ▁final ▁Leader Retrieval Service ▁resourceManager Leader Retriever ▁; ▁private ▁final ▁H ard ware Description ▁hard ware Description ▁; ▁private ▁final ▁TaskExecutor Memory Configuration ▁memory Configuration ▁; ▁private ▁File Cache ▁file Cache ▁; ▁private ▁final ▁Heartbeat Manager ▁< ▁Alloc ated Slot Report ▁, ▁TaskExecutor To JobManager Heartbeat Payload ▁> ▁jobManager Heartbeat Manager ▁; ▁private ▁final ▁Heartbeat Manager ▁< ▁Void ▁, ▁TaskExecutor Heartbeat Payload ▁> ▁resourceManager Heartbeat Manager ▁; ▁private ▁final ▁TaskExecutor Partition Tracker ▁partition Tracker ▁; ▁@ ▁Nullable ▁private ▁ResourceManager Address ▁resourceManager Address ▁; ▁@ ▁Nullable ▁private ▁E sta blish ed ResourceManager Connection ▁e sta blish ed ResourceManager Connection ▁; ▁@ ▁Nullable ▁private ▁TaskExecutor To ResourceManager Connection ▁resourceManager Connection ▁; ▁@ ▁Nullable ▁private ▁UUID ▁current Registration Timeout Id ▁; ▁private ▁Map ▁< ▁JobID ▁, ▁Collection ▁< ▁Completable Future ▁< ▁ExecutionState ▁> ▁> ▁> ▁task ResultPartition Cleanup Futures Per Job ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁8 ▁) ▁; ▁private ▁final ▁ThreadInfo Sample Service ▁threadInfo Sample Service ▁; ▁public ▁TaskExecutor ▁( ▁Rpc Service ▁rpc Service ▁, ▁TaskManager Configuration ▁taskManager Configuration ▁, ▁High Availability Services ▁ha Services ▁, ▁TaskManager Services ▁taskExecutor Services ▁, ▁External Resource InfoProvider ▁external Resource InfoProvider ▁, ▁Heartbeat Services ▁heartbeat Services ▁, ▁TaskManager MetricGroup ▁taskManager MetricGroup ▁, ▁@ ▁Nullable ▁String ▁metric QueryService Address ▁, ▁Blob Cache Service ▁blob Cache Service ▁, ▁F atal ErrorHandler ▁fatal ErrorHandler ▁, ▁TaskExecutor Partition Tracker ▁partition Tracker ▁) ▁{ ▁super ▁( ▁rpc Service ▁, ▁Rpc Service Utils ▁. ▁createRandom Name ▁( ▁TASK _ MANAGER _ NAME ▁) ▁) ▁; ▁checkArgument ▁( ▁taskManager Configuration ▁. ▁getNumber Slots ▁( ▁) ▁> ▁0 ▁, ▁STR ▁) ▁; ▁this ▁. ▁taskManager Configuration ▁= ▁checkNotNull ▁( ▁taskManager Configuration ▁) ▁; ▁this ▁. ▁taskExecutor Services ▁= ▁checkNotNull ▁( ▁taskExecutor Services ▁) ▁; ▁this ▁. ▁ha Services ▁= ▁checkNotNull ▁( ▁ha Services ▁) ▁; ▁this ▁. ▁fatal ErrorHandler ▁= ▁checkNotNull ▁( ▁fatal ErrorHandler ▁) ▁;
▁public ▁class ▁Frozen Searchable Snapshots Integ Tests ▁extends ▁Base Frozen Searchable Snapshots IntegTestCase ▁{ ▁public ▁void ▁testCreate And Restore Partial Searchable Snapshot ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁String ▁fs Repo Name ▁= ▁randomAlpha OfLength ▁( ▁10 ▁) ▁; ▁final ▁String ▁indexName ▁= ▁randomAlpha OfLength ▁( ▁10 ▁) ▁. ▁toLowerCase ▁( ▁Locale ▁. ▁ROOT ▁) ▁; ▁final ▁String ▁alias Name ▁= ▁randomAlpha OfLength ▁( ▁10 ▁) ▁. ▁toLowerCase ▁( ▁Locale ▁. ▁ROOT ▁) ▁; ▁final ▁String ▁restored IndexName ▁= ▁randomBoolean ▁( ▁) ▁? ▁indexName ▁: ▁randomAlpha OfLength ▁( ▁10 ▁) ▁. ▁toLowerCase ▁( ▁Locale ▁. ▁ROOT ▁) ▁; ▁final ▁String ▁snapshot Name ▁= ▁randomAlpha OfLength ▁( ▁10 ▁) ▁. ▁toLowerCase ▁( ▁Locale ▁. ▁ROOT ▁) ▁; ▁create Repository ▁( ▁fs Repo Name ▁, ▁STR ▁, ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁STR ▁, ▁random Repo Path ▁( ▁) ▁) ▁. ▁put ▁( ▁STR ▁, ▁randomInt Between ▁( ▁100 ▁, ▁1000 ▁) ▁, ▁ByteSize Unit ▁. ▁BYTES ▁) ▁) ▁; ▁final ▁Settings ▁. ▁Builder ▁original Index Settings ▁= ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁INDEX _ S OFT _ DELETE S _ SETTING ▁. ▁getKey ▁( ▁) ▁, ▁true ▁) ▁; ▁if ▁( ▁randomBoolean ▁( ▁) ▁) ▁{ ▁original Index Settings ▁. ▁put ▁( ▁IndexSettings ▁. ▁INDEX _ CHECK _ ON _ START UP ▁. ▁getKey ▁( ▁) ▁, ▁randomFrom ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁) ▁; ▁} ▁assertAcked ▁( ▁prepareCreate ▁( ▁indexName ▁, ▁original Index Settings ▁) ▁) ▁; ▁assertAcked ▁( ▁client ▁( ▁) ▁. ▁admin ▁( ▁) ▁. ▁indices ▁( ▁) ▁. ▁prepare Aliases ▁( ▁) ▁. ▁add Alias ▁( ▁indexName ▁, ▁alias Name ▁) ▁) ▁; ▁populate Index ▁( ▁indexName ▁, ▁10_000 ▁) ▁; ▁final ▁Total Hits ▁original All Hits ▁= ▁internalCluster ▁( ▁) ▁. ▁client ▁( ▁) ▁. ▁prepareSearch ▁( ▁indexName ▁) ▁. ▁set Track Total Hits ▁( ▁true ▁) ▁. ▁get ▁( ▁) ▁. ▁getHits ▁( ▁) ▁. ▁getTotal Hits ▁( ▁) ▁; ▁final ▁Total Hits ▁original Bar Hits ▁= ▁internalCluster ▁( ▁) ▁. ▁client ▁( ▁) ▁. ▁prepareSearch ▁( ▁indexName ▁) ▁. ▁set Track Total Hits ▁( ▁true ▁) ▁. ▁setQuery ▁( ▁match Query ▁( ▁STR ▁, ▁STR ▁) ▁) ▁. ▁get ▁( ▁) ▁. ▁getHits ▁( ▁) ▁. ▁getTotal Hits ▁( ▁) ▁; ▁logger ▁. ▁info ▁( ▁STR ▁, ▁original All Hits ▁, ▁original Bar Hits ▁) ▁; ▁expectThrows ▁( ▁Resource Not FoundException ▁. ▁class ▁, ▁STR ▁, ▁( ▁) ▁-> ▁client ▁( ▁) ▁. ▁execute ▁( ▁Searchable Snapshots StatsAction ▁. ▁INSTANCE ▁, ▁new ▁Searchable Snapshots StatsRequest ▁( ▁) ▁) ▁. ▁actionGet ▁( ▁) ▁) ▁; ▁final ▁Snapshot Info ▁snapshot Info ▁= ▁create Full Snapshot ▁( ▁fs Repo Name ▁, ▁snapshot Name ▁) ▁; ▁ensureGreen ▁( ▁indexName ▁) ▁; ▁assert Shard Folder s ▁( ▁indexName ▁, ▁false ▁) ▁;
▁assertThat ▁( ▁server TestInstance ▁. ▁getTimestamp Millis ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁getTimestamp Millis ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁server TestInstance ▁. ▁getTime UpperBound Millis ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁getTime UpperBound Millis ▁( ▁) ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁assert Transform Checkpoint Info ▁( ▁org ▁. ▁elasticsearch ▁. ▁xpack ▁. ▁core ▁. ▁transform ▁. ▁transforms ▁. ▁Transform Checkpointing Info ▁server TestInstance ▁, ▁Transform Checkpointing Info ▁clientInstance ▁) ▁{ ▁assert Transform CheckpointStats ▁( ▁server TestInstance ▁. ▁getNext ▁( ▁) ▁, ▁clientInstance ▁. ▁getNext ▁( ▁) ▁) ▁; ▁assert Transform CheckpointStats ▁( ▁server TestInstance ▁. ▁getLast ▁( ▁) ▁, ▁clientInstance ▁. ▁getLast ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁server TestInstance ▁. ▁get Changes Last Detected At ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁get Changes Last Detected At ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁server TestInstance ▁. ▁get Operations Behind ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁get Operations Behind ▁( ▁) ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁assert Transform Indexer Stats ▁( ▁org ▁. ▁elasticsearch ▁. ▁xpack ▁. ▁core ▁. ▁transform ▁. ▁transforms ▁. ▁Transform Indexer Stats ▁server TestInstance ▁, ▁Transform Indexer Stats ▁clientInstance ▁) ▁{ ▁assertThat ▁( ▁server TestInstance ▁. ▁get Exp Avg Checkpoint Duration Ms ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁get Exp Avg Checkpoint Duration Ms ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁server TestInstance ▁. ▁get Exp Avg Document s Processed ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁get Exp Avg Document s Processed ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁server TestInstance ▁. ▁get Exp Avg Document s Indexed ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁get Exp Avg Document s Indexed ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁server TestInstance ▁. ▁getNum Pages ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁getP ages Processed ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁server TestInstance ▁. ▁getIndex Failures ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁getIndex Failures ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁server TestInstance ▁. ▁getIndex Time ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁getIndex Time ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁server TestInstance ▁. ▁getIndex Total ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁getIndex Total ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁server TestInstance ▁. ▁getNum Document s ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁getDocument s Processed ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁server TestInstance ▁. ▁getNum Invocations ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁getT rigger Count ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁server TestInstance ▁. ▁getOutput Document s ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁getDocument s Indexed ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁server TestInstance ▁. ▁getNum Deleted Document s ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁getDocument s Deleted ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁server TestInstance ▁. ▁getSearch Failures ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁getSearch Failures ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁server TestInstance ▁. ▁getSearch Time ▁( ▁) ▁, ▁equalTo ▁( ▁clientInstance ▁. ▁getSearch Time ▁( ▁) ▁) ▁) ▁;
▁AL 10 ▁. ▁al Source i ▁( ▁source Id ▁, ▁S OFT Direct Channels ▁. ▁AL _ DIRECT _ CHANNEL S _ S OFT ▁, ▁AL 10 ▁. ▁AL _ TR UE ▁) ▁; ▁return ▁source Id ▁; ▁} ▁} ▁return ▁- ▁1 ▁; ▁} ▁void ▁free Source ▁( ▁int ▁source ID ▁) ▁{ ▁if ▁( ▁no Device ▁) ▁return ▁; ▁al Source Stop ▁( ▁source ID ▁) ▁; ▁al Source i ▁( ▁source ID ▁, ▁AL _ BUFFER ▁, ▁0 ▁) ▁; ▁Long ▁sound Id ▁= ▁source To S ound Id ▁. ▁remove ▁( ▁source ID ▁) ▁; ▁if ▁( ▁sound Id ▁!= ▁null ▁) ▁sound Id To Source ▁. ▁remove ▁( ▁sound Id ▁) ▁; ▁idle Sources ▁. ▁add ▁( ▁source ID ▁) ▁; ▁} ▁void ▁free Buffer ▁( ▁int ▁buffer ID ▁) ▁{ ▁if ▁( ▁no Device ▁) ▁return ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁, ▁n ▁= ▁idle Sources ▁. ▁size ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁source ID ▁= ▁idle Sources ▁. ▁get ▁( ▁i ▁) ▁; ▁if ▁( ▁al Get Source i ▁( ▁source ID ▁, ▁AL _ BUFFER ▁) ▁== ▁buffer ID ▁) ▁{ ▁Long ▁sound Id ▁= ▁source To S ound Id ▁. ▁remove ▁( ▁source ID ▁) ▁; ▁if ▁( ▁sound Id ▁!= ▁null ▁) ▁sound Id To Source ▁. ▁remove ▁( ▁sound Id ▁) ▁; ▁al Source Stop ▁( ▁source ID ▁) ▁; ▁al Source i ▁( ▁source ID ▁, ▁AL _ BUFFER ▁, ▁0 ▁) ▁; ▁} ▁} ▁} ▁void ▁stop Source sWith Buffer ▁( ▁int ▁buffer ID ▁) ▁{ ▁if ▁( ▁no Device ▁) ▁return ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁, ▁n ▁= ▁idle Sources ▁. ▁size ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁source ID ▁= ▁idle Sources ▁. ▁get ▁( ▁i ▁) ▁; ▁if ▁( ▁al Get Source i ▁( ▁source ID ▁, ▁AL _ BUFFER ▁) ▁== ▁buffer ID ▁) ▁{ ▁Long ▁sound Id ▁= ▁source To S ound Id ▁. ▁remove ▁( ▁source ID ▁) ▁; ▁if ▁( ▁sound Id ▁!= ▁null ▁) ▁sound Id To Source ▁. ▁remove ▁( ▁sound Id ▁) ▁; ▁al Source Stop ▁( ▁source ID ▁) ▁; ▁} ▁} ▁} ▁void ▁pause Source sWith Buffer ▁( ▁int ▁buffer ID ▁) ▁{ ▁if ▁( ▁no Device ▁) ▁return ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁, ▁n ▁= ▁idle Sources ▁. ▁size ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁source ID ▁= ▁idle Sources ▁. ▁get ▁( ▁i ▁) ▁; ▁if ▁( ▁al Get Source i ▁( ▁source ID ▁, ▁AL _ BUFFER ▁) ▁== ▁buffer ID ▁) ▁al Source Pause ▁( ▁source ID ▁) ▁; ▁} ▁} ▁void ▁resume Source sWith Buffer ▁( ▁int ▁buffer ID ▁) ▁{ ▁if ▁( ▁no Device ▁) ▁return ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁, ▁n ▁= ▁idle Sources ▁. ▁size ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁int ▁source ID ▁= ▁idle Sources ▁. ▁get ▁( ▁i ▁) ▁;
▁public ▁class ▁Graph ql Interceptor ▁implements ▁InstanceMethods A roundInterceptor ▁{ ▁@ ▁Override ▁public ▁void ▁beforeMethod ▁( ▁En hancedInstance ▁objInst ▁, ▁Method ▁method ▁, ▁Object ▁[ ▁] ▁allArguments ▁, ▁Class ▁< ▁? ▁> ▁[ ▁] ▁argumentsTypes ▁, ▁Method InterceptResult ▁result ▁) ▁throws ▁Throwable ▁{ ▁Execution Strategy Parameters ▁parameters ▁= ▁( ▁Execution Strategy Parameters ▁) ▁allArguments ▁[ ▁1 ▁] ▁; ▁if ▁( ▁parameters ▁== ▁null ▁|| ▁! ▁parameters ▁. ▁getParent ▁( ▁) ▁. ▁getPath ▁( ▁) ▁. ▁equals ▁( ▁Execution Path ▁. ▁rootPath ▁( ▁) ▁) ▁) ▁{ ▁return ▁; ▁} ▁AbstractSpan ▁span ▁= ▁ContextManager ▁. ▁createLocal Span ▁( ▁parameters ▁. ▁getField ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁getName ▁( ▁) ▁) ▁; ▁Tags ▁. ▁LOG IC _ ENDPOINT ▁. ▁set ▁( ▁span ▁, ▁Tags ▁. ▁VAL _ LOCAL _ SPAN _ AS _ LOGIC _ ENDPOINT ▁) ▁; ▁span ▁. ▁setComponent ▁( ▁Components Define ▁. ▁GR AP H QL ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁afterMethod ▁( ▁En hancedInstance ▁objInst ▁, ▁Method ▁method ▁, ▁Object ▁[ ▁] ▁allArguments ▁, ▁Class ▁< ▁? ▁> ▁[ ▁] ▁argumentsTypes ▁, ▁Object ▁ret ▁) ▁throws ▁Throwable ▁{ ▁Execution Strategy Parameters ▁parameters ▁= ▁( ▁Execution Strategy Parameters ▁) ▁allArguments ▁[ ▁1 ▁] ▁; ▁if ▁( ▁parameters ▁== ▁null ▁|| ▁! ▁parameters ▁. ▁getParent ▁( ▁) ▁. ▁getPath ▁( ▁) ▁. ▁equals ▁( ▁Execution Path ▁. ▁rootPath ▁( ▁) ▁) ▁) ▁{ ▁return ▁ret ▁; ▁} ▁ContextManager ▁. ▁stopSpan ▁( ▁) ▁; ▁return ▁ret ▁; ▁} ▁@ ▁Override ▁public ▁void ▁handle MethodException ▁( ▁En hancedInstance ▁objInst ▁, ▁Method ▁method ▁, ▁Object ▁[ ▁] ▁allArguments ▁, ▁Class ▁< ▁? ▁> ▁[ ▁] ▁argumentsTypes ▁, ▁Throwable ▁t ▁) ▁{ ▁Execution Strategy Parameters ▁parameters ▁= ▁( ▁Execution Strategy Parameters ▁) ▁allArguments ▁[ ▁1 ▁] ▁; ▁if ▁( ▁parameters ▁== ▁null ▁|| ▁! ▁parameters ▁. ▁getParent ▁( ▁) ▁. ▁getPath ▁( ▁) ▁. ▁equals ▁( ▁Execution Path ▁. ▁rootPath ▁( ▁) ▁) ▁) ▁{ ▁return ▁; ▁} ▁de al Exception ▁( ▁t ▁) ▁; ▁} ▁private ▁void ▁de al Exception ▁( ▁Throwable ▁throwable ▁) ▁{ ▁AbstractSpan ▁span ▁= ▁ContextManager ▁. ▁activeSpan ▁( ▁) ▁; ▁span ▁. ▁log ▁( ▁throwable ▁) ▁; ▁} ▁}
▁public ▁class ▁Weak Intern er ▁< ▁T ▁> ▁implements ▁Interner ▁< ▁T ▁> ▁{ ▁private ▁final ▁SimpleCache ▁< ▁T ▁, ▁T ▁> ▁cache ▁= ▁new ▁SimpleCache ▁< ▁> ▁( ▁) ▁; ▁@ ▁Override ▁public ▁T ▁intern ▁( ▁T ▁sample ▁) ▁{ ▁if ▁( ▁null ▁== ▁sample ▁) ▁{ ▁return ▁null ▁; ▁} ▁return ▁cache ▁. ▁get ▁( ▁sample ▁, ▁( ▁) ▁-> ▁sample ▁) ▁; ▁} ▁}
▁public ▁class ▁RocksDB Timestamp ed Seg mented Bytes Store ▁extends ▁Abstract R ocksDB Seg mented Bytes Store ▁< ▁Timestamped Segment ▁> ▁{ ▁RocksDB Timestamp ed Seg mented Bytes Store ▁( ▁final ▁String ▁name ▁, ▁final ▁String ▁metrics Scope ▁, ▁final ▁long ▁retention ▁, ▁final ▁long ▁segment Interval ▁, ▁final ▁Key Schema ▁key Schema ▁) ▁{ ▁super ▁( ▁name ▁, ▁metrics Scope ▁, ▁key Schema ▁, ▁new ▁Timestamped Segments ▁( ▁name ▁, ▁metrics Scope ▁, ▁retention ▁, ▁segment Interval ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁P ull With Batch ed P ol ler ▁{ ▁public ▁static ▁void ▁main ▁( ▁final ▁String ▁[ ▁] ▁args ▁) ▁throws ▁Exception ▁{ ▁int ▁batchSize ▁= ▁40 ▁; ▁R ingBuffer ▁< ▁Batch ed P ol ler ▁. ▁Data Event ▁< ▁Object ▁> ▁> ▁ringBuffer ▁= ▁R ingBuffer ▁. ▁create Multi Producer ▁( ▁Batch ed P ol ler ▁. ▁Data Event ▁. ▁factory ▁( ▁) ▁, ▁1024 ▁) ▁; ▁Batch ed P ol ler ▁< ▁Object ▁> ▁pol ler ▁= ▁new ▁Batch ed P ol ler ▁< ▁> ▁( ▁ringBuffer ▁, ▁batchSize ▁) ▁; ▁Object ▁value ▁= ▁pol ler ▁. ▁poll ▁( ▁) ▁; ▁if ▁( ▁null ▁!= ▁value ▁) ▁{ ▁} ▁} ▁static ▁class ▁Batch ed P ol ler ▁< ▁T ▁> ▁{ ▁private ▁final ▁Event P ol ler ▁< ▁Data Event ▁< ▁T ▁> ▁> ▁pol ler ▁; ▁private ▁final ▁Batch edData ▁< ▁T ▁> ▁pol led Data ▁; ▁Batch ed P ol ler ▁( ▁final ▁R ingBuffer ▁< ▁Data Event ▁< ▁T ▁> ▁> ▁ringBuffer ▁, ▁final ▁int ▁batchSize ▁) ▁{ ▁this ▁. ▁pol ler ▁= ▁ringBuffer ▁. ▁new P ol ler ▁( ▁) ▁; ▁ringBuffer ▁. ▁add G ating Sequences ▁( ▁pol ler ▁. ▁getSequence ▁( ▁) ▁) ▁; ▁this ▁. ▁pol led Data ▁= ▁new ▁Batch edData ▁< ▁> ▁( ▁batchSize ▁) ▁; ▁} ▁public ▁T ▁poll ▁( ▁) ▁throws ▁Exception ▁{ ▁if ▁( ▁pol led Data ▁. ▁getMsg Count ▁( ▁) ▁> ▁0 ▁) ▁{ ▁return ▁pol led Data ▁. ▁poll Message ▁( ▁) ▁; ▁} ▁load Next Values ▁( ▁pol ler ▁, ▁pol led Data ▁) ▁; ▁return ▁pol led Data ▁. ▁getMsg Count ▁( ▁) ▁> ▁0 ▁? ▁pol led Data ▁. ▁poll Message ▁( ▁) ▁: ▁null ▁; ▁} ▁private ▁Event P ol ler ▁. ▁P oll State ▁load Next Values ▁( ▁final ▁Event P ol ler ▁< ▁Data Event ▁< ▁T ▁> ▁> ▁pol ler ▁, ▁final ▁Batch edData ▁< ▁T ▁> ▁batch ▁) ▁throws ▁Exception ▁{ ▁return ▁pol ler ▁. ▁poll ▁( ▁( ▁event ▁, ▁sequence ▁, ▁endOf Batch ▁) ▁-> ▁{ ▁T ▁item ▁= ▁event ▁. ▁copyOf Data ▁( ▁) ▁; ▁return ▁item ▁!= ▁null ▁? ▁batch ▁. ▁addData Item ▁( ▁item ▁) ▁: ▁false ▁; ▁} ▁) ▁; ▁} ▁public ▁static ▁class ▁Data Event ▁< ▁T ▁> ▁{ ▁T ▁data ▁; ▁public ▁static ▁< ▁T ▁> ▁Event Factory ▁< ▁Data Event ▁< ▁T ▁> ▁> ▁factory ▁( ▁) ▁{ ▁return ▁Data Event ▁:: ▁new ▁; ▁} ▁public ▁T ▁copyOf Data ▁( ▁) ▁{ ▁return ▁data ▁; ▁} ▁void ▁set ▁( ▁final ▁T ▁d ▁) ▁{ ▁data ▁= ▁d ▁; ▁} ▁} ▁private ▁static ▁class ▁Batch edData ▁< ▁T ▁> ▁{ ▁private ▁int ▁msg High Bound ▁; ▁private ▁final ▁int ▁capacity ▁; ▁private ▁final ▁T ▁[ ▁] ▁data ▁; ▁private ▁int ▁cursor ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁Batch edData ▁( ▁final ▁int ▁size ▁) ▁{ ▁this ▁. ▁capacity ▁= ▁size ▁; ▁data ▁= ▁( ▁T ▁[ ▁] ▁) ▁new ▁Object ▁[ ▁this ▁. ▁capacity ▁] ▁; ▁}
▁return ▁STR ▁; ▁} ▁public ▁static ▁String ▁getMain Color ▁( ▁BufferedImage ▁buffered Image ▁) ▁{ ▁if ▁( ▁buffered Image ▁== ▁null ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁List ▁< ▁String ▁> ▁list ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁y ▁= ▁buffered Image ▁. ▁getMin Y ▁( ▁) ▁; ▁y ▁< ▁buffered Image ▁. ▁getHeight ▁( ▁) ▁; ▁y ▁++ ▁) ▁{ ▁for ▁( ▁int ▁x ▁= ▁buffered Image ▁. ▁getMin X ▁( ▁) ▁; ▁x ▁< ▁buffered Image ▁. ▁getWidth ▁( ▁) ▁; ▁x ▁++ ▁) ▁{ ▁int ▁pixel ▁= ▁buffered Image ▁. ▁getR GB ▁( ▁x ▁, ▁y ▁) ▁; ▁list ▁. ▁add ▁( ▁( ▁( ▁pixel ▁& ▁0 xff 0000 ▁) ▁>> ▁16 ▁) ▁+ ▁STR ▁+ ▁( ▁( ▁pixel ▁& ▁0 xff 00 ▁) ▁>> ▁8 ▁) ▁+ ▁STR ▁+ ▁( ▁pixel ▁& ▁0 xff ▁) ▁) ▁; ▁} ▁} ▁Map ▁< ▁String ▁, ▁Integer ▁> ▁map ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁list ▁. ▁size ▁( ▁) ▁) ▁; ▁for ▁( ▁String ▁string ▁: ▁list ▁) ▁{ ▁Integer ▁integer ▁= ▁map ▁. ▁get ▁( ▁string ▁) ▁; ▁if ▁( ▁integer ▁== ▁null ▁) ▁{ ▁integer ▁= ▁1 ▁; ▁} ▁else ▁{ ▁integer ▁++ ▁; ▁} ▁map ▁. ▁put ▁( ▁string ▁, ▁integer ▁) ▁; ▁} ▁String ▁max ▁= ▁STR ▁; ▁long ▁num ▁= ▁0 ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁Integer ▁> ▁entry ▁: ▁map ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁String ▁key ▁= ▁entry ▁. ▁getKey ▁( ▁) ▁; ▁Integer ▁temp ▁= ▁entry ▁. ▁getValue ▁( ▁) ▁; ▁if ▁( ▁StrUtil ▁. ▁isBlank ▁( ▁max ▁) ▁|| ▁temp ▁> ▁num ▁) ▁{ ▁max ▁= ▁key ▁; ▁num ▁= ▁temp ▁; ▁} ▁} ▁String ▁[ ▁] ▁strings ▁= ▁max ▁. ▁split ▁( ▁STR ▁) ▁; ▁int ▁rgb Length ▁= ▁3 ▁; ▁if ▁( ▁strings ▁. ▁length ▁== ▁rgb Length ▁) ▁{ ▁return ▁Img Util ▁. ▁to Hex ▁( ▁Integer ▁. ▁parseInt ▁( ▁strings ▁[ ▁0 ▁] ▁) ▁, ▁Integer ▁. ▁parseInt ▁( ▁strings ▁[ ▁1 ▁] ▁) ▁, ▁Integer ▁. ▁parseInt ▁( ▁strings ▁[ ▁2 ▁] ▁) ▁) ▁; ▁} ▁return ▁STR ▁; ▁} ▁private ▁static ▁boolean ▁file Type Validation ▁( ▁File ▁input ▁, ▁String ▁[ ▁] ▁images Type ▁) ▁{ ▁if ▁( ▁! ▁input ▁. ▁exists ▁( ▁) ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁String ▁type ▁= ▁FileType Util ▁. ▁getType ▁( ▁input ▁) ▁; ▁if ▁( ▁! ▁ArrayUtil ▁. ▁contains ▁( ▁images Type ▁, ▁type ▁) ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁StrUtil ▁. ▁format ▁( ▁STR ▁, ▁type ▁) ▁) ▁; ▁} ▁return ▁false ▁; ▁} ▁}
▁IndexSettings ▁settings ▁= ▁new ▁IndexSettings ▁( ▁IndexMetadata ▁. ▁builder ▁( ▁STR ▁) ▁. ▁settings ▁( ▁indexSettings ▁) ▁. ▁build ▁( ▁) ▁, ▁Settings ▁. ▁EMPTY ▁) ▁; ▁Mockito ▁. ▁when ▁( ▁context ▁. ▁index ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁settings ▁. ▁getIndex ▁( ▁) ▁) ▁; ▁Mockito ▁. ▁when ▁( ▁context ▁. ▁getShard Id ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁0 ▁) ▁; ▁Mockito ▁. ▁when ▁( ▁context ▁. ▁getIndex Settings ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁settings ▁) ▁; ▁Mockito ▁. ▁when ▁( ▁context ▁. ▁getField Type ▁( ▁Id FieldMapper ▁. ▁NAME ▁) ▁) ▁. ▁thenReturn ▁( ▁new ▁Keyword FieldMapper ▁. ▁Keyword FieldType ▁( ▁Id FieldMapper ▁. ▁NAME ▁) ▁) ▁; ▁Mockito ▁. ▁when ▁( ▁context ▁. ▁is Field Mapped ▁( ▁Id FieldMapper ▁. ▁NAME ▁) ▁) ▁. ▁thenReturn ▁( ▁true ▁) ▁; ▁builder ▁. ▁to Function ▁( ▁context ▁) ▁; ▁assert Warnings ▁( ▁STR ▁) ▁; ▁} ▁public ▁void ▁test Random Score Function With Seed ▁( ▁) ▁throws ▁Exception ▁{ ▁Random Score Function Builder ▁builder ▁= ▁new ▁Random Score Function Builder ▁( ▁) ▁; ▁builder ▁. ▁setField ▁( ▁STR ▁) ▁; ▁builder ▁. ▁seed ▁( ▁42 ▁) ▁; ▁Search ExecutionContext ▁context ▁= ▁Mockito ▁. ▁mock ▁( ▁Search ExecutionContext ▁. ▁class ▁) ▁; ▁Settings ▁indexSettings ▁= ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁IndexMetadata ▁. ▁SETTING _ VERSION _ CREATED ▁, ▁Version ▁. ▁CURRENT ▁) ▁. ▁put ▁( ▁IndexMetadata ▁. ▁SETTING _ NUMBER _ OF _ SHAR DS ▁, ▁1 ▁) ▁. ▁put ▁( ▁IndexMetadata ▁. ▁SETTING _ NUMBER _ OF _ REP LIC AS ▁, ▁1 ▁) ▁. ▁build ▁( ▁) ▁; ▁IndexSettings ▁settings ▁= ▁new ▁IndexSettings ▁( ▁IndexMetadata ▁. ▁builder ▁( ▁STR ▁) ▁. ▁settings ▁( ▁indexSettings ▁) ▁. ▁build ▁( ▁) ▁, ▁Settings ▁. ▁EMPTY ▁) ▁; ▁Mockito ▁. ▁when ▁( ▁context ▁. ▁index ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁settings ▁. ▁getIndex ▁( ▁) ▁) ▁; ▁Mockito ▁. ▁when ▁( ▁context ▁. ▁getShard Id ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁0 ▁) ▁; ▁Mockito ▁. ▁when ▁( ▁context ▁. ▁getIndex Settings ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁settings ▁) ▁; ▁MappedFieldType ▁ft ▁= ▁new ▁Number FieldMapper ▁. ▁Number FieldType ▁( ▁STR ▁, ▁Number Type ▁. ▁LONG ▁) ▁; ▁Mockito ▁. ▁when ▁( ▁context ▁. ▁getField Type ▁( ▁STR ▁) ▁) ▁. ▁thenReturn ▁( ▁ft ▁) ▁; ▁Mockito ▁. ▁when ▁( ▁context ▁. ▁is Field Mapped ▁( ▁STR ▁) ▁) ▁. ▁thenReturn ▁( ▁true ▁) ▁; ▁builder ▁. ▁to Function ▁( ▁context ▁) ▁; ▁} ▁}
▁if ▁( ▁this ▁. ▁agent Type ▁== ▁Agent Type ▁. ▁P LUGIN _ TEST ▁) ▁{ ▁properties ▁. ▁put ▁( ▁Default Pro filerConfig ▁. ▁PRO FI LER _ INTERCEPTOR _ EXCEPTION _ PROP AG ATE ▁, ▁STR ▁) ▁; ▁} ▁final ▁String ▁import Plugin Ids ▁= ▁StringUtils ▁. ▁default String ▁( ▁this ▁. ▁agent Args ▁. ▁get ▁( ▁Agent Parameter ▁. ▁IMP ORT _ P LUGIN ▁) ▁, ▁STR ▁) ▁; ▁properties ▁. ▁put ▁( ▁Default Pro filerConfig ▁. ▁IMP ORT _ P LUGIN ▁, ▁import Plugin Ids ▁) ▁; ▁return ▁properties ▁; ▁} ▁private ▁Simple Property ▁copy Java SystemProperty ▁( ▁) ▁{ ▁return ▁new ▁Property Snapshot ▁( ▁System ▁. ▁getProperties ▁( ▁) ▁) ▁; ▁} ▁private ▁Simple Property ▁copy OS Env Variables ▁( ▁) ▁{ ▁return ▁new ▁Os Env Simple Property ▁( ▁System ▁. ▁getenv ▁( ▁) ▁) ▁; ▁} ▁private ▁ClassLoader ▁create ClassLoader ▁( ▁final ▁String ▁name ▁, ▁final ▁URL ▁[ ▁] ▁urls ▁, ▁final ▁ClassLoader ▁parent ClassLoader ▁) ▁{ ▁if ▁( ▁System ▁. ▁getSecurity Manager ▁( ▁) ▁!= ▁null ▁) ▁{ ▁return ▁Access Controller ▁. ▁doPrivileged ▁( ▁new ▁Privileged Action ▁< ▁ClassLoader ▁> ▁( ▁) ▁{ ▁public ▁ClassLoader ▁run ▁( ▁) ▁{ ▁return ▁Pinpoint ClassLoader Factory ▁. ▁create ClassLoader ▁( ▁name ▁, ▁urls ▁, ▁parent ClassLoader ▁, ▁Profiler Libs ▁. ▁P IN POINT _ PRO FI LER _ CLASS ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁else ▁{ ▁return ▁Pinpoint ClassLoader Factory ▁. ▁create ClassLoader ▁( ▁name ▁, ▁urls ▁, ▁parent ClassLoader ▁, ▁Profiler Libs ▁. ▁P IN POINT _ PRO FI LER _ CLASS ▁) ▁; ▁} ▁} ▁private ▁String ▁getB oot Class ▁( ▁) ▁{ ▁if ▁( ▁is Test Agent ▁( ▁) ▁) ▁{ ▁return ▁P LUGIN _ TEST _ BO OT _ CLASS ▁; ▁} ▁return ▁BO OT _ CLASS ▁; ▁} ▁private ▁boolean ▁is Test Agent ▁( ▁) ▁{ ▁final ▁String ▁agent Type ▁= ▁getAgent Type ▁( ▁) ▁; ▁return ▁P LUGIN _ TEST _ AGENT ▁. ▁equals IgnoreCase ▁( ▁agent Type ▁) ▁; ▁} ▁private ▁String ▁getAgent Type ▁( ▁) ▁{ ▁String ▁agent Type ▁= ▁agent Args ▁. ▁get ▁( ▁AGENT _ TYPE ▁) ▁; ▁if ▁( ▁agent Type ▁== ▁null ▁) ▁{ ▁return ▁DEFAULT _ AGENT ▁; ▁} ▁return ▁agent Type ▁; ▁} ▁private ▁Agent Option ▁create Agent Option ▁( ▁String ▁agentId ▁, ▁String ▁agent Name ▁, ▁String ▁applicationName ▁, ▁boolean ▁is Container ▁, ▁ProfilerConfig ▁profilerConfig ▁, ▁Instrumentation ▁instrumentation ▁, ▁List ▁< ▁String ▁> ▁plugin Jars ▁, ▁Agent Directory ▁agent Directory ▁) ▁{ ▁List ▁< ▁String ▁> ▁bootstrap Jar Paths ▁= ▁agent Directory ▁. ▁getB oot Dir ▁( ▁) ▁. ▁toList ▁( ▁) ▁; ▁return ▁new ▁Default Agent Option ▁( ▁instrumentation ▁, ▁agentId ▁, ▁agent Name ▁, ▁applicationName ▁, ▁is Container ▁, ▁profilerConfig ▁, ▁plugin Jars ▁, ▁bootstrap Jar Paths ▁) ▁; ▁} ▁void ▁set SystemProperty ▁( ▁Simple Property ▁system Property ▁) ▁{ ▁this ▁. ▁system Property ▁= ▁system Property ▁; ▁}
▁this ▁. ▁instrument ▁= ▁context ▁. ▁getEngine ▁( ▁) ▁. ▁getInstrument s ▁( ▁) ▁. ▁get ▁( ▁Input FilterTest Instrument ▁. ▁ID ▁) ▁. ▁lookup ▁( ▁Input FilterTest Instrument ▁. ▁class ▁) ▁; ▁this ▁. ▁instrument er ▁= ▁instrument ▁. ▁environment ▁. ▁getInstrument er ▁( ▁) ▁; ▁this ▁. ▁events ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁this ▁. ▁factory ▁= ▁new ▁Collect Events Factory ▁( ▁) ▁; ▁} ▁private ▁final ▁Set ▁< ▁org ▁. ▁g raal vm ▁. ▁p olyglot ▁. ▁Source ▁> ▁sources ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁protected ▁final ▁void ▁execute ▁( ▁org ▁. ▁g raal vm ▁. ▁p olyglot ▁. ▁Source ▁source ▁) ▁{ ▁context ▁. ▁eval ▁( ▁source ▁) ▁; ▁if ▁( ▁error ▁!= ▁null ▁) ▁{ ▁throw ▁error ▁; ▁} ▁sources ▁. ▁add ▁( ▁source ▁) ▁; ▁} ▁protected ▁final ▁void ▁execute ▁( ▁String ▁expression ▁) ▁{ ▁execute ▁( ▁create Source ▁( ▁expression ▁) ▁) ▁; ▁} ▁protected ▁static ▁final ▁org ▁. ▁g raal vm ▁. ▁p olyglot ▁. ▁Source ▁create Source ▁( ▁String ▁expression ▁) ▁{ ▁return ▁org ▁. ▁g raal vm ▁. ▁p olyglot ▁. ▁Source ▁. ▁create ▁( ▁Instrumentation Test Language ▁. ▁ID ▁, ▁expression ▁) ▁; ▁} ▁protected ▁static ▁void ▁assert Characters ▁( ▁Event ▁e ▁, ▁String ▁s ▁) ▁{ ▁assertEquals ▁( ▁s ▁, ▁e ▁. ▁context ▁. ▁getIn strumented Source Section ▁( ▁) ▁. ▁get Characters ▁( ▁) ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁protected ▁final ▁void ▁assert On ▁( ▁Event Kind ▁expected Kind ▁) ▁{ ▁assert On ▁( ▁expected Kind ▁, ▁( ▁e ▁) ▁-> ▁{ ▁} ▁) ▁; ▁} ▁protected ▁final ▁void ▁assert On ▁( ▁Event Kind ▁expected Kind ▁, ▁Consumer ▁< ▁Event ▁> ▁verify ▁) ▁{ ▁assertFalse ▁( ▁STR ▁, ▁events ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁Event ▁event ▁= ▁events ▁. ▁remove ▁( ▁0 ▁) ▁; ▁assertEquals ▁( ▁expected Kind ▁, ▁event ▁. ▁kind ▁) ▁; ▁verify ▁. ▁accept ▁( ▁event ▁) ▁; ▁} ▁protected ▁final ▁void ▁assert All Events Consumed ▁( ▁) ▁{ ▁assertTrue ▁( ▁STR ▁+ ▁events ▁, ▁events ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁} ▁@ ▁After ▁public ▁final ▁void ▁tearDown ▁( ▁) ▁{ ▁context ▁. ▁close ▁( ▁) ▁; ▁assert All Events Consumed ▁( ▁) ▁; ▁} ▁enum ▁Event Kind ▁{ ▁EN TER ▁, ▁INPUT _ VALUE ▁, ▁RETURN _ VALUE ▁, ▁UN W IND ▁, ▁} ▁protected ▁static ▁class ▁Event ▁{ ▁public ▁final ▁Event Kind ▁kind ▁; ▁public ▁final ▁VirtualFrame ▁frame ▁; ▁public ▁final ▁Event Context ▁context ▁; ▁public ▁final ▁Object ▁result ▁; ▁public ▁final ▁Object ▁[ ▁] ▁inputs ▁; ▁public ▁final ▁int ▁input Value Index ▁; ▁public ▁final ▁Object ▁input Value ▁; ▁public ▁final ▁Event Context ▁[ ▁] ▁input Contexts ▁; ▁public ▁final ▁Object ▁unw ind Value ▁; ▁Event ▁( ▁Event Kind ▁kind ▁, ▁Event Context ▁context ▁, ▁VirtualFrame ▁frame ▁, ▁Object ▁[ ▁] ▁inputs ▁, ▁Object ▁result ▁, ▁int ▁index ▁, ▁Object ▁input Value ▁, ▁Event Context ▁[ ▁] ▁input Contexts ▁, ▁Object ▁unw ind Value ▁) ▁{ ▁this ▁. ▁kind ▁= ▁kind ▁; ▁this ▁. ▁context ▁= ▁context ▁;
▁System ▁. ▁arraycopy ▁( ▁result ▁. ▁toArray ▁( ▁) ▁, ▁0 ▁, ▁result Array ▁, ▁0 ▁, ▁result ▁. ▁size ▁( ▁) ▁) ▁; ▁return ▁new ▁Value Ref ▁. ▁TypedValue Holder Value Ref ▁( ▁new ▁TypedValue ▁( ▁result Array ▁) ▁, ▁this ▁) ▁; ▁} ▁return ▁new ▁Value Ref ▁. ▁TypedValue Holder Value Ref ▁( ▁new ▁TypedValue ▁( ▁result ▁) ▁, ▁this ▁) ▁; ▁} ▁if ▁( ▁operand ▁== ▁null ▁) ▁{ ▁if ▁( ▁this ▁. ▁nullSafe ▁) ▁{ ▁return ▁Value Ref ▁. ▁NullValue Ref ▁. ▁INSTANCE ▁; ▁} ▁throw ▁new ▁Spel Evalu ationException ▁( ▁getStart Position ▁( ▁) ▁, ▁Spel Message ▁. ▁PRO JE CTION _ NOT _ SUPPORTED _ ON _ TYPE ▁, ▁STR ▁) ▁; ▁} ▁throw ▁new ▁Spel Evalu ationException ▁( ▁getStart Position ▁( ▁) ▁, ▁Spel Message ▁. ▁PRO JE CTION _ NOT _ SUPPORTED _ ON _ TYPE ▁, ▁operand ▁. ▁getClass ▁( ▁) ▁. ▁getName ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString AST ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁getChild ▁( ▁0 ▁) ▁. ▁toString AST ▁( ▁) ▁+ ▁STR ▁; ▁} ▁private ▁Class ▁< ▁? ▁> ▁determine Common Type ▁( ▁@ ▁Nullable ▁Class ▁< ▁? ▁> ▁old Type ▁, ▁Class ▁< ▁? ▁> ▁new Type ▁) ▁{ ▁if ▁( ▁old Type ▁== ▁null ▁) ▁{ ▁return ▁new Type ▁; ▁} ▁if ▁( ▁old Type ▁. ▁isAssignable From ▁( ▁new Type ▁) ▁) ▁{ ▁return ▁old Type ▁; ▁} ▁Class ▁< ▁? ▁> ▁next Type ▁= ▁new Type ▁; ▁while ▁( ▁next Type ▁!= ▁Object ▁. ▁class ▁) ▁{ ▁if ▁( ▁next Type ▁. ▁isAssignable From ▁( ▁old Type ▁) ▁) ▁{ ▁return ▁next Type ▁; ▁} ▁next Type ▁= ▁next Type ▁. ▁getSuperclass ▁( ▁) ▁; ▁} ▁for ▁( ▁Class ▁< ▁? ▁> ▁next Interface ▁: ▁ClassUtils ▁. ▁getAll Interfaces For Class As Set ▁( ▁new Type ▁) ▁) ▁{ ▁if ▁( ▁next Interface ▁. ▁isAssignable From ▁( ▁old Type ▁) ▁) ▁{ ▁return ▁next Interface ▁; ▁} ▁} ▁return ▁Object ▁. ▁class ▁; ▁} ▁}
▁if ▁( ▁old Version ▁< ▁A TT A CH MENT _ D IME N SION S ▁) ▁{ ▁db ▁. ▁exec SQL ▁( ▁STR ▁) ▁; ▁db ▁. ▁exec SQL ▁( ▁STR ▁) ▁; ▁} ▁if ▁( ▁old Version ▁< ▁ QUO TED _ REP LI ES ▁) ▁{ ▁db ▁. ▁exec SQL ▁( ▁STR ▁) ▁; ▁db ▁. ▁exec SQL ▁( ▁STR ▁) ▁; ▁db ▁. ▁exec SQL ▁( ▁STR ▁) ▁; ▁db ▁. ▁exec SQL ▁( ▁STR ▁) ▁; ▁db ▁. ▁exec SQL ▁( ▁STR ▁) ▁; ▁} ▁if ▁( ▁old Version ▁< ▁SHAR ED _ CON TACT S ▁) ▁{ ▁db ▁. ▁exec SQL ▁( ▁STR ▁) ▁; ▁} ▁if ▁( ▁old Version ▁< ▁FULL _ TEXT _ SEARCH ▁) ▁{ ▁db ▁. ▁exec SQL ▁( ▁STR ▁) ▁; ▁db ▁. ▁exec SQL ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁; ▁db ▁. ▁exec SQL ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁; ▁db ▁. ▁exec SQL ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁; ▁db ▁. ▁exec SQL ▁( ▁STR ▁) ▁; ▁db ▁. ▁exec SQL ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁; ▁db ▁. ▁exec SQL ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁; ▁db ▁. ▁exec SQL ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁; ▁Log ▁. ▁i ▁( ▁TAG ▁, ▁STR ▁) ▁; ▁long ▁start ▁= ▁SystemClock ▁. ▁elapsed Real time ▁( ▁) ▁; ▁db ▁. ▁exec SQL ▁( ▁STR ▁) ▁; ▁long ▁s ms Finished ▁= ▁SystemClock ▁. ▁elapsed Real time ▁( ▁) ▁; ▁Log ▁. ▁i ▁( ▁TAG ▁, ▁STR ▁+ ▁( ▁s ms Finished ▁- ▁start ▁) ▁+ ▁STR ▁) ▁; ▁db ▁. ▁exec SQL ▁( ▁STR ▁) ▁; ▁long ▁m ms Finished ▁= ▁SystemClock ▁. ▁elapsed Real time ▁( ▁) ▁; ▁Log ▁. ▁i ▁( ▁TAG ▁, ▁STR ▁+ ▁( ▁m ms Finished ▁- ▁s ms Finished ▁) ▁+ ▁STR ▁) ▁; ▁Log ▁. ▁i ▁( ▁TAG ▁, ▁STR ▁+ ▁( ▁m ms Finished ▁- ▁start ▁) ▁+ ▁STR ▁) ▁; ▁} ▁if ▁( ▁old Version ▁< ▁BAD _ IMP ORT _ C LEAN UP ▁) ▁{ ▁String ▁trimmed Condition ▁= ▁STR ▁; ▁db ▁. ▁delete ▁( ▁STR ▁, ▁STR ▁+ ▁trimmed Condition ▁, ▁null ▁) ▁; ▁String ▁[ ▁] ▁columns ▁= ▁new ▁String ▁[ ▁] ▁{ ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁} ▁; ▁try ▁( ▁Cursor ▁cursor ▁= ▁db ▁. ▁query ▁( ▁STR ▁, ▁columns ▁, ▁STR ▁+ ▁trimmed Condition ▁, ▁null ▁, ▁null ▁, ▁null ▁, ▁null ▁) ▁) ▁{ ▁while ▁( ▁cursor ▁!= ▁null ▁&& ▁cursor ▁. ▁moveTo Next ▁( ▁) ▁) ▁{ ▁db ▁. ▁delete ▁( ▁STR ▁, ▁STR ▁, ▁new ▁String ▁[ ▁] ▁{ ▁String ▁. ▁valueOf ▁( ▁cursor ▁. ▁getLong ▁( ▁0 ▁) ▁) ▁, ▁String ▁. ▁valueOf ▁( ▁cursor ▁. ▁getLong ▁( ▁1 ▁) ▁) ▁} ▁) ▁; ▁String ▁data ▁= ▁cursor ▁. ▁getString ▁( ▁2 ▁) ▁; ▁String ▁th umbnail ▁= ▁cursor ▁. ▁getString ▁( ▁3 ▁) ▁;
▁@ ▁Override ▁public ▁void ▁check Can Create View With Select From Columns ▁( ▁Connector Transaction Handle ▁transaction Handle ▁, ▁Connector Identity ▁identity ▁, ▁AccessControl Context ▁context ▁, ▁SchemaTableName ▁tableName ▁, ▁Set ▁< ▁String ▁> ▁columnNames ▁) ▁{ ▁delegate ▁( ▁) ▁. ▁check Can Create View With Select From Columns ▁( ▁transaction Handle ▁, ▁identity ▁, ▁context ▁, ▁tableName ▁, ▁columnNames ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁check Can Set Catalog Session Property ▁( ▁Connector Transaction Handle ▁transaction Handle ▁, ▁Connector Identity ▁identity ▁, ▁AccessControl Context ▁context ▁, ▁String ▁propertyName ▁) ▁{ ▁delegate ▁( ▁) ▁. ▁check Can Set Catalog Session Property ▁( ▁transaction Handle ▁, ▁identity ▁, ▁context ▁, ▁propertyName ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁check Can Grant Table Privilege ▁( ▁Connector Transaction Handle ▁transaction Handle ▁, ▁Connector Identity ▁identity ▁, ▁AccessControl Context ▁context ▁, ▁Privilege ▁privilege ▁, ▁SchemaTableName ▁tableName ▁, ▁Presto Principal ▁g rantee ▁, ▁boolean ▁with Grant Option ▁) ▁{ ▁delegate ▁( ▁) ▁. ▁check Can Grant Table Privilege ▁( ▁transaction Handle ▁, ▁identity ▁, ▁context ▁, ▁privilege ▁, ▁tableName ▁, ▁g rantee ▁, ▁with Grant Option ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁check Can Re voke Table Privilege ▁( ▁Connector Transaction Handle ▁transaction Handle ▁, ▁Connector Identity ▁identity ▁, ▁AccessControl Context ▁context ▁, ▁Privilege ▁privilege ▁, ▁SchemaTableName ▁tableName ▁, ▁Presto Principal ▁re vok ee ▁, ▁boolean ▁grant Option For ▁) ▁{ ▁delegate ▁( ▁) ▁. ▁check Can Grant Table Privilege ▁( ▁transaction Handle ▁, ▁identity ▁, ▁context ▁, ▁privilege ▁, ▁tableName ▁, ▁re vok ee ▁, ▁grant Option For ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁check Can Create Role ▁( ▁Connector Transaction Handle ▁transaction Handle ▁, ▁Connector Identity ▁identity ▁, ▁AccessControl Context ▁context ▁, ▁String ▁role ▁, ▁Optional ▁< ▁Presto Principal ▁> ▁grant or ▁) ▁{ ▁delegate ▁( ▁) ▁. ▁check Can Create Role ▁( ▁transaction Handle ▁, ▁identity ▁, ▁context ▁, ▁role ▁, ▁grant or ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁check Can Drop Role ▁( ▁Connector Transaction Handle ▁transaction Handle ▁, ▁Connector Identity ▁identity ▁, ▁AccessControl Context ▁context ▁, ▁String ▁role ▁) ▁{ ▁delegate ▁( ▁) ▁. ▁check Can Drop Role ▁( ▁transaction Handle ▁, ▁identity ▁, ▁context ▁, ▁role ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁check Can Grant Roles ▁( ▁Connector Transaction Handle ▁transaction Handle ▁, ▁Connector Identity ▁identity ▁, ▁AccessControl Context ▁context ▁, ▁Set ▁< ▁String ▁> ▁roles ▁, ▁Set ▁< ▁Presto Principal ▁> ▁g ran te es ▁, ▁boolean ▁with Admin Option ▁, ▁Optional ▁< ▁Presto Principal ▁> ▁grant or ▁, ▁String ▁catalogName ▁) ▁{ ▁delegate ▁( ▁) ▁. ▁check Can Grant Roles ▁( ▁transaction Handle ▁, ▁identity ▁, ▁context ▁, ▁roles ▁, ▁g ran te es ▁, ▁with Admin Option ▁, ▁grant or ▁, ▁catalogName ▁) ▁; ▁}
▁@ ▁RunWith ▁( ▁Th e ories ▁. ▁class ▁) ▁public ▁class ▁Identity Value Profile Test ▁{ ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁private ▁static ▁Integer ▁new Integer ▁( ▁int ▁value ▁) ▁{ ▁return ▁new ▁Integer ▁( ▁value ▁) ▁; ▁} ▁@ ▁Data Point ▁public ▁static ▁final ▁String ▁O 1 ▁= ▁new ▁String ▁( ▁) ▁; ▁@ ▁Data Point ▁public ▁static ▁final ▁String ▁O 2 ▁= ▁O 1 ▁; ▁@ ▁Data Point ▁public ▁static ▁final ▁Object ▁O 3 ▁= ▁new ▁Object ▁( ▁) ▁; ▁@ ▁Data Point ▁public ▁static ▁final ▁Integer ▁O 4 ▁= ▁new Integer ▁( ▁1 ▁) ▁; ▁@ ▁Data Point ▁public ▁static ▁final ▁Integer ▁O 5 ▁= ▁null ▁; ▁private ▁Value Profile ▁profile ▁; ▁@ ▁Before ▁public ▁void ▁create ▁( ▁) ▁{ ▁profile ▁= ▁( ▁Value Profile ▁) ▁invoke Static ▁( ▁load Relative ▁( ▁Identity Value Profile Test ▁. ▁class ▁, ▁STR ▁) ▁, ▁STR ▁) ▁; ▁} ▁private ▁static ▁boolean ▁is Generic ▁( ▁Value Profile ▁profile ▁) ▁{ ▁return ▁( ▁boolean ▁) ▁invoke ▁( ▁profile ▁, ▁STR ▁) ▁; ▁} ▁private ▁static ▁boolean ▁isUn initialized ▁( ▁Value Profile ▁profile ▁) ▁{ ▁return ▁( ▁boolean ▁) ▁invoke ▁( ▁profile ▁, ▁STR ▁) ▁; ▁} ▁private ▁static ▁Object ▁getCached Value ▁( ▁Value Profile ▁profile ▁) ▁{ ▁return ▁invoke ▁( ▁profile ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Initial ▁( ▁) ▁throws ▁Exception ▁{ ▁assertThat ▁( ▁is Generic ▁( ▁profile ▁) ▁, ▁is ▁( ▁false ▁) ▁) ▁; ▁assertThat ▁( ▁isUn initialized ▁( ▁profile ▁) ▁, ▁is ▁( ▁true ▁) ▁) ▁; ▁profile ▁. ▁toString ▁( ▁) ▁; ▁} ▁@ ▁Th e ory ▁public ▁void ▁test Disabled ▁( ▁Object ▁value ▁) ▁{ ▁Value Profile ▁p ▁= ▁( ▁Value Profile ▁) ▁get Static Field ▁( ▁load Relative ▁( ▁Identity Value Profile Test ▁. ▁class ▁, ▁STR ▁) ▁, ▁STR ▁) ▁; ▁assertThat ▁( ▁p ▁. ▁profile ▁( ▁value ▁) ▁, ▁is ▁( ▁value ▁) ▁) ▁; ▁p ▁. ▁toString ▁( ▁) ▁; ▁} ▁@ ▁Th e ory ▁public ▁void ▁test Profile One ▁( ▁Object ▁value ▁) ▁throws ▁Exception ▁{ ▁Object ▁result ▁= ▁profile ▁. ▁profile ▁( ▁value ▁) ▁; ▁assertThat ▁( ▁result ▁, ▁is ▁( ▁value ▁) ▁) ▁; ▁assertEquals ▁( ▁getCached Value ▁( ▁profile ▁) ▁, ▁value ▁) ▁; ▁assertThat ▁( ▁isUn initialized ▁( ▁profile ▁) ▁, ▁is ▁( ▁false ▁) ▁) ▁; ▁profile ▁. ▁toString ▁( ▁) ▁; ▁} ▁@ ▁Th e ory ▁public ▁void ▁test Profile Two ▁( ▁Object ▁value 0 ▁, ▁Object ▁value 1 ▁) ▁throws ▁Exception ▁{ ▁Object ▁result 0 ▁= ▁profile ▁. ▁profile ▁( ▁value 0 ▁) ▁; ▁Object ▁result 1 ▁= ▁profile ▁. ▁profile ▁( ▁value 1 ▁) ▁; ▁assertThat ▁( ▁result 0 ▁, ▁is ▁( ▁value 0 ▁) ▁) ▁; ▁assertThat ▁( ▁result 1 ▁, ▁is ▁( ▁value 1 ▁) ▁) ▁; ▁if ▁( ▁value 0 ▁== ▁value 1 ▁) ▁{ ▁assertThat ▁( ▁getCached Value ▁( ▁profile ▁) ▁, ▁is ▁( ▁value 0 ▁) ▁) ▁; ▁assertThat ▁( ▁is Generic ▁( ▁profile ▁) ▁, ▁is ▁( ▁false ▁) ▁) ▁; ▁}
▁for ▁( ▁Label Atom ▁label ▁: ▁assigned Labels ▁) ▁{ ▁if ▁( ▁first ▁) ▁{ ▁listener ▁. ▁getLogger ▁( ▁) ▁. ▁print ▁( ▁STR ▁) ▁; ▁first ▁= ▁false ▁; ▁} ▁else ▁{ ▁listener ▁. ▁getLogger ▁( ▁) ▁. ▁print ▁( ▁CHAR ▁) ▁; ▁} ▁listener ▁. ▁getLogger ▁( ▁) ▁. ▁print ▁( ▁label ▁. ▁getName ▁( ▁) ▁) ▁; ▁} ▁listener ▁. ▁getLogger ▁( ▁) ▁. ▁print ▁( ▁CHAR ▁) ▁; ▁} ▁} ▁} ▁else ▁{ ▁listener ▁. ▁getLogger ▁( ▁) ▁. ▁print ▁( ▁Messages ▁. ▁AbstractBuild _ Build ing ▁( ▁) ▁) ▁; ▁} ▁le ase ▁= ▁dec ide Workspace ▁( ▁node ▁, ▁Computer ▁. ▁current Computer ▁( ▁) ▁. ▁getWorkspace List ▁( ▁) ▁) ▁; ▁workspace ▁= ▁le ase ▁. ▁path ▁. ▁getRemote ▁( ▁) ▁; ▁listener ▁. ▁getLogger ▁( ▁) ▁. ▁println ▁( ▁Messages ▁. ▁AbstractBuild _ Build ing In Workspace ▁( ▁workspace ▁) ▁) ▁; ▁for ▁( ▁Workspace Listener ▁wl ▁: ▁Workspace Listener ▁. ▁all ▁( ▁) ▁) ▁{ ▁wl ▁. ▁before Use ▁( ▁AbstractBuild ▁. ▁this ▁, ▁le ase ▁. ▁path ▁, ▁listener ▁) ▁; ▁} ▁getProject ▁( ▁) ▁. ▁getSc m Checkout Strategy ▁( ▁) ▁. ▁pre Checkout ▁( ▁AbstractBuild ▁. ▁this ▁, ▁launcher ▁, ▁this ▁. ▁listener ▁) ▁; ▁getProject ▁( ▁) ▁. ▁getSc m Checkout Strategy ▁( ▁) ▁. ▁checkout ▁( ▁this ▁) ▁; ▁if ▁( ▁! ▁pre Build ▁( ▁listener ▁, ▁project ▁. ▁getProperties ▁( ▁) ▁) ▁) ▁return ▁Result ▁. ▁FAILURE ▁; ▁result ▁= ▁do Run ▁( ▁listener ▁) ▁; ▁} ▁finally ▁{ ▁if ▁( ▁! ▁tearDown Marker ▁. ▁t or n Down ▁) ▁{ ▁result ▁= ▁Result ▁. ▁combine ▁( ▁result ▁, ▁tearDown Build Environment s ▁( ▁listener ▁) ▁) ▁; ▁} ▁} ▁if ▁( ▁node ▁. ▁getChannel ▁( ▁) ▁!= ▁null ▁) ▁{ ▁launcher ▁. ▁kill ▁( ▁get Character istic Env Vars ▁( ▁) ▁) ▁; ▁} ▁if ▁( ▁result ▁== ▁null ▁) ▁result ▁= ▁getResult ▁( ▁) ▁; ▁if ▁( ▁result ▁== ▁null ▁) ▁result ▁= ▁Result ▁. ▁SUCCESS ▁; ▁return ▁result ▁; ▁} ▁private ▁Result ▁tearDown Build Environment s ▁( ▁@ ▁NonNull ▁Build Listener ▁listener ▁) ▁throws ▁Interrupted Exception ▁{ ▁Result ▁result ▁= ▁null ▁; ▁Interrupted Exception ▁first Interrupted Exception ▁= ▁null ▁; ▁for ▁( ▁int ▁i ▁= ▁build Environment s ▁. ▁size ▁( ▁) ▁- ▁1 ▁; ▁i ▁>= ▁0 ▁; ▁i ▁-- ▁) ▁{ ▁final ▁Environment ▁environment ▁= ▁build Environment s ▁. ▁get ▁( ▁i ▁) ▁; ▁try ▁{ ▁if ▁( ▁! ▁environment ▁. ▁tearDown ▁( ▁AbstractBuild ▁. ▁this ▁, ▁listener ▁) ▁) ▁{ ▁result ▁= ▁Result ▁. ▁combine ▁( ▁result ▁, ▁Result ▁. ▁FAILURE ▁) ▁; ▁} ▁} ▁catch ▁( ▁Interrupted Exception ▁e ▁) ▁{ ▁if ▁( ▁first Interrupted Exception ▁== ▁null ▁) ▁{ ▁first Interrupted Exception ▁= ▁e ▁; ▁} ▁else ▁{ ▁Functions ▁. ▁printStackTrace ▁( ▁e ▁, ▁listener ▁. ▁error ▁( ▁STR ▁+ ▁e ▁. ▁getMessage ▁( ▁) ▁) ▁) ▁; ▁} ▁}
▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁final ▁class ▁Espresso Exception ▁extends ▁Runtime Exception ▁implements ▁com ▁. ▁oracle ▁. ▁truffle ▁. ▁api ▁. ▁Truffle Exception ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁- ▁7 6 679 5 75 75 37 74 19 5 20 L ▁; ▁private ▁final ▁StaticObject ▁exception ▁; ▁private ▁Espresso Exception ▁( ▁@ ▁JavaType ▁( ▁Throwable ▁. ▁class ▁) ▁StaticObject ▁throwable ▁) ▁{ ▁assert ▁StaticObject ▁. ▁notNull ▁( ▁throwable ▁) ▁; ▁assert ▁Inter preter To VM ▁. ▁instanceOf ▁( ▁throwable ▁, ▁throwable ▁. ▁getK lass ▁( ▁) ▁. ▁getMeta ▁( ▁) ▁. ▁java _ lang _ Throwable ▁) ▁; ▁this ▁. ▁exception ▁= ▁throwable ▁; ▁} ▁public ▁static ▁Espresso Exception ▁wrap ▁( ▁@ ▁JavaType ▁( ▁Throwable ▁. ▁class ▁) ▁StaticObject ▁throwable ▁, ▁Meta ▁meta ▁) ▁{ ▁if ▁( ▁throwable ▁. ▁is Foreign Object ▁( ▁) ▁) ▁{ ▁return ▁new ▁Espresso Exception ▁( ▁throwable ▁) ▁; ▁} ▁Espresso Exception ▁wrapper ▁= ▁( ▁Espresso Exception ▁) ▁meta ▁. ▁H IDDEN _ EXCEPTION _ WRAPPER ▁. ▁getH idden Object ▁( ▁throwable ▁) ▁; ▁if ▁( ▁wrapper ▁!= ▁null ▁) ▁{ ▁return ▁wrapper ▁; ▁} ▁wrapper ▁= ▁new ▁Espresso Exception ▁( ▁throwable ▁) ▁; ▁meta ▁. ▁H IDDEN _ EXCEPTION _ WRAPPER ▁. ▁setH idden Object ▁( ▁throwable ▁, ▁wrapper ▁) ▁; ▁return ▁wrapper ▁; ▁} ▁public ▁static ▁VM ▁. ▁StackTrace ▁get Frames ▁( ▁StaticObject ▁exception ▁, ▁Meta ▁meta ▁) ▁{ ▁return ▁( ▁VM ▁. ▁StackTrace ▁) ▁meta ▁. ▁H IDDEN _ FRAME S ▁. ▁getH idden Object ▁( ▁exception ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getMessage ▁( ▁) ▁{ ▁return ▁getMessage ▁( ▁exception ▁) ▁; ▁} ▁public ▁StaticObject ▁getG uest Message ▁( ▁) ▁{ ▁return ▁( ▁StaticObject ▁) ▁exception ▁. ▁getK lass ▁( ▁) ▁. ▁lookup Method ▁( ▁Name ▁. ▁getMessage ▁, ▁Signature ▁. ▁String ▁) ▁. ▁invoke Direct ▁( ▁exception ▁) ▁; ▁} ▁public ▁static ▁String ▁getMessage ▁( ▁StaticObject ▁e ▁) ▁{ ▁return ▁Meta ▁. ▁to Host String Static ▁( ▁( ▁StaticObject ▁) ▁e ▁. ▁getK lass ▁( ▁) ▁. ▁lookup Method ▁( ▁Name ▁. ▁getMessage ▁, ▁Signature ▁. ▁String ▁) ▁. ▁invoke Direct ▁( ▁e ▁) ▁) ▁; ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁@ ▁Override ▁public ▁Throwable ▁fill In StackTrace ▁( ▁) ▁{ ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁StaticObject ▁getException Object ▁( ▁) ▁{ ▁return ▁exception ▁; ▁} ▁@ ▁Override ▁public ▁Node ▁getLocation ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁SourceSection ▁getSource Location ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁getException Object ▁( ▁) ▁+ ▁STR ▁+ ▁getMessage ▁( ▁) ▁+ ▁STR ▁; ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁private ▁boolean ▁match ▁( ▁String ▁exception Class ▁, ▁String ▁message ▁) ▁{ ▁if ▁( ▁exception Class ▁== ▁null ▁) ▁{ ▁return ▁getMessage ▁( ▁) ▁!= ▁null ▁&& ▁getMessage ▁( ▁) ▁. ▁contains ▁( ▁message ▁) ▁; ▁}
▁class ▁Builder Build pack ▁implements ▁Buildpack ▁{ ▁private ▁static ▁final ▁String ▁PREFIX ▁= ▁STR ▁; ▁private ▁final ▁Buildpack Coordinates ▁coordinates ▁; ▁Builder Build pack ▁( ▁Buildpack Metadata ▁build pack Metadata ▁) ▁{ ▁this ▁. ▁coordinates ▁= ▁Buildpack Coordinates ▁. ▁from Build pack Metadata ▁( ▁build pack Metadata ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Buildpack Coordinates ▁getCo ordinates ▁( ▁) ▁{ ▁return ▁this ▁. ▁coordinates ▁; ▁} ▁@ ▁Override ▁public ▁void ▁apply ▁( ▁IO Consumer ▁< ▁Layer ▁> ▁layers ▁) ▁throws ▁IOException ▁{ ▁} ▁static ▁Buildpack ▁resolve ▁( ▁Buildpack Resolver Context ▁context ▁, ▁Buildpack Reference ▁reference ▁) ▁{ ▁boolean ▁un amb iguous ▁= ▁reference ▁. ▁has Prefix ▁( ▁PREFIX ▁) ▁; ▁Builder Reference ▁builder Reference ▁= ▁Builder Reference ▁. ▁of ▁( ▁un amb iguous ▁? ▁reference ▁. ▁getSub Reference ▁( ▁PREFIX ▁) ▁: ▁reference ▁. ▁toString ▁( ▁) ▁) ▁; ▁Buildpack Metadata ▁build pack Metadata ▁= ▁find Build pack Metadata ▁( ▁context ▁, ▁builder Reference ▁) ▁; ▁if ▁( ▁un amb iguous ▁) ▁{ ▁Assert ▁. ▁isTrue ▁( ▁build pack Metadata ▁!= ▁null ▁, ▁( ▁) ▁-> ▁STR ▁+ ▁reference ▁+ ▁STR ▁) ▁; ▁} ▁return ▁( ▁build pack Metadata ▁!= ▁null ▁) ▁? ▁new ▁Builder Build pack ▁( ▁build pack Metadata ▁) ▁: ▁null ▁; ▁} ▁private ▁static ▁Buildpack Metadata ▁find Build pack Metadata ▁( ▁Buildpack Resolver Context ▁context ▁, ▁Builder Reference ▁builder Reference ▁) ▁{ ▁for ▁( ▁Buildpack Metadata ▁candidate ▁: ▁context ▁. ▁getBuild pack Metadata ▁( ▁) ▁) ▁{ ▁if ▁( ▁builder Reference ▁. ▁matches ▁( ▁candidate ▁) ▁) ▁{ ▁return ▁candidate ▁; ▁} ▁} ▁return ▁null ▁; ▁} ▁static ▁class ▁Builder Reference ▁{ ▁private ▁final ▁String ▁id ▁; ▁private ▁final ▁String ▁version ▁; ▁Builder Reference ▁( ▁String ▁id ▁, ▁String ▁version ▁) ▁{ ▁this ▁. ▁id ▁= ▁id ▁; ▁this ▁. ▁version ▁= ▁version ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁( ▁this ▁. ▁version ▁!= ▁null ▁) ▁? ▁this ▁. ▁id ▁+ ▁STR ▁+ ▁this ▁. ▁version ▁: ▁this ▁. ▁id ▁; ▁} ▁boolean ▁matches ▁( ▁Buildpack Metadata ▁candidate ▁) ▁{ ▁return ▁this ▁. ▁id ▁. ▁equals ▁( ▁candidate ▁. ▁getId ▁( ▁) ▁) ▁&& ▁( ▁this ▁. ▁version ▁== ▁null ▁|| ▁this ▁. ▁version ▁. ▁equals ▁( ▁candidate ▁. ▁getVersion ▁( ▁) ▁) ▁) ▁; ▁} ▁static ▁Builder Reference ▁of ▁( ▁String ▁value ▁) ▁{ ▁if ▁( ▁value ▁. ▁contains ▁( ▁STR ▁) ▁) ▁{ ▁String ▁[ ▁] ▁parts ▁= ▁value ▁. ▁split ▁( ▁STR ▁) ▁; ▁return ▁new ▁Builder Reference ▁( ▁parts ▁[ ▁0 ▁] ▁, ▁parts ▁[ ▁1 ▁] ▁) ▁; ▁} ▁return ▁new ▁Builder Reference ▁( ▁value ▁, ▁null ▁) ▁; ▁} ▁} ▁}
▁public ▁class ▁Add Sub tract Days Skip ping Week ends Utils UnitTest ▁{ ▁@ ▁Test ▁public ▁void ▁given Local Date And Day sTo Add _ then Add Days Skip ping Week ends ▁( ▁) ▁{ ▁LocalDate ▁initial Date ▁= ▁LocalDate ▁. ▁of ▁( ▁20 19 ▁, ▁11 ▁, ▁7 ▁) ▁; ▁LocalDate ▁expected Date ▁= ▁LocalDate ▁. ▁of ▁( ▁20 19 ▁, ▁11 ▁, ▁13 ▁) ▁; ▁LocalDate ▁result ▁= ▁Add Sub tract Days Skip ping Week ends Utils ▁. ▁add Days Skip ping Week ends ▁( ▁initial Date ▁, ▁4 ▁) ▁; ▁assertEquals ▁( ▁expected Date ▁, ▁result ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁given Local Date And Day sTo Sub tract _ then Sub tract Days Skip ping Week ends ▁( ▁) ▁{ ▁LocalDate ▁initial Date ▁= ▁LocalDate ▁. ▁of ▁( ▁20 19 ▁, ▁11 ▁, ▁7 ▁) ▁; ▁LocalDate ▁expected Date ▁= ▁LocalDate ▁. ▁of ▁( ▁20 19 ▁, ▁11 ▁, ▁1 ▁) ▁; ▁LocalDate ▁result ▁= ▁Add Sub tract Days Skip ping Week ends Utils ▁. ▁subtract Days Skip ping Week ends ▁( ▁initial Date ▁, ▁4 ▁) ▁; ▁assertEquals ▁( ▁expected Date ▁, ▁result ▁) ▁; ▁} ▁}
▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁abstract ▁class ▁Internal MultiBucket Aggregation ▁< ▁A ▁extends ▁Internal MultiBucket Aggregation ▁, ▁B ▁extends ▁Internal MultiBucket Aggregation ▁. ▁Internal Bucket ▁> ▁extends ▁Internal Aggregation ▁implements ▁Multi Buckets Aggregation ▁{ ▁public ▁Internal MultiBucket Aggregation ▁( ▁String ▁name ▁, ▁Map ▁< ▁String ▁, ▁Object ▁> ▁metadata ▁) ▁{ ▁super ▁( ▁name ▁, ▁metadata ▁) ▁; ▁} ▁protected ▁Internal MultiBucket Aggregation ▁( ▁StreamInput ▁in ▁) ▁throws ▁IOException ▁{ ▁super ▁( ▁in ▁) ▁; ▁} ▁public ▁abstract ▁A ▁create ▁( ▁List ▁< ▁B ▁> ▁buckets ▁) ▁; ▁public ▁abstract ▁B ▁create Bucket ▁( ▁Internal Aggregations ▁aggregations ▁, ▁B ▁prototype ▁) ▁; ▁protected ▁abstract ▁B ▁reduce Bucket ▁( ▁List ▁< ▁B ▁> ▁buckets ▁, ▁Reduce Context ▁context ▁) ▁; ▁@ ▁Override ▁public ▁abstract ▁List ▁< ▁B ▁> ▁getBuckets ▁( ▁) ▁; ▁@ ▁Override ▁public ▁Object ▁getProperty ▁( ▁List ▁< ▁String ▁> ▁path ▁) ▁{ ▁if ▁( ▁path ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁return ▁this ▁; ▁} ▁return ▁resolve Property From Path ▁( ▁path ▁, ▁getBuckets ▁( ▁) ▁, ▁getName ▁( ▁) ▁) ▁; ▁} ▁static ▁Object ▁resolve Property From Path ▁( ▁List ▁< ▁String ▁> ▁path ▁, ▁List ▁< ▁? ▁extends ▁Internal Bucket ▁> ▁buckets ▁, ▁String ▁name ▁) ▁{ ▁String ▁agg Name ▁= ▁path ▁. ▁get ▁( ▁0 ▁) ▁; ▁if ▁( ▁agg Name ▁. ▁equals ▁( ▁STR ▁) ▁) ▁{ ▁return ▁buckets ▁. ▁size ▁( ▁) ▁; ▁} ▁if ▁( ▁agg Name ▁. ▁startsWith ▁( ▁STR ▁) ▁&& ▁agg Name ▁. ▁endsWith ▁( ▁STR ▁) ▁) ▁{ ▁for ▁( ▁Internal Bucket ▁bucket ▁: ▁buckets ▁) ▁{ ▁if ▁( ▁bucket ▁. ▁getKey AsString ▁( ▁) ▁. ▁equals ▁( ▁agg Name ▁. ▁substring ▁( ▁1 ▁, ▁agg Name ▁. ▁length ▁( ▁) ▁- ▁1 ▁) ▁) ▁) ▁{ ▁return ▁bucket ▁. ▁getProperty ▁( ▁name ▁, ▁path ▁. ▁subList ▁( ▁1 ▁, ▁path ▁. ▁size ▁( ▁) ▁) ▁) ▁; ▁} ▁} ▁throw ▁new ▁Invalid Aggregation Path Exception ▁( ▁STR ▁+ ▁agg Name ▁+ ▁STR ▁+ ▁name ▁+ ▁STR ▁) ▁; ▁} ▁Object ▁[ ▁] ▁property Array ▁= ▁new ▁Object ▁[ ▁buckets ▁. ▁size ▁( ▁) ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁buckets ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁property Array ▁[ ▁i ▁] ▁= ▁buckets ▁. ▁get ▁( ▁i ▁) ▁. ▁getProperty ▁( ▁name ▁, ▁path ▁) ▁; ▁} ▁return ▁property Array ▁; ▁} ▁public ▁static ▁int ▁count Inner Bucket ▁( ▁Internal Bucket ▁bucket ▁) ▁{ ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁Aggregation ▁agg ▁: ▁bucket ▁. ▁getAggregations ▁( ▁) ▁. ▁asList ▁( ▁) ▁) ▁{ ▁count ▁+= ▁count Inner Bucket ▁( ▁agg ▁) ▁; ▁} ▁return ▁count ▁; ▁} ▁public ▁static ▁int ▁count Inner Bucket ▁( ▁Aggregation ▁agg ▁) ▁{ ▁int ▁size ▁= ▁0 ▁; ▁if ▁( ▁agg ▁instanceof ▁Multi Buckets Aggregation ▁) ▁{ ▁Multi Buckets Aggregation ▁multi ▁= ▁( ▁Multi Buckets Aggregation ▁) ▁agg ▁; ▁for ▁( ▁Multi Buckets Aggregation ▁. ▁Bucket ▁bucket ▁: ▁multi ▁. ▁getBuckets ▁( ▁) ▁) ▁{ ▁++ ▁size ▁;
▁public ▁class ▁Test MR Async Disk Service ▁{ ▁public ▁static ▁final ▁Logger ▁LOG ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Test MR Async Disk Service ▁. ▁class ▁) ▁; ▁private ▁static ▁String ▁TEST _ ROOT _ DIR ▁= ▁new ▁Path ▁( ▁System ▁. ▁getProperty ▁( ▁STR ▁, ▁STR ▁) ▁) ▁. ▁toString ▁( ▁) ▁; ▁@ ▁Before ▁public ▁void ▁setUp ▁( ▁) ▁{ ▁FileUtil ▁. ▁fully Delete ▁( ▁new ▁File ▁( ▁TEST _ ROOT _ DIR ▁) ▁) ▁; ▁} ▁private ▁String ▁relative To Work ing ▁( ▁String ▁path name ▁) ▁{ ▁String ▁c wd ▁= ▁System ▁. ▁getProperty ▁( ▁STR ▁, ▁STR ▁) ▁; ▁path name ▁= ▁( ▁new ▁Path ▁( ▁path name ▁) ▁) ▁. ▁toUri ▁( ▁) ▁. ▁getPath ▁( ▁) ▁; ▁c wd ▁= ▁( ▁new ▁Path ▁( ▁c wd ▁) ▁) ▁. ▁toUri ▁( ▁) ▁. ▁getPath ▁( ▁) ▁; ▁String ▁[ ▁] ▁c wd Parts ▁= ▁c wd ▁. ▁split ▁( ▁Path ▁. ▁SEPARATOR ▁) ▁; ▁String ▁[ ▁] ▁path Parts ▁= ▁path name ▁. ▁split ▁( ▁Path ▁. ▁SEPARATOR ▁) ▁; ▁if ▁( ▁c wd ▁. ▁equals ▁( ▁path name ▁) ▁) ▁{ ▁LOG ▁. ▁info ▁( ▁STR ▁+ ▁path name ▁+ ▁STR ▁) ▁; ▁return ▁STR ▁; ▁} ▁int ▁common ▁= ▁0 ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁Math ▁. ▁min ▁( ▁c wd Parts ▁. ▁length ▁, ▁path Parts ▁. ▁length ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁c wd Parts ▁[ ▁i ▁] ▁. ▁equals ▁( ▁path Parts ▁[ ▁i ▁] ▁) ▁) ▁{ ▁common ▁++ ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁} ▁StringBuilder ▁sb ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁int ▁parent Dirs Required ▁= ▁c wd Parts ▁. ▁length ▁- ▁common ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁parent Dirs Required ▁; ▁i ▁++ ▁) ▁{ ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁sb ▁. ▁append ▁( ▁Path ▁. ▁SEPARATOR ▁) ▁; ▁} ▁for ▁( ▁int ▁i ▁= ▁common ▁; ▁i ▁< ▁path Parts ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁sb ▁. ▁append ▁( ▁path Parts ▁[ ▁i ▁] ▁) ▁; ▁sb ▁. ▁append ▁( ▁Path ▁. ▁SEPARATOR ▁) ▁; ▁} ▁String ▁s ▁= ▁sb ▁. ▁toString ▁( ▁) ▁; ▁if ▁( ▁s ▁. ▁endsWith ▁( ▁Path ▁. ▁SEPARATOR ▁) ▁) ▁{ ▁s ▁= ▁s ▁. ▁substring ▁( ▁0 ▁, ▁s ▁. ▁length ▁( ▁) ▁- ▁1 ▁) ▁; ▁} ▁LOG ▁. ▁info ▁( ▁STR ▁+ ▁path name ▁+ ▁STR ▁+ ▁s ▁) ▁; ▁return ▁s ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Relative To Work ing ▁( ▁) ▁{ ▁assertEquals ▁( ▁STR ▁, ▁relative To Work ing ▁( ▁System ▁. ▁getProperty ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁; ▁String ▁c wd ▁= ▁System ▁. ▁getProperty ▁( ▁STR ▁, ▁STR ▁) ▁; ▁Path ▁c wd Path ▁= ▁new ▁Path ▁( ▁c wd ▁) ▁; ▁Path ▁sub dir ▁= ▁new ▁Path ▁( ▁c wd Path ▁, ▁STR ▁) ▁;
▁public ▁class ▁Interval Join ITCase ▁{ ▁private ▁static ▁List ▁< ▁String ▁> ▁test Results ▁; ▁@ ▁Before ▁public ▁void ▁setup ▁( ▁) ▁{ ▁test Results ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Can Join Over Same Key ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁StreamExecution Environment ▁env ▁= ▁StreamExecution Environment ▁. ▁getExecution Environment ▁( ▁) ▁; ▁env ▁. ▁setParallelism ▁( ▁1 ▁) ▁; ▁Keyed Stream ▁< ▁Tuple 2 ▁< ▁String ▁, ▁Integer ▁> ▁, ▁String ▁> ▁stream One ▁= ▁env ▁. ▁fromElements ▁( ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁0 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁1 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁2 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁3 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁4 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁5 ▁) ▁) ▁. ▁assign Timestamp sAnd Watermarks ▁( ▁new ▁Asc ending Tuple 2 Timestamp Extractor ▁( ▁) ▁) ▁. ▁key By ▁( ▁new ▁Tuple 2 Key Extractor ▁( ▁) ▁) ▁; ▁Keyed Stream ▁< ▁Tuple 2 ▁< ▁String ▁, ▁Integer ▁> ▁, ▁String ▁> ▁stream Two ▁= ▁env ▁. ▁fromElements ▁( ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁0 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁1 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁2 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁3 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁4 ▁) ▁, ▁Tuple 2 ▁. ▁of ▁( ▁STR ▁, ▁5 ▁) ▁) ▁. ▁assign Timestamp sAnd Watermarks ▁( ▁new ▁Asc ending Tuple 2 Timestamp Extractor ▁( ▁) ▁) ▁. ▁key By ▁( ▁new ▁Tuple 2 Key Extractor ▁( ▁) ▁) ▁; ▁stream One ▁. ▁interval Join ▁( ▁stream Two ▁) ▁. ▁between ▁( ▁Time ▁. ▁milliseconds ▁( ▁0 ▁) ▁, ▁Time ▁. ▁milliseconds ▁( ▁0 ▁) ▁) ▁. ▁process ▁( ▁new ▁Process Join Function ▁< ▁Tuple 2 ▁< ▁String ▁, ▁Integer ▁> ▁, ▁Tuple 2 ▁< ▁String ▁, ▁Integer ▁> ▁, ▁String ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁processElement ▁( ▁Tuple 2 ▁< ▁String ▁, ▁Integer ▁> ▁left ▁, ▁Tuple 2 ▁< ▁String ▁, ▁Integer ▁> ▁right ▁, ▁Context ▁ctx ▁, ▁Collector ▁< ▁String ▁> ▁out ▁) ▁throws ▁Exception ▁{ ▁out ▁. ▁collect ▁( ▁left ▁+ ▁STR ▁+ ▁right ▁) ▁; ▁} ▁} ▁) ▁. ▁add Sink ▁( ▁new ▁Result Sink ▁( ▁) ▁) ▁; ▁env ▁. ▁execute ▁( ▁) ▁; ▁expect InAnyOrder ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test J o ins Correct ly With Multiple Keys ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁StreamExecution Environment ▁env ▁= ▁StreamExecution Environment ▁. ▁getExecution Environment ▁( ▁) ▁; ▁env ▁. ▁setParallelism ▁( ▁1 ▁) ▁;
▁class ▁Tree View Provider ▁implements ▁View Provider Service ▁{ ▁private ▁Program Tree Panel ▁tree Panel ▁; ▁private ▁AddressSet ▁view ▁; ▁private ▁Program ▁program ▁; ▁private ▁GoTo Service ▁goTo Service ▁; ▁private ▁View Manager Service ▁view Manager Service ▁; ▁private ▁Program Tree Plugin ▁plugin ▁; ▁private ▁final ▁static ▁String ▁NUMBER _ OF _ GROUP S ▁= ▁STR ▁; ▁private ▁final ▁static ▁String ▁GROUP _ NAME ▁= ▁STR ▁; ▁private ▁final ▁static ▁int ▁DE LAY ▁= ▁500 ▁; ▁public ▁Tree View Provider ▁( ▁String ▁tree Name ▁, ▁final ▁Program Tree Plugin ▁plugin ▁) ▁{ ▁tree Panel ▁= ▁new ▁Program Tree Panel ▁( ▁tree Name ▁, ▁plugin ▁) ▁; ▁this ▁. ▁plugin ▁= ▁plugin ▁; ▁tree Panel ▁. ▁add Tree Listener ▁( ▁new ▁Tree Listener ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁tree View Changed ▁( ▁Change Event ▁e ▁) ▁{ ▁notify Listeners ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁goTo ▁( ▁Address ▁addr ▁) ▁{ ▁goTo Service ▁. ▁goTo ▁( ▁new ▁Address FieldLocation ▁( ▁plugin ▁. ▁getCurrent Program ▁( ▁) ▁, ▁addr ▁) ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁@ ▁Override ▁public ▁JComponent ▁getView Component ▁( ▁) ▁{ ▁return ▁tree Panel ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getView Name ▁( ▁) ▁{ ▁return ▁tree Panel ▁. ▁getTree Name ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Has Focus ▁( ▁boolean ▁has Focus ▁) ▁{ ▁tree Panel ▁. ▁set Has Focus ▁( ▁has Focus ▁) ▁; ▁plugin ▁. ▁enable Actions ▁( ▁program ▁!= ▁null ▁) ▁; ▁if ▁( ▁has Focus ▁) ▁{ ▁plugin ▁. ▁tree View Changed ▁( ▁this ▁) ▁; ▁if ▁( ▁goTo Service ▁== ▁null ▁) ▁{ ▁goTo Service ▁= ▁plugin ▁. ▁getG o To Service ▁( ▁) ▁; ▁} ▁if ▁( ▁view Manager Service ▁== ▁null ▁) ▁{ ▁view Manager Service ▁= ▁plugin ▁. ▁getView Manager Service ▁( ▁) ▁; ▁} ▁notify Listeners ▁( ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁Object ▁getActive Popup Object ▁( ▁MouseEvent ▁event ▁) ▁{ ▁return ▁tree Panel ▁. ▁prepare Selection For Popup ▁( ▁event ▁) ▁; ▁} ▁@ ▁Override ▁public ▁ActionContext ▁get ActionContext ▁( ▁MouseEvent ▁event ▁) ▁{ ▁return ▁new ▁ActionContext ▁( ▁) ▁. ▁setContext Object ▁( ▁getActive Popup Object ▁( ▁event ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁getActive Object ▁( ▁) ▁{ ▁return ▁tree Panel ▁. ▁getSelected Node ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁DockingAction ▁[ ▁] ▁getTool Bar Actions ▁( ▁) ▁{ ▁return ▁plugin ▁. ▁getTool Bar Actions ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁view Closed ▁( ▁) ▁{ ▁if ▁( ▁program ▁== ▁null ▁) ▁{ ▁return ▁false ▁; ▁} ▁if ▁( ▁plugin ▁. ▁close View ▁( ▁this ▁) ▁) ▁{ ▁dispose ▁( ▁) ▁; ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁view Deleted ▁( ▁) ▁{ ▁if ▁( ▁program ▁== ▁null ▁) ▁{ ▁return ▁false ▁; ▁} ▁if ▁( ▁plugin ▁. ▁delete View ▁( ▁this ▁) ▁) ▁{ ▁dispose ▁( ▁) ▁; ▁return ▁true ▁; ▁} ▁return ▁false ▁; ▁}
▁catch ▁( ▁Invocation TargetException ▁ex ▁) ▁{ ▁String ▁msg ▁= ▁STR ▁+ ▁beanName ▁+ ▁STR ▁; ▁if ▁( ▁logger ▁. ▁isDebugEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁warn ▁( ▁msg ▁, ▁ex ▁. ▁getTarget Exception ▁( ▁) ▁) ▁; ▁} ▁else ▁{ ▁logger ▁. ▁warn ▁( ▁msg ▁+ ▁STR ▁+ ▁ex ▁. ▁getTarget Exception ▁( ▁) ▁) ▁; ▁} ▁} ▁catch ▁( ▁Throwable ▁ex ▁) ▁{ ▁logger ▁. ▁warn ▁( ▁STR ▁+ ▁beanName ▁+ ▁STR ▁, ▁ex ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁boolean ▁requires Dest ru ction ▁( ▁Object ▁bean ▁) ▁{ ▁return ▁find Lifecycle Metadata ▁( ▁bean ▁. ▁getClass ▁( ▁) ▁) ▁. ▁has Destroy Methods ▁( ▁) ▁; ▁} ▁private ▁Lifecycle Metadata ▁find Lifecycle Metadata ▁( ▁Class ▁< ▁? ▁> ▁clazz ▁) ▁{ ▁if ▁( ▁this ▁. ▁lifecycle Metadata Cache ▁== ▁null ▁) ▁{ ▁return ▁build Lifecycle Metadata ▁( ▁clazz ▁) ▁; ▁} ▁Lifecycle Metadata ▁metadata ▁= ▁this ▁. ▁lifecycle Metadata Cache ▁. ▁get ▁( ▁clazz ▁) ▁; ▁if ▁( ▁metadata ▁== ▁null ▁) ▁{ ▁synchronized ▁( ▁this ▁. ▁lifecycle Metadata Cache ▁) ▁{ ▁metadata ▁= ▁this ▁. ▁lifecycle Metadata Cache ▁. ▁get ▁( ▁clazz ▁) ▁; ▁if ▁( ▁metadata ▁== ▁null ▁) ▁{ ▁metadata ▁= ▁build Lifecycle Metadata ▁( ▁clazz ▁) ▁; ▁this ▁. ▁lifecycle Metadata Cache ▁. ▁put ▁( ▁clazz ▁, ▁metadata ▁) ▁; ▁} ▁return ▁metadata ▁; ▁} ▁} ▁return ▁metadata ▁; ▁} ▁private ▁Lifecycle Metadata ▁build Lifecycle Metadata ▁( ▁final ▁Class ▁< ▁? ▁> ▁clazz ▁) ▁{ ▁if ▁( ▁! ▁Annotation Utils ▁. ▁isC andidate Class ▁( ▁clazz ▁, ▁Arrays ▁. ▁asList ▁( ▁this ▁. ▁init Annotation Type ▁, ▁this ▁. ▁destroy Annotation Type ▁) ▁) ▁) ▁{ ▁return ▁this ▁. ▁empty Lifecycle Metadata ▁; ▁} ▁List ▁< ▁Lifecycle Element ▁> ▁init Methods ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁List ▁< ▁Lifecycle Element ▁> ▁destroy Methods ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁Class ▁< ▁? ▁> ▁targetClass ▁= ▁clazz ▁; ▁do ▁{ ▁final ▁List ▁< ▁Lifecycle Element ▁> ▁curr Init Methods ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁final ▁List ▁< ▁Lifecycle Element ▁> ▁curr Destroy Methods ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁ReflectionUtils ▁. ▁do With Local Methods ▁( ▁targetClass ▁, ▁method ▁-> ▁{ ▁if ▁( ▁this ▁. ▁init Annotation Type ▁!= ▁null ▁&& ▁method ▁. ▁isAnnotation Present ▁( ▁this ▁. ▁init Annotation Type ▁) ▁) ▁{ ▁Lifecycle Element ▁element ▁= ▁new ▁Lifecycle Element ▁( ▁method ▁) ▁; ▁curr Init Methods ▁. ▁add ▁( ▁element ▁) ▁; ▁if ▁( ▁logger ▁. ▁isTraceEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁trace ▁( ▁STR ▁+ ▁clazz ▁. ▁getName ▁( ▁) ▁+ ▁STR ▁+ ▁method ▁) ▁; ▁} ▁} ▁if ▁( ▁this ▁. ▁destroy Annotation Type ▁!= ▁null ▁&& ▁method ▁. ▁isAnnotation Present ▁( ▁this ▁. ▁destroy Annotation Type ▁) ▁) ▁{ ▁curr Destroy Methods ▁. ▁add ▁( ▁new ▁Lifecycle Element ▁( ▁method ▁) ▁) ▁; ▁if ▁( ▁logger ▁. ▁isTraceEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁trace ▁( ▁STR ▁+ ▁clazz ▁. ▁getName ▁( ▁) ▁+ ▁STR ▁+ ▁method ▁) ▁; ▁} ▁} ▁} ▁) ▁;
▁if ▁( ▁! ▁m Need Vertical Scroll bar ▁&& ▁! ▁m Need H orizontal Scroll bar ▁) ▁{ ▁if ▁( ▁m State ▁!= ▁STATE _ H IDDEN ▁) ▁{ ▁setState ▁( ▁STATE _ H IDDEN ▁) ▁; ▁} ▁return ▁; ▁} ▁if ▁( ▁m Need Vertical Scroll bar ▁) ▁{ ▁float ▁middle Screen Pos ▁= ▁offset Y ▁+ ▁v ertical Visible Length ▁ / ▁2.0 f ▁; ▁m Vertical Th umb Center Y ▁= ▁( ▁int ▁) ▁( ▁( ▁v ertical Visible Length ▁ * ▁middle Screen Pos ▁) ▁ / ▁v ertical ContentLength ▁) ▁; ▁m Vertical Th umb Height ▁= ▁Math ▁. ▁min ▁( ▁v ertical Visible Length ▁, ▁( ▁v ertical Visible Length ▁ * ▁v ertical Visible Length ▁) ▁ / ▁v ertical ContentLength ▁) ▁; ▁} ▁if ▁( ▁m Need H orizontal Scroll bar ▁) ▁{ ▁float ▁middle Screen Pos ▁= ▁offset X ▁+ ▁h orizontal Visible Length ▁ / ▁2.0 f ▁; ▁m H orizontal Th umb Center X ▁= ▁( ▁int ▁) ▁( ▁( ▁h orizontal Visible Length ▁ * ▁middle Screen Pos ▁) ▁ / ▁h orizontal ContentLength ▁) ▁; ▁m H orizontal Th umb Width ▁= ▁Math ▁. ▁min ▁( ▁h orizontal Visible Length ▁, ▁( ▁h orizontal Visible Length ▁ * ▁h orizontal Visible Length ▁) ▁ / ▁h orizontal ContentLength ▁) ▁; ▁} ▁if ▁( ▁m State ▁== ▁STATE _ H IDDEN ▁|| ▁m State ▁== ▁STATE _ VI SIBLE ▁) ▁{ ▁setState ▁( ▁STATE _ VI SIBLE ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁boolean ▁on Intercept Touch Event ▁( ▁@ ▁NonNull ▁RecyclerView ▁recyclerView ▁, ▁@ ▁NonNull ▁MotionEvent ▁ev ▁) ▁{ ▁final ▁boolean ▁handled ▁; ▁if ▁( ▁m State ▁== ▁STATE _ VI SIBLE ▁) ▁{ ▁boolean ▁ins ide Vertical Th umb ▁= ▁is Point Inside Vertical Th umb ▁( ▁ev ▁. ▁getX ▁( ▁) ▁, ▁ev ▁. ▁getY ▁( ▁) ▁) ▁; ▁boolean ▁ins ide H orizontal Th umb ▁= ▁is Point Inside H orizontal Th umb ▁( ▁ev ▁. ▁getX ▁( ▁) ▁, ▁ev ▁. ▁getY ▁( ▁) ▁) ▁; ▁if ▁( ▁ev ▁. ▁getAction ▁( ▁) ▁== ▁MotionEvent ▁. ▁ACTION _ DOWN ▁&& ▁( ▁ins ide Vertical Th umb ▁|| ▁ins ide H orizontal Th umb ▁) ▁) ▁{ ▁if ▁( ▁ins ide H orizontal Th umb ▁) ▁{ ▁m Drag State ▁= ▁DR AG _ X ▁; ▁m H orizontal Drag X ▁= ▁( ▁int ▁) ▁ev ▁. ▁getX ▁( ▁) ▁; ▁} ▁else ▁if ▁( ▁ins ide Vertical Th umb ▁) ▁{ ▁m Drag State ▁= ▁DR AG _ Y ▁; ▁m Vertical Drag Y ▁= ▁( ▁int ▁) ▁ev ▁. ▁getY ▁( ▁) ▁; ▁} ▁setState ▁( ▁STATE _ DR AG G ING ▁) ▁; ▁handled ▁= ▁true ▁; ▁} ▁else ▁{ ▁handled ▁= ▁false ▁; ▁} ▁} ▁else ▁if ▁( ▁m State ▁== ▁STATE _ DR AG G ING ▁) ▁{ ▁handled ▁= ▁true ▁; ▁} ▁else ▁{ ▁handled ▁= ▁false ▁; ▁} ▁return ▁handled ▁; ▁}
▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isEqualTo ▁( ▁Label Validator ▁. ▁PACKAGE _ NAME _ ERROR ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isEqualTo ▁( ▁Label Validator ▁. ▁PACKAGE _ NAME _ D OT _ ERROR ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isEqualTo ▁( ▁Label Validator ▁. ▁PACKAGE _ NAME _ D OT _ ERROR ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isEqualTo ▁( ▁Label Validator ▁. ▁PACKAGE _ NAME _ D OT _ ERROR ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isEqualTo ▁( ▁Label Validator ▁. ▁PACKAGE _ NAME _ D OT _ ERROR ▁) ▁; ▁assertThat ▁( ▁Label Validator ▁. ▁validate Package Name ▁( ▁STR ▁) ▁) ▁. ▁isEqualTo ▁( ▁Label Validator ▁. ▁PACKAGE _ NAME _ D OT _ ERROR ▁) ▁;
▁@ ▁Override ▁public ▁List ▁< ▁Route ▁> ▁routes ▁( ▁) ▁{ ▁return ▁Collections ▁. ▁emptyList ▁( ▁) ▁; ▁} ▁} ▁; ▁final ▁HashMap ▁< ▁String ▁, ▁String ▁> ▁params ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁params ▁. ▁put ▁( ▁STR ▁, ▁randomAlpha OfLength ▁( ▁8 ▁) ▁) ▁; ▁params ▁. ▁put ▁( ▁STR ▁, ▁randomAlpha OfLength ▁( ▁8 ▁) ▁) ▁; ▁RestRequest ▁request ▁= ▁new ▁FakeRest Request ▁. ▁Builder ▁( ▁xContent Registry ▁( ▁) ▁) ▁. ▁with Params ▁( ▁params ▁) ▁. ▁build ▁( ▁) ▁; ▁RestChannel ▁channel ▁= ▁new ▁FakeRest Channel ▁( ▁request ▁, ▁randomBoolean ▁( ▁) ▁, ▁1 ▁) ▁; ▁handler ▁. ▁handleRequest ▁( ▁request ▁, ▁channel ▁, ▁mock Client ▁) ▁; ▁assertTrue ▁( ▁executed ▁. ▁get ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁testDefault Response Parameters ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁AtomicBoolean ▁executed ▁= ▁new ▁AtomicBoolean ▁( ▁) ▁; ▁BaseRestHandler ▁handler ▁= ▁new ▁BaseRestHandler ▁( ▁) ▁{ ▁@ ▁Override ▁protected ▁RestChannel Consumer ▁prepareRequest ▁( ▁RestRequest ▁request ▁, ▁NodeClient ▁client ▁) ▁throws ▁IOException ▁{ ▁return ▁channel ▁-> ▁executed ▁. ▁set ▁( ▁true ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁Route ▁> ▁routes ▁( ▁) ▁{ ▁return ▁Collections ▁. ▁emptyList ▁( ▁) ▁; ▁} ▁} ▁; ▁final ▁HashMap ▁< ▁String ▁, ▁String ▁> ▁params ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁params ▁. ▁put ▁( ▁STR ▁, ▁randomAlpha OfLength ▁( ▁8 ▁) ▁) ▁; ▁params ▁. ▁put ▁( ▁STR ▁, ▁randomAlpha OfLength ▁( ▁8 ▁) ▁) ▁; ▁params ▁. ▁put ▁( ▁STR ▁, ▁randomFrom ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁null ▁) ▁) ▁; ▁params ▁. ▁put ▁( ▁STR ▁, ▁null ▁) ▁; ▁RestRequest ▁request ▁= ▁new ▁FakeRest Request ▁. ▁Builder ▁( ▁xContent Registry ▁( ▁) ▁) ▁. ▁with Params ▁( ▁params ▁) ▁. ▁build ▁( ▁) ▁; ▁RestChannel ▁channel ▁= ▁new ▁FakeRest Channel ▁( ▁request ▁, ▁randomBoolean ▁( ▁) ▁, ▁1 ▁) ▁; ▁handler ▁. ▁handleRequest ▁( ▁request ▁, ▁channel ▁, ▁mock Client ▁) ▁; ▁assertTrue ▁( ▁executed ▁. ▁get ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁testC at Response Parameters ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁AtomicBoolean ▁executed ▁= ▁new ▁AtomicBoolean ▁( ▁) ▁; ▁Abstract C at Action ▁handler ▁= ▁new ▁Abstract C at Action ▁( ▁) ▁{ ▁@ ▁Override ▁protected ▁RestChannel Consumer ▁do C at Request ▁( ▁RestRequest ▁request ▁, ▁NodeClient ▁client ▁) ▁{ ▁return ▁channel ▁-> ▁executed ▁. ▁set ▁( ▁true ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁documentation ▁( ▁StringBuilder ▁sb ▁) ▁{ ▁} ▁@ ▁Override ▁protected ▁Table ▁getTable With Header ▁( ▁RestRequest ▁request ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁Route ▁> ▁routes ▁( ▁) ▁{ ▁return ▁Collections ▁. ▁emptyList ▁( ▁) ▁; ▁} ▁} ▁; ▁final ▁HashMap ▁< ▁String ▁, ▁String ▁> ▁params ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁params ▁. ▁put ▁( ▁STR ▁, ▁randomAlpha OfLength ▁( ▁8 ▁) ▁) ▁; ▁params ▁. ▁put ▁( ▁STR ▁, ▁randomAlpha OfLength ▁( ▁8 ▁) ▁) ▁;
▁private ▁Asset Dependencies ▁make Deps ▁( ▁RuleContext ▁ruleContext ▁, ▁boolean ▁never link ▁) ▁{ ▁Parsed Android Assets ▁first Direct ▁= ▁get Dependency Assets ▁( ▁ruleContext ▁, ▁STR ▁) ▁; ▁Parsed Android Assets ▁second Direct ▁= ▁get Dependency Assets ▁( ▁ruleContext ▁, ▁STR ▁) ▁; ▁Parsed Android Assets ▁first Transitive ▁= ▁get Dependency Assets ▁( ▁ruleContext ▁, ▁STR ▁) ▁; ▁Parsed Android Assets ▁second Transitive ▁= ▁get Dependency Assets ▁( ▁ruleContext ▁, ▁STR ▁) ▁; ▁return ▁Asset Dependencies ▁. ▁of ▁( ▁never link ▁, ▁NestedSet Builder ▁. ▁create ▁( ▁Order ▁. ▁N A IVE _ LINK _ ORDER ▁, ▁first Direct ▁, ▁second Direct ▁) ▁, ▁NestedSet Builder ▁. ▁create ▁( ▁Order ▁. ▁N A IVE _ LINK _ ORDER ▁, ▁first Transitive ▁, ▁second Transitive ▁) ▁, ▁NestedSet Builder ▁. ▁wrap ▁( ▁Order ▁. ▁N A IVE _ LINK _ ORDER ▁, ▁Iterables ▁. ▁concat ▁( ▁first Direct ▁. ▁getAss ets ▁( ▁) ▁, ▁second Direct ▁. ▁getAss ets ▁( ▁) ▁, ▁first Transitive ▁. ▁getAss ets ▁( ▁) ▁, ▁second Transitive ▁. ▁getAss ets ▁( ▁) ▁) ▁) ▁, ▁NestedSet Builder ▁. ▁wrap ▁( ▁Order ▁. ▁N A IVE _ LINK _ ORDER ▁, ▁ImmutableList ▁. ▁of ▁( ▁first Direct ▁. ▁getSymbol s ▁( ▁) ▁, ▁second Direct ▁. ▁getSymbol s ▁( ▁) ▁, ▁first Transitive ▁. ▁getSymbol s ▁( ▁) ▁, ▁second Transitive ▁. ▁getSymbol s ▁( ▁) ▁) ▁) ▁, ▁NestedSet Builder ▁. ▁wrap ▁( ▁Order ▁. ▁N A IVE _ LINK _ ORDER ▁, ▁ImmutableList ▁. ▁of ▁( ▁first Direct ▁. ▁getComp iled Symbols ▁( ▁) ▁, ▁second Direct ▁. ▁getComp iled Symbols ▁( ▁) ▁, ▁first Transitive ▁. ▁getComp iled Symbols ▁( ▁) ▁, ▁second Transitive ▁. ▁getComp iled Symbols ▁( ▁) ▁) ▁) ▁) ▁; ▁} ▁private ▁Merged Android Assets ▁assert Merge ▁( ▁RuleContext ▁ruleContext ▁, ▁Parsed Android Assets ▁parsed ▁, ▁Asset Dependencies ▁deps ▁) ▁throws ▁Interrupted Exception ▁{ ▁Merged Android Assets ▁merged ▁= ▁Merged Android Assets ▁. ▁merge From ▁( ▁Android Data Context ▁. ▁for Native ▁( ▁ruleContext ▁) ▁, ▁parsed ▁, ▁deps ▁) ▁; ▁assertThat ▁( ▁new ▁Parsed Android Assets ▁( ▁merged ▁) ▁) ▁. ▁isEqualTo ▁( ▁parsed ▁) ▁; ▁assert Action Artifacts ▁( ▁ruleContext ▁, ▁ImmutableList ▁. ▁< ▁Artifact ▁> ▁builder ▁( ▁) ▁. ▁addAll ▁( ▁merged ▁. ▁getAss ets ▁( ▁) ▁) ▁. ▁add ▁( ▁merged ▁. ▁getSymbol s ▁( ▁) ▁) ▁. ▁addAll ▁( ▁deps ▁. ▁get Transitive Assets ▁( ▁) ▁. ▁toList ▁( ▁) ▁) ▁. ▁addAll ▁( ▁deps ▁. ▁get Transitive Symbols ▁( ▁) ▁. ▁toList ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁, ▁ImmutableList ▁. ▁of ▁( ▁merged ▁. ▁getM erged Assets ▁( ▁) ▁) ▁) ▁; ▁return ▁merged ▁; ▁} ▁private ▁Android Assets ▁getLocal Assets ▁( ▁) ▁{ ▁return ▁new ▁Android Assets ▁( ▁ImmutableList ▁. ▁of ▁( ▁getResource ▁( ▁STR ▁) ▁, ▁getResource ▁( ▁STR ▁) ▁) ▁, ▁ImmutableList ▁. ▁of ▁( ▁PathFragment ▁. ▁create ▁( ▁STR ▁) ▁) ▁, ▁STR ▁) ▁; ▁}
▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁class ▁Lazy Singleton Aspect Instance Factory Decorator ▁implements ▁Metadata Aware Aspect Instance Factory ▁, ▁Serializable ▁{ ▁private ▁final ▁Metadata Aware Aspect Instance Factory ▁m a aif ▁; ▁@ ▁Nullable ▁private ▁volatile ▁Object ▁materialized ▁; ▁public ▁Lazy Singleton Aspect Instance Factory Decorator ▁( ▁Metadata Aware Aspect Instance Factory ▁m a aif ▁) ▁{ ▁Assert ▁. ▁notNull ▁( ▁m a aif ▁, ▁STR ▁) ▁; ▁this ▁. ▁m a aif ▁= ▁m a aif ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁get Aspect Instance ▁( ▁) ▁{ ▁Object ▁aspect Instance ▁= ▁this ▁. ▁materialized ▁; ▁if ▁( ▁aspect Instance ▁== ▁null ▁) ▁{ ▁Object ▁mutex ▁= ▁this ▁. ▁m a aif ▁. ▁get Aspect Creation M utex ▁( ▁) ▁; ▁if ▁( ▁mutex ▁== ▁null ▁) ▁{ ▁aspect Instance ▁= ▁this ▁. ▁m a aif ▁. ▁get Aspect Instance ▁( ▁) ▁; ▁this ▁. ▁materialized ▁= ▁aspect Instance ▁; ▁} ▁else ▁{ ▁synchronized ▁( ▁mutex ▁) ▁{ ▁aspect Instance ▁= ▁this ▁. ▁materialized ▁; ▁if ▁( ▁aspect Instance ▁== ▁null ▁) ▁{ ▁aspect Instance ▁= ▁this ▁. ▁m a aif ▁. ▁get Aspect Instance ▁( ▁) ▁; ▁this ▁. ▁materialized ▁= ▁aspect Instance ▁; ▁} ▁} ▁} ▁} ▁return ▁aspect Instance ▁; ▁} ▁public ▁boolean ▁is Materialized ▁( ▁) ▁{ ▁return ▁( ▁this ▁. ▁materialized ▁!= ▁null ▁) ▁; ▁} ▁@ ▁Override ▁@ ▁Nullable ▁public ▁ClassLoader ▁get Aspect ClassLoader ▁( ▁) ▁{ ▁return ▁this ▁. ▁m a aif ▁. ▁get Aspect ClassLoader ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Aspect Metadata ▁get Aspect Metadata ▁( ▁) ▁{ ▁return ▁this ▁. ▁m a aif ▁. ▁get Aspect Metadata ▁( ▁) ▁; ▁} ▁@ ▁Override ▁@ ▁Nullable ▁public ▁Object ▁get Aspect Creation M utex ▁( ▁) ▁{ ▁return ▁this ▁. ▁m a aif ▁. ▁get Aspect Creation M utex ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getOrder ▁( ▁) ▁{ ▁return ▁this ▁. ▁m a aif ▁. ▁getOrder ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁this ▁. ▁m a aif ▁; ▁} ▁}
▁public ▁class ▁View Controller Registry Tests ▁{ ▁private ▁View Controller Registry ▁registry ▁; ▁private ▁MockHttpServlet Request ▁request ▁; ▁private ▁MockHttpServlet Response ▁response ▁; ▁@ ▁BeforeEach ▁public ▁void ▁setup ▁( ▁) ▁{ ▁this ▁. ▁registry ▁= ▁new ▁View Controller Registry ▁( ▁new ▁Static Application Context ▁( ▁) ▁) ▁; ▁this ▁. ▁request ▁= ▁new ▁MockHttpServlet Request ▁( ▁STR ▁, ▁STR ▁) ▁; ▁this ▁. ▁response ▁= ▁new ▁MockHttpServlet Response ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁no View Control lers ▁( ▁) ▁{ ▁assertThat ▁( ▁this ▁. ▁registry ▁. ▁build HandlerMapping ▁( ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁addView Controller ▁( ▁) ▁{ ▁this ▁. ▁registry ▁. ▁addView Controller ▁( ▁STR ▁) ▁. ▁setView Name ▁( ▁STR ▁) ▁; ▁Parameter izable View Controller ▁controller ▁= ▁get Controller ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁controller ▁. ▁getView Name ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁controller ▁. ▁getStatusCode ▁( ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁controller ▁. ▁is Status Only ▁( ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁assertThat ▁( ▁controller ▁. ▁getApplication Context ▁( ▁) ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁addView Controller WithDefault View Name ▁( ▁) ▁{ ▁this ▁. ▁registry ▁. ▁addView Controller ▁( ▁STR ▁) ▁; ▁Parameter izable View Controller ▁controller ▁= ▁get Controller ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁controller ▁. ▁getView Name ▁( ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁controller ▁. ▁getStatusCode ▁( ▁) ▁) ▁. ▁isNull ▁( ▁) ▁; ▁assertThat ▁( ▁controller ▁. ▁is Status Only ▁( ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁assertThat ▁( ▁controller ▁. ▁getApplication Context ▁( ▁) ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁add Redirect View Controller ▁( ▁) ▁throws ▁Exception ▁{ ▁this ▁. ▁registry ▁. ▁add Redirect View Controller ▁( ▁STR ▁, ▁STR ▁) ▁; ▁Redirect View ▁redirect View ▁= ▁getRe direct View ▁( ▁STR ▁) ▁; ▁this ▁. ▁request ▁. ▁setQuery String ▁( ▁STR ▁) ▁; ▁this ▁. ▁request ▁. ▁setContext Path ▁( ▁STR ▁) ▁; ▁redirect View ▁. ▁render ▁( ▁Collections ▁. ▁emptyMap ▁( ▁) ▁, ▁this ▁. ▁request ▁, ▁this ▁. ▁response ▁) ▁; ▁assertThat ▁( ▁this ▁. ▁response ▁. ▁getStatus ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁30 2 ▁) ▁; ▁assertThat ▁( ▁this ▁. ▁response ▁. ▁getRe d irected Url ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁redirect View ▁. ▁getApplication Context ▁( ▁) ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁add Redirect View Controller With Custom Settings ▁( ▁) ▁throws ▁Exception ▁{ ▁this ▁. ▁registry ▁. ▁add Redirect View Controller ▁( ▁STR ▁, ▁STR ▁) ▁. ▁setContext Relative ▁( ▁false ▁) ▁. ▁set Keep Query Params ▁( ▁true ▁) ▁. ▁setStatus Code ▁( ▁HttpStatus ▁. ▁PER MAN ENT _ RE DIRECT ▁) ▁; ▁Redirect View ▁redirect View ▁= ▁getRe direct View ▁( ▁STR ▁) ▁; ▁this ▁. ▁request ▁. ▁setQuery String ▁( ▁STR ▁) ▁; ▁this ▁. ▁request ▁. ▁setContext Path ▁( ▁STR ▁) ▁;
▁abstract ▁class ▁Operand Field Helper ▁extends ▁Field Factory ▁{ ▁private ▁final ▁static ▁String ▁EN ABLE _ WORD _ WR AP _ MSG ▁= ▁Ghidra Options ▁. ▁OPER AND _ GROUP _ TITLE ▁+ ▁Options ▁. ▁DE LIMITER ▁+ ▁STR ▁; ▁private ▁final ▁static ▁String ▁MAX _ DI SPLAY _ LIN ES _ MSG ▁= ▁Ghidra Options ▁. ▁OPER AND _ GROUP _ TITLE ▁+ ▁Options ▁. ▁DE LIMITER ▁+ ▁STR ▁; ▁private ▁final ▁static ▁String ▁UN DER LINE _ OPTION ▁= ▁Ghidra Options ▁. ▁OPER AND _ GROUP _ TITLE ▁+ ▁Options ▁. ▁DE LIMITER ▁+ ▁STR ▁; ▁private ▁final ▁static ▁String ▁SPACE _ AFTER _ SEPARATOR _ OPTION ▁= ▁Ghidra Options ▁. ▁OPER AND _ GROUP _ TITLE ▁+ ▁Options ▁. ▁DE LIMITER ▁+ ▁STR ▁; ▁public ▁static ▁enum ▁UN DER LINE _ CH O I CE ▁{ ▁H idden ▁, ▁All ▁, ▁None ▁} ▁private ▁Symbol Inspector ▁ins pector ▁; ▁private ▁Color Style Attributes ▁address Attributes ▁= ▁new ▁Color Style Attributes ▁( ▁) ▁; ▁private ▁Color Style Attributes ▁external Ref Attributes ▁= ▁new ▁Color Style Attributes ▁( ▁) ▁; ▁private ▁Color Style Attributes ▁bad Ref Attributes ▁= ▁new ▁Color Style Attributes ▁( ▁) ▁; ▁private ▁Color Style Attributes ▁separator Attributes ▁= ▁new ▁Color Style Attributes ▁( ▁) ▁; ▁private ▁Color Style Attributes ▁scalar Attributes ▁= ▁new ▁Color Style Attributes ▁( ▁) ▁; ▁private ▁Color Style Attributes ▁variable Ref Attributes ▁= ▁new ▁Color Style Attributes ▁( ▁) ▁; ▁private ▁Color Style Attributes ▁register Attributes ▁= ▁new ▁Color Style Attributes ▁( ▁) ▁; ▁private ▁UN DER LINE _ CH O I CE ▁under line Choice ▁= ▁UN DER LINE _ CH O I CE ▁. ▁H idden ▁; ▁private ▁boolean ▁is Word Wrap ▁= ▁false ▁; ▁private ▁int ▁max Display Lines ▁= ▁2 ▁; ▁private ▁boolean ▁space After Separator ▁= ▁false ▁; ▁protected ▁Browser Code Unit Format ▁code Unit Format ▁; ▁private ▁ChangeListener ▁code Unit Format Listener ▁= ▁e ▁-> ▁Operand Field Helper ▁. ▁this ▁. ▁model ▁. ▁update ▁( ▁) ▁; ▁Operand Field Helper ▁( ▁String ▁name ▁) ▁{ ▁super ▁( ▁name ▁) ▁; ▁} ▁Operand Field Helper ▁( ▁String ▁name ▁, ▁Field Format Model ▁model ▁, ▁Highlight Provider ▁h l Provider ▁, ▁ToolOptions ▁display Options ▁, ▁ToolOptions ▁field Options ▁) ▁{ ▁super ▁( ▁name ▁, ▁model ▁, ▁h l Provider ▁, ▁display Options ▁, ▁field Options ▁) ▁; ▁setOptions ▁( ▁display Options ▁) ▁; ▁HelpLocation ▁h l ▁= ▁new ▁HelpLocation ▁( ▁STR ▁, ▁STR ▁) ▁; ▁field Options ▁. ▁register Option ▁( ▁EN ABLE _ WORD _ WR AP _ MSG ▁, ▁false ▁, ▁h l ▁, ▁STR ▁) ▁; ▁field Options ▁. ▁register Option ▁( ▁MAX _ DI SPLAY _ LIN ES _ MSG ▁, ▁2 ▁, ▁h l ▁, ▁STR ▁) ▁; ▁field Options ▁. ▁register Option ▁( ▁UN DER LINE _ OPTION ▁, ▁UN DER LINE _ CH O I CE ▁. ▁H idden ▁, ▁h l ▁, ▁STR ▁+ ▁STR ▁+ ▁STR ▁) ▁;
▁public ▁Sql Runner ▁sql ▁( ▁) ▁{ ▁return ▁new ▁Sql Runner ▁( ▁this ▁. ▁entity Class ▁) ▁; ▁} ▁protected ▁SqlSession ▁sqlSession ▁( ▁) ▁{ ▁return ▁Sql Helper ▁. ▁sqlSession ▁( ▁this ▁. ▁entity Class ▁) ▁; ▁} ▁protected ▁String ▁sqlStatement ▁( ▁Sql Method ▁sql Method ▁) ▁{ ▁return ▁sqlStatement ▁( ▁sql Method ▁. ▁getMethod ▁( ▁) ▁) ▁; ▁} ▁protected ▁String ▁sqlStatement ▁( ▁String ▁sql Method ▁) ▁{ ▁return ▁Sql Helper ▁. ▁table ▁( ▁this ▁. ▁entity Class ▁) ▁. ▁getSqlStatement ▁( ▁sql Method ▁) ▁; ▁} ▁public ▁Serializable ▁pk Val ▁( ▁) ▁{ ▁Table Info ▁table Info ▁= ▁Table Info Helper ▁. ▁getTable Info ▁( ▁this ▁. ▁entity Class ▁) ▁; ▁return ▁( ▁Serializable ▁) ▁table Info ▁. ▁getProperty Value ▁( ▁this ▁, ▁table Info ▁. ▁getKey Property ▁( ▁) ▁) ▁; ▁} ▁protected ▁void ▁close Sql Session ▁( ▁SqlSession ▁sqlSession ▁) ▁{ ▁SqlSession Utils ▁. ▁close Sql Session ▁( ▁sqlSession ▁, ▁Global Config Utils ▁. ▁current SessionFactory ▁( ▁this ▁. ▁entity Class ▁) ▁) ▁; ▁} ▁}
▁else ▁{ ▁assertThat ▁( ▁Thread ▁. ▁currentThread ▁( ▁) ▁. ▁getName ▁( ▁) ▁, ▁startsWith ▁( ▁STR ▁) ▁) ▁; ▁} ▁} ▁} ▁) ▁; ▁} ▁} ▁@ ▁Override ▁protected ▁Settings ▁nodeSettings ▁( ▁) ▁{ ▁return ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁public ▁void ▁test Clear On Close ▁( ▁) ▁{ ▁createIndex ▁( ▁STR ▁) ▁; ▁client ▁( ▁) ▁. ▁prepareIndex ▁( ▁STR ▁) ▁. ▁setId ▁( ▁STR ▁) ▁. ▁setSource ▁( ▁STR ▁, ▁STR ▁) ▁. ▁set RefreshPolicy ▁( ▁IM MEDIATE ▁) ▁. ▁get ▁( ▁) ▁; ▁SearchResponse ▁searchResponse ▁= ▁client ▁( ▁) ▁. ▁prepareSearch ▁( ▁STR ▁) ▁. ▁setSize ▁( ▁1 ▁) ▁. ▁set Scroll ▁( ▁STR ▁) ▁. ▁get ▁( ▁) ▁; ▁assertThat ▁( ▁searchResponse ▁. ▁getSc roll Id ▁( ▁) ▁, ▁is ▁( ▁notNullValue ▁( ▁) ▁) ▁) ▁; ▁Search Service ▁service ▁= ▁getInstance From Node ▁( ▁Search Service ▁. ▁class ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁service ▁. ▁getActive Contexts ▁( ▁) ▁) ▁; ▁service ▁. ▁do Close ▁( ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁service ▁. ▁getActive Contexts ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁test Clear On Stop ▁( ▁) ▁{ ▁createIndex ▁( ▁STR ▁) ▁; ▁client ▁( ▁) ▁. ▁prepareIndex ▁( ▁STR ▁) ▁. ▁setId ▁( ▁STR ▁) ▁. ▁setSource ▁( ▁STR ▁, ▁STR ▁) ▁. ▁set RefreshPolicy ▁( ▁IM MEDIATE ▁) ▁. ▁get ▁( ▁) ▁; ▁SearchResponse ▁searchResponse ▁= ▁client ▁( ▁) ▁. ▁prepareSearch ▁( ▁STR ▁) ▁. ▁setSize ▁( ▁1 ▁) ▁. ▁set Scroll ▁( ▁STR ▁) ▁. ▁get ▁( ▁) ▁; ▁assertThat ▁( ▁searchResponse ▁. ▁getSc roll Id ▁( ▁) ▁, ▁is ▁( ▁notNullValue ▁( ▁) ▁) ▁) ▁; ▁Search Service ▁service ▁= ▁getInstance From Node ▁( ▁Search Service ▁. ▁class ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁service ▁. ▁getActive Contexts ▁( ▁) ▁) ▁; ▁service ▁. ▁do Stop ▁( ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁service ▁. ▁getActive Contexts ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁test Clear Index Delete ▁( ▁) ▁{ ▁createIndex ▁( ▁STR ▁) ▁; ▁client ▁( ▁) ▁. ▁prepareIndex ▁( ▁STR ▁) ▁. ▁setId ▁( ▁STR ▁) ▁. ▁setSource ▁( ▁STR ▁, ▁STR ▁) ▁. ▁set RefreshPolicy ▁( ▁IM MEDIATE ▁) ▁. ▁get ▁( ▁) ▁; ▁SearchResponse ▁searchResponse ▁= ▁client ▁( ▁) ▁. ▁prepareSearch ▁( ▁STR ▁) ▁. ▁setSize ▁( ▁1 ▁) ▁. ▁set Scroll ▁( ▁STR ▁) ▁. ▁get ▁( ▁) ▁; ▁assertThat ▁( ▁searchResponse ▁. ▁getSc roll Id ▁( ▁) ▁, ▁is ▁( ▁notNullValue ▁( ▁) ▁) ▁) ▁; ▁Search Service ▁service ▁= ▁getInstance From Node ▁( ▁Search Service ▁. ▁class ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁service ▁. ▁getActive Contexts ▁( ▁) ▁) ▁; ▁assertAcked ▁( ▁client ▁( ▁) ▁. ▁admin ▁( ▁) ▁. ▁indices ▁( ▁) ▁. ▁prepare Delete ▁( ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁service ▁. ▁getActive Contexts ▁( ▁) ▁) ▁; ▁}
▁@ ▁On Prepare ▁static ▁void ▁on Prepare ▁( ▁Component Context ▁c ▁, ▁@ ▁Pro p ▁( ▁optional ▁= ▁true ▁) ▁final ▁@ ▁Nullable ▁Object ▁caller Context ▁, ▁@ ▁Pro p ▁( ▁optional ▁= ▁true ▁) ▁final ▁@ ▁Nullable ▁Pref etch ▁prefetch ▁, ▁@ ▁Pro p ▁( ▁optional ▁= ▁true ▁) ▁final ▁@ ▁Nullable ▁Request Listener ▁prefetch Request Listener ▁, ▁@ ▁Cached Value ▁V ito Image Request ▁image Request ▁, ▁Output ▁< ▁DataSource ▁< ▁Void ▁> ▁> ▁prefetch DataSource ▁) ▁{ ▁Pref etch Config ▁config ▁= ▁Fresco V ito Provider ▁. ▁getConfig ▁( ▁) ▁. ▁getPre f etch Config ▁( ▁) ▁; ▁if ▁( ▁should Prefetch In On Prepare ▁( ▁prefetch ▁) ▁) ▁{ ▁prefetch DataSource ▁. ▁set ▁( ▁Fresco V ito Provider ▁. ▁getPre f etch er ▁( ▁) ▁. ▁prefetch ▁( ▁config ▁. ▁prefetch Target On Prepare ▁( ▁) ▁, ▁image Request ▁, ▁caller Context ▁, ▁prefetch Request Listener ▁, ▁STR ▁) ▁) ▁; ▁} ▁} ▁@ ▁On Mount ▁static ▁void ▁on Mount ▁( ▁Component Context ▁c ▁, ▁final ▁Fresco Drawable 2 ▁f resco Drawable ▁, ▁@ ▁Pro p ▁( ▁optional ▁= ▁true ▁) ▁final ▁@ ▁Nullable ▁Image Listener ▁image Listener ▁, ▁@ ▁Pro p ▁( ▁optional ▁= ▁true ▁) ▁final ▁@ ▁Nullable ▁Object ▁caller Context ▁, ▁@ ▁Pro p ▁( ▁optional ▁= ▁true ▁) ▁F ade Drawable ▁. ▁On F ade Listener ▁on F ade Listener ▁, ▁@ ▁Pro p ▁( ▁optional ▁= ▁true ▁) ▁boolean ▁mutate Drawable s ▁, ▁@ ▁Cached Value ▁V ito Image Request ▁image Request ▁, ▁@ ▁From Prepare ▁@ ▁Nullable ▁DataSource ▁< ▁Void ▁> ▁prefetch DataSource ▁, ▁@ ▁From Bounds Defined ▁Rect ▁viewport Dimensions ▁, ▁@ ▁State ▁final ▁@ ▁Nullable ▁AtomicReference ▁< ▁DataSource ▁< ▁Void ▁> ▁> ▁working Range Prefetch Data ▁, ▁@ ▁Tree Prop ▁final ▁@ ▁Nullable ▁Context Chain ▁context Chain ▁) ▁{ ▁f resco Drawable ▁. ▁setM ut ate Drawable s ▁( ▁mutate Drawable s ▁) ▁; ▁if ▁( ▁Fresco V ito Provider ▁. ▁getConfig ▁( ▁) ▁. ▁use Bind Only ▁( ▁) ▁) ▁{ ▁return ▁; ▁} ▁Fresco V ito Provider ▁. ▁get Controller ▁( ▁) ▁. ▁fetch ▁( ▁f resco Drawable ▁, ▁image Request ▁, ▁caller Context ▁, ▁context Chain ▁, ▁image Listener ▁, ▁on F ade Listener ▁, ▁viewport Dimensions ▁) ▁; ▁f resco Drawable ▁. ▁getImage Perf Listener ▁( ▁) ▁. ▁on Image Mount ▁( ▁f resco Drawable ▁) ▁; ▁if ▁( ▁prefetch DataSource ▁!= ▁null ▁) ▁{ ▁prefetch DataSource ▁. ▁close ▁( ▁) ▁; ▁} ▁if ▁( ▁Fresco V ito Provider ▁. ▁getConfig ▁( ▁) ▁. ▁getPre f etch Config ▁( ▁) ▁. ▁cancel Prefetch When F et ched ▁( ▁) ▁) ▁{ ▁cancel Work ing Range Prefetch ▁( ▁working Range Prefetch Data ▁) ▁; ▁} ▁}
▁@ ▁C Context ▁( ▁JNI Header Directives ▁. ▁class ▁) ▁@ ▁C Struct ▁( ▁value ▁= ▁STR ▁) ▁public ▁interface ▁JNI Value ▁extends ▁PointerBase ▁{ ▁@ ▁CField ▁( ▁STR ▁) ▁boolean ▁getBoolean ▁( ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁void ▁setBoolean ▁( ▁boolean ▁z ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁byte ▁getByte ▁( ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁void ▁set Byte ▁( ▁byte ▁b ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁char ▁getChar ▁( ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁void ▁set Char ▁( ▁char ▁c ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁short ▁getShort ▁( ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁void ▁set Short ▁( ▁short ▁s ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁int ▁getInt ▁( ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁void ▁setInt ▁( ▁int ▁i ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁long ▁getLong ▁( ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁void ▁setLong ▁( ▁long ▁j ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁float ▁getFloat ▁( ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁void ▁set Float ▁( ▁float ▁f ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁double ▁getDouble ▁( ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁void ▁set Double ▁( ▁double ▁d ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁JNI Object Handle ▁getObject ▁( ▁) ▁; ▁@ ▁CField ▁( ▁STR ▁) ▁void ▁setObject ▁( ▁JNI Object Handle ▁l ▁) ▁; ▁JNI Value ▁address Of ▁( ▁int ▁index ▁) ▁; ▁}
▁@ ▁Override ▁protected ▁void ▁on Measure ▁( ▁int ▁width MeasureSpec ▁, ▁int ▁height MeasureSpec ▁) ▁{ ▁super ▁. ▁on Measure ▁( ▁width MeasureSpec ▁, ▁height MeasureSpec ▁) ▁; ▁int ▁y ▁= ▁getMeasured Height ▁( ▁) ▁ / ▁2 ▁- ▁Android Utilities ▁. ▁dp ▁( ▁28 ▁) ▁ / ▁2 ▁; ▁delete Progress Rect ▁. ▁set ▁( ▁getMeasured Width ▁( ▁) ▁- ▁Android Utilities ▁. ▁dp ▁( ▁30 ▁+ ▁19 ▁) ▁, ▁y ▁, ▁getMeasured Width ▁( ▁) ▁- ▁Android Utilities ▁. ▁dp ▁( ▁2 ▁+ ▁19 ▁) ▁, ▁y ▁+ ▁Android Utilities ▁. ▁dp ▁( ▁28 ▁) ▁) ▁; ▁} ▁@ ▁SuppressLint ▁( ▁STR ▁) ▁@ ▁Override ▁protected ▁void ▁on Draw ▁( ▁Canvas ▁canvas ▁) ▁{ ▁if ▁( ▁current Message Object ▁== ▁null ▁|| ▁current Message Object ▁. ▁message Owner ▁. ▁destroy Time ▁== ▁0 ▁) ▁{ ▁return ▁; ▁} ▁canvas ▁. ▁draw Circle ▁( ▁getMeasured Width ▁( ▁) ▁- ▁Android Utilities ▁. ▁dp ▁( ▁16 ▁+ ▁19 ▁) ▁, ▁getMeasured Height ▁( ▁) ▁ / ▁2 ▁, ▁Android Utilities ▁. ▁dp ▁( ▁16 ▁) ▁, ▁circle Paint ▁) ▁; ▁float ▁progress ▁; ▁if ▁( ▁use Video Progress ▁) ▁{ ▁if ▁( ▁video Player ▁!= ▁null ▁) ▁{ ▁long ▁duration ▁= ▁video Player ▁. ▁getDuration ▁( ▁) ▁; ▁long ▁position ▁= ▁video Player ▁. ▁getCurrent Position ▁( ▁) ▁; ▁if ▁( ▁duration ▁!= ▁C ▁. ▁TIME _ UNSET ▁&& ▁position ▁!= ▁C ▁. ▁TIME _ UNSET ▁) ▁{ ▁progress ▁= ▁1.0 f ▁- ▁( ▁position ▁ / ▁( ▁float ▁) ▁duration ▁) ▁; ▁} ▁else ▁{ ▁progress ▁= ▁1 ▁; ▁} ▁} ▁else ▁{ ▁progress ▁= ▁1 ▁; ▁} ▁} ▁else ▁{ ▁long ▁ms Time ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁+ ▁Connection s Manager ▁. ▁getInstance ▁( ▁current Account ▁) ▁. ▁getTime Difference ▁( ▁) ▁ * ▁1000 ▁; ▁progress ▁= ▁Math ▁. ▁max ▁( ▁0 ▁, ▁destroy Time ▁- ▁ms Time ▁) ▁ / ▁( ▁destroy Ttl ▁ * ▁1000 .0 f ▁) ▁; ▁} ▁int ▁x ▁= ▁getMeasured Width ▁( ▁) ▁- ▁Android Utilities ▁. ▁dp ▁( ▁32 ▁- ▁11 ▁+ ▁19 ▁) ▁; ▁int ▁y ▁= ▁( ▁getMeasured Height ▁( ▁) ▁- ▁Android Utilities ▁. ▁dp ▁( ▁14 ▁) ▁) ▁ / ▁2 ▁- ▁Android Utilities ▁. ▁dp ▁( ▁0.5 f ▁) ▁; ▁drawable ▁. ▁setBounds ▁( ▁x ▁, ▁y ▁, ▁x ▁+ ▁Android Utilities ▁. ▁dp ▁( ▁10 ▁) ▁, ▁y ▁+ ▁Android Utilities ▁. ▁dp ▁( ▁14 ▁) ▁) ▁; ▁drawable ▁. ▁draw ▁( ▁canvas ▁) ▁; ▁float ▁r ad Progress ▁= ▁- ▁3 60 ▁ * ▁progress ▁; ▁canvas ▁. ▁draw Ar c ▁( ▁delete Progress Rect ▁, ▁- ▁90 ▁, ▁r ad Progress ▁, ▁false ▁, ▁after Delete Progress Paint ▁) ▁; ▁timer Part icle s ▁. ▁draw ▁( ▁canvas ▁, ▁particle Paint ▁, ▁delete Progress Rect ▁, ▁r ad Progress ▁, ▁1.0 f ▁) ▁; ▁invalidate ▁( ▁) ▁; ▁} ▁} ▁private ▁class ▁Photo Background Drawable ▁extends ▁Color Drawable ▁{ ▁private ▁Runnable ▁draw Runnable ▁; ▁private ▁int ▁frame ▁;
▁private ▁Optional ▁< ▁Pinot Expression ▁> ▁handle Date Or Timestamp Binary Expression ▁( ▁String ▁operator ▁, ▁List ▁< ▁RowExpression ▁> ▁arguments ▁, ▁Function ▁< ▁Variable Reference Expression ▁, ▁Selection ▁> ▁context ▁) ▁{ ▁Optional ▁< ▁String ▁> ▁left ▁= ▁handle TimeValue Cast ▁( ▁context ▁, ▁arguments ▁. ▁get ▁( ▁1 ▁) ▁, ▁arguments ▁. ▁get ▁( ▁0 ▁) ▁) ▁; ▁Optional ▁< ▁String ▁> ▁right ▁= ▁handle TimeValue Cast ▁( ▁context ▁, ▁arguments ▁. ▁get ▁( ▁0 ▁) ▁, ▁arguments ▁. ▁get ▁( ▁1 ▁) ▁) ▁; ▁if ▁( ▁left ▁. ▁isPresent ▁( ▁) ▁&& ▁right ▁. ▁isPresent ▁( ▁) ▁) ▁{ ▁return ▁Optional ▁. ▁of ▁( ▁derived ▁( ▁format ▁( ▁STR ▁, ▁left ▁. ▁get ▁( ▁) ▁, ▁operator ▁, ▁right ▁. ▁get ▁( ▁) ▁) ▁) ▁) ▁; ▁} ▁return ▁Optional ▁. ▁empty ▁( ▁) ▁; ▁} ▁private ▁static ▁boolean ▁is DateTime Constant Type ▁( ▁Type ▁type ▁) ▁{ ▁return ▁type ▁== ▁Date Type ▁. ▁DATE ▁|| ▁type ▁== ▁Timestamp Type ▁. ▁TIMESTAMP ▁|| ▁type ▁== ▁Timestamp With Time Z one Type ▁. ▁TIMESTAMP _ WITH _ TIME _ Z ONE ▁; ▁} ▁private ▁Optional ▁< ▁String ▁> ▁handle TimeValue Cast ▁( ▁Function ▁< ▁Variable Reference Expression ▁, ▁Selection ▁> ▁context ▁, ▁RowExpression ▁time Field Expression ▁, ▁RowExpression ▁timeValue Expression ▁) ▁{ ▁Type ▁inputType ▁; ▁Type ▁expected Type ▁; ▁if ▁( ▁! ▁is DateTime Constant Type ▁( ▁time Field Expression ▁. ▁getType ▁( ▁) ▁) ▁|| ▁! ▁is DateTime Constant Type ▁( ▁timeValue Expression ▁. ▁getType ▁( ▁) ▁) ▁) ▁{ ▁return ▁Optional ▁. ▁empty ▁( ▁) ▁; ▁} ▁String ▁timeValue String ▁= ▁timeValue Expression ▁. ▁accept ▁( ▁this ▁, ▁context ▁) ▁. ▁get Definition ▁( ▁) ▁; ▁if ▁( ▁time Field Expression ▁instanceof ▁CallExpression ▁) ▁{ ▁CallExpression ▁call Expression ▁= ▁( ▁CallExpression ▁) ▁time Field Expression ▁; ▁if ▁( ▁! ▁standard Function Resolution ▁. ▁isC ast Function ▁( ▁call Expression ▁. ▁getFunction Handle ▁( ▁) ▁) ▁) ▁{ ▁return ▁Optional ▁. ▁empty ▁( ▁) ▁; ▁} ▁if ▁( ▁call Expression ▁. ▁getArguments ▁( ▁) ▁. ▁size ▁( ▁) ▁!= ▁1 ▁) ▁{ ▁return ▁Optional ▁. ▁empty ▁( ▁) ▁; ▁} ▁inputType ▁= ▁call Expression ▁. ▁getArguments ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁. ▁getType ▁( ▁) ▁; ▁expected Type ▁= ▁call Expression ▁. ▁getType ▁( ▁) ▁; ▁} ▁else ▁if ▁( ▁time Field Expression ▁instanceof ▁Variable Reference Expression ▁) ▁{ ▁inputType ▁= ▁time Field Expression ▁. ▁getType ▁( ▁) ▁; ▁expected Type ▁= ▁timeValue Expression ▁. ▁getType ▁( ▁) ▁; ▁} ▁else ▁if ▁( ▁time Field Expression ▁instanceof ▁Constant Expression ▁) ▁{ ▁return ▁Optional ▁. ▁of ▁( ▁timeValue String ▁) ▁; ▁} ▁else ▁{ ▁return ▁Optional ▁. ▁empty ▁( ▁) ▁; ▁}
▁public ▁class ▁Find Replace ▁extends ▁javax ▁. ▁sw ing ▁. ▁JFrame ▁{ ▁private ▁static ▁final ▁String ▁F IND _ TEXT ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁REPLACE _ TEXT ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁IGNORE _ CASE ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁SEARCH _ ALL _ FILES ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁WRAP _ AR OUND ▁= ▁STR ▁; ▁private ▁final ▁Editor ▁editor ▁; ▁public ▁Find Replace ▁( ▁Editor ▁editor ▁, ▁Map ▁< ▁String ▁, ▁Object ▁> ▁state ▁) ▁{ ▁this ▁. ▁editor ▁= ▁editor ▁; ▁init Components ▁( ▁) ▁; ▁if ▁( ▁OS Utils ▁. ▁is Mac OS ▁( ▁) ▁) ▁{ ▁button s Container ▁. ▁removeAll ▁( ▁) ▁; ▁button s Container ▁. ▁add ▁( ▁replaceAll Button ▁) ▁; ▁button s Container ▁. ▁add ▁( ▁replace Button ▁) ▁; ▁button s Container ▁. ▁add ▁( ▁replace Find Button ▁) ▁; ▁button s Container ▁. ▁add ▁( ▁previous Button ▁) ▁; ▁button s Container ▁. ▁add ▁( ▁find Button ▁) ▁; ▁} ▁Base ▁. ▁register Window Close Keys ▁( ▁getRoot Pane ▁( ▁) ▁, ▁e ▁-> ▁{ ▁setVisible ▁( ▁false ▁) ▁; ▁Base ▁. ▁F IND _ DI AL OG _ STATE ▁= ▁find Dialog State ▁( ▁) ▁; ▁} ▁) ▁; ▁Base ▁. ▁setIcon ▁( ▁this ▁) ▁; ▁add Window Listener ▁( ▁new ▁Window Adapter ▁( ▁) ▁{ ▁public ▁void ▁window Activated ▁( ▁Window Event ▁e ▁) ▁{ ▁findField ▁. ▁request Focus In Window ▁( ▁) ▁; ▁findField ▁. ▁selectAll ▁( ▁) ▁; ▁} ▁} ▁) ▁; ▁restore Find Dialog State ▁( ▁state ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setVisible ▁( ▁boolean ▁b ▁) ▁{ ▁getRoot Pane ▁( ▁) ▁. ▁setDefault Button ▁( ▁find Button ▁) ▁; ▁super ▁. ▁setVisible ▁( ▁b ▁) ▁; ▁} ▁private ▁Map ▁< ▁String ▁, ▁Object ▁> ▁find Dialog State ▁( ▁) ▁{ ▁Map ▁< ▁String ▁, ▁Object ▁> ▁state ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁state ▁. ▁put ▁( ▁F IND _ TEXT ▁, ▁findField ▁. ▁getText ▁( ▁) ▁) ▁; ▁state ▁. ▁put ▁( ▁REPLACE _ TEXT ▁, ▁replace Field ▁. ▁getText ▁( ▁) ▁) ▁; ▁state ▁. ▁put ▁( ▁IGNORE _ CASE ▁, ▁ignore Case Box ▁. ▁isSelected ▁( ▁) ▁) ▁; ▁state ▁. ▁put ▁( ▁WRAP _ AR OUND ▁, ▁wrap Around Box ▁. ▁isSelected ▁( ▁) ▁) ▁; ▁state ▁. ▁put ▁( ▁SEARCH _ ALL _ FILES ▁, ▁search All Files Box ▁. ▁isSelected ▁( ▁) ▁) ▁; ▁return ▁state ▁; ▁} ▁private ▁void ▁restore Find Dialog State ▁( ▁Map ▁< ▁String ▁, ▁Object ▁> ▁state ▁) ▁{ ▁if ▁( ▁state ▁. ▁containsKey ▁( ▁F IND _ TEXT ▁) ▁) ▁{ ▁findField ▁. ▁setText ▁( ▁( ▁String ▁) ▁state ▁. ▁get ▁( ▁F IND _ TEXT ▁) ▁) ▁; ▁} ▁if ▁( ▁state ▁. ▁containsKey ▁( ▁REPLACE _ TEXT ▁) ▁) ▁{ ▁replace Field ▁. ▁setText ▁( ▁( ▁String ▁) ▁state ▁. ▁get ▁( ▁REPLACE _ TEXT ▁) ▁) ▁; ▁}
▁@ ▁Required ArgsConstructor ▁( ▁access ▁= ▁AccessLevel ▁. ▁PRIVATE ▁) ▁@ ▁Equals AndHashCode ▁@ ▁ToString ▁@ ▁Getter ▁public ▁class ▁Result ▁{ ▁public ▁static ▁Result ▁fail ▁( ▁final ▁Throwable ▁throwable ▁) ▁{ ▁return ▁new ▁Result ▁( ▁false ▁, ▁true ▁, ▁throwable ▁. ▁getMessage ▁( ▁) ▁, ▁Sample Family ▁. ▁EMPTY ▁) ▁; ▁} ▁public ▁static ▁Result ▁fail ▁( ▁String ▁message ▁) ▁{ ▁return ▁new ▁Result ▁( ▁false ▁, ▁false ▁, ▁message ▁, ▁Sample Family ▁. ▁EMPTY ▁) ▁; ▁} ▁public ▁static ▁Result ▁fail ▁( ▁) ▁{ ▁return ▁new ▁Result ▁( ▁false ▁, ▁false ▁, ▁null ▁, ▁Sample Family ▁. ▁EMPTY ▁) ▁; ▁} ▁public ▁static ▁Result ▁success ▁( ▁Sample Family ▁sf ▁) ▁{ ▁return ▁new ▁Result ▁( ▁true ▁, ▁false ▁, ▁null ▁, ▁sf ▁) ▁; ▁} ▁private ▁final ▁boolean ▁success ▁; ▁private ▁final ▁boolean ▁is Throwable ▁; ▁private ▁final ▁String ▁error ▁; ▁private ▁final ▁Sample Family ▁data ▁; ▁}
▁public ▁final ▁class ▁Tinker Inline Fence Action ▁{ ▁public ▁static ▁final ▁int ▁ACTION _ ON _ BASE _ CONTEXT _ AT TA CHED ▁= ▁1 ▁; ▁public ▁static ▁final ▁int ▁ACTION _ ON _ CREATE ▁= ▁2 ▁; ▁public ▁static ▁final ▁int ▁ACTION _ ON _ CONFIGURATION _ CHANG ED ▁= ▁3 ▁; ▁public ▁static ▁final ▁int ▁ACTION _ ON _ TR IM _ MEMORY ▁= ▁4 ▁; ▁public ▁static ▁final ▁int ▁ACTION _ ON _ LOW _ MEMORY ▁= ▁5 ▁; ▁public ▁static ▁final ▁int ▁ACTION _ ON _ TERMIN ATE ▁= ▁6 ▁; ▁public ▁static ▁final ▁int ▁ACTION _ GET _ CLASS LOADER ▁= ▁7 ▁; ▁public ▁static ▁final ▁int ▁ACTION _ GET _ BASE _ CONTEXT ▁= ▁8 ▁; ▁public ▁static ▁final ▁int ▁ACTION _ GET _ AS SET S ▁= ▁9 ▁; ▁public ▁static ▁final ▁int ▁ACTION _ GET _ RESOURCE S ▁= ▁10 ▁; ▁public ▁static ▁final ▁int ▁ACTION _ GET _ SYSTEM _ SERVICE ▁= ▁11 ▁; ▁public ▁static ▁final ▁int ▁ACTION _ M Z _ N IGHT MODE _ USE _ OF ▁= ▁12 ▁; ▁static ▁void ▁call On Base Context Att ached ▁( ▁Handler ▁inline Fence ▁, ▁Context ▁context ▁) ▁{ ▁Message ▁msg ▁= ▁null ▁; ▁try ▁{ ▁msg ▁= ▁Message ▁. ▁obtain ▁( ▁inline Fence ▁, ▁ACTION _ ON _ BASE _ CONTEXT _ AT TA CHED ▁, ▁context ▁) ▁; ▁inline Fence ▁. ▁handle Message ▁( ▁msg ▁) ▁; ▁} ▁finally ▁{ ▁msg ▁. ▁recycle ▁( ▁) ▁; ▁} ▁} ▁static ▁void ▁call On Create ▁( ▁Handler ▁inline Fence ▁) ▁{ ▁Message ▁msg ▁= ▁null ▁; ▁try ▁{ ▁msg ▁= ▁Message ▁. ▁obtain ▁( ▁inline Fence ▁, ▁ACTION _ ON _ CREATE ▁) ▁; ▁inline Fence ▁. ▁handle Message ▁( ▁msg ▁) ▁; ▁} ▁finally ▁{ ▁msg ▁. ▁recycle ▁( ▁) ▁; ▁} ▁} ▁static ▁void ▁call On Configuration Changed ▁( ▁Handler ▁inline Fence ▁, ▁Configuration ▁new Config ▁) ▁{ ▁Message ▁msg ▁= ▁null ▁; ▁try ▁{ ▁msg ▁= ▁Message ▁. ▁obtain ▁( ▁inline Fence ▁, ▁ACTION _ ON _ CONFIGURATION _ CHANG ED ▁, ▁new Config ▁) ▁; ▁inline Fence ▁. ▁handle Message ▁( ▁msg ▁) ▁; ▁} ▁finally ▁{ ▁msg ▁. ▁recycle ▁( ▁) ▁; ▁} ▁} ▁static ▁void ▁call On Trim Memory ▁( ▁Handler ▁inline Fence ▁, ▁int ▁level ▁) ▁{ ▁Message ▁msg ▁= ▁null ▁; ▁try ▁{ ▁msg ▁= ▁Message ▁. ▁obtain ▁( ▁inline Fence ▁, ▁ACTION _ ON _ TR IM _ MEMORY ▁, ▁level ▁) ▁; ▁inline Fence ▁. ▁handle Message ▁( ▁msg ▁) ▁; ▁} ▁finally ▁{ ▁msg ▁. ▁recycle ▁( ▁) ▁; ▁} ▁} ▁static ▁void ▁call On Low Memory ▁( ▁Handler ▁inline Fence ▁) ▁{ ▁Message ▁msg ▁= ▁null ▁; ▁try ▁{ ▁msg ▁= ▁Message ▁. ▁obtain ▁( ▁inline Fence ▁, ▁ACTION _ ON _ LOW _ MEMORY ▁) ▁; ▁inline Fence ▁. ▁handle Message ▁( ▁msg ▁) ▁; ▁} ▁finally ▁{ ▁msg ▁. ▁recycle ▁( ▁) ▁; ▁} ▁} ▁static ▁void ▁call On Terminate ▁( ▁Handler ▁inline Fence ▁) ▁{ ▁Message ▁msg ▁= ▁null ▁;
▁public ▁class ▁Test De alloc ate Task ▁{ ▁private ▁final ▁Metadata Manager ▁metadata ▁= ▁createTest MetadataManager ▁( ▁) ▁; ▁private ▁final ▁ExecutorService ▁executor ▁= ▁newCached ThreadPool ▁( ▁daemon Threads Named ▁( ▁STR ▁) ▁) ▁; ▁@ ▁AfterClass ▁( ▁always Run ▁= ▁true ▁) ▁public ▁void ▁tearDown ▁( ▁) ▁{ ▁executor ▁. ▁shutdownNow ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test De alloc ate ▁( ▁) ▁{ ▁Session ▁session ▁= ▁test SessionBuilder ▁( ▁) ▁. ▁add Pre paredStatement ▁( ▁STR ▁, ▁STR ▁) ▁. ▁build ▁( ▁) ▁; ▁Set ▁< ▁String ▁> ▁statements ▁= ▁execute De alloc ate ▁( ▁STR ▁, ▁STR ▁, ▁session ▁) ▁; ▁assertEquals ▁( ▁statements ▁, ▁ImmutableSet ▁. ▁of ▁( ▁STR ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test De alloc ate No Such Statement ▁( ▁) ▁{ ▁try ▁{ ▁execute De alloc ate ▁( ▁STR ▁, ▁STR ▁, ▁TEST _ SESSION ▁) ▁; ▁fail ▁( ▁STR ▁) ▁; ▁} ▁catch ▁( ▁PrestoException ▁e ▁) ▁{ ▁assertEquals ▁( ▁e ▁. ▁getErrorCode ▁( ▁) ▁, ▁NOT _ FOUND ▁. ▁to ErrorCode ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁STR ▁) ▁; ▁} ▁} ▁private ▁Set ▁< ▁String ▁> ▁execute De alloc ate ▁( ▁String ▁statement Name ▁, ▁String ▁sql String ▁, ▁Session ▁session ▁) ▁{ ▁Transaction Manager ▁transaction Manager ▁= ▁createTest Transaction Manager ▁( ▁) ▁; ▁Query StateMachine ▁stateMachine ▁= ▁createQuery StateMachine ▁( ▁sql String ▁, ▁session ▁, ▁false ▁, ▁transaction Manager ▁, ▁executor ▁, ▁metadata ▁) ▁; ▁De alloc ate ▁de alloc ate ▁= ▁new ▁De alloc ate ▁( ▁new ▁Identifier ▁( ▁statement Name ▁) ▁) ▁; ▁new ▁De alloc ate Task ▁( ▁) ▁. ▁execute ▁( ▁de alloc ate ▁, ▁transaction Manager ▁, ▁metadata ▁, ▁new ▁Allow All AccessControl ▁( ▁) ▁, ▁stateMachine ▁, ▁emptyList ▁( ▁) ▁) ▁; ▁return ▁stateMachine ▁. ▁get De allocated Pre paredStatements ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁Future Spawn ▁{ ▁public ▁static ▁Future Spawn ▁immediate ▁( ▁Spawn Result ▁f ▁) ▁{ ▁return ▁new ▁Future Spawn ▁( ▁Futures ▁. ▁immediate Future ▁( ▁f ▁) ▁) ▁; ▁} ▁private ▁final ▁List enableFuture ▁< ▁? ▁extends ▁Spawn Result ▁> ▁future ▁; ▁private ▁final ▁Wrapper ▁wrapper ▁; ▁public ▁Future Spawn ▁( ▁List enableFuture ▁< ▁? ▁extends ▁Spawn Result ▁> ▁future ▁) ▁{ ▁this ▁( ▁future ▁, ▁( ▁c ▁) ▁-> ▁c ▁. ▁get ▁( ▁) ▁) ▁; ▁} ▁private ▁Future Spawn ▁( ▁List enableFuture ▁< ▁? ▁extends ▁Spawn Result ▁> ▁future ▁, ▁Wrapper ▁wrapper ▁) ▁{ ▁this ▁. ▁future ▁= ▁future ▁; ▁this ▁. ▁wrapper ▁= ▁wrapper ▁; ▁} ▁public ▁List enableFuture ▁< ▁? ▁extends ▁Spawn Result ▁> ▁get Future ▁( ▁) ▁{ ▁return ▁future ▁; ▁} ▁public ▁Spawn Result ▁get ▁( ▁) ▁throws ▁Exec Exception ▁, ▁Interrupted Exception ▁{ ▁return ▁wrapper ▁. ▁apply ▁( ▁( ▁) ▁-> ▁{ ▁try ▁{ ▁return ▁future ▁. ▁get ▁( ▁) ▁; ▁} ▁catch ▁( ▁Execution Exception ▁e ▁) ▁{ ▁Throwable s ▁. ▁propagate IfPossible ▁( ▁e ▁. ▁getCause ▁( ▁) ▁, ▁Exec Exception ▁. ▁class ▁, ▁Interrupted Exception ▁. ▁class ▁) ▁; ▁throw ▁new ▁Runtime Exception ▁( ▁e ▁) ▁; ▁} ▁catch ▁( ▁Cancel lation Exception ▁e ▁) ▁{ ▁throw ▁new ▁Interrupted Exception ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁Interrupted Exception ▁e ▁) ▁{ ▁future ▁. ▁cancel ▁( ▁true ▁) ▁; ▁throw ▁e ▁; ▁} ▁} ▁) ▁; ▁} ▁public ▁Future Spawn ▁wrap ▁( ▁Wrapper ▁wrapper ▁) ▁{ ▁Wrapper ▁previous Wrapper ▁= ▁this ▁. ▁wrapper ▁; ▁return ▁new ▁Future Spawn ▁( ▁future ▁, ▁( ▁c ▁) ▁-> ▁wrapper ▁. ▁apply ▁( ▁( ▁) ▁-> ▁previous Wrapper ▁. ▁apply ▁( ▁c ▁) ▁) ▁) ▁; ▁} ▁@ ▁Functional Interface ▁public ▁interface ▁Callable ▁< ▁T ▁> ▁{ ▁T ▁get ▁( ▁) ▁throws ▁Exec Exception ▁, ▁Interrupted Exception ▁; ▁} ▁@ ▁Functional Interface ▁public ▁interface ▁Wrapper ▁{ ▁Spawn Result ▁apply ▁( ▁Callable ▁< ▁Spawn Result ▁> ▁future ▁) ▁throws ▁Exec Exception ▁, ▁Interrupted Exception ▁; ▁} ▁}
▁@ ▁SpringBoot Application ▁public ▁class ▁Ldap Demo Application ▁{ ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Spring Application ▁. ▁run ▁( ▁Ldap Demo Application ▁. ▁class ▁, ▁args ▁) ▁; ▁} ▁}
▁cpu ▁. ▁toXContent ▁( ▁builder ▁, ▁params ▁) ▁; ▁mem ▁. ▁toXContent ▁( ▁builder ▁, ▁params ▁) ▁; ▁swap ▁. ▁toXContent ▁( ▁builder ▁, ▁params ▁) ▁; ▁if ▁( ▁c group ▁!= ▁null ▁) ▁{ ▁c group ▁. ▁toXContent ▁( ▁builder ▁, ▁params ▁) ▁; ▁} ▁builder ▁. ▁endObject ▁( ▁) ▁; ▁return ▁builder ▁; ▁} ▁public ▁static ▁class ▁Cpu ▁implements ▁Writeable ▁, ▁ToXContent Fragment ▁{ ▁private ▁final ▁short ▁percent ▁; ▁private ▁final ▁double ▁[ ▁] ▁load Average ▁; ▁public ▁Cpu ▁( ▁short ▁system Cpu Percent ▁, ▁double ▁[ ▁] ▁system Load Average ▁) ▁{ ▁this ▁. ▁percent ▁= ▁system Cpu Percent ▁; ▁this ▁. ▁load Average ▁= ▁system Load Average ▁; ▁} ▁public ▁Cpu ▁( ▁StreamInput ▁in ▁) ▁throws ▁IOException ▁{ ▁this ▁. ▁percent ▁= ▁in ▁. ▁readShort ▁( ▁) ▁; ▁if ▁( ▁in ▁. ▁readBoolean ▁( ▁) ▁) ▁{ ▁this ▁. ▁load Average ▁= ▁in ▁. ▁readDouble Array ▁( ▁) ▁; ▁} ▁else ▁{ ▁this ▁. ▁load Average ▁= ▁null ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁writeTo ▁( ▁StreamOutput ▁out ▁) ▁throws ▁IOException ▁{ ▁out ▁. ▁writeShort ▁( ▁percent ▁) ▁; ▁if ▁( ▁load Average ▁== ▁null ▁) ▁{ ▁out ▁. ▁writeBoolean ▁( ▁false ▁) ▁; ▁} ▁else ▁{ ▁out ▁. ▁writeBoolean ▁( ▁true ▁) ▁; ▁out ▁. ▁writeDouble Array ▁( ▁load Average ▁) ▁; ▁} ▁} ▁public ▁short ▁getPer cent ▁( ▁) ▁{ ▁return ▁percent ▁; ▁} ▁public ▁double ▁[ ▁] ▁getLoad Average ▁( ▁) ▁{ ▁return ▁load Average ▁; ▁} ▁@ ▁Override ▁public ▁XContentBuilder ▁toXContent ▁( ▁XContentBuilder ▁builder ▁, ▁Params ▁params ▁) ▁throws ▁IOException ▁{ ▁builder ▁. ▁startObject ▁( ▁Fields ▁. ▁CPU ▁) ▁; ▁builder ▁. ▁field ▁( ▁Fields ▁. ▁PER CENT ▁, ▁getPer cent ▁( ▁) ▁) ▁; ▁if ▁( ▁getLoad Average ▁( ▁) ▁!= ▁null ▁&& ▁Arrays ▁. ▁stream ▁( ▁getLoad Average ▁( ▁) ▁) ▁. ▁anyMatch ▁( ▁load ▁-> ▁load ▁!= ▁- ▁1 ▁) ▁) ▁{ ▁builder ▁. ▁startObject ▁( ▁Fields ▁. ▁LOAD _ A VER AGE ▁) ▁; ▁if ▁( ▁getLoad Average ▁( ▁) ▁[ ▁0 ▁] ▁!= ▁- ▁1 ▁) ▁{ ▁builder ▁. ▁field ▁( ▁Fields ▁. ▁LOAD _ A VER AGE _1 M ▁, ▁getLoad Average ▁( ▁) ▁[ ▁0 ▁] ▁) ▁; ▁} ▁if ▁( ▁getLoad Average ▁( ▁) ▁[ ▁1 ▁] ▁!= ▁- ▁1 ▁) ▁{ ▁builder ▁. ▁field ▁( ▁Fields ▁. ▁LOAD _ A VER AGE _5 M ▁, ▁getLoad Average ▁( ▁) ▁[ ▁1 ▁] ▁) ▁; ▁} ▁if ▁( ▁getLoad Average ▁( ▁) ▁[ ▁2 ▁] ▁!= ▁- ▁1 ▁) ▁{ ▁builder ▁. ▁field ▁( ▁Fields ▁. ▁LOAD _ A VER AGE _15 M ▁, ▁getLoad Average ▁( ▁) ▁[ ▁2 ▁] ▁) ▁; ▁} ▁builder ▁. ▁endObject ▁( ▁) ▁; ▁} ▁builder ▁. ▁endObject ▁( ▁) ▁; ▁return ▁builder ▁; ▁} ▁} ▁public ▁static ▁class ▁Sw ap ▁implements ▁Writeable ▁, ▁ToXContent Fragment ▁{ ▁private ▁static ▁final ▁Logger ▁logger ▁= ▁LogManager ▁. ▁getLogger ▁( ▁Sw ap ▁. ▁class ▁) ▁; ▁private ▁final ▁long ▁total ▁; ▁private ▁final ▁long ▁free ▁;
▁public ▁class ▁Raw Enumerator Impl ▁extends ▁Unknown Ex Impl ▁implements ▁Raw Enumerator Internal ▁{ ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁private ▁final ▁Opaque Clean able ▁clean able ▁; ▁private ▁final ▁I Raw Enumerator ▁jnaData ▁; ▁private ▁ULONG ▁kind ▁; ▁private ▁ModelObject ▁value ▁; ▁public ▁Raw Enumerator Impl ▁( ▁I Raw Enumerator ▁jnaData ▁) ▁{ ▁super ▁( ▁jnaData ▁) ▁; ▁this ▁. ▁clean able ▁= ▁DbgModel ▁. ▁release When Ph an tom ▁( ▁this ▁, ▁jnaData ▁) ▁; ▁this ▁. ▁jnaData ▁= ▁jnaData ▁; ▁} ▁@ ▁Override ▁public ▁Pointer ▁getPointer ▁( ▁) ▁{ ▁return ▁jnaData ▁. ▁getPointer ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁reset ▁( ▁) ▁{ ▁COMUtils ▁. ▁checkRC ▁( ▁jnaData ▁. ▁Reset ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getNext ▁( ▁) ▁{ ▁B STR ByReference ▁b ref ▁= ▁new ▁B STR ByReference ▁( ▁) ▁; ▁ULONG ByReference ▁ul Kind ▁= ▁new ▁ULONG ByReference ▁( ▁) ▁; ▁Pointer ByReference ▁pp Value ▁= ▁new ▁Pointer ByReference ▁( ▁) ▁; ▁HRESULT ▁h r ▁= ▁jnaData ▁. ▁Get Next ▁( ▁b ref ▁, ▁ul Kind ▁, ▁pp Value ▁) ▁; ▁if ▁( ▁h r ▁. ▁equals ▁( ▁COMUtils Extra ▁. ▁E _ B OUN DS ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁COMUtils ▁. ▁checkRC ▁( ▁h r ▁) ▁; ▁kind ▁= ▁ul Kind ▁. ▁getValue ▁( ▁) ▁; ▁WrapI Model Object ▁wrap ▁= ▁new ▁WrapI Model Object ▁( ▁pp Value ▁. ▁getValue ▁( ▁) ▁) ▁; ▁try ▁{ ▁value ▁= ▁ModelObject Internal ▁. ▁tryPreferred Interfaces ▁( ▁wrap ▁:: ▁Query Interface ▁) ▁; ▁} ▁finally ▁{ ▁wrap ▁. ▁Release ▁( ▁) ▁; ▁} ▁B STR ▁b str ▁= ▁b ref ▁. ▁getValue ▁( ▁) ▁; ▁String ▁key ▁= ▁b str ▁. ▁getValue ▁( ▁) ▁; ▁O le Auto ▁. ▁INSTANCE ▁. ▁Sys Free String ▁( ▁b str ▁) ▁; ▁return ▁key ▁; ▁} ▁@ ▁Override ▁public ▁ModelObject Kind ▁getKind ▁( ▁) ▁{ ▁return ▁ModelObject Kind ▁. ▁values ▁( ▁) ▁[ ▁kind ▁. ▁intValue ▁( ▁) ▁] ▁; ▁} ▁@ ▁Override ▁public ▁ModelObject ▁getValue ▁( ▁) ▁{ ▁return ▁value ▁; ▁} ▁}
▁state ▁. ▁routingTable ▁( ▁Routing Table ▁. ▁builder ▁( ▁) ▁. ▁add ▁( ▁Index Routing Table ▁. ▁builder ▁( ▁indexMetadata ▁. ▁getIndex ▁( ▁) ▁) ▁. ▁add Index Shard ▁( ▁index Shard Routing Table ▁) ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁return ▁state ▁. ▁build ▁( ▁) ▁; ▁} ▁public ▁static ▁ClusterState ▁state ▁( ▁String ▁index ▁, ▁final ▁int ▁numberOf Nodes ▁, ▁final ▁int ▁numberOf P rim aries ▁) ▁{ ▁DiscoveryNodes ▁. ▁Builder ▁dis co Builder ▁= ▁DiscoveryNodes ▁. ▁builder ▁( ▁) ▁; ▁Set ▁< ▁String ▁> ▁nodes ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁numberOf Nodes ▁; ▁i ▁++ ▁) ▁{ ▁final ▁DiscoveryNode ▁node ▁= ▁newNode ▁( ▁i ▁) ▁; ▁dis co Builder ▁= ▁dis co Builder ▁. ▁add ▁( ▁node ▁) ▁; ▁nodes ▁. ▁add ▁( ▁node ▁. ▁getId ▁( ▁) ▁) ▁; ▁} ▁dis co Builder ▁. ▁local NodeId ▁( ▁newNode ▁( ▁0 ▁) ▁. ▁getId ▁( ▁) ▁) ▁; ▁dis co Builder ▁. ▁master NodeId ▁( ▁randomFrom ▁( ▁nodes ▁) ▁) ▁; ▁IndexMetadata ▁indexMetadata ▁= ▁IndexMetadata ▁. ▁builder ▁( ▁index ▁) ▁. ▁settings ▁( ▁Settings ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁SETTING _ VERSION _ CREATED ▁, ▁Version ▁. ▁CURRENT ▁) ▁. ▁put ▁( ▁SETTING _ NUMBER _ OF _ SHAR DS ▁, ▁numberOf P rim aries ▁) ▁. ▁put ▁( ▁SETTING _ NUMBER _ OF _ REP LIC AS ▁, ▁0 ▁) ▁. ▁put ▁( ▁SETTING _ CRE ATION _ DATE ▁, ▁System ▁. ▁current TimeMillis ▁( ▁) ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁Index Routing Table ▁. ▁Builder ▁index Routing Table ▁= ▁Index Routing Table ▁. ▁builder ▁( ▁indexMetadata ▁. ▁getIndex ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁numberOf P rim aries ▁; ▁i ▁++ ▁) ▁{ ▁ShardId ▁shardId ▁= ▁new ▁ShardId ▁( ▁indexMetadata ▁. ▁getIndex ▁( ▁) ▁, ▁i ▁) ▁; ▁IndexShard Routing Table ▁. ▁Builder ▁index Shard Routing Builder ▁= ▁new ▁IndexShard Routing Table ▁. ▁Builder ▁( ▁shardId ▁) ▁; ▁index Shard Routing Builder ▁. ▁add Shard ▁( ▁Test Shard Routing ▁. ▁new Shard Routing ▁( ▁shardId ▁, ▁randomFrom ▁( ▁nodes ▁) ▁, ▁true ▁, ▁ShardRouting State ▁. ▁STARTED ▁) ▁) ▁; ▁index Routing Table ▁. ▁add Index Shard ▁( ▁index Shard Routing Builder ▁. ▁build ▁( ▁) ▁) ▁; ▁} ▁ClusterState ▁. ▁Builder ▁state ▁= ▁ClusterState ▁. ▁builder ▁( ▁new ▁ClusterName ▁( ▁STR ▁) ▁) ▁; ▁state ▁. ▁nodes ▁( ▁dis co Builder ▁) ▁; ▁state ▁. ▁metadata ▁( ▁Metadata ▁. ▁builder ▁( ▁) ▁. ▁put ▁( ▁indexMetadata ▁, ▁false ▁) ▁. ▁generate Cluster Uuid IfNeeded ▁( ▁) ▁) ▁; ▁state ▁. ▁routingTable ▁( ▁Routing Table ▁. ▁builder ▁( ▁) ▁. ▁add ▁( ▁index Routing Table ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁return ▁state ▁. ▁build ▁( ▁) ▁; ▁} ▁public ▁static ▁ClusterState ▁state ▁( ▁final ▁int ▁numberOf Nodes ▁, ▁final ▁String ▁[ ▁] ▁indices ▁, ▁final ▁int ▁numberOf P rim aries ▁) ▁{ ▁DiscoveryNodes ▁. ▁Builder ▁dis co Builder ▁= ▁DiscoveryNodes ▁. ▁builder ▁( ▁) ▁;
▁public ▁class ▁bt F ace ▁extends ▁BulletBase ▁{ ▁private ▁long ▁swigCPtr ▁; ▁protected ▁bt F ace ▁( ▁final ▁String ▁className ▁, ▁long ▁cPtr ▁, ▁boolean ▁cMemoryOwn ▁) ▁{ ▁super ▁( ▁className ▁, ▁cPtr ▁, ▁cMemoryOwn ▁) ▁; ▁swigCPtr ▁= ▁cPtr ▁; ▁} ▁public ▁bt F ace ▁( ▁long ▁cPtr ▁, ▁boolean ▁cMemoryOwn ▁) ▁{ ▁this ▁( ▁STR ▁, ▁cPtr ▁, ▁cMemoryOwn ▁) ▁; ▁construct ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁reset ▁( ▁long ▁cPtr ▁, ▁boolean ▁cMemoryOwn ▁) ▁{ ▁if ▁( ▁! ▁destroyed ▁) ▁destroy ▁( ▁) ▁; ▁super ▁. ▁reset ▁( ▁swigCPtr ▁= ▁cPtr ▁, ▁cMemoryOwn ▁) ▁; ▁} ▁public ▁static ▁long ▁getCPtr ▁( ▁bt F ace ▁obj ▁) ▁{ ▁return ▁( ▁obj ▁== ▁null ▁) ▁? ▁0 ▁: ▁obj ▁. ▁swigCPtr ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁finalize ▁( ▁) ▁throws ▁Throwable ▁{ ▁if ▁( ▁! ▁destroyed ▁) ▁destroy ▁( ▁) ▁; ▁super ▁. ▁finalize ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁synchronized ▁void ▁delete ▁( ▁) ▁{ ▁if ▁( ▁swigCPtr ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁swigCMemOwn ▁) ▁{ ▁swigCMemOwn ▁= ▁false ▁; ▁CollisionJNI ▁. ▁delete _ bt F ace ▁( ▁swigCPtr ▁) ▁; ▁} ▁swigCPtr ▁= ▁0 ▁; ▁} ▁super ▁. ▁delete ▁( ▁) ▁; ▁} ▁public ▁void ▁set Indices ▁( ▁SWIGTYPE _ p _ btAligned ObjectArrayT _ int _ t ▁value ▁) ▁{ ▁CollisionJNI ▁. ▁bt F ace _ ind ices _ set ▁( ▁swigCPtr ▁, ▁this ▁, ▁SWIGTYPE _ p _ btAligned ObjectArrayT _ int _ t ▁. ▁getCPtr ▁( ▁value ▁) ▁) ▁; ▁} ▁public ▁SWIGTYPE _ p _ btAligned ObjectArrayT _ int _ t ▁getIndices ▁( ▁) ▁{ ▁long ▁cPtr ▁= ▁CollisionJNI ▁. ▁bt F ace _ ind ices _ get ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁return ▁( ▁cPtr ▁== ▁0 ▁) ▁? ▁null ▁: ▁new ▁SWIGTYPE _ p _ btAligned ObjectArrayT _ int _ t ▁( ▁cPtr ▁, ▁false ▁) ▁; ▁} ▁public ▁void ▁set Plan e ▁( ▁float ▁[ ▁] ▁value ▁) ▁{ ▁CollisionJNI ▁. ▁bt F ace _ pl ane _ set ▁( ▁swigCPtr ▁, ▁this ▁, ▁value ▁) ▁; ▁} ▁public ▁float ▁[ ▁] ▁getP lan e ▁( ▁) ▁{ ▁return ▁CollisionJNI ▁. ▁bt F ace _ pl ane _ get ▁( ▁swigCPtr ▁, ▁this ▁) ▁; ▁} ▁public ▁bt F ace ▁( ▁) ▁{ ▁this ▁( ▁CollisionJNI ▁. ▁new _ bt F ace ▁( ▁) ▁, ▁true ▁) ▁; ▁} ▁}
▁( ▁( ▁ClusterState Applier ▁) ▁invocation ▁. ▁getArguments ▁( ▁) ▁[ ▁0 ▁] ▁) ▁. ▁apply ClusterState ▁( ▁event ▁) ▁; ▁return ▁null ▁; ▁} ▁) ▁. ▁when ▁( ▁clusterService ▁) ▁. ▁add State Applier ▁( ▁any ▁( ▁ClusterState Applier ▁. ▁class ▁) ▁) ▁; ▁ingest Service ▁= ▁mock ▁( ▁Ingest Service ▁. ▁class ▁) ▁; ▁action ▁= ▁new ▁Test Transport Bulk Action ▁( ▁) ▁; ▁single Item Bulk Write Action ▁= ▁new ▁Test Single Item Bulk Write Action ▁( ▁action ▁) ▁; ▁reset ▁( ▁transport Service ▁) ▁; ▁} ▁public ▁void ▁test In gest Skipped ▁( ▁) ▁throws ▁Exception ▁{ ▁Bulk Request ▁bulk Request ▁= ▁new ▁Bulk Request ▁( ▁) ▁; ▁IndexRequest ▁index Request ▁= ▁new ▁IndexRequest ▁( ▁STR ▁) ▁. ▁id ▁( ▁STR ▁) ▁; ▁index Request ▁. ▁source ▁( ▁Collections ▁. ▁emptyMap ▁( ▁) ▁) ▁; ▁bulk Request ▁. ▁add ▁( ▁index Request ▁) ▁; ▁Action TestUtils ▁. ▁execute ▁( ▁action ▁, ▁null ▁, ▁bulk Request ▁, ▁ActionListener ▁. ▁wrap ▁( ▁response ▁-> ▁{ ▁} ▁, ▁exception ▁-> ▁{ ▁throw ▁new ▁AssertionError ▁( ▁exception ▁) ▁; ▁} ▁) ▁) ▁; ▁assertTrue ▁( ▁action ▁. ▁is Executed ▁) ▁; ▁verify Z ero Interactions ▁( ▁ingest Service ▁) ▁; ▁} ▁public ▁void ▁test Single Item Bulk Action In gest Skipped ▁( ▁) ▁throws ▁Exception ▁{ ▁IndexRequest ▁index Request ▁= ▁new ▁IndexRequest ▁( ▁STR ▁) ▁. ▁id ▁( ▁STR ▁) ▁; ▁index Request ▁. ▁source ▁( ▁Collections ▁. ▁emptyMap ▁( ▁) ▁) ▁; ▁Action TestUtils ▁. ▁execute ▁( ▁single Item Bulk Write Action ▁, ▁null ▁, ▁index Request ▁, ▁ActionListener ▁. ▁wrap ▁( ▁response ▁-> ▁{ ▁} ▁, ▁exception ▁-> ▁{ ▁throw ▁new ▁AssertionError ▁( ▁exception ▁) ▁; ▁} ▁) ▁) ▁; ▁assertTrue ▁( ▁action ▁. ▁is Executed ▁) ▁; ▁verify Z ero Interactions ▁( ▁ingest Service ▁) ▁; ▁} ▁public ▁void ▁test In gest Local ▁( ▁) ▁throws ▁Exception ▁{ ▁Exception ▁exception ▁= ▁new ▁Exception ▁( ▁STR ▁) ▁; ▁Bulk Request ▁bulk Request ▁= ▁new ▁Bulk Request ▁( ▁) ▁; ▁IndexRequest ▁index Request 1 ▁= ▁new ▁IndexRequest ▁( ▁STR ▁) ▁. ▁id ▁( ▁STR ▁) ▁; ▁index Request 1 ▁. ▁source ▁( ▁Collections ▁. ▁emptyMap ▁( ▁) ▁) ▁; ▁index Request 1 ▁. ▁set Pipeline ▁( ▁STR ▁) ▁; ▁IndexRequest ▁index Request 2 ▁= ▁new ▁IndexRequest ▁( ▁STR ▁) ▁. ▁id ▁( ▁STR ▁) ▁; ▁index Request 2 ▁. ▁source ▁( ▁Collections ▁. ▁emptyMap ▁( ▁) ▁) ▁; ▁index Request 2 ▁. ▁set Pipeline ▁( ▁STR ▁) ▁; ▁bulk Request ▁. ▁add ▁( ▁index Request 1 ▁) ▁; ▁bulk Request ▁. ▁add ▁( ▁index Request 2 ▁) ▁; ▁AtomicBoolean ▁response Called ▁= ▁new ▁AtomicBoolean ▁( ▁false ▁) ▁; ▁AtomicBoolean ▁failure Called ▁= ▁new ▁AtomicBoolean ▁( ▁false ▁) ▁; ▁Action TestUtils ▁. ▁execute ▁( ▁action ▁, ▁null ▁, ▁bulk Request ▁, ▁ActionListener ▁. ▁wrap ▁( ▁response ▁-> ▁{ ▁Bulk ItemResponse ▁item Response ▁= ▁response ▁. ▁iterator ▁( ▁) ▁. ▁next ▁( ▁) ▁; ▁assertThat ▁( ▁item Response ▁. ▁getFailure ▁( ▁) ▁. ▁getMessage ▁( ▁) ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁response Called ▁. ▁set ▁( ▁true ▁) ▁;
▁assertThat ▁( ▁descriptor ▁. ▁getDecl aringClass ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁In herited Annotation Interface ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁descriptor ▁. ▁getAnnotation ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁raw Annotation ▁) ▁; ▁descriptor ▁= ▁find Annotation Descriptor ▁( ▁Sub In herited Annotation Interface ▁. ▁class ▁, ▁Transactional ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁descriptor ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁assertThat ▁( ▁descriptor ▁. ▁getRoot Decl aringClass ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Sub In herited Annotation Interface ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁descriptor ▁. ▁getDecl aringClass ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁In herited Annotation Interface ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁descriptor ▁. ▁getAnnotation ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁raw Annotation ▁) ▁; ▁descriptor ▁= ▁find Annotation Descriptor ▁( ▁Sub Sub In herited Annotation Interface ▁. ▁class ▁, ▁Transactional ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁descriptor ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁assertThat ▁( ▁descriptor ▁. ▁getRoot Decl aringClass ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Sub Sub In herited Annotation Interface ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁descriptor ▁. ▁getDecl aringClass ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁In herited Annotation Interface ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁descriptor ▁. ▁getAnnotation ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁raw Annotation ▁) ▁; ▁} ▁@ ▁Test ▁void ▁find Annotation Descriptor For Non In herited Annotation On Class ▁( ▁) ▁{ ▁assertThat ▁( ▁find Annotation Descriptor ▁( ▁Non In herited Annotation Class ▁. ▁class ▁, ▁Order ▁. ▁class ▁) ▁. ▁getRoot Decl aringClass ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Non In herited Annotation Class ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁find Annotation Descriptor ▁( ▁Sub Non In herited Annotation Class ▁. ▁class ▁, ▁Order ▁. ▁class ▁) ▁. ▁getRoot Decl aringClass ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Non In herited Annotation Class ▁. ▁class ▁) ▁; ▁} ▁@ ▁Test ▁void ▁find Annotation Descriptor For Non In herited Annotation On Interface ▁( ▁) ▁{ ▁Order ▁raw Annotation ▁= ▁Non In herited Annotation Interface ▁. ▁class ▁. ▁getAnnotation ▁( ▁Order ▁. ▁class ▁) ▁; ▁Annotation Descriptor ▁< ▁Order ▁> ▁descriptor ▁= ▁find Annotation Descriptor ▁( ▁Non In herited Annotation Interface ▁. ▁class ▁, ▁Order ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁descriptor ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁assertThat ▁( ▁descriptor ▁. ▁getRoot Decl aringClass ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Non In herited Annotation Interface ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁descriptor ▁. ▁getDecl aringClass ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Non In herited Annotation Interface ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁descriptor ▁. ▁getAnnotation ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁raw Annotation ▁) ▁; ▁descriptor ▁= ▁find Annotation Descriptor ▁( ▁Sub Non In herited Annotation Interface ▁. ▁class ▁, ▁Order ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁descriptor ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁assertThat ▁( ▁descriptor ▁. ▁getRoot Decl aringClass ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Sub Non In herited Annotation Interface ▁. ▁class ▁) ▁; ▁assertThat ▁( ▁descriptor ▁. ▁getDecl aringClass ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Non In herited Annotation Interface ▁. ▁class ▁) ▁;
▁} ▁@ ▁GetMapping ▁@ ▁Sec ured ▁( ▁parser ▁= ▁Naming Resource Parser ▁. ▁class ▁, ▁action ▁= ▁Action Types ▁. ▁READ ▁) ▁public ▁ObjectNode ▁detail ▁( ▁HttpServlet Request ▁request ▁) ▁throws ▁Exception ▁{ ▁String ▁namespaceId ▁= ▁Web Utils ▁. ▁optional ▁( ▁request ▁, ▁Common Params ▁. ▁NAMESPACE _ ID ▁, ▁Constants ▁. ▁DEFAULT _ NAMESPACE _ ID ▁) ▁; ▁String ▁serviceName ▁= ▁Web Utils ▁. ▁required ▁( ▁request ▁, ▁Common Params ▁. ▁SERVICE _ NAME ▁) ▁; ▁Naming Utils ▁. ▁check ServiceName Format ▁( ▁serviceName ▁) ▁; ▁String ▁cluster ▁= ▁Web Utils ▁. ▁optional ▁( ▁request ▁, ▁Common Params ▁. ▁CLUSTER _ NAME ▁, ▁Utils And Commons ▁. ▁DEFAULT _ CLUSTER _ NAME ▁) ▁; ▁String ▁ip ▁= ▁Web Utils ▁. ▁required ▁( ▁request ▁, ▁STR ▁) ▁; ▁int ▁port ▁= ▁Integer ▁. ▁parseInt ▁( ▁Web Utils ▁. ▁required ▁( ▁request ▁, ▁STR ▁) ▁) ▁; ▁com ▁. ▁alibaba ▁. ▁nacos ▁. ▁api ▁. ▁naming ▁. ▁p ojo ▁. ▁Instance ▁instance ▁= ▁getInstance Operator ▁( ▁) ▁. ▁getInstance ▁( ▁namespaceId ▁, ▁serviceName ▁, ▁cluster ▁, ▁ip ▁, ▁port ▁) ▁; ▁ObjectNode ▁result ▁= ▁Jackson Utils ▁. ▁createEmpty Json Node ▁( ▁) ▁; ▁result ▁. ▁put ▁( ▁STR ▁, ▁serviceName ▁) ▁; ▁result ▁. ▁put ▁( ▁STR ▁, ▁ip ▁) ▁; ▁result ▁. ▁put ▁( ▁STR ▁, ▁port ▁) ▁; ▁result ▁. ▁put ▁( ▁STR ▁, ▁cluster ▁) ▁; ▁result ▁. ▁put ▁( ▁STR ▁, ▁instance ▁. ▁getWeight ▁( ▁) ▁) ▁; ▁result ▁. ▁put ▁( ▁STR ▁, ▁instance ▁. ▁is Healthy ▁( ▁) ▁) ▁; ▁result ▁. ▁put ▁( ▁STR ▁, ▁instance ▁. ▁getInstance Id ▁( ▁) ▁) ▁; ▁result ▁. ▁set ▁( ▁STR ▁, ▁Jackson Utils ▁. ▁transferTo Json Node ▁( ▁instance ▁. ▁getMetadata ▁( ▁) ▁) ▁) ▁; ▁return ▁result ▁; ▁} ▁@ ▁Can Dist ro ▁@ ▁PutMapping ▁( ▁STR ▁) ▁@ ▁Sec ured ▁( ▁parser ▁= ▁Naming Resource Parser ▁. ▁class ▁, ▁action ▁= ▁Action Types ▁. ▁WRITE ▁) ▁public ▁ObjectNode ▁be at ▁( ▁HttpServlet Request ▁request ▁) ▁throws ▁Exception ▁{ ▁ObjectNode ▁result ▁= ▁Jackson Utils ▁. ▁createEmpty Json Node ▁( ▁) ▁; ▁result ▁. ▁put ▁( ▁Switch Entry ▁. ▁CLIENT _ BEAT _ INTERVAL ▁, ▁switch Domain ▁. ▁getClient Beat Interval ▁( ▁) ▁) ▁; ▁String ▁be at ▁= ▁Web Utils ▁. ▁optional ▁( ▁request ▁, ▁STR ▁, ▁StringUtils ▁. ▁EMPTY ▁) ▁; ▁R s Info ▁client Beat ▁= ▁null ▁; ▁if ▁( ▁StringUtils ▁. ▁isNotBlank ▁( ▁be at ▁) ▁) ▁{ ▁client Beat ▁= ▁Jackson Utils ▁. ▁to Obj ▁( ▁be at ▁, ▁R s Info ▁. ▁class ▁) ▁; ▁} ▁String ▁clusterName ▁= ▁Web Utils ▁. ▁optional ▁( ▁request ▁, ▁Common Params ▁. ▁CLUSTER _ NAME ▁, ▁Utils And Commons ▁. ▁DEFAULT _ CLUSTER _ NAME ▁) ▁; ▁String ▁ip ▁= ▁Web Utils ▁. ▁optional ▁( ▁request ▁, ▁STR ▁, ▁StringUtils ▁. ▁EMPTY ▁) ▁; ▁int ▁port ▁= ▁Integer ▁. ▁parseInt ▁( ▁Web Utils ▁. ▁optional ▁( ▁request ▁, ▁STR ▁, ▁STR ▁) ▁) ▁;
▁@ ▁Name ▁( ▁STR ▁) ▁@ ▁Summary ▁( ▁STR ▁) ▁@ ▁Description ▁( ▁Constants ▁. ▁EX AMPLE ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁Constants ▁. ▁W I K I ▁+ ▁Constants ▁. ▁W I K I _ HOME ▁+ ▁STR ▁) ▁public ▁class ▁Dump Class Command ▁extends ▁Annotated Command ▁{ ▁private ▁static ▁final ▁Logger ▁logger ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Dump Class Command ▁. ▁class ▁) ▁; ▁private ▁String ▁class Pattern ▁; ▁private ▁String ▁code ▁= ▁null ▁; ▁private ▁String ▁classLoader Class ▁; ▁private ▁boolean ▁is Reg Ex ▁= ▁false ▁; ▁private ▁String ▁directory ▁; ▁private ▁int ▁limit ▁; ▁@ ▁Argument ▁( ▁index ▁= ▁0 ▁, ▁arg Name ▁= ▁STR ▁) ▁@ ▁Description ▁( ▁STR ▁) ▁public ▁void ▁setClass Pattern ▁( ▁String ▁class Pattern ▁) ▁{ ▁this ▁. ▁class Pattern ▁= ▁class Pattern ▁; ▁} ▁@ ▁Option ▁( ▁shortName ▁= ▁STR ▁, ▁long Name ▁= ▁STR ▁) ▁@ ▁Description ▁( ▁STR ▁) ▁public ▁void ▁setCode ▁( ▁String ▁code ▁) ▁{ ▁this ▁. ▁code ▁= ▁code ▁; ▁} ▁@ ▁Option ▁( ▁long Name ▁= ▁STR ▁) ▁@ ▁Description ▁( ▁STR ▁) ▁public ▁void ▁set ClassLoader Class ▁( ▁String ▁classLoader Class ▁) ▁{ ▁this ▁. ▁classLoader Class ▁= ▁classLoader Class ▁; ▁} ▁@ ▁Option ▁( ▁shortName ▁= ▁STR ▁, ▁long Name ▁= ▁STR ▁, ▁flag ▁= ▁true ▁) ▁@ ▁Description ▁( ▁STR ▁) ▁public ▁void ▁set Reg Ex ▁( ▁boolean ▁reg Ex ▁) ▁{ ▁is Reg Ex ▁= ▁reg Ex ▁; ▁} ▁@ ▁Option ▁( ▁shortName ▁= ▁STR ▁, ▁long Name ▁= ▁STR ▁) ▁@ ▁Description ▁( ▁STR ▁) ▁public ▁void ▁set Directory ▁( ▁String ▁directory ▁) ▁{ ▁this ▁. ▁directory ▁= ▁directory ▁; ▁} ▁@ ▁Option ▁( ▁shortName ▁= ▁STR ▁, ▁long Name ▁= ▁STR ▁) ▁@ ▁Description ▁( ▁STR ▁) ▁@ ▁Default Value ▁( ▁STR ▁) ▁public ▁void ▁setLimit ▁( ▁int ▁limit ▁) ▁{ ▁this ▁. ▁limit ▁= ▁limit ▁; ▁} ▁@ ▁Override ▁public ▁void ▁process ▁( ▁CommandProcess ▁process ▁) ▁{ ▁Row A ffect ▁effect ▁= ▁new ▁Row A ffect ▁( ▁) ▁; ▁try ▁{ ▁if ▁( ▁directory ▁!= ▁null ▁) ▁{ ▁File ▁dir ▁= ▁new ▁File ▁( ▁directory ▁) ▁; ▁if ▁( ▁dir ▁. ▁isFile ▁( ▁) ▁) ▁{ ▁process ▁. ▁end ▁( ▁- ▁1 ▁, ▁directory ▁+ ▁STR ▁) ▁; ▁return ▁; ▁} ▁} ▁Exit Status ▁status ▁= ▁null ▁; ▁Instrumentation ▁inst ▁= ▁process ▁. ▁session ▁( ▁) ▁. ▁getIn strumentation ▁( ▁) ▁; ▁if ▁( ▁code ▁== ▁null ▁&& ▁classLoader Class ▁!= ▁null ▁) ▁{ ▁List ▁< ▁ClassLoader ▁> ▁matched Class Loaders ▁= ▁ClassLoader Utils ▁. ▁getClassLoader By ClassName ▁( ▁inst ▁, ▁classLoader Class ▁) ▁; ▁if ▁( ▁matched Class Loaders ▁. ▁size ▁( ▁) ▁== ▁1 ▁) ▁{ ▁code ▁= ▁Integer ▁. ▁toHexString ▁( ▁matched Class Loaders ▁. ▁get ▁( ▁0 ▁) ▁. ▁hashCode ▁( ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁matched Class Loaders ▁. ▁size ▁( ▁) ▁> ▁1 ▁) ▁{ ▁Collection ▁< ▁ClassLoader VO ▁> ▁classLoader VO List ▁= ▁ClassUtils ▁. ▁create ClassLoader VO List ▁( ▁matched Class Loaders ▁) ▁;
▁public ▁class ▁Selection Range Params ▁extends ▁Work Done Progress Params ▁{ ▁Selection Range Params ▁( ▁JSONObject ▁jsonData ▁) ▁{ ▁super ▁( ▁jsonData ▁) ▁; ▁} ▁public ▁TextDocument Identifier ▁getText Document ▁( ▁) ▁{ ▁return ▁new ▁TextDocument Identifier ▁( ▁jsonData ▁. ▁getJSONObject ▁( ▁STR ▁) ▁) ▁; ▁} ▁public ▁Selection Range Params ▁setText Document ▁( ▁TextDocument Identifier ▁text Document ▁) ▁{ ▁jsonData ▁. ▁put ▁( ▁STR ▁, ▁text Document ▁. ▁jsonData ▁) ▁; ▁return ▁this ▁; ▁} ▁public ▁List ▁< ▁Position ▁> ▁getPosition s ▁( ▁) ▁{ ▁final ▁JSONArray ▁json ▁= ▁jsonData ▁. ▁getJSON Array ▁( ▁STR ▁) ▁; ▁final ▁List ▁< ▁Position ▁> ▁list ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁json ▁. ▁length ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁json ▁. ▁length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁list ▁. ▁add ▁( ▁new ▁Position ▁( ▁json ▁. ▁getJSONObject ▁( ▁i ▁) ▁) ▁) ▁; ▁} ▁return ▁Collections ▁. ▁unmodifiable List ▁( ▁list ▁) ▁; ▁} ▁public ▁Selection Range Params ▁set Positions ▁( ▁List ▁< ▁Position ▁> ▁positions ▁) ▁{ ▁final ▁JSONArray ▁json ▁= ▁new ▁JSONArray ▁( ▁) ▁; ▁for ▁( ▁Position ▁position ▁: ▁positions ▁) ▁{ ▁json ▁. ▁put ▁( ▁position ▁. ▁jsonData ▁) ▁; ▁} ▁jsonData ▁. ▁put ▁( ▁STR ▁, ▁json ▁) ▁; ▁return ▁this ▁; ▁} ▁public ▁Object ▁getPart ial Result Token ▁( ▁) ▁{ ▁return ▁jsonData ▁. ▁opt ▁( ▁STR ▁) ▁; ▁} ▁public ▁Selection Range Params ▁set Partial Result Token ▁( ▁Object ▁partial Result Token ▁) ▁{ ▁jsonData ▁. ▁putOpt ▁( ▁STR ▁, ▁partial Result Token ▁) ▁; ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁obj ▁) ▁{ ▁if ▁( ▁this ▁== ▁obj ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁obj ▁== ▁null ▁) ▁{ ▁return ▁false ▁; ▁} ▁if ▁( ▁this ▁. ▁getClass ▁( ▁) ▁!= ▁obj ▁. ▁getClass ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁Selection Range Params ▁other ▁= ▁( ▁Selection Range Params ▁) ▁obj ▁; ▁if ▁( ▁! ▁Objects ▁. ▁equals ▁( ▁this ▁. ▁getText Document ▁( ▁) ▁, ▁other ▁. ▁getText Document ▁( ▁) ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁if ▁( ▁! ▁Objects ▁. ▁equals ▁( ▁this ▁. ▁getPosition s ▁( ▁) ▁, ▁other ▁. ▁getPosition s ▁( ▁) ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁if ▁( ▁! ▁Objects ▁. ▁equals ▁( ▁this ▁. ▁getPart ial Result Token ▁( ▁) ▁, ▁other ▁. ▁getPart ial Result Token ▁( ▁) ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁if ▁( ▁! ▁Objects ▁. ▁equals ▁( ▁this ▁. ▁getWorkDone Token ▁( ▁) ▁, ▁other ▁. ▁getWorkDone Token ▁( ▁) ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁int ▁hash ▁= ▁5 ▁; ▁hash ▁= ▁7 3 ▁ * ▁hash ▁+ ▁Objects ▁. ▁hashCode ▁( ▁this ▁. ▁getText Document ▁( ▁) ▁) ▁; ▁hash ▁= ▁7 3 ▁ * ▁hash ▁+ ▁Objects ▁. ▁hashCode ▁( ▁this ▁. ▁getPosition s ▁( ▁) ▁) ▁;
▁public ▁class ▁Unsigned Integer 3 DataType ▁extends ▁Abstract Integer DataType ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁public ▁final ▁static ▁Unsigned Integer 3 DataType ▁dataType ▁= ▁new ▁Unsigned Integer 3 DataType ▁( ▁) ▁; ▁static ▁{ ▁Class Translator ▁. ▁put ▁( ▁STR ▁, ▁Unsigned Integer 3 DataType ▁. ▁class ▁. ▁getName ▁( ▁) ▁) ▁; ▁} ▁public ▁Unsigned Integer 3 DataType ▁( ▁) ▁{ ▁this ▁( ▁null ▁) ▁; ▁} ▁public ▁Unsigned Integer 3 DataType ▁( ▁DataTypeManager ▁dtm ▁) ▁{ ▁super ▁( ▁STR ▁, ▁false ▁, ▁dtm ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getDescription ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getLength ▁( ▁) ▁{ ▁return ▁3 ▁; ▁} ▁@ ▁Override ▁public ▁Integer 3 DataType ▁getOp pos ite Signed ness DataType ▁( ▁) ▁{ ▁return ▁Integer 3 DataType ▁. ▁dataType ▁. ▁clone ▁( ▁getDataType Manager ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Unsigned Integer 3 DataType ▁clone ▁( ▁DataTypeManager ▁dtm ▁) ▁{ ▁if ▁( ▁dtm ▁== ▁getDataType Manager ▁( ▁) ▁) ▁{ ▁return ▁this ▁; ▁} ▁return ▁new ▁Unsigned Integer 3 DataType ▁( ▁dtm ▁) ▁; ▁} ▁}
▁private ▁final ▁GL Surface View ▁s urface View ▁; ▁private ▁final ▁int ▁[ ▁] ▁y uv Texture s ▁; ▁private ▁final ▁int ▁[ ▁] ▁t ex Locations ▁; ▁private ▁final ▁int ▁[ ▁] ▁previous Width s ▁; ▁private ▁final ▁int ▁[ ▁] ▁previous Stride s ▁; ▁private ▁final ▁AtomicReference ▁< ▁@ ▁Nullable Type ▁Video Decoder OutputBuffer ▁> ▁pending OutputBuffer Reference ▁; ▁private ▁final ▁Float Buffer ▁[ ▁] ▁texture Coord s ▁; ▁private ▁int ▁program ▁; ▁private ▁int ▁color Matrix Location ▁; ▁private ▁@ ▁Mon otonic NonNull ▁Video Decoder OutputBuffer ▁render ed OutputBuffer ▁; ▁public ▁Renderer ▁( ▁GL Surface View ▁s urface View ▁) ▁{ ▁this ▁. ▁s urface View ▁= ▁s urface View ▁; ▁y uv Texture s ▁= ▁new ▁int ▁[ ▁3 ▁] ▁; ▁t ex Locations ▁= ▁new ▁int ▁[ ▁3 ▁] ▁; ▁previous Width s ▁= ▁new ▁int ▁[ ▁3 ▁] ▁; ▁previous Stride s ▁= ▁new ▁int ▁[ ▁3 ▁] ▁; ▁pending OutputBuffer Reference ▁= ▁new ▁AtomicReference ▁< ▁> ▁( ▁) ▁; ▁texture Coord s ▁= ▁new ▁Float Buffer ▁[ ▁3 ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁3 ▁; ▁i ▁++ ▁) ▁{ ▁previous Width s ▁[ ▁i ▁] ▁= ▁previous Stride s ▁[ ▁i ▁] ▁= ▁- ▁1 ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁on Surface Created ▁( ▁GL 10 ▁unused ▁, ▁EGL Config ▁config ▁) ▁{ ▁program ▁= ▁G l Util ▁. ▁compile Program ▁( ▁VER TE X _ SH ADER ▁, ▁FR AGMENT _ SH ADER ▁) ▁; ▁GLES 20 ▁. ▁gl Use Program ▁( ▁program ▁) ▁; ▁int ▁pos Location ▁= ▁GLES 20 ▁. ▁gl Get Att rib Location ▁( ▁program ▁, ▁STR ▁) ▁; ▁GLES 20 ▁. ▁gl Enable Vertex Att rib Array ▁( ▁pos Location ▁) ▁; ▁GLES 20 ▁. ▁gl Vertex Att rib Pointer ▁( ▁pos Location ▁, ▁2 ▁, ▁GLES 20 ▁. ▁GL _ FLOAT ▁, ▁false ▁, ▁0 ▁, ▁TEXT URE _ VER TI CES ▁) ▁; ▁t ex Locations ▁[ ▁0 ▁] ▁= ▁GLES 20 ▁. ▁gl Get Att rib Location ▁( ▁program ▁, ▁STR ▁) ▁; ▁GLES 20 ▁. ▁gl Enable Vertex Att rib Array ▁( ▁t ex Locations ▁[ ▁0 ▁] ▁) ▁; ▁t ex Locations ▁[ ▁1 ▁] ▁= ▁GLES 20 ▁. ▁gl Get Att rib Location ▁( ▁program ▁, ▁STR ▁) ▁; ▁GLES 20 ▁. ▁gl Enable Vertex Att rib Array ▁( ▁t ex Locations ▁[ ▁1 ▁] ▁) ▁; ▁t ex Locations ▁[ ▁2 ▁] ▁= ▁GLES 20 ▁. ▁gl Get Att rib Location ▁( ▁program ▁, ▁STR ▁) ▁; ▁GLES 20 ▁. ▁gl Enable Vertex Att rib Array ▁( ▁t ex Locations ▁[ ▁2 ▁] ▁) ▁; ▁G l Util ▁. ▁check G l Error ▁( ▁) ▁; ▁color Matrix Location ▁= ▁GLES 20 ▁. ▁gl Get Un iform Location ▁( ▁program ▁, ▁STR ▁) ▁; ▁G l Util ▁. ▁check G l Error ▁( ▁) ▁; ▁setup Texture s ▁( ▁) ▁; ▁G l Util ▁. ▁check G l Error ▁( ▁) ▁; ▁}
▁String ▁userName ▁= ▁br ▁. ▁readLine ▁( ▁) ▁. ▁trim ▁( ▁) ▁; ▁if ▁( ▁Shell ▁. ▁WINDOWS ▁) ▁{ ▁int ▁sp ▁= ▁userName ▁. ▁lastIndexOf ▁( ▁CHAR ▁) ▁; ▁if ▁( ▁sp ▁!= ▁- ▁1 ▁) ▁{ ▁userName ▁= ▁userName ▁. ▁substring ▁( ▁sp ▁+ ▁1 ▁) ▁; ▁} ▁userName ▁= ▁StringUtils ▁. ▁toLowerCase ▁( ▁userName ▁) ▁; ▁} ▁pp ▁= ▁Runtime ▁. ▁getRuntime ▁( ▁) ▁. ▁exec ▁( ▁Shell ▁. ▁WINDOWS ▁? ▁Shell ▁. ▁getW in Utils Path ▁( ▁) ▁+ ▁STR ▁: ▁STR ▁+ ▁userName ▁) ▁; ▁br ▁= ▁new ▁BufferedReader ▁( ▁new ▁InputStream Reader ▁( ▁pp ▁. ▁getInputStream ▁( ▁) ▁) ▁) ▁; ▁String ▁line ▁= ▁br ▁. ▁readLine ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁userName ▁+ ▁STR ▁+ ▁line ▁) ▁; ▁Set ▁< ▁String ▁> ▁groups ▁= ▁new ▁LinkedHashSet ▁< ▁String ▁> ▁( ▁) ▁; ▁String ▁[ ▁] ▁tokens ▁= ▁line ▁. ▁split ▁( ▁Shell ▁. ▁TOKEN _ SEPARATOR _ REGEX ▁) ▁; ▁for ▁( ▁String ▁s ▁: ▁tokens ▁) ▁{ ▁groups ▁. ▁add ▁( ▁s ▁) ▁; ▁} ▁final ▁UserGroup Information ▁login ▁= ▁UserGroup Information ▁. ▁getCurrentUser ▁( ▁) ▁; ▁String ▁login UserName ▁= ▁login ▁. ▁getShort UserName ▁( ▁) ▁; ▁if ▁( ▁Shell ▁. ▁WINDOWS ▁) ▁{ ▁login UserName ▁= ▁StringUtils ▁. ▁toLowerCase ▁( ▁login UserName ▁) ▁; ▁} ▁assertEquals ▁( ▁userName ▁, ▁login UserName ▁) ▁; ▁String ▁[ ▁] ▁g i ▁= ▁login ▁. ▁getGroup Names ▁( ▁) ▁; ▁assertEquals ▁( ▁groups ▁. ▁size ▁( ▁) ▁, ▁g i ▁. ▁length ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁g i ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁assertTrue ▁( ▁groups ▁. ▁contains ▁( ▁g i ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁final ▁UserGroup Information ▁fake User ▁= ▁UserGroup Information ▁. ▁create Remote User ▁( ▁STR ▁) ▁; ▁fake User ▁. ▁do As ▁( ▁new ▁Privileged Exception Action ▁< ▁Object ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Object ▁run ▁( ▁) ▁throws ▁IOException ▁{ ▁UserGroup Information ▁current ▁= ▁UserGroup Information ▁. ▁getCurrentUser ▁( ▁) ▁; ▁assertFalse ▁( ▁current ▁. ▁equals ▁( ▁login ▁) ▁) ▁; ▁assertEquals ▁( ▁current ▁, ▁fake User ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁current ▁. ▁getGroup Names ▁( ▁) ▁. ▁length ▁) ▁; ▁return ▁null ▁; ▁} ▁} ▁) ▁; ▁} ▁@ ▁Test ▁( ▁timeout ▁= ▁30000 ▁) ▁public ▁void ▁test Constructor ▁( ▁) ▁throws ▁Exception ▁{ ▁test Constructor Success ▁( ▁STR ▁, ▁STR ▁) ▁; ▁test Constructor Success ▁( ▁STR ▁, ▁STR ▁) ▁; ▁test Constructor Success ▁( ▁STR ▁, ▁STR ▁) ▁; ▁test Constructor Success ▁( ▁STR ▁, ▁STR ▁) ▁; ▁test Constructor Success ▁( ▁STR ▁, ▁STR ▁) ▁; ▁test Constructor Failures ▁( ▁null ▁) ▁; ▁test Constructor Failures ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁( ▁timeout ▁= ▁30000 ▁) ▁public ▁void ▁test Constructor With Rules ▁( ▁) ▁throws ▁Exception ▁{ ▁conf ▁. ▁set ▁( ▁HADOOP _ SECURITY _ AUTH _ TO _ LOCAL ▁, ▁STR ▁) ▁;
▁@ ▁RunWith ▁( ▁AndroidJUnit 4 ▁. ▁class ▁) ▁public ▁class ▁Link ingObject s Query Tests ▁extends ▁Query Tests ▁{ ▁@ ▁Test ▁public ▁void ▁query _ start With Back link ▁( ▁) ▁{ ▁realm ▁. ▁begin Transaction ▁( ▁) ▁; ▁All Java Types Unsupported Types ▁gen 1 ▁= ▁realm ▁. ▁create Object ▁( ▁All Java Types Unsupported Types ▁. ▁class ▁, ▁10 ▁) ▁; ▁All Java Types Unsupported Types ▁gen 2 A ▁= ▁realm ▁. ▁create Object ▁( ▁All Java Types Unsupported Types ▁. ▁class ▁, ▁1 ▁) ▁; ▁gen 2 A ▁. ▁setField Object ▁( ▁gen 1 ▁) ▁; ▁All Java Types Unsupported Types ▁gen 2 B ▁= ▁realm ▁. ▁create Object ▁( ▁All Java Types Unsupported Types ▁. ▁class ▁, ▁2 ▁) ▁; ▁gen 2 B ▁. ▁setField Object ▁( ▁gen 1 ▁) ▁; ▁All Java Types Unsupported Types ▁gen 3 ▁= ▁realm ▁. ▁create Object ▁( ▁All Java Types Unsupported Types ▁. ▁class ▁, ▁3 ▁) ▁; ▁Realm List ▁< ▁All Java Types Unsupported Types ▁> ▁parent s ▁= ▁gen 3 ▁. ▁getField List ▁( ▁) ▁; ▁parent s ▁. ▁add ▁( ▁gen 2 A ▁) ▁; ▁parent s ▁. ▁add ▁( ▁gen 2 B ▁) ▁; ▁realm ▁. ▁commit Transaction ▁( ▁) ▁; ▁Realm Results ▁< ▁All Java Types Unsupported Types ▁> ▁result ▁= ▁realm ▁. ▁where ▁( ▁All Java Types Unsupported Types ▁. ▁class ▁) ▁. ▁greaterThan ▁( ▁All Java Types Unsupported Types ▁. ▁FIELD _ LO _ OBJECT ▁+ ▁STR ▁+ ▁All Java Types Unsupported Types ▁. ▁FIELD _ OBJECT ▁+ ▁STR ▁+ ▁All Java Types Unsupported Types ▁. ▁FIELD _ ID ▁, ▁1 ▁) ▁. ▁findAll ▁( ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁result ▁. ▁size ▁( ▁) ▁) ▁; ▁assertTrue ▁( ▁result ▁. ▁contains ▁( ▁gen 1 ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁query _ back link In Middle ▁( ▁) ▁{ ▁realm ▁. ▁begin Transaction ▁( ▁) ▁; ▁All Java Types Unsupported Types ▁gen 1 ▁= ▁realm ▁. ▁create Object ▁( ▁All Java Types Unsupported Types ▁. ▁class ▁, ▁10 ▁) ▁; ▁All Java Types Unsupported Types ▁gen 2 A ▁= ▁realm ▁. ▁create Object ▁( ▁All Java Types Unsupported Types ▁. ▁class ▁, ▁1 ▁) ▁; ▁gen 2 A ▁. ▁setField Object ▁( ▁gen 1 ▁) ▁; ▁All Java Types Unsupported Types ▁gen 2 B ▁= ▁realm ▁. ▁create Object ▁( ▁All Java Types Unsupported Types ▁. ▁class ▁, ▁2 ▁) ▁; ▁gen 2 B ▁. ▁setField Object ▁( ▁gen 1 ▁) ▁; ▁All Java Types Unsupported Types ▁gen 3 ▁= ▁realm ▁. ▁create Object ▁( ▁All Java Types Unsupported Types ▁. ▁class ▁, ▁3 ▁) ▁; ▁Realm List ▁< ▁All Java Types Unsupported Types ▁> ▁parent s ▁= ▁gen 3 ▁. ▁getField List ▁( ▁) ▁; ▁parent s ▁. ▁add ▁( ▁gen 2 A ▁) ▁; ▁parent s ▁. ▁add ▁( ▁gen 2 B ▁) ▁; ▁realm ▁. ▁commit Transaction ▁( ▁) ▁;
▁this ▁. ▁connectionInfo ▁= ▁source ▁. ▁connectionInfo ▁; ▁this ▁. ▁client Home ▁= ▁source ▁. ▁client Home ▁; ▁this ▁. ▁connection Modify Re strict ions ▁= ▁source ▁. ▁connection Modify Re strict ions ▁== ▁null ▁? ▁null ▁: ▁new ▁ArrayList ▁< ▁> ▁( ▁source ▁. ▁connection Modify Re strict ions ▁) ▁; ▁this ▁. ▁connectionInfo ▁= ▁new ▁DBP Connection Configuration ▁( ▁source ▁. ▁connectionInfo ▁) ▁; ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁String ▁, ▁Filter Mapping ▁> ▁f e ▁: ▁source ▁. ▁filter Map ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁this ▁. ▁filter Map ▁. ▁put ▁( ▁f e ▁. ▁getKey ▁( ▁) ▁, ▁new ▁Filter Mapping ▁( ▁f e ▁. ▁getValue ▁( ▁) ▁) ▁) ▁; ▁} ▁this ▁. ▁lock Password Hash ▁= ▁source ▁. ▁lock Password Hash ▁; ▁if ▁( ▁source ▁. ▁getRegistry ▁( ▁) ▁== ▁registry ▁) ▁{ ▁this ▁. ▁folder ▁= ▁source ▁. ▁folder ▁; ▁} ▁else ▁if ▁( ▁source ▁. ▁folder ▁!= ▁null ▁) ▁{ ▁this ▁. ▁folder ▁= ▁( ▁DataSource Folder ▁) ▁registry ▁. ▁getF older ▁( ▁source ▁. ▁folder ▁. ▁getF older Path ▁( ▁) ▁) ▁; ▁} ▁this ▁. ▁preference Store ▁= ▁new ▁DataSource PreferenceStore ▁( ▁this ▁) ▁; ▁this ▁. ▁preference Store ▁. ▁setProperties ▁( ▁source ▁. ▁preference Store ▁. ▁getProperties ▁( ▁) ▁) ▁; ▁this ▁. ▁preference Store ▁. ▁setDefault Properties ▁( ▁source ▁. ▁preference Store ▁. ▁getDefault Properties ▁( ▁) ▁) ▁; ▁if ▁( ▁source ▁. ▁formatter Profile ▁== ▁null ▁|| ▁source ▁. ▁formatter Profile ▁. ▁getProfile Name ▁( ▁) ▁. ▁equals ▁( ▁source ▁. ▁getId ▁( ▁) ▁) ▁) ▁{ ▁this ▁. ▁formatter Profile ▁= ▁null ▁; ▁} ▁else ▁{ ▁this ▁. ▁formatter Profile ▁= ▁new ▁Data Formatter Profile ▁( ▁source ▁. ▁formatter Profile ▁. ▁getProfile Name ▁( ▁) ▁, ▁preference Store ▁) ▁; ▁} ▁this ▁. ▁virtual Model ▁= ▁new ▁DB V Model ▁( ▁this ▁, ▁source ▁. ▁virtual Model ▁) ▁; ▁} ▁public ▁boolean ▁isDisposed ▁( ▁) ▁{ ▁return ▁disposed ▁; ▁} ▁public ▁void ▁dispose ▁( ▁) ▁{ ▁if ▁( ▁disposed ▁) ▁{ ▁log ▁. ▁warn ▁( ▁STR ▁) ▁; ▁return ▁; ▁} ▁synchronized ▁( ▁users ▁) ▁{ ▁users ▁. ▁clear ▁( ▁) ▁; ▁} ▁this ▁. ▁virtual Model ▁. ▁dispose ▁( ▁) ▁; ▁disposed ▁= ▁true ▁; ▁} ▁@ ▁NotNull ▁@ ▁Override ▁@ ▁Property ▁( ▁name ▁= ▁STR ▁, ▁viewable ▁= ▁false ▁, ▁order ▁= ▁0 ▁) ▁public ▁String ▁getId ▁( ▁) ▁{ ▁return ▁id ▁; ▁} ▁public ▁void ▁setId ▁( ▁@ ▁NotNull ▁String ▁id ▁) ▁{ ▁this ▁. ▁id ▁= ▁id ▁; ▁} ▁@ ▁NotNull ▁@ ▁Override ▁public ▁DBP Driver ▁getDriver ▁( ▁) ▁{ ▁return ▁driver ▁; ▁} ▁@ ▁NotNull ▁@ ▁Override ▁public ▁DBPDataSource Configuration Storage ▁get Configuration Storage ▁( ▁) ▁{ ▁return ▁storage ▁; ▁} ▁@ ▁Property ▁( ▁viewable ▁= ▁true ▁, ▁order ▁= ▁3 ▁) ▁@ ▁NotNull ▁@ ▁Override ▁public ▁DBPDataSource Origin ▁getOrigin ▁( ▁) ▁{ ▁if ▁( ▁origin ▁instanceof ▁DataSource Origin Lazy ▁) ▁{ ▁DBPDataSource Origin ▁real Origin ▁= ▁( ▁( ▁DataSource Origin Lazy ▁) ▁this ▁. ▁origin ▁) ▁. ▁resolve Real Origin ▁( ▁) ▁;
▁@ ▁Configuration ▁@ ▁Mapper Scan ▁( ▁STR ▁) ▁public ▁class ▁Mybatis Plus Config ▁{ ▁@ ▁Bean ▁( ▁STR ▁) ▁public ▁SqlSession Factory ▁sqlSession Factory ▁( ▁DataSource ▁dataSource ▁, ▁Global Config ▁global Config ▁) ▁throws ▁Exception ▁{ ▁Mybatis Sql Session FactoryBean ▁sqlSession Factory ▁= ▁new ▁Mybatis Sql Session FactoryBean ▁( ▁) ▁; ▁sqlSession Factory ▁. ▁setDataSource ▁( ▁dataSource ▁) ▁; ▁sqlSession Factory ▁. ▁setType Enum s Package ▁( ▁STR ▁) ▁; ▁sqlSession Factory ▁. ▁set Mapper Locations ▁( ▁new ▁Path Matching Resource Pattern Resolver ▁( ▁) ▁. ▁getResources ▁( ▁STR ▁) ▁) ▁; ▁Mybatis Configuration ▁configuration ▁= ▁new ▁Mybatis Configuration ▁( ▁) ▁; ▁configuration ▁. ▁set Jdbc Type ForNull ▁( ▁JdbcType ▁. ▁NULL ▁) ▁; ▁configuration ▁. ▁set Map Under s core To C amelCase ▁( ▁true ▁) ▁; ▁Mybatis Plus Interceptor ▁my batis Plus Interceptor ▁= ▁new ▁Mybatis Plus Interceptor ▁( ▁) ▁; ▁my batis Plus Interceptor ▁. ▁add Inner Interceptor ▁( ▁new ▁Pagination Inner Interceptor ▁( ▁) ▁) ▁; ▁my batis Plus Interceptor ▁. ▁add Inner Interceptor ▁( ▁new ▁Optim istic Lock er Inner Interceptor ▁( ▁) ▁) ▁; ▁sqlSession Factory ▁. ▁set Plugins ▁( ▁my batis Plus Interceptor ▁) ▁; ▁configuration ▁. ▁setObject Wrapper Factory ▁( ▁new ▁Mybatis Map Wrapper Factory ▁( ▁) ▁) ▁; ▁sqlSession Factory ▁. ▁set Configuration ▁( ▁configuration ▁) ▁; ▁global Config ▁. ▁set Meta Object Handler ▁( ▁new ▁Mysql Meta Object Handler ▁( ▁) ▁) ▁; ▁sqlSession Factory ▁. ▁setGlobal Config ▁( ▁global Config ▁) ▁; ▁return ▁sqlSession Factory ▁. ▁getObject ▁( ▁) ▁; ▁} ▁@ ▁Bean ▁public ▁Global Config ▁global Config ▁( ▁) ▁{ ▁Global Config ▁conf ▁= ▁new ▁Global Config ▁( ▁) ▁; ▁conf ▁. ▁set Db Config ▁( ▁new ▁Global Config ▁. ▁Db Config ▁( ▁) ▁. ▁set Column Format ▁( ▁STR ▁) ▁) ▁; ▁Default Sql Injector ▁logic Sql Injector ▁= ▁new ▁Default Sql Injector ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁List ▁< ▁Abstract Method ▁> ▁getMethod List ▁( ▁Class ▁< ▁? ▁> ▁mapper Class ▁) ▁{ ▁List ▁< ▁Abstract Method ▁> ▁method List ▁= ▁super ▁. ▁getMethod List ▁( ▁mapper Class ▁) ▁; ▁method List ▁. ▁add ▁( ▁new ▁Logic Delete ById With Fill ▁( ▁) ▁) ▁; ▁method List ▁. ▁add ▁( ▁new ▁Insert Batch Some Column ▁( ▁t ▁-> ▁! ▁t ▁. ▁is Logic Delete ▁( ▁) ▁&& ▁! ▁t ▁. ▁is Version ▁( ▁) ▁&& ▁t ▁. ▁getField Fill ▁( ▁) ▁!= ▁Field Fill ▁. ▁UPDATE ▁) ▁) ▁; ▁method List ▁. ▁add ▁( ▁new ▁Al ways Update Some Column ById ▁( ▁t ▁-> ▁t ▁. ▁getField Fill ▁( ▁) ▁!= ▁Field Fill ▁. ▁INSERT ▁&& ▁! ▁t ▁. ▁getProperty ▁( ▁) ▁. ▁equals ▁( ▁STR ▁) ▁) ▁) ▁; ▁return ▁method List ▁; ▁} ▁} ▁; ▁conf ▁. ▁set Sql Injector ▁( ▁logic Sql Injector ▁) ▁; ▁return ▁conf ▁; ▁} ▁}
▁public ▁class ▁i Boot I m Header ▁implements ▁StructConverter ▁{ ▁private ▁byte ▁[ ▁] ▁signature ▁; ▁private ▁int ▁unknown ▁; ▁private ▁int ▁compression Type ▁; ▁private ▁int ▁format ▁; ▁private ▁short ▁width ▁; ▁private ▁short ▁height ▁; ▁private ▁byte ▁[ ▁] ▁padding ▁; ▁public ▁i Boot I m Header ▁( ▁ByteProvider ▁provider ▁) ▁throws ▁IOException ▁{ ▁BinaryReader ▁reader ▁= ▁new ▁BinaryReader ▁( ▁provider ▁, ▁true ▁) ▁; ▁signature ▁= ▁reader ▁. ▁readNext ByteArray ▁( ▁i Boot I m Constants ▁. ▁SIGN ATURE _ LENGTH ▁) ▁; ▁unknown ▁= ▁reader ▁. ▁readNextInt ▁( ▁) ▁; ▁compression Type ▁= ▁reader ▁. ▁readNextInt ▁( ▁) ▁; ▁format ▁= ▁reader ▁. ▁readNextInt ▁( ▁) ▁; ▁width ▁= ▁reader ▁. ▁readNextShort ▁( ▁) ▁; ▁height ▁= ▁reader ▁. ▁readNextShort ▁( ▁) ▁; ▁padding ▁= ▁reader ▁. ▁readNext ByteArray ▁( ▁i Boot I m Constants ▁. ▁P ADD ING _ LENGTH ▁) ▁; ▁} ▁public ▁String ▁getSignature ▁( ▁) ▁{ ▁return ▁new ▁String ▁( ▁signature ▁) ▁. ▁trim ▁( ▁) ▁; ▁} ▁public ▁int ▁getUn known ▁( ▁) ▁{ ▁return ▁unknown ▁; ▁} ▁public ▁int ▁get Compression Type ▁( ▁) ▁{ ▁return ▁compression Type ▁; ▁} ▁public ▁int ▁getFormat ▁( ▁) ▁{ ▁return ▁format ▁; ▁} ▁public ▁short ▁getWidth ▁( ▁) ▁{ ▁return ▁width ▁; ▁} ▁public ▁short ▁getHeight ▁( ▁) ▁{ ▁return ▁height ▁; ▁} ▁public ▁byte ▁[ ▁] ▁getPadding ▁( ▁) ▁{ ▁return ▁padding ▁; ▁} ▁public ▁DataType ▁toDataType ▁( ▁) ▁throws ▁Duplicate NameException ▁, ▁IOException ▁{ ▁Structure ▁struct ▁= ▁new ▁Structure DataType ▁( ▁StructConverter Util ▁. ▁parse Name ▁( ▁i Boot I m Header ▁. ▁class ▁) ▁, ▁0 ▁) ▁; ▁struct ▁. ▁add ▁( ▁STRING ▁, ▁i Boot I m Constants ▁. ▁SIGN ATURE _ LENGTH ▁, ▁STR ▁, ▁null ▁) ▁; ▁struct ▁. ▁add ▁( ▁DWORD ▁, ▁STR ▁, ▁null ▁) ▁; ▁struct ▁. ▁add ▁( ▁DWORD ▁, ▁STR ▁, ▁null ▁) ▁; ▁struct ▁. ▁add ▁( ▁DWORD ▁, ▁STR ▁, ▁null ▁) ▁; ▁struct ▁. ▁add ▁( ▁WORD ▁, ▁STR ▁, ▁null ▁) ▁; ▁struct ▁. ▁add ▁( ▁WORD ▁, ▁STR ▁, ▁null ▁) ▁; ▁DataType ▁padding DataType ▁= ▁new ▁ArrayDataType ▁( ▁BYTE ▁, ▁i Boot I m Constants ▁. ▁P ADD ING _ LENGTH ▁, ▁BYTE ▁. ▁getLength ▁( ▁) ▁) ▁; ▁struct ▁. ▁add ▁( ▁padding DataType ▁, ▁STR ▁, ▁null ▁) ▁; ▁return ▁struct ▁; ▁} ▁}
▁repo ▁. ▁setUsername ▁( ▁username ▁, ▁( ▁result ▁) ▁-> ▁{ ▁Thread Util ▁. ▁runOn Main ▁( ▁( ▁) ▁-> ▁{ ▁switch ▁( ▁result ▁) ▁{ ▁case ▁SUCCESS ▁: ▁ui State ▁. ▁setValue ▁( ▁new ▁State ▁( ▁Button State ▁. ▁SUB MIT _ DIS ABLED ▁, ▁Username Status ▁. ▁NONE ▁) ▁) ▁; ▁events ▁. ▁postValue ▁( ▁Event ▁. ▁SUB MIT _ SUCCESS ▁) ▁; ▁break ▁; ▁case ▁USER NAME _ INVALID ▁: ▁ui State ▁. ▁setValue ▁( ▁new ▁State ▁( ▁Button State ▁. ▁SUB MIT _ DIS ABLED ▁, ▁Username Status ▁. ▁INVALID _ GENER IC ▁) ▁) ▁; ▁events ▁. ▁postValue ▁( ▁Event ▁. ▁SUB MIT _ FAIL _ INVALID ▁) ▁; ▁break ▁; ▁case ▁USER NAME _ UN AVAILABLE ▁: ▁ui State ▁. ▁setValue ▁( ▁new ▁State ▁( ▁Button State ▁. ▁SUB MIT _ DIS ABLED ▁, ▁Username Status ▁. ▁T A KEN ▁) ▁) ▁; ▁events ▁. ▁postValue ▁( ▁Event ▁. ▁SUB MIT _ FAIL _ TA KEN ▁) ▁; ▁break ▁; ▁case ▁NETWORK _ ERROR ▁: ▁ui State ▁. ▁setValue ▁( ▁new ▁State ▁( ▁Button State ▁. ▁SUB MIT ▁, ▁Username Status ▁. ▁NONE ▁) ▁) ▁; ▁events ▁. ▁postValue ▁( ▁Event ▁. ▁NETWORK _ FAILURE ▁) ▁; ▁break ▁; ▁} ▁} ▁) ▁; ▁} ▁) ▁; ▁} ▁void ▁on Username Deleted ▁( ▁) ▁{ ▁ui State ▁. ▁setValue ▁( ▁new ▁State ▁( ▁Button State ▁. ▁DELETE _ LOAD ING ▁, ▁Username Status ▁. ▁NONE ▁) ▁) ▁; ▁repo ▁. ▁delete Username ▁( ▁( ▁result ▁) ▁-> ▁{ ▁Thread Util ▁. ▁runOn Main ▁( ▁( ▁) ▁-> ▁{ ▁switch ▁( ▁result ▁) ▁{ ▁case ▁SUCCESS ▁: ▁ui State ▁. ▁postValue ▁( ▁new ▁State ▁( ▁Button State ▁. ▁DELETE _ DIS ABLED ▁, ▁Username Status ▁. ▁NONE ▁) ▁) ▁; ▁events ▁. ▁postValue ▁( ▁Event ▁. ▁DELETE _ SUCCESS ▁) ▁; ▁break ▁; ▁case ▁NETWORK _ ERROR ▁: ▁ui State ▁. ▁postValue ▁( ▁new ▁State ▁( ▁Button State ▁. ▁DELETE ▁, ▁Username Status ▁. ▁NONE ▁) ▁) ▁; ▁events ▁. ▁postValue ▁( ▁Event ▁. ▁NETWORK _ FAILURE ▁) ▁; ▁break ▁; ▁} ▁} ▁) ▁; ▁} ▁) ▁; ▁} ▁@ ▁NonNull ▁LiveData ▁< ▁State ▁> ▁get Ui State ▁( ▁) ▁{ ▁return ▁ui State ▁; ▁} ▁@ ▁NonNull ▁LiveData ▁< ▁Event ▁> ▁get Events ▁( ▁) ▁{ ▁return ▁events ▁; ▁} ▁private ▁static ▁Username Status ▁map Username Error ▁( ▁@ ▁NonNull ▁Invalid Reason ▁invalid Reason ▁) ▁{ ▁switch ▁( ▁invalid Reason ▁) ▁{ ▁case ▁TO O _ SHORT ▁: ▁return ▁Username Status ▁. ▁TO O _ SHORT ▁; ▁case ▁TO O _ LONG ▁: ▁return ▁Username Status ▁. ▁TO O _ LONG ▁; ▁case ▁START S _ WITH _ NUMBER ▁: ▁return ▁Username Status ▁. ▁C AN NOT _ START _ WITH _ NUMBER ▁; ▁case ▁INVALID _ CHAR ACT ERS ▁: ▁return ▁Username Status ▁. ▁INVALID _ CHAR ACT ERS ▁; ▁default ▁: ▁return ▁Username Status ▁. ▁INVALID _ GENER IC ▁; ▁} ▁} ▁static ▁class ▁State ▁{ ▁private ▁final ▁Button State ▁button State ▁; ▁private ▁final ▁Username Status ▁username Status ▁;
▁@ ▁PublicEvolving ▁public ▁class ▁Long Parser ▁extends ▁Field Parser ▁< ▁Long ▁> ▁{ ▁private ▁long ▁result ▁; ▁@ ▁Override ▁public ▁int ▁parse Field ▁( ▁byte ▁[ ▁] ▁bytes ▁, ▁int ▁startPos ▁, ▁int ▁limit ▁, ▁byte ▁[ ▁] ▁delimiter ▁, ▁Long ▁re usable ▁) ▁{ ▁if ▁( ▁startPos ▁== ▁limit ▁) ▁{ ▁setError State ▁( ▁Parse Error State ▁. ▁EMPTY _ COLUMN ▁) ▁; ▁return ▁- ▁1 ▁; ▁} ▁long ▁val ▁= ▁0 ▁; ▁boolean ▁neg ▁= ▁false ▁; ▁final ▁int ▁delim Limit ▁= ▁limit ▁- ▁delimiter ▁. ▁length ▁+ ▁1 ▁; ▁if ▁( ▁bytes ▁[ ▁startPos ▁] ▁== ▁CHAR ▁) ▁{ ▁neg ▁= ▁true ▁; ▁startPos ▁++ ▁; ▁if ▁( ▁startPos ▁== ▁limit ▁|| ▁( ▁startPos ▁< ▁delim Limit ▁&& ▁delimiter Next ▁( ▁bytes ▁, ▁startPos ▁, ▁delimiter ▁) ▁) ▁) ▁{ ▁setError State ▁( ▁Parse Error State ▁. ▁NUMERIC _ VALUE _ OR PH AN _ SIGN ▁) ▁; ▁return ▁- ▁1 ▁; ▁} ▁} ▁for ▁( ▁int ▁i ▁= ▁startPos ▁; ▁i ▁< ▁limit ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁i ▁< ▁delim Limit ▁&& ▁delimiter Next ▁( ▁bytes ▁, ▁i ▁, ▁delimiter ▁) ▁) ▁{ ▁if ▁( ▁i ▁== ▁startPos ▁) ▁{ ▁setError State ▁( ▁Parse Error State ▁. ▁EMPTY _ COLUMN ▁) ▁; ▁return ▁- ▁1 ▁; ▁} ▁this ▁. ▁result ▁= ▁neg ▁? ▁- ▁val ▁: ▁val ▁; ▁return ▁i ▁+ ▁delimiter ▁. ▁length ▁; ▁} ▁if ▁( ▁bytes ▁[ ▁i ▁] ▁< ▁48 ▁|| ▁bytes ▁[ ▁i ▁] ▁> ▁5 7 ▁) ▁{ ▁setError State ▁( ▁Parse Error State ▁. ▁NUMERIC _ VALUE _ IL LEG AL _ CHAR ACTER ▁) ▁; ▁return ▁- ▁1 ▁; ▁} ▁val ▁ * = ▁10 ▁; ▁val ▁+= ▁bytes ▁[ ▁i ▁] ▁- ▁48 ▁; ▁if ▁( ▁val ▁< ▁0 ▁) ▁{ ▁if ▁( ▁neg ▁&& ▁val ▁== ▁Long ▁. ▁MIN _ VALUE ▁) ▁{ ▁this ▁. ▁result ▁= ▁Long ▁. ▁MIN _ VALUE ▁; ▁if ▁( ▁i ▁+ ▁1 ▁>= ▁limit ▁) ▁{ ▁return ▁limit ▁; ▁} ▁else ▁if ▁( ▁i ▁+ ▁1 ▁< ▁delim Limit ▁&& ▁delimiter Next ▁( ▁bytes ▁, ▁i ▁+ ▁1 ▁, ▁delimiter ▁) ▁) ▁{ ▁return ▁i ▁+ ▁1 ▁+ ▁delimiter ▁. ▁length ▁; ▁} ▁else ▁{ ▁setError State ▁( ▁Parse Error State ▁. ▁NUMERIC _ VALUE _ OVER FLOW _ UN DER FLOW ▁) ▁; ▁return ▁- ▁1 ▁; ▁} ▁} ▁else ▁{ ▁setError State ▁( ▁Parse Error State ▁. ▁NUMERIC _ VALUE _ OVER FLOW _ UN DER FLOW ▁) ▁; ▁return ▁- ▁1 ▁; ▁} ▁} ▁} ▁this ▁. ▁result ▁= ▁neg ▁? ▁- ▁val ▁: ▁val ▁; ▁return ▁limit ▁; ▁} ▁@ ▁Override ▁public ▁Long ▁createValue ▁( ▁) ▁{ ▁return ▁Long ▁. ▁MIN _ VALUE ▁; ▁} ▁@ ▁Override ▁public ▁Long ▁getLast Result ▁( ▁) ▁{ ▁return ▁Long ▁. ▁valueOf ▁( ▁this ▁. ▁result ▁) ▁; ▁} ▁public ▁static ▁final ▁long ▁parse Field ▁( ▁byte ▁[ ▁] ▁bytes ▁, ▁int ▁startPos ▁, ▁int ▁length ▁) ▁{ ▁return ▁parse Field ▁( ▁bytes ▁, ▁startPos ▁, ▁length ▁, ▁( ▁char ▁) ▁0 xffff ▁) ▁; ▁}
▁executeAsync With Origin ▁( ▁client ▁. ▁threadPool ▁( ▁) ▁. ▁getThread Context ▁( ▁) ▁, ▁W ATCH ER _ ORIGIN ▁, ▁update Request ▁, ▁ActionListener ▁. ▁< ▁Update Response ▁> ▁wrap ▁( ▁response ▁-> ▁{ ▁boolean ▁created ▁= ▁response ▁. ▁getResult ▁( ▁) ▁== ▁Doc Write Response ▁. ▁Result ▁. ▁CREATED ▁; ▁listener ▁. ▁onResponse ▁( ▁new ▁Put WatchResponse ▁( ▁response ▁. ▁getId ▁( ▁) ▁, ▁response ▁. ▁getVersion ▁( ▁) ▁, ▁response ▁. ▁get SeqNo ▁( ▁) ▁, ▁response ▁. ▁getPrimary Term ▁( ▁) ▁, ▁created ▁) ▁) ▁; ▁} ▁, ▁listener ▁:: ▁onFailure ▁) ▁, ▁client ▁:: ▁update ▁) ▁; ▁} ▁else ▁{ ▁IndexRequest ▁index Request ▁= ▁new ▁IndexRequest ▁( ▁Watch ▁. ▁INDEX ▁) ▁. ▁id ▁( ▁request ▁. ▁getId ▁( ▁) ▁) ▁; ▁index Request ▁. ▁source ▁( ▁builder ▁) ▁; ▁index Request ▁. ▁set RefreshPolicy ▁( ▁WriteRequest ▁. ▁RefreshPolicy ▁. ▁IM MEDIATE ▁) ▁; ▁executeAsync With Origin ▁( ▁client ▁. ▁threadPool ▁( ▁) ▁. ▁getThread Context ▁( ▁) ▁, ▁W ATCH ER _ ORIGIN ▁, ▁index Request ▁, ▁ActionListener ▁. ▁< ▁Index Response ▁> ▁wrap ▁( ▁response ▁-> ▁{ ▁boolean ▁created ▁= ▁response ▁. ▁getResult ▁( ▁) ▁== ▁Doc Write Response ▁. ▁Result ▁. ▁CREATED ▁; ▁listener ▁. ▁onResponse ▁( ▁new ▁Put WatchResponse ▁( ▁response ▁. ▁getId ▁( ▁) ▁, ▁response ▁. ▁getVersion ▁( ▁) ▁, ▁response ▁. ▁get SeqNo ▁( ▁) ▁, ▁response ▁. ▁getPrimary Term ▁( ▁) ▁, ▁created ▁) ▁) ▁; ▁} ▁, ▁listener ▁:: ▁onFailure ▁) ▁, ▁client ▁:: ▁index ▁) ▁; ▁} ▁} ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁listener ▁. ▁onFailure ▁( ▁e ▁) ▁; ▁} ▁} ▁}
▁@ ▁Deprecated ▁public ▁class ▁Watermark Spec ▁{ ▁private ▁final ▁String ▁row time Attribute ▁; ▁private ▁final ▁String ▁watermark Expression String ▁; ▁private ▁final ▁DataType ▁watermark Expr Output Type ▁; ▁public ▁Watermark Spec ▁( ▁String ▁row time Attribute ▁, ▁String ▁watermark Expression String ▁, ▁DataType ▁watermark Expr Output Type ▁) ▁{ ▁this ▁. ▁row time Attribute ▁= ▁checkNotNull ▁( ▁row time Attribute ▁) ▁; ▁this ▁. ▁watermark Expression String ▁= ▁checkNotNull ▁( ▁watermark Expression String ▁) ▁; ▁this ▁. ▁watermark Expr Output Type ▁= ▁checkNotNull ▁( ▁watermark Expr Output Type ▁) ▁; ▁} ▁public ▁String ▁getRow time Attribute ▁( ▁) ▁{ ▁return ▁row time Attribute ▁; ▁} ▁public ▁String ▁get Watermark Expr ▁( ▁) ▁{ ▁return ▁watermark Expression String ▁; ▁} ▁public ▁DataType ▁get Watermark Expr Output Type ▁( ▁) ▁{ ▁return ▁watermark Expr Output Type ▁; ▁} ▁public ▁String ▁asSummaryString ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁row time Attribute ▁+ ▁STR ▁+ ▁watermark Expr Output Type ▁+ ▁STR ▁+ ▁watermark Expression String ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁o ▁) ▁{ ▁if ▁( ▁this ▁== ▁o ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁o ▁== ▁null ▁|| ▁getClass ▁( ▁) ▁!= ▁o ▁. ▁getClass ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁Watermark Spec ▁that ▁= ▁( ▁Watermark Spec ▁) ▁o ▁; ▁return ▁Objects ▁. ▁equals ▁( ▁row time Attribute ▁, ▁that ▁. ▁row time Attribute ▁) ▁&& ▁Objects ▁. ▁equals ▁( ▁watermark Expression String ▁, ▁that ▁. ▁watermark Expression String ▁) ▁&& ▁Objects ▁. ▁equals ▁( ▁watermark Expr Output Type ▁, ▁that ▁. ▁watermark Expr Output Type ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁Objects ▁. ▁hash ▁( ▁row time Attribute ▁, ▁watermark Expression String ▁, ▁watermark Expr Output Type ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁asSummaryString ▁( ▁) ▁; ▁} ▁}
▁public ▁final ▁class ▁Mqtt TestUtils ▁{ ▁private ▁Mqtt TestUtils ▁( ▁) ▁{ ▁} ▁public ▁static ▁void ▁validate Properties ▁( ▁Mqtt Properties ▁expected ▁, ▁Mqtt Properties ▁actual ▁) ▁{ ▁for ▁( ▁Mqtt Properties ▁. ▁Mqtt Property ▁expected Property ▁: ▁expected ▁. ▁list All ▁( ▁) ▁) ▁{ ▁Mqtt Properties ▁. ▁Mqtt Property ▁actual Property ▁= ▁actual ▁. ▁getProperty ▁( ▁expected Property ▁. ▁property Id ▁) ▁; ▁List ▁< ▁? ▁extends ▁Mqtt Properties ▁. ▁Mqtt Property ▁> ▁actual Properties ▁= ▁actual ▁. ▁getProperties ▁( ▁expected Property ▁. ▁property Id ▁) ▁; ▁switch ▁( ▁Mqtt Properties ▁. ▁Mqtt Property Type ▁. ▁valueOf ▁( ▁expected Property ▁. ▁property Id ▁) ▁) ▁{ ▁case ▁P AY LOAD _ FORMAT _ IND IC ATOR ▁: ▁case ▁REQUEST _ PRO BLE M _ IN FORM ATION ▁: ▁case ▁REQUEST _ RESPONSE _ IN FORM ATION ▁: ▁case ▁MAX IMUM _ Q OS ▁: ▁case ▁RE TA IN _ AVAILABLE ▁: ▁case ▁W ILD C ARD _ SUB SCRIPTION _ AVAILABLE ▁: ▁case ▁SUB SCRIPTION _ IDENT IFIER _ AVAILABLE ▁: ▁case ▁SHAR ED _ SUB SCRIPTION _ AVAILABLE ▁: ▁{ ▁final ▁Integer ▁expectedValue ▁= ▁( ▁( ▁Mqtt Properties ▁. ▁Integer Property ▁) ▁expected Property ▁) ▁. ▁value ▁; ▁final ▁Integer ▁actual Value ▁= ▁( ▁( ▁Mqtt Properties ▁. ▁Integer Property ▁) ▁actual Property ▁) ▁. ▁value ▁; ▁assertEquals ▁( ▁expectedValue ▁, ▁actual Value ▁, ▁STR ▁) ▁; ▁break ▁; ▁} ▁case ▁SERVER _ K EEP _ AL IVE ▁: ▁case ▁RE CE IVE _ MAX IMUM ▁: ▁case ▁TOPIC _ ALIAS _ MAX IMUM ▁: ▁case ▁TOPIC _ ALIAS ▁: ▁{ ▁final ▁Integer ▁expectedValue ▁= ▁( ▁( ▁Mqtt Properties ▁. ▁Integer Property ▁) ▁expected Property ▁) ▁. ▁value ▁; ▁final ▁Integer ▁actual Value ▁= ▁( ▁( ▁Mqtt Properties ▁. ▁Integer Property ▁) ▁actual Property ▁) ▁. ▁value ▁; ▁assertEquals ▁( ▁expectedValue ▁, ▁actual Value ▁, ▁STR ▁) ▁; ▁break ▁; ▁} ▁case ▁PUB LICATION _ EX PI R Y _ INTERVAL ▁: ▁case ▁SESSION _ EX PI R Y _ INTERVAL ▁: ▁case ▁W IL L _ DELAY _ INTERVAL ▁: ▁case ▁MAX IMUM _ P ACKET _ SI Z E ▁: ▁{ ▁final ▁Integer ▁expectedValue ▁= ▁( ▁( ▁Mqtt Properties ▁. ▁Integer Property ▁) ▁expected Property ▁) ▁. ▁value ▁; ▁final ▁Integer ▁actual Value ▁= ▁( ▁( ▁Mqtt Properties ▁. ▁Integer Property ▁) ▁actual Property ▁) ▁. ▁value ▁; ▁assertEquals ▁( ▁expectedValue ▁, ▁actual Value ▁, ▁STR ▁) ▁; ▁break ▁; ▁} ▁case ▁SUB SCRIPTION _ IDENT IFIER ▁: ▁{ ▁final ▁Integer ▁expectedValue ▁= ▁( ▁( ▁Mqtt Properties ▁. ▁Integer Property ▁) ▁expected Property ▁) ▁. ▁value ▁; ▁assertContains Value ▁( ▁STR ▁, ▁expectedValue ▁, ▁actual Properties ▁) ▁; ▁break ▁; ▁}
▁public ▁class ▁Duplicate Action ▁extends ▁Composite Editor Table Action ▁{ ▁private ▁final ▁static ▁ImageIcon ▁ICON ▁= ▁ResourceManager ▁. ▁loadImage ▁( ▁STR ▁) ▁; ▁public ▁final ▁static ▁String ▁ACTION _ NAME ▁= ▁STR ▁; ▁private ▁final ▁static ▁String ▁GROUP _ NAME ▁= ▁COMPONENT _ ACTION _ GROUP ▁; ▁private ▁final ▁static ▁String ▁DESCRIPTION ▁= ▁STR ▁; ▁private ▁final ▁static ▁String ▁[ ▁] ▁P OP UP _ PATH ▁= ▁new ▁String ▁[ ▁] ▁{ ▁ACTION _ NAME ▁} ▁; ▁private ▁final ▁static ▁KeyStroke ▁KEY _ STR OK E ▁= ▁KeyStroke ▁. ▁getKey Stroke ▁( ▁KeyEvent ▁. ▁VK _ D ▁, ▁InputEvent ▁. ▁AL T _ DOWN _ MASK ▁) ▁; ▁public ▁Duplicate Action ▁( ▁Composite EditorProvider ▁provider ▁) ▁{ ▁super ▁( ▁provider ▁, ▁ED IT _ ACTION _ PREFIX ▁+ ▁ACTION _ NAME ▁, ▁GROUP _ NAME ▁, ▁P OP UP _ PATH ▁, ▁null ▁, ▁ICON ▁) ▁; ▁setDescription ▁( ▁DESCRIPTION ▁) ▁; ▁setKey BindingData ▁( ▁new ▁KeyBindingData ▁( ▁KEY _ STR OK E ▁) ▁) ▁; ▁adjust Enablement ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁actionPerformed ▁( ▁ActionContext ▁context ▁) ▁{ ▁int ▁[ ▁] ▁indices ▁= ▁model ▁. ▁getSelected Component Rows ▁( ▁) ▁; ▁if ▁( ▁indices ▁. ▁length ▁!= ▁1 ▁) ▁{ ▁return ▁; ▁} ▁int ▁max ▁= ▁model ▁. ▁getMax Duplicates ▁( ▁indices ▁[ ▁0 ▁] ▁) ▁; ▁if ▁( ▁max ▁!= ▁0 ▁) ▁{ ▁try ▁{ ▁model ▁. ▁duplicate Multiple ▁( ▁indices ▁[ ▁0 ▁] ▁, ▁1 ▁, ▁TaskMonitor ▁. ▁DUMMY ▁) ▁; ▁} ▁catch ▁( ▁U sr Exception ▁e 1 ▁) ▁{ ▁model ▁. ▁setStatus ▁( ▁e 1 ▁. ▁getMessage ▁( ▁) ▁, ▁true ▁) ▁; ▁} ▁} ▁request Table Focus ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁adjust Enablement ▁( ▁) ▁{ ▁setEnabled ▁( ▁model ▁. ▁is Duplicate Allowed ▁( ▁) ▁) ▁; ▁} ▁}
▁Vector 2 ▁d ▁= ▁be z ier ▁. ▁der ivative At ▁( ▁new ▁Vector 2 ▁( ▁) ▁, ▁0.5 f ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁1 ▁, ▁d ▁. ▁x ▁, ▁epsilon ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁1 ▁, ▁d ▁. ▁y ▁, ▁epsilon ▁) ▁; ▁Vector 2 ▁v ▁= ▁be z ier ▁. ▁value At ▁( ▁new ▁Vector 2 ▁( ▁) ▁, ▁0.5 f ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁0.5 f ▁, ▁v ▁. ▁x ▁, ▁epsilon ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁0.5 f ▁, ▁v ▁. ▁y ▁, ▁epsilon ▁) ▁; ▁float ▁t ▁= ▁be z ier ▁. ▁app ro ximate ▁( ▁new ▁Vector 2 ▁( ▁. 5 f ▁, ▁. 5 f ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁. 5 f ▁, ▁t ▁, ▁epsilon App rim ations ▁) ▁; ▁float ▁l ▁= ▁be z ier ▁. ▁locate ▁( ▁new ▁Vector 2 ▁( ▁. 5 f ▁, ▁. 5 f ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁. 5 f ▁, ▁t ▁, ▁epsilon ▁) ▁; ▁} ▁}
▁public ▁final ▁class ▁Field And Format ▁implements ▁Writeable ▁, ▁ToXContent Object ▁{ ▁private ▁static ▁final ▁String ▁USE _ DEFAULT _ FORMAT ▁= ▁STR ▁; ▁private ▁static ▁final ▁Deprecation Logger ▁DE PRE CATION _ LOGGER ▁= ▁Deprecation Logger ▁. ▁getLogger ▁( ▁Fetch DocValues Phase ▁. ▁class ▁) ▁; ▁private ▁static ▁final ▁ParseField ▁FIELD _ FIELD ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁ParseField ▁FORMAT _ FIELD ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁ParseField ▁IN CLUDE _ UN MAP PED _ FIELD ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁Construct ingObjectParser ▁< ▁Field And Format ▁, ▁Void ▁> ▁PARSER ▁= ▁new ▁Construct ingObjectParser ▁< ▁> ▁( ▁STR ▁, ▁a ▁-> ▁new ▁Field And Format ▁( ▁( ▁String ▁) ▁a ▁[ ▁0 ▁] ▁, ▁( ▁String ▁) ▁a ▁[ ▁1 ▁] ▁, ▁( ▁Boolean ▁) ▁a ▁[ ▁2 ▁] ▁) ▁) ▁; ▁static ▁{ ▁PARSER ▁. ▁declareString ▁( ▁Construct ingObjectParser ▁. ▁constructorArg ▁( ▁) ▁, ▁FIELD _ FIELD ▁) ▁; ▁PARSER ▁. ▁declareString OrNull ▁( ▁Construct ingObjectParser ▁. ▁optional ConstructorArg ▁( ▁) ▁, ▁FORMAT _ FIELD ▁. ▁for Rest ApiVersion ▁( ▁onOrAfter ▁( ▁RestApiVersion ▁. ▁V _8 ▁) ▁) ▁) ▁; ▁PARSER ▁. ▁declareField ▁( ▁Construct ingObjectParser ▁. ▁optional ConstructorArg ▁( ▁) ▁, ▁ignore Use Field Mapping String Parser ▁( ▁) ▁, ▁FORMAT _ FIELD ▁. ▁for Rest ApiVersion ▁( ▁equalTo ▁( ▁RestApiVersion ▁. ▁V _7 ▁) ▁) ▁, ▁ObjectParser ▁. ▁ValueType ▁. ▁STRING _ OR _ NULL ▁) ▁; ▁PARSER ▁. ▁declareBoolean ▁( ▁Construct ingObjectParser ▁. ▁optional ConstructorArg ▁( ▁) ▁, ▁IN CLUDE _ UN MAP PED _ FIELD ▁) ▁; ▁} ▁private ▁static ▁Checked Function ▁< ▁XContentParser ▁, ▁String ▁, ▁IOException ▁> ▁ignore Use Field Mapping String Parser ▁( ▁) ▁{ ▁return ▁( ▁p ▁) ▁-> ▁{ ▁if ▁( ▁p ▁. ▁currentToken ▁( ▁) ▁== ▁XContentParser ▁. ▁Token ▁. ▁VALUE _ NULL ▁) ▁{ ▁return ▁null ▁; ▁} ▁else ▁{ ▁String ▁text ▁= ▁p ▁. ▁text ▁( ▁) ▁; ▁if ▁( ▁text ▁. ▁equals ▁( ▁USE _ DEFAULT _ FORMAT ▁) ▁) ▁{ ▁DE PRE CATION _ LOGGER ▁. ▁compatible Api Warning ▁( ▁STR ▁, ▁STR ▁+ ▁USE _ DEFAULT _ FORMAT ▁+ ▁STR ▁+ ▁STR ▁) ▁; ▁return ▁null ▁; ▁} ▁else ▁{ ▁return ▁text ▁; ▁} ▁} ▁} ▁; ▁} ▁public ▁static ▁Field And Format ▁fromXContent ▁( ▁XContentParser ▁parser ▁) ▁throws ▁IOException ▁{ ▁XContentParser ▁. ▁Token ▁token ▁= ▁parser ▁. ▁currentToken ▁( ▁) ▁; ▁if ▁( ▁token ▁. ▁is Value ▁( ▁) ▁) ▁{ ▁return ▁new ▁Field And Format ▁( ▁parser ▁. ▁text ▁( ▁) ▁, ▁null ▁) ▁; ▁} ▁else ▁{ ▁return ▁PARSER ▁. ▁apply ▁( ▁parser ▁, ▁null ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁XContentBuilder ▁toXContent ▁( ▁XContentBuilder ▁builder ▁, ▁Params ▁params ▁) ▁throws ▁IOException ▁{ ▁builder ▁. ▁startObject ▁( ▁) ▁; ▁builder ▁. ▁field ▁( ▁FIELD _ FIELD ▁. ▁getPreferred Name ▁( ▁) ▁, ▁field ▁) ▁; ▁if ▁( ▁format ▁!= ▁null ▁) ▁{ ▁builder ▁. ▁field ▁( ▁FORMAT _ FIELD ▁. ▁getPreferred Name ▁( ▁) ▁, ▁format ▁) ▁; ▁}
▁@ ▁Override ▁public ▁void ▁setWrite Method ▁( ▁@ ▁Nullable ▁Method ▁write Method ▁) ▁{ ▁this ▁. ▁write Method ▁= ▁write Method ▁; ▁} ▁@ ▁Override ▁@ ▁Nullable ▁public ▁Class ▁< ▁? ▁> ▁getProperty Type ▁( ▁) ▁{ ▁if ▁( ▁this ▁. ▁property Type ▁== ▁null ▁) ▁{ ▁try ▁{ ▁this ▁. ▁property Type ▁= ▁Property Descriptor Utils ▁. ▁find Property Type ▁( ▁this ▁. ▁read Method ▁, ▁this ▁. ▁write Method ▁) ▁; ▁} ▁catch ▁( ▁Int ros pection Exception ▁ex ▁) ▁{ ▁} ▁} ▁return ▁this ▁. ▁property Type ▁; ▁} ▁@ ▁Override ▁@ ▁Nullable ▁public ▁Method ▁getIndex ed Read Method ▁( ▁) ▁{ ▁return ▁this ▁. ▁indexed Read Method ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Indexed Read Method ▁( ▁@ ▁Nullable ▁Method ▁indexed Read Method ▁) ▁throws ▁Int ros pection Exception ▁{ ▁this ▁. ▁indexed Read Method ▁= ▁indexed Read Method ▁; ▁} ▁@ ▁Override ▁@ ▁Nullable ▁public ▁Method ▁getIndex ed Write Method ▁( ▁) ▁{ ▁return ▁this ▁. ▁indexed Write Method ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Indexed Write Method ▁( ▁@ ▁Nullable ▁Method ▁indexed Write Method ▁) ▁throws ▁Int ros pection Exception ▁{ ▁this ▁. ▁indexed Write Method ▁= ▁indexed Write Method ▁; ▁} ▁@ ▁Override ▁@ ▁Nullable ▁public ▁Class ▁< ▁? ▁> ▁getIndex ed Property Type ▁( ▁) ▁{ ▁if ▁( ▁this ▁. ▁indexed Property Type ▁== ▁null ▁) ▁{ ▁try ▁{ ▁this ▁. ▁indexed Property Type ▁= ▁Property Descriptor Utils ▁. ▁find Indexed Property Type ▁( ▁getName ▁( ▁) ▁, ▁getProperty Type ▁( ▁) ▁, ▁this ▁. ▁indexed Read Method ▁, ▁this ▁. ▁indexed Write Method ▁) ▁; ▁} ▁catch ▁( ▁Int ros pection Exception ▁ex ▁) ▁{ ▁} ▁} ▁return ▁this ▁. ▁indexed Property Type ▁; ▁} ▁@ ▁Override ▁@ ▁Nullable ▁public ▁Class ▁< ▁? ▁> ▁getProperty Editor Class ▁( ▁) ▁{ ▁return ▁this ▁. ▁property Editor Class ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setProperty Editor Class ▁( ▁@ ▁Nullable ▁Class ▁< ▁? ▁> ▁property Editor Class ▁) ▁{ ▁this ▁. ▁property Editor Class ▁= ▁property Editor Class ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁@ ▁Nullable ▁Object ▁other ▁) ▁{ ▁if ▁( ▁this ▁== ▁other ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁! ▁( ▁other ▁instanceof ▁Indexed Property Descriptor ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁Indexed Property Descriptor ▁other P d ▁= ▁( ▁Indexed Property Descriptor ▁) ▁other ▁; ▁return ▁( ▁ObjectUtils ▁. ▁nullSafeEquals ▁( ▁getIndex ed Read Method ▁( ▁) ▁, ▁other P d ▁. ▁getIndex ed Read Method ▁( ▁) ▁) ▁&& ▁ObjectUtils ▁. ▁nullSafeEquals ▁( ▁getIndex ed Write Method ▁( ▁) ▁, ▁other P d ▁. ▁getIndex ed Write Method ▁( ▁) ▁) ▁&& ▁ObjectUtils ▁. ▁nullSafeEquals ▁( ▁getIndex ed Property Type ▁( ▁) ▁, ▁other P d ▁. ▁getIndex ed Property Type ▁( ▁) ▁) ▁&& ▁Property Descriptor Utils ▁. ▁equals ▁( ▁this ▁, ▁other P d ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁int ▁hashCode ▁= ▁ObjectUtils ▁. ▁nullSafe HashCode ▁( ▁getRead Method ▁( ▁) ▁) ▁;
▁public ▁class ▁Text Blocks UnitTest ▁{ ▁private ▁static ▁final ▁String ▁JSON _ STRING ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁private ▁static ▁final ▁String ▁TEXT _ BLOCK _ JSON ▁= ▁STR ▁ " ▁{ ▁STR ▁: ▁STR ▁, ▁STR ▁: ▁STR ▁} ▁STR ▁ " ; ▁@ ▁Test ▁public ▁void ▁when Text Blocks _ then String Operations Work ▁( ▁) ▁{ ▁assertThat ▁( ▁TEXT _ BLOCK _ JSON ▁. ▁contains ▁( ▁STR ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁assertThat ▁( ▁TEXT _ BLOCK _ JSON ▁. ▁indexOf ▁( ▁STR ▁) ▁) ▁. ▁isGreaterThan ▁( ▁0 ▁) ▁; ▁assertThat ▁( ▁TEXT _ BLOCK _ JSON ▁. ▁length ▁( ▁) ▁) ▁. ▁isGreaterThan ▁( ▁0 ▁) ▁; ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁@ ▁Test ▁public ▁void ▁when Text Blocks _ then Format ted Work s As Format ▁( ▁) ▁{ ▁assertThat ▁( ▁TEXT _ BLOCK _ JSON ▁. ▁formatted ▁( ▁STR ▁) ▁. ▁contains ▁( ▁STR ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁assertThat ▁( ▁String ▁. ▁format ▁( ▁JSON _ STRING ▁, ▁STR ▁) ▁. ▁contains ▁( ▁STR ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁P lay ing G ame Drawable ▁extends ▁Status Drawable ▁{ ▁private ▁boolean ▁is Chat ▁= ▁false ▁; ▁private ▁Paint ▁paint ▁= ▁new ▁Paint ▁( ▁Paint ▁. ▁ANT I _ ALIAS _ FLAG ▁) ▁; ▁private ▁int ▁current Account ▁= ▁User Config ▁. ▁selected Account ▁; ▁private ▁long ▁last UpdateTime ▁= ▁0 ▁; ▁private ▁boolean ▁started ▁= ▁false ▁; ▁private ▁RectF ▁rect ▁= ▁new ▁RectF ▁( ▁) ▁; ▁private ▁float ▁progress ▁; ▁private ▁final ▁boolean ▁is Dialog Screen ▁; ▁public ▁P lay ing G ame Drawable ▁( ▁boolean ▁is Dialog Screen ▁) ▁{ ▁this ▁. ▁is Dialog Screen ▁= ▁is Dialog Screen ▁; ▁} ▁public ▁void ▁setIs Chat ▁( ▁boolean ▁value ▁) ▁{ ▁is Chat ▁= ▁value ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setColor ▁( ▁int ▁color ▁) ▁{ ▁} ▁private ▁void ▁update ▁( ▁) ▁{ ▁long ▁new Time ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁; ▁long ▁dt ▁= ▁new Time ▁- ▁last UpdateTime ▁; ▁last UpdateTime ▁= ▁new Time ▁; ▁if ▁( ▁dt ▁> ▁16 ▁) ▁{ ▁dt ▁= ▁16 ▁; ▁} ▁if ▁( ▁progress ▁>= ▁1.0 f ▁) ▁{ ▁progress ▁= ▁0.0 f ▁; ▁} ▁progress ▁+= ▁dt ▁ / ▁300 .0 f ▁; ▁if ▁( ▁progress ▁> ▁1.0 f ▁) ▁{ ▁progress ▁= ▁1.0 f ▁; ▁} ▁invalidate Self ▁( ▁) ▁; ▁} ▁public ▁void ▁start ▁( ▁) ▁{ ▁last UpdateTime ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁; ▁started ▁= ▁true ▁; ▁invalidate Self ▁( ▁) ▁; ▁} ▁public ▁void ▁stop ▁( ▁) ▁{ ▁progress ▁= ▁0.0 f ▁; ▁started ▁= ▁false ▁; ▁} ▁@ ▁Override ▁public ▁void ▁draw ▁( ▁Canvas ▁canvas ▁) ▁{ ▁int ▁size ▁= ▁Android Utilities ▁. ▁dp ▁( ▁10 ▁) ▁; ▁int ▁y ▁= ▁getBounds ▁( ▁) ▁. ▁top ▁+ ▁( ▁getIntrinsic Height ▁( ▁) ▁- ▁size ▁) ▁ / ▁2 ▁; ▁if ▁( ▁is Chat ▁) ▁{ ▁} ▁else ▁{ ▁y ▁+= ▁Android Utilities ▁. ▁dp ▁( ▁1 ▁) ▁; ▁} ▁paint ▁. ▁setColor ▁( ▁Theme ▁. ▁getColor ▁( ▁is Dialog Screen ▁? ▁Theme ▁. ▁key _ ch at s _ action Message ▁: ▁Theme ▁. ▁key _ ch at _ status ▁) ▁) ▁; ▁rect ▁. ▁set ▁( ▁0 ▁, ▁y ▁, ▁size ▁, ▁y ▁+ ▁size ▁) ▁; ▁int ▁r ad ▁; ▁if ▁( ▁progress ▁< ▁0.5 f ▁) ▁{ ▁r ad ▁= ▁( ▁int ▁) ▁( ▁35 ▁ * ▁( ▁1.0 f ▁- ▁progress ▁ / ▁0.5 f ▁) ▁) ▁; ▁} ▁else ▁{ ▁r ad ▁= ▁( ▁int ▁) ▁( ▁35 ▁ * ▁( ▁progress ▁- ▁0.5 f ▁) ▁ / ▁0.5 f ▁) ▁; ▁} ▁for ▁( ▁int ▁a ▁= ▁0 ▁; ▁a ▁< ▁3 ▁; ▁a ▁++ ▁) ▁{ ▁float ▁x ▁= ▁a ▁ * ▁Android Utilities ▁. ▁dp ▁( ▁5 ▁) ▁+ ▁Android Utilities ▁. ▁dp ▁( ▁9 . 2 f ▁) ▁- ▁Android Utilities ▁. ▁dp ▁( ▁5 ▁) ▁ * ▁progress ▁;
▁public ▁final ▁class ▁Parallel FlatMap Stream ▁< ▁T ▁, ▁R ▁> ▁extends ▁Parallel Flowable ▁< ▁R ▁> ▁{ ▁final ▁Parallel Flowable ▁< ▁T ▁> ▁source ▁; ▁final ▁Function ▁< ▁? ▁super ▁T ▁, ▁? ▁extends ▁Stream ▁< ▁? ▁extends ▁R ▁> ▁> ▁mapper ▁; ▁final ▁int ▁prefetch ▁; ▁public ▁Parallel FlatMap Stream ▁( ▁Parallel Flowable ▁< ▁T ▁> ▁source ▁, ▁Function ▁< ▁? ▁super ▁T ▁, ▁? ▁extends ▁Stream ▁< ▁? ▁extends ▁R ▁> ▁> ▁mapper ▁, ▁int ▁prefetch ▁) ▁{ ▁this ▁. ▁source ▁= ▁source ▁; ▁this ▁. ▁mapper ▁= ▁mapper ▁; ▁this ▁. ▁prefetch ▁= ▁prefetch ▁; ▁} ▁@ ▁Override ▁public ▁int ▁parallelism ▁( ▁) ▁{ ▁return ▁source ▁. ▁parallelism ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁subscribe ▁( ▁Subscriber ▁< ▁? ▁super ▁R ▁> ▁[ ▁] ▁subscribers ▁) ▁{ ▁if ▁( ▁! ▁validate ▁( ▁subscribers ▁) ▁) ▁{ ▁return ▁; ▁} ▁int ▁n ▁= ▁subscribers ▁. ▁length ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁final ▁Subscriber ▁< ▁T ▁> ▁[ ▁] ▁parent s ▁= ▁new ▁Subscriber ▁[ ▁n ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁n ▁; ▁i ▁++ ▁) ▁{ ▁parent s ▁[ ▁i ▁] ▁= ▁Flowable FlatMap Stream ▁. ▁subscribe ▁( ▁subscribers ▁[ ▁i ▁] ▁, ▁mapper ▁, ▁prefetch ▁) ▁; ▁} ▁source ▁. ▁subscribe ▁( ▁parent s ▁) ▁; ▁} ▁}
▁public ▁class ▁Fi fo In tra Queue Preemption Plugin ▁implements ▁In tra Queue Preemption Compute Plugin ▁{ ▁protected ▁final ▁Capacity Scheduler Preemption Context ▁context ▁; ▁protected ▁final ▁Resource Calculator ▁rc ▁; ▁private ▁static ▁final ▁Logger ▁LOG ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Fi fo In tra Queue Preemption Plugin ▁. ▁class ▁) ▁; ▁public ▁Fi fo In tra Queue Preemption Plugin ▁( ▁Resource Calculator ▁rc ▁, ▁Capacity Scheduler Preemption Context ▁pre emption Context ▁) ▁{ ▁this ▁. ▁context ▁= ▁pre emption Context ▁; ▁this ▁. ▁rc ▁= ▁rc ▁; ▁} ▁@ ▁Override ▁public ▁Collection ▁< ▁Fi Ca Scheduler App ▁> ▁getPre empt able Apps ▁( ▁String ▁queueName ▁, ▁String ▁partition ▁) ▁{ ▁Temp Queue Per Partition ▁t q ▁= ▁context ▁. ▁getQueue By Partition ▁( ▁queueName ▁, ▁partition ▁) ▁; ▁List ▁< ▁Fi Ca Scheduler App ▁> ▁app s ▁= ▁new ▁ArrayList ▁< ▁Fi Ca Scheduler App ▁> ▁( ▁) ▁; ▁for ▁( ▁Temp App Per Partition ▁tmp App ▁: ▁t q ▁. ▁get Apps ▁( ▁) ▁) ▁{ ▁if ▁( ▁Resources ▁. ▁equals ▁( ▁tmp App ▁. ▁get Act ually ToBe Pre emp ted ▁( ▁) ▁, ▁Resources ▁. ▁none ▁( ▁) ▁) ▁) ▁{ ▁continue ▁; ▁} ▁app s ▁. ▁add ▁( ▁tmp App ▁. ▁app ▁) ▁; ▁} ▁return ▁app s ▁; ▁} ▁@ ▁Override ▁public ▁Map ▁< ▁String ▁, ▁Resource ▁> ▁getResource Dem and From Apps Per Queue ▁( ▁String ▁queueName ▁, ▁String ▁partition ▁) ▁{ ▁Map ▁< ▁String ▁, ▁Resource ▁> ▁res To O btain By Partition ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁Temp Queue Per Partition ▁t q ▁= ▁context ▁. ▁getQueue By Partition ▁( ▁queueName ▁, ▁partition ▁) ▁; ▁Collection ▁< ▁Temp App Per Partition ▁> ▁app s Ordered By Priority ▁= ▁t q ▁. ▁get Apps ▁( ▁) ▁; ▁Resource ▁actual Pre empt Needed ▁= ▁res To O btain By Partition ▁. ▁get ▁( ▁partition ▁) ▁; ▁if ▁( ▁actual Pre empt Needed ▁== ▁null ▁) ▁{ ▁actual Pre empt Needed ▁= ▁Resources ▁. ▁create Resource ▁( ▁0 ▁, ▁0 ▁) ▁; ▁res To O btain By Partition ▁. ▁put ▁( ▁partition ▁, ▁actual Pre empt Needed ▁) ▁; ▁} ▁for ▁( ▁Temp App Per Partition ▁a 1 ▁: ▁app s Ordered By Priority ▁) ▁{ ▁Resources ▁. ▁addTo ▁( ▁actual Pre empt Needed ▁, ▁a 1 ▁. ▁get Act ually ToBe Pre emp ted ▁( ▁) ▁) ▁; ▁} ▁LOG ▁. ▁debug ▁( ▁STR ▁, ▁actual Pre empt Needed ▁, ▁partition ▁) ▁; ▁return ▁res To O btain By Partition ▁; ▁} ▁@ ▁Override ▁public ▁void ▁compute Apps I de al Allocation ▁( ▁Resource ▁cluster Resource ▁, ▁Temp Queue Per Partition ▁t q ▁, ▁Map ▁< ▁Application AttemptId ▁, ▁Set ▁< ▁RMContainer ▁> ▁> ▁selected Candidates ▁, ▁Resource ▁total Pre emp ted Resource Allowed ▁, ▁Resource ▁queue Re assign able Resource ▁, ▁float ▁max Allow able Pre empt Limit ▁) ▁{ ▁Map ▁< ▁String ▁, ▁Resource ▁> ▁per User AM Used ▁= ▁new ▁HashMap ▁< ▁String ▁, ▁Resource ▁> ▁( ▁) ▁;
▁public ▁class ▁Find Reference sTo Address Action ▁extends ▁Abstract Find Reference sTo Address Action ▁{ ▁public ▁Find Reference sTo Address Action ▁( ▁PluginTool ▁tool ▁, ▁String ▁owner ▁) ▁{ ▁super ▁( ▁tool ▁, ▁owner ▁) ▁; ▁setHelpLocation ▁( ▁new ▁HelpLocation ▁( ▁Help Topics ▁. ▁DE COMP ILER ▁, ▁STR ▁) ▁) ▁; ▁setPopupMenu Data ▁( ▁new ▁MenuData ▁( ▁new ▁String ▁[ ▁] ▁{ ▁Location References Service ▁. ▁MENU _ GROUP ▁, ▁NAME ▁} ▁) ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁ProgramLocation ▁getLocation ▁( ▁Navigatable ActionContext ▁context ▁) ▁{ ▁if ▁( ▁! ▁( ▁context ▁instanceof ▁Decompiler ActionContext ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁return ▁context ▁. ▁getLocation ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁isEnabledFor Context ▁( ▁ActionContext ▁context ▁) ▁{ ▁if ▁( ▁! ▁( ▁context ▁instanceof ▁Decompiler ActionContext ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁Decompiler ActionContext ▁decompiler Context ▁= ▁( ▁Decompiler ActionContext ▁) ▁context ▁; ▁return ▁decompiler Context ▁. ▁check Action Enablement ▁( ▁( ▁) ▁-> ▁{ ▁return ▁super ▁. ▁isEnabledFor Context ▁( ▁context ▁) ▁; ▁} ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁actionPerformed ▁( ▁ActionContext ▁context ▁) ▁{ ▁Decompiler ActionContext ▁decompiler Context ▁= ▁( ▁Decompiler ActionContext ▁) ▁context ▁; ▁decompiler Context ▁. ▁performAction ▁( ▁( ▁) ▁-> ▁{ ▁super ▁. ▁actionPerformed ▁( ▁context ▁) ▁; ▁} ▁) ▁; ▁} ▁}
▁handle Event ▁( ▁new ▁Json Event Impl ▁( ▁null ▁, ▁Json EventType ▁. ▁VALUE ▁, ▁event ▁. ▁fieldName ▁( ▁) ▁, ▁new ▁JsonObject ▁( ▁handler ▁. ▁convert ▁( ▁Map ▁. ▁class ▁) ▁) ▁) ▁) ▁; ▁} ▁; ▁token Handler ▁= ▁handler ▁; ▁handler ▁. ▁handle ▁( ▁new ▁Json Event Impl ▁( ▁Json Token ▁. ▁START _ OBJECT ▁, ▁Json EventType ▁. ▁START _ OBJECT ▁, ▁null ▁, ▁null ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁event ▁. ▁type ▁( ▁) ▁== ▁Json EventType ▁. ▁START _ ARRAY ▁&& ▁array Value Mode ▁) ▁{ ▁Buffer ing Handler ▁handler ▁= ▁new ▁Buffer ing Handler ▁( ▁) ▁; ▁handler ▁. ▁handler ▁= ▁buffer ▁-> ▁{ ▁token Handler ▁= ▁this ▁:: ▁handle Event ▁; ▁handle Event ▁( ▁new ▁Json Event Impl ▁( ▁null ▁, ▁Json EventType ▁. ▁VALUE ▁, ▁event ▁. ▁fieldName ▁( ▁) ▁, ▁new ▁JsonArray ▁( ▁handler ▁. ▁convert ▁( ▁List ▁. ▁class ▁) ▁) ▁) ▁) ▁; ▁} ▁; ▁token Handler ▁= ▁handler ▁; ▁handler ▁. ▁handle ▁( ▁new ▁Json Event Impl ▁( ▁Json Token ▁. ▁START _ ARRAY ▁, ▁Json EventType ▁. ▁START _ ARRAY ▁, ▁null ▁, ▁null ▁) ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁dem and ▁!= ▁Long ▁. ▁MAX _ VALUE ▁) ▁{ ▁dem and ▁-- ▁; ▁} ▁if ▁( ▁eventHandler ▁!= ▁null ▁) ▁{ ▁eventHandler ▁. ▁handle ▁( ▁event ▁) ▁; ▁} ▁} ▁} ▁@ ▁Override ▁public ▁void ▁handle ▁( ▁Buffer ▁data ▁) ▁{ ▁byte ▁[ ▁] ▁bytes ▁= ▁data ▁. ▁getBytes ▁( ▁) ▁; ▁try ▁{ ▁parser ▁. ▁feed Input ▁( ▁bytes ▁, ▁0 ▁, ▁bytes ▁. ▁length ▁) ▁; ▁check Tokens ▁( ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁if ▁( ▁exception Handler ▁!= ▁null ▁) ▁{ ▁exception Handler ▁. ▁handle ▁( ▁e ▁) ▁; ▁return ▁; ▁} ▁else ▁{ ▁throw ▁new ▁Decode Exception ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁e ▁) ▁; ▁} ▁} ▁check Pending ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁end ▁( ▁) ▁{ ▁if ▁( ▁en ded ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁} ▁en ded ▁= ▁true ▁; ▁parser ▁. ▁endOf Input ▁( ▁) ▁; ▁try ▁{ ▁check Tokens ▁( ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁if ▁( ▁exception Handler ▁!= ▁null ▁) ▁{ ▁exception Handler ▁. ▁handle ▁( ▁e ▁) ▁; ▁return ▁; ▁} ▁else ▁{ ▁throw ▁new ▁Decode Exception ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁e ▁) ▁; ▁} ▁} ▁check Pending ▁( ▁) ▁; ▁} ▁private ▁void ▁check Tokens ▁( ▁) ▁throws ▁IOException ▁{ ▁while ▁( ▁true ▁) ▁{ ▁Json Token ▁token ▁= ▁parser ▁. ▁nextToken ▁( ▁) ▁; ▁if ▁( ▁token ▁== ▁null ▁|| ▁token ▁== ▁Json Token ▁. ▁NOT _ AVAILABLE ▁) ▁{ ▁break ▁; ▁} ▁String ▁field ▁= ▁current Field ▁; ▁current Field ▁= ▁null ▁; ▁Json Event Impl ▁event ▁; ▁switch ▁( ▁token ▁) ▁{ ▁case ▁START _ OBJECT ▁: ▁{ ▁event ▁= ▁new ▁Json Event Impl ▁( ▁token ▁, ▁Json EventType ▁. ▁START _ OBJECT ▁, ▁field ▁, ▁null ▁) ▁; ▁break ▁; ▁}
▁public ▁class ▁Collector ClusterInfo Repository Test ▁{ ▁private ▁static ▁final ▁String ▁PRO FI LER _ SEPARATOR ▁= ▁Collector ClusterInfo Repository ▁. ▁PRO FI LER _ SEPARATOR ▁; ▁private ▁final ▁Logger ▁logger ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁this ▁. ▁getClass ▁( ▁) ▁) ▁; ▁@ ▁Test ▁public ▁void ▁test ▁( ▁) ▁throws ▁Exception ▁{ ▁Collector ClusterInfo Repository ▁info ▁= ▁new ▁Collector ClusterInfo Repository ▁( ▁) ▁; ▁final ▁String ▁agent 1 ▁= ▁STR ▁; ▁final ▁String ▁agent 2 ▁= ▁STR ▁; ▁final ▁String ▁profiler Info ▁= ▁agent 1 ▁+ ▁PRO FI LER _ SEPARATOR ▁+ ▁agent 2 ▁; ▁byte ▁[ ▁] ▁profiler Info Bytes ▁= ▁profiler Info ▁. ▁getBytes ▁( ▁Standard Charsets ▁. ▁UTF _8 ▁) ▁; ▁info ▁. ▁put ▁( ▁STR ▁, ▁profiler Info Bytes ▁) ▁; ▁List ▁< ▁String ▁> ▁collector List ▁= ▁info ▁. ▁get ▁( ▁STR ▁, ▁STR ▁, ▁0 ▁) ▁; ▁logger ▁. ▁debug ▁( ▁STR ▁, ▁collector List ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁collector List ▁. ▁get ▁( ▁0 ▁) ▁) ▁; ▁info ▁. ▁remove ▁( ▁STR ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁STR ▁, ▁info ▁. ▁get ▁( ▁STR ▁, ▁STR ▁, ▁0 ▁) ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁Quote ▁{ ▁private ▁static ▁final ▁long ▁S G X _ FLAGS _ INIT TED ▁= ▁0 x 0000 _0 000 _0 000 _000 1 L ▁; ▁private ▁static ▁final ▁long ▁S G X _ FLAGS _ DEBUG ▁= ▁0 x 0000 _0 000 _0 000 _000 2 L ▁; ▁private ▁static ▁final ▁long ▁S G X _ FLAGS _ MODE 64 BIT ▁= ▁0 x 0000 _0 000 _0 000 _000 4 L ▁; ▁private ▁static ▁final ▁long ▁S G X _ FLAGS _ PRO VI SION _ KEY ▁= ▁0 x 0000 _0 000 _0 000 _000 4 L ▁; ▁private ▁static ▁final ▁long ▁S G X _ FLAGS _ E INIT TOKEN _ KEY ▁= ▁0 x 0000 _0 000 _0 000 _000 4 L ▁; ▁private ▁static ▁final ▁long ▁S G X _ FLAGS _ RE SER VED ▁= ▁0 xFFFF _ FFFF _ FFFF _ FF C 8 L ▁; ▁private ▁static ▁final ▁long ▁S G X _ X F RM _ LEGACY ▁= ▁0 x 0000 _0 000 _0 000 _000 3 L ▁; ▁private ▁static ▁final ▁long ▁S G X _ X F RM _ AV X ▁= ▁0 x 0000 _0 000 _0 000 _000 6 L ▁; ▁private ▁static ▁final ▁long ▁S G X _ X F RM _ RE SER VED ▁= ▁0 xFFFF _ FFFF _ FFFF _ FF F 8 L ▁; ▁private ▁final ▁int ▁version ▁; ▁private ▁final ▁boolean ▁isS ig Link able ▁; ▁private ▁final ▁long ▁g id ▁; ▁private ▁final ▁int ▁q e S v n ▁; ▁private ▁final ▁int ▁p ce S v n ▁; ▁private ▁final ▁byte ▁[ ▁] ▁bas ename ▁= ▁new ▁byte ▁[ ▁32 ▁] ▁; ▁private ▁final ▁byte ▁[ ▁] ▁cpu S v n ▁= ▁new ▁byte ▁[ ▁16 ▁] ▁; ▁private ▁final ▁long ▁flags ▁; ▁private ▁final ▁long ▁x f rm ▁; ▁private ▁final ▁byte ▁[ ▁] ▁mr en cl ave ▁= ▁new ▁byte ▁[ ▁32 ▁] ▁; ▁private ▁final ▁byte ▁[ ▁] ▁mr s ign er ▁= ▁new ▁byte ▁[ ▁32 ▁] ▁; ▁private ▁final ▁int ▁is v Pro d Id ▁; ▁private ▁final ▁int ▁is v S v n ▁; ▁private ▁final ▁byte ▁[ ▁] ▁report Data ▁= ▁new ▁byte ▁[ ▁64 ▁] ▁; ▁private ▁final ▁byte ▁[ ▁] ▁signature ▁; ▁private ▁final ▁byte ▁[ ▁] ▁quote Bytes ▁; ▁public ▁Quote ▁( ▁byte ▁[ ▁] ▁quote Bytes ▁) ▁throws ▁Invalid Quote FormatException ▁{ ▁this ▁. ▁quote Bytes ▁= ▁quote Bytes ▁; ▁ByteBuffer ▁quote Buf ▁= ▁ByteBuffer ▁. ▁wrap ▁( ▁quote Bytes ▁) ▁; ▁quote Buf ▁. ▁order ▁( ▁ByteOrder ▁. ▁LITTLE _ ENDIAN ▁) ▁; ▁this ▁. ▁version ▁= ▁quote Buf ▁. ▁getShort ▁( ▁0 ▁) ▁& ▁0 xFFFF ▁; ▁if ▁( ▁! ▁( ▁version ▁>= ▁1 ▁&& ▁version ▁<= ▁2 ▁) ▁) ▁{ ▁throw ▁new ▁Invalid Quote FormatException ▁( ▁STR ▁+ ▁version ▁) ▁; ▁} ▁int ▁sign _ type ▁= ▁quote Buf ▁. ▁getShort ▁( ▁2 ▁) ▁& ▁0 xFFFF ▁;
▁@ ▁Automatic Feature ▁class ▁JDK Registration s ▁extends ▁JNI Registration Util ▁implements ▁Graal Feature ▁{ ▁@ ▁Override ▁public ▁void ▁d uring Setup ▁( ▁D uring Setup Access ▁a ▁) ▁{ ▁r erun Class Init ▁( ▁a ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁if ▁( ▁JavaVersion Util ▁. ▁JAVA _ SPEC ▁<= ▁8 ▁) ▁{ ▁if ▁( ▁is Pos ix ▁( ▁) ▁) ▁{ ▁r erun Class Init ▁( ▁a ▁, ▁STR ▁) ▁; ▁} ▁} ▁else ▁{ ▁r erun Class Init ▁( ▁a ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁} ▁if ▁( ▁JavaVersion Util ▁. ▁JAVA _ SPEC ▁>= ▁15 ▁) ▁{ ▁r erun Class Init ▁( ▁a ▁, ▁STR ▁) ▁; ▁} ▁if ▁( ▁JavaVersion Util ▁. ▁JAVA _ SPEC ▁>= ▁16 ▁) ▁{ ▁r erun Class Init ▁( ▁a ▁, ▁STR ▁) ▁; ▁} ▁r erun Class Init ▁( ▁a ▁, ▁STR ▁, ▁STR ▁) ▁; ▁} ▁}
▁final ▁class ▁E arly Class Initializer Analysis ▁{ ▁private ▁final ▁Configurable Class Initialization ▁class Initialization Support ▁; ▁private ▁final ▁Providers ▁original Providers ▁; ▁private ▁final ▁High TierContext ▁context ▁; ▁E arly Class Initializer Analysis ▁( ▁Configurable Class Initialization ▁class Initialization Support ▁) ▁{ ▁this ▁. ▁class Initialization Support ▁= ▁class Initialization Support ▁; ▁original Providers ▁= ▁Graal Access ▁. ▁getOriginal Providers ▁( ▁) ▁; ▁context ▁= ▁new ▁High TierContext ▁( ▁original Providers ▁, ▁null ▁, ▁Optim istic Optim izations ▁. ▁NONE ▁) ▁; ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁boolean ▁can Initialize Without SideEffect s ▁( ▁Class ▁< ▁? ▁> ▁clazz ▁, ▁Set ▁< ▁Class ▁< ▁? ▁> ▁> ▁existing Analyz ed Classes ▁) ▁{ ▁ResolvedJava Type ▁type ▁= ▁original Providers ▁. ▁getMetaAccess ▁( ▁) ▁. ▁lookupJavaType ▁( ▁clazz ▁) ▁; ▁assert ▁type ▁. ▁getSuperclass ▁( ▁) ▁== ▁null ▁|| ▁type ▁. ▁getSuperclass ▁( ▁) ▁. ▁isInitialized ▁( ▁) ▁: ▁STR ▁+ ▁type ▁. ▁toJava Name ▁( ▁true ▁) ▁; ▁ResolvedJava Method ▁cl init ▁= ▁type ▁. ▁getClass Initializer ▁( ▁) ▁; ▁if ▁( ▁cl init ▁== ▁null ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁if ▁( ▁cl init ▁. ▁getCode ▁( ▁) ▁== ▁null ▁) ▁{ ▁return ▁false ▁; ▁} ▁Set ▁< ▁Class ▁< ▁? ▁> ▁> ▁analy z ed Classes ▁= ▁existing Analyz ed Classes ▁; ▁if ▁( ▁analy z ed Classes ▁== ▁null ▁) ▁{ ▁analy z ed Classes ▁= ▁new ▁HashSet ▁< ▁> ▁( ▁) ▁; ▁} ▁else ▁if ▁( ▁analy z ed Classes ▁. ▁contains ▁( ▁clazz ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁analy z ed Classes ▁. ▁add ▁( ▁clazz ▁) ▁; ▁OptionValues ▁options ▁= ▁Hosted Option Values ▁. ▁singleton ▁( ▁) ▁; ▁DebugContext ▁debug ▁= ▁new ▁Builder ▁( ▁options ▁) ▁. ▁build ▁( ▁) ▁; ▁try ▁( ▁DebugContext ▁. ▁Scope ▁s ▁= ▁debug ▁. ▁scope ▁( ▁STR ▁, ▁cl init ▁) ▁) ▁{ ▁return ▁can Initialize Without SideEffect s ▁( ▁cl init ▁, ▁analy z ed Classes ▁, ▁options ▁, ▁debug ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁ex ▁) ▁{ ▁throw ▁debug ▁. ▁handle ▁( ▁ex ▁) ▁; ▁} ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁private ▁boolean ▁can Initialize Without SideEffect s ▁( ▁ResolvedJava Method ▁cl init ▁, ▁Set ▁< ▁Class ▁< ▁? ▁> ▁> ▁analy z ed Classes ▁, ▁OptionValues ▁options ▁, ▁DebugContext ▁debug ▁) ▁{ ▁Invocation Plugins ▁invocation Plugins ▁= ▁new ▁Invocation Plugins ▁( ▁) ▁; ▁P lugins ▁plugins ▁= ▁new ▁P lugins ▁( ▁invocation Plugins ▁) ▁; ▁plugins ▁. ▁append Inline Invoke Plugin ▁( ▁new ▁Ab ort On Recursive Inlining Plugin ▁( ▁) ▁) ▁; ▁Ab ort On Unit ialized Class Plugin ▁class Initialization Plugin ▁= ▁new ▁Ab ort On Unit ialized Class Plugin ▁( ▁analy z ed Classes ▁) ▁; ▁plugins ▁. ▁setClass Initialization Plugin ▁( ▁class Initialization Plugin ▁) ▁; ▁plugins ▁. ▁append Node Plugin ▁( ▁new ▁E arly Constant Fold Load Field Plugin ▁( ▁original Providers ▁. ▁getMetaAccess ▁( ▁) ▁, ▁original Providers ▁. ▁getS nippet Reflection ▁( ▁) ▁) ▁) ▁;
▁private ▁void ▁initialize Options ▁( ▁) ▁{ ▁ToolOptions ▁options ▁= ▁tool ▁. ▁getOptions ▁( ▁Listing Code Comparison Options ▁. ▁OPTION S _ CATEGORY _ NAME ▁) ▁; ▁options ▁. ▁add Options ChangeListener ▁( ▁this ▁) ▁; ▁comp arison Options ▁. ▁initialize Options ▁( ▁options ▁) ▁; ▁comp arison Options ▁. ▁load Options ▁( ▁options ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁options Changed ▁( ▁ToolOptions ▁options ▁, ▁String ▁option Name ▁, ▁Object ▁oldValue ▁, ▁Object ▁newValue ▁) ▁{ ▁comp arison Options ▁. ▁load Options ▁( ▁options ▁) ▁; ▁rep aint ▁( ▁) ▁; ▁if ▁( ▁program s ▁[ ▁LEFT ▁] ▁== ▁null ▁) ▁{ ▁return ▁; ▁} ▁Color ▁un matched Code Units BackgroundColor ▁= ▁comp arison Options ▁. ▁getUn matched Code Units BackgroundColor ▁( ▁) ▁; ▁un matched Code Markers ▁[ ▁LEFT ▁] ▁. ▁set Marker Color ▁( ▁un matched Code Units BackgroundColor ▁) ▁; ▁un matched Code Markers ▁[ ▁RIGHT ▁] ▁. ▁set Marker Color ▁( ▁un matched Code Units BackgroundColor ▁) ▁; ▁Color ▁diff Code Units BackgroundColor ▁= ▁comp arison Options ▁. ▁get Diff Code Units BackgroundColor ▁( ▁) ▁; ▁diff Markers ▁[ ▁LEFT ▁] ▁. ▁set Marker Color ▁( ▁diff Code Units BackgroundColor ▁) ▁; ▁diff Markers ▁[ ▁RIGHT ▁] ▁. ▁set Marker Color ▁( ▁diff Code Units BackgroundColor ▁) ▁; ▁marker Managers ▁[ ▁LEFT ▁] ▁. ▁set Program ▁( ▁getLeft Program ▁( ▁) ▁) ▁; ▁marker Managers ▁[ ▁RIGHT ▁] ▁. ▁set Program ▁( ▁getRight Program ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁JComponent ▁getComponent ▁( ▁) ▁{ ▁return ▁this ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getTitle ▁( ▁) ▁{ ▁return ▁T ITLE ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setVisible ▁( ▁boolean ▁a Flag ▁) ▁{ ▁super ▁. ▁setVisible ▁( ▁a Flag ▁) ▁; ▁update Action Enablement ▁( ▁) ▁; ▁} ▁private ▁Format Manager ▁create Format Manager ▁( ▁int ▁left Or Right ▁) ▁{ ▁ToolOptions ▁display Options ▁= ▁tool ▁. ▁getOptions ▁( ▁Ghidra Options ▁. ▁CATEG ORY _ B ROWSER _ DI SPLAY ▁) ▁; ▁ToolOptions ▁field Options ▁= ▁tool ▁. ▁getOptions ▁( ▁Ghidra Options ▁. ▁CATEG ORY _ B ROWSER _ FI ELDS ▁) ▁; ▁Format Manager ▁format Manager ▁= ▁new ▁Format Manager ▁( ▁display Options ▁, ▁field Options ▁) ▁; ▁ServiceProvider Decorator ▁sp ▁= ▁ServiceProvider Decorator ▁. ▁createEmpty Decorator ▁( ▁) ▁; ▁sp ▁. ▁override Service ▁( ▁GoTo Service ▁. ▁class ▁, ▁d ual Listing Service Providers ▁[ ▁left Or Right ▁] ▁. ▁getService ▁( ▁GoTo Service ▁. ▁class ▁) ▁) ▁; ▁format Manager ▁. ▁setService Provider ▁( ▁sp ▁) ▁; ▁if ▁( ▁field Options ▁. ▁isRegistered ▁( ▁Ghidra Options ▁. ▁HIGH LI GHT _ CUR S OR _ LINE _ COLOR ▁) ▁) ▁{ ▁cursor Highlight Color ▁= ▁field Options ▁. ▁getColor ▁( ▁Ghidra Options ▁. ▁HIGH LI GHT _ CUR S OR _ LINE _ COLOR ▁, ▁C UR S OR _ LINE _ COLOR ▁) ▁; ▁} ▁else ▁{ ▁cursor Highlight Color ▁= ▁C UR S OR _ LINE _ COLOR ▁; ▁} ▁return ▁format Manager ▁; ▁}
▁public ▁class ▁ClassPath FileSystem Watcher ▁implements ▁Initializing Bean ▁, ▁Disposable Bean ▁, ▁Application Context Aware ▁{ ▁private ▁final ▁FileSystem Watcher ▁fileSystem Watcher ▁; ▁private ▁ClassPath Restart Strategy ▁restart Strategy ▁; ▁private ▁Application Context ▁application Context ▁; ▁private ▁boolean ▁stop Watcher On Restart ▁; ▁public ▁ClassPath FileSystem Watcher ▁( ▁FileSystem Watcher Factory ▁fileSystem Watcher Factory ▁, ▁ClassPath Restart Strategy ▁restart Strategy ▁, ▁URL ▁[ ▁] ▁urls ▁) ▁{ ▁Assert ▁. ▁notNull ▁( ▁fileSystem Watcher Factory ▁, ▁STR ▁) ▁; ▁Assert ▁. ▁notNull ▁( ▁urls ▁, ▁STR ▁) ▁; ▁this ▁. ▁fileSystem Watcher ▁= ▁fileSystem Watcher Factory ▁. ▁getFileSystem Watcher ▁( ▁) ▁; ▁this ▁. ▁restart Strategy ▁= ▁restart Strategy ▁; ▁this ▁. ▁fileSystem Watcher ▁. ▁addSource Directories ▁( ▁new ▁ClassPath Directories ▁( ▁urls ▁) ▁) ▁; ▁} ▁public ▁void ▁set Stop Watcher On Restart ▁( ▁boolean ▁stop Watcher On Restart ▁) ▁{ ▁this ▁. ▁stop Watcher On Restart ▁= ▁stop Watcher On Restart ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setApplication Context ▁( ▁Application Context ▁application Context ▁) ▁throws ▁BeansException ▁{ ▁this ▁. ▁application Context ▁= ▁application Context ▁; ▁} ▁@ ▁Override ▁public ▁void ▁after PropertiesSet ▁( ▁) ▁throws ▁Exception ▁{ ▁if ▁( ▁this ▁. ▁restart Strategy ▁!= ▁null ▁) ▁{ ▁FileSystem Watcher ▁watcher To Stop ▁= ▁null ▁; ▁if ▁( ▁this ▁. ▁stop Watcher On Restart ▁) ▁{ ▁watcher To Stop ▁= ▁this ▁. ▁fileSystem Watcher ▁; ▁} ▁this ▁. ▁fileSystem Watcher ▁. ▁addListener ▁( ▁new ▁ClassPath File ChangeListener ▁( ▁this ▁. ▁application Context ▁, ▁this ▁. ▁restart Strategy ▁, ▁watcher To Stop ▁) ▁) ▁; ▁} ▁this ▁. ▁fileSystem Watcher ▁. ▁start ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁destroy ▁( ▁) ▁throws ▁Exception ▁{ ▁this ▁. ▁fileSystem Watcher ▁. ▁stop ▁( ▁) ▁; ▁} ▁}
▁if ▁( ▁add Another Context ▁) ▁{ ▁source ▁. ▁field ▁( ▁STR ▁, ▁STR ▁+ ▁i ▁ % ▁3 ▁) ▁; ▁} ▁source ▁. ▁endObject ▁( ▁) ▁; ▁index RequestBuilder s ▁. ▁add ▁( ▁client ▁( ▁) ▁. ▁prepareIndex ▁( ▁INDEX ▁) ▁. ▁setId ▁( ▁STR ▁+ ▁i ▁) ▁. ▁setSource ▁( ▁source ▁) ▁) ▁; ▁} ▁index Random ▁( ▁true ▁, ▁index RequestBuilder s ▁) ▁; ▁Completion Suggestion Builder ▁prefix ▁= ▁S uggest Builders ▁. ▁completion Suggestion ▁( ▁FIELD ▁) ▁. ▁prefix ▁( ▁STR ▁, ▁F uzz iness ▁. ▁ONE ▁) ▁. ▁contexts ▁( ▁Collections ▁. ▁singletonMap ▁( ▁STR ▁, ▁Collections ▁. ▁singletonList ▁( ▁Category Query Context ▁. ▁builder ▁( ▁) ▁. ▁setCategory ▁( ▁STR ▁) ▁. ▁set Prefix ▁( ▁true ▁) ▁. ▁build ▁( ▁) ▁) ▁) ▁) ▁; ▁assert S uggest ions ▁( ▁STR ▁, ▁prefix ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁; ▁} ▁public ▁void ▁testContext Filtering Work sWith UTF 8 Categ ories ▁( ▁) ▁throws ▁Exception ▁{ ▁Category Context Mapping ▁context Mapping ▁= ▁Context Builder ▁. ▁category ▁( ▁STR ▁) ▁. ▁field ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁; ▁LinkedHashMap ▁< ▁String ▁, ▁Context Mapping ▁< ▁? ▁> ▁> ▁map ▁= ▁new ▁LinkedHashMap ▁< ▁> ▁( ▁Collections ▁. ▁singletonMap ▁( ▁STR ▁, ▁context Mapping ▁) ▁) ▁; ▁final ▁Completion Mapping Builder ▁mapping ▁= ▁new ▁Completion Mapping Builder ▁( ▁) ▁. ▁context ▁( ▁map ▁) ▁; ▁createIndex And Mapping ▁( ▁mapping ▁) ▁; ▁Index Response ▁index Response ▁= ▁client ▁( ▁) ▁. ▁prepareIndex ▁( ▁INDEX ▁) ▁. ▁setId ▁( ▁STR ▁) ▁. ▁setSource ▁( ▁jsonBuilder ▁( ▁) ▁. ▁startObject ▁( ▁) ▁. ▁startObject ▁( ▁FIELD ▁) ▁. ▁field ▁( ▁STR ▁, ▁STR ▁) ▁. ▁endObject ▁( ▁) ▁. ▁field ▁( ▁STR ▁, ▁STR ▁) ▁. ▁endObject ▁( ▁) ▁) ▁. ▁get ▁( ▁) ▁; ▁assertThat ▁( ▁index Response ▁. ▁status ▁( ▁) ▁, ▁equalTo ▁( ▁RestStatus ▁. ▁CREATED ▁) ▁) ▁; ▁assertNo Failures ▁( ▁client ▁( ▁) ▁. ▁admin ▁( ▁) ▁. ▁indices ▁( ▁) ▁. ▁prepare Refresh ▁( ▁INDEX ▁) ▁. ▁get ▁( ▁) ▁) ▁; ▁Completion Suggestion Builder ▁context S uggest Query ▁= ▁S uggest Builders ▁. ▁completion Suggestion ▁( ▁FIELD ▁) ▁. ▁prefix ▁( ▁STR ▁) ▁. ▁contexts ▁( ▁Collections ▁. ▁singletonMap ▁( ▁STR ▁, ▁Collections ▁. ▁singletonList ▁( ▁Category Query Context ▁. ▁builder ▁( ▁) ▁. ▁setCategory ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁) ▁) ▁) ▁; ▁assert S uggest ions ▁( ▁STR ▁, ▁context S uggest Query ▁, ▁STR ▁) ▁; ▁} ▁public ▁void ▁test Single Context Filtering ▁( ▁) ▁throws ▁Exception ▁{ ▁Category Context Mapping ▁context Mapping ▁= ▁Context Builder ▁. ▁category ▁( ▁STR ▁) ▁. ▁field ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁; ▁LinkedHashMap ▁< ▁String ▁, ▁Context Mapping ▁< ▁? ▁> ▁> ▁map ▁= ▁new ▁LinkedHashMap ▁< ▁> ▁( ▁Collections ▁. ▁singletonMap ▁( ▁STR ▁, ▁context Mapping ▁) ▁) ▁; ▁final ▁Completion Mapping Builder ▁mapping ▁= ▁new ▁Completion Mapping Builder ▁( ▁) ▁. ▁context ▁( ▁map ▁) ▁; ▁createIndex And Mapping ▁( ▁mapping ▁) ▁;
▁public ▁class ▁Router Factory $ Adapt ive ▁implements ▁org ▁. ▁apache ▁. ▁dubbo ▁. ▁rpc ▁. ▁cluster ▁. ▁Router Factory ▁{ ▁public ▁org ▁. ▁apache ▁. ▁dubbo ▁. ▁rpc ▁. ▁cluster ▁. ▁Router ▁getRout er ▁( ▁org ▁. ▁apache ▁. ▁dubbo ▁. ▁common ▁. ▁URL ▁arg 0 ▁) ▁{ ▁if ▁( ▁arg 0 ▁== ▁null ▁) ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁org ▁. ▁apache ▁. ▁dubbo ▁. ▁common ▁. ▁URL ▁url ▁= ▁arg 0 ▁; ▁String ▁ext Name ▁= ▁( ▁url ▁. ▁getProtocol ▁( ▁) ▁== ▁null ▁? ▁STR ▁: ▁url ▁. ▁getProtocol ▁( ▁) ▁) ▁; ▁if ▁( ▁ext Name ▁== ▁null ▁) ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁+ ▁url ▁. ▁toString ▁( ▁) ▁+ ▁STR ▁) ▁; ▁org ▁. ▁apache ▁. ▁dubbo ▁. ▁rpc ▁. ▁cluster ▁. ▁Router Factory ▁extension ▁= ▁( ▁org ▁. ▁apache ▁. ▁dubbo ▁. ▁rpc ▁. ▁cluster ▁. ▁Router Factory ▁) ▁ExtensionLoader ▁. ▁getExtension Loader ▁( ▁org ▁. ▁apache ▁. ▁dubbo ▁. ▁rpc ▁. ▁cluster ▁. ▁Router Factory ▁. ▁class ▁) ▁. ▁getExtension ▁( ▁ext Name ▁) ▁; ▁return ▁extension ▁. ▁getRout er ▁( ▁arg 0 ▁) ▁; ▁} ▁}
▁public ▁class ▁Test Enum ▁extends ▁AbstractTest ▁{ ▁public ▁enum ▁Direction ▁{ ▁N OR TH ▁, ▁S OU TH ▁, ▁E AST ▁, ▁W EST ▁} ▁public ▁static ▁final ▁String ▁D OG ▁= ▁STR ▁; ▁public ▁enum ▁Animal ▁{ ▁CAT ▁, ▁D OG ▁} ▁private ▁static ▁int ▁th ree ▁= ▁3 ▁; ▁public ▁enum ▁Num bers ▁{ ▁ONE ▁( ▁1 ▁) ▁, ▁TWO ▁( ▁2 ▁) ▁, ▁TH REE ▁( ▁th ree ▁) ▁, ▁F OUR ▁( ▁th ree ▁+ ▁1 ▁) ▁; ▁private ▁final ▁int ▁num ▁; ▁private ▁Num bers ▁( ▁int ▁n ▁) ▁{ ▁this ▁. ▁num ▁= ▁n ▁; ▁} ▁public ▁int ▁getNum ▁( ▁) ▁{ ▁return ▁num ▁; ▁} ▁} ▁public ▁enum ▁Operation ▁{ ▁P LU S ▁{ ▁@ ▁Override ▁int ▁apply ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁return ▁x ▁+ ▁y ▁; ▁} ▁} ▁, ▁MIN US ▁{ ▁@ ▁Override ▁int ▁apply ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁{ ▁return ▁x ▁- ▁y ▁; ▁} ▁} ▁; ▁abstract ▁int ▁apply ▁( ▁int ▁x ▁, ▁int ▁y ▁) ▁; ▁} ▁public ▁interface ▁IO ps ▁{ ▁double ▁apply ▁( ▁double ▁x ▁, ▁double ▁y ▁) ▁; ▁} ▁public ▁enum ▁Double Operations ▁implements ▁IO ps ▁{ ▁TIME S ▁( ▁STR ▁) ▁{ ▁@ ▁Override ▁public ▁double ▁apply ▁( ▁double ▁x ▁, ▁double ▁y ▁) ▁{ ▁return ▁x ▁ * ▁y ▁; ▁} ▁} ▁, ▁DI VID E ▁( ▁STR ▁) ▁{ ▁@ ▁Override ▁public ▁double ▁apply ▁( ▁double ▁x ▁, ▁double ▁y ▁) ▁{ ▁return ▁x ▁ / ▁y ▁; ▁} ▁} ▁; ▁private ▁final ▁String ▁op ▁; ▁private ▁Double Operations ▁( ▁String ▁op ▁) ▁{ ▁this ▁. ▁op ▁= ▁op ▁; ▁} ▁public ▁String ▁getOp ▁( ▁) ▁{ ▁return ▁op ▁; ▁} ▁} ▁public ▁enum ▁Types ▁{ ▁INT ▁, ▁FLOAT ▁, ▁LONG ▁, ▁DOUBLE ▁, ▁OBJECT ▁, ▁ARRAY ▁; ▁private ▁static ▁Set ▁< ▁Types ▁> ▁p rimitives ▁= ▁EnumSet ▁. ▁of ▁( ▁INT ▁, ▁FLOAT ▁, ▁LONG ▁, ▁DOUBLE ▁) ▁; ▁public ▁static ▁List ▁< ▁Types ▁> ▁references ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁static ▁{ ▁references ▁. ▁add ▁( ▁OBJECT ▁) ▁; ▁references ▁. ▁add ▁( ▁ARRAY ▁) ▁; ▁} ▁public ▁static ▁Set ▁< ▁Types ▁> ▁getP rimitives ▁( ▁) ▁{ ▁return ▁p rimitives ▁; ▁} ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁enum ▁Empty Enum ▁{ ▁; ▁public ▁static ▁String ▁getOp ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁} ▁public ▁enum ▁Singleton ▁{ ▁INSTANCE ▁; ▁public ▁String ▁test ▁( ▁String ▁arg ▁) ▁{ ▁return ▁arg ▁. ▁concat ▁( ▁STR ▁) ▁; ▁} ▁} ▁public ▁String ▁test Enum Switch ▁( ▁final ▁Direction ▁color ▁) ▁{ ▁String ▁d ▁; ▁switch ▁( ▁color ▁) ▁{ ▁case ▁N OR TH ▁: ▁d ▁= ▁STR ▁; ▁break ▁; ▁case ▁S OU TH ▁: ▁d ▁= ▁STR ▁; ▁break ▁; ▁default ▁: ▁d ▁= ▁STR ▁; ▁break ▁; ▁} ▁return ▁d ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁testRun ▁( ▁) ▁throws ▁Exception ▁{ ▁Direction ▁d ▁= ▁Direction ▁. ▁E AST ▁; ▁assertTrue ▁( ▁d ▁. ▁toString ▁( ▁) ▁. ▁equals ▁( ▁STR ▁) ▁) ▁;
▁public ▁class ▁Basic Enrich Tests ▁extends ▁E SS ingle Node TestCase ▁{ ▁static ▁final ▁String ▁SOURCE _ INDEX _ NAME ▁= ▁STR ▁; ▁static ▁final ▁String ▁MATCH _ FIELD ▁= ▁STR ▁; ▁static ▁final ▁String ▁[ ▁] ▁DE C OR ATE _ FI ELDS ▁= ▁new ▁String ▁[ ▁] ▁{ ▁STR ▁, ▁STR ▁, ▁STR ▁} ▁; ▁@ ▁Override ▁protected ▁Collection ▁< ▁Class ▁< ▁? ▁extends ▁Plugin ▁> ▁> ▁getPlugins ▁( ▁) ▁{ ▁return ▁Arrays ▁. ▁asList ▁( ▁Local State Enrich ▁. ▁class ▁, ▁Re index Plugin ▁. ▁class ▁, ▁Ingest Common Plugin ▁. ▁class ▁, ▁Mustache Plugin ▁. ▁class ▁, ▁Geo Plugin ▁. ▁class ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁boolean ▁reset Node After Test ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁public ▁void ▁test In gest Data With Match Processor ▁( ▁) ▁{ ▁int ▁num Docs ▁= ▁32 ▁; ▁int ▁max Matches ▁= ▁randomInt Between ▁( ▁2 ▁, ▁8 ▁) ▁; ▁List ▁< ▁String ▁> ▁keys ▁= ▁create Source Match Index ▁( ▁num Docs ▁, ▁max Matches ▁) ▁; ▁String ▁policy Name ▁= ▁STR ▁; ▁Enrich Policy ▁en rich Policy ▁= ▁new ▁Enrich Policy ▁( ▁Enrich Policy ▁. ▁MATCH _ TYPE ▁, ▁null ▁, ▁List ▁. ▁of ▁( ▁SOURCE _ INDEX _ NAME ▁) ▁, ▁MATCH _ FIELD ▁, ▁List ▁. ▁of ▁( ▁DE C OR ATE _ FI ELDS ▁) ▁) ▁; ▁Put Enrich PolicyAction ▁. ▁Request ▁request ▁= ▁new ▁Put Enrich PolicyAction ▁. ▁Request ▁( ▁policy Name ▁, ▁en rich Policy ▁) ▁; ▁client ▁( ▁) ▁. ▁execute ▁( ▁Put Enrich PolicyAction ▁. ▁INSTANCE ▁, ▁request ▁) ▁. ▁actionGet ▁( ▁) ▁; ▁client ▁( ▁) ▁. ▁execute ▁( ▁Execute Enrich PolicyAction ▁. ▁INSTANCE ▁, ▁new ▁Execute Enrich PolicyAction ▁. ▁Request ▁( ▁policy Name ▁) ▁) ▁. ▁actionGet ▁( ▁) ▁; ▁String ▁pipeline Name ▁= ▁STR ▁; ▁String ▁pipeline Body ▁= ▁STR ▁+ ▁policy Name ▁+ ▁STR ▁+ ▁MATCH _ FIELD ▁+ ▁STR ▁+ ▁max Matches ▁+ ▁STR ▁; ▁Put PipelineRequest ▁put PipelineRequest ▁= ▁new ▁Put PipelineRequest ▁( ▁pipeline Name ▁, ▁new ▁BytesArray ▁( ▁pipeline Body ▁) ▁, ▁XContentType ▁. ▁JSON ▁) ▁; ▁client ▁( ▁) ▁. ▁admin ▁( ▁) ▁. ▁cluster ▁( ▁) ▁. ▁put Pipeline ▁( ▁put PipelineRequest ▁) ▁. ▁actionGet ▁( ▁) ▁; ▁Bulk Request ▁bulk Request ▁= ▁new ▁Bulk Request ▁( ▁STR ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁num Docs ▁; ▁i ▁++ ▁) ▁{ ▁IndexRequest ▁index Request ▁= ▁new ▁IndexRequest ▁( ▁) ▁; ▁index Request ▁. ▁id ▁( ▁Integer ▁. ▁toString ▁( ▁i ▁) ▁) ▁; ▁index Request ▁. ▁set Pipeline ▁( ▁pipeline Name ▁) ▁; ▁index Request ▁. ▁source ▁( ▁Map ▁. ▁of ▁( ▁MATCH _ FIELD ▁, ▁keys ▁. ▁get ▁( ▁i ▁) ▁) ▁) ▁; ▁bulk Request ▁. ▁add ▁( ▁index Request ▁) ▁; ▁} ▁Bulk Response ▁bulk Response ▁= ▁client ▁( ▁) ▁. ▁bulk ▁( ▁bulk Request ▁) ▁. ▁actionGet ▁( ▁) ▁; ▁assertThat ▁( ▁STR ▁+ ▁bulk Response ▁. ▁build Failure Message ▁( ▁) ▁, ▁bulk Response ▁. ▁has Failures ▁( ▁) ▁, ▁is ▁( ▁false ▁) ▁) ▁;
▁public ▁class ▁Dubbo Config BeanDefinition Conflict Application Listener ▁implements ▁Application Listener ▁< ▁Context Refresh ed Event ▁> ▁, ▁Ordered ▁{ ▁private ▁final ▁Logger ▁logger ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁getClass ▁( ▁) ▁) ▁; ▁@ ▁Override ▁public ▁void ▁on ApplicationEvent ▁( ▁Context Refresh ed Event ▁event ▁) ▁{ ▁Application Context ▁application Context ▁= ▁event ▁. ▁getApplication Context ▁( ▁) ▁; ▁BeanDefinition Registry ▁registry ▁= ▁getBean Definition Registry ▁( ▁application Context ▁) ▁; ▁resolve Unique Application Config Bean ▁( ▁registry ▁, ▁application Context ▁) ▁; ▁} ▁private ▁BeanDefinition Registry ▁getBean Definition Registry ▁( ▁Application Context ▁application Context ▁) ▁{ ▁Aut owire Cap ableBeanFactory ▁beanFactory ▁= ▁application Context ▁. ▁getA ut owire Cap ableBeanFactory ▁( ▁) ▁; ▁if ▁( ▁beanFactory ▁instanceof ▁BeanDefinition Registry ▁) ▁{ ▁return ▁( ▁BeanDefinition Registry ▁) ▁beanFactory ▁; ▁} ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁} ▁private ▁void ▁resolve Unique Application Config Bean ▁( ▁BeanDefinition Registry ▁registry ▁, ▁List ableBeanFactory ▁beanFactory ▁) ▁{ ▁String ▁[ ▁] ▁beans Names ▁= ▁bean Names ForType In cluding Ance stors ▁( ▁beanFactory ▁, ▁Application Config ▁. ▁class ▁) ▁; ▁if ▁( ▁beans Names ▁. ▁length ▁< ▁2 ▁) ▁{ ▁return ▁; ▁} ▁Environment ▁environment ▁= ▁beanFactory ▁. ▁getBean ▁( ▁EN VI RON MENT _ BEAN _ NAME ▁, ▁Environment ▁. ▁class ▁) ▁; ▁Stream ▁. ▁of ▁( ▁beans Names ▁) ▁. ▁filter ▁( ▁beans Name ▁-> ▁is Configured Application Config BeanName ▁( ▁environment ▁, ▁beans Name ▁) ▁) ▁. ▁forEach ▁( ▁registry ▁:: ▁remove BeanDefinition ▁) ▁; ▁beans Names ▁= ▁bean Names ForType In cluding Ance stors ▁( ▁beanFactory ▁, ▁Application Config ▁. ▁class ▁) ▁; ▁if ▁( ▁beans Names ▁. ▁length ▁> ▁1 ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁String ▁. ▁format ▁( ▁STR ▁, ▁Application Config ▁. ▁class ▁. ▁getSimpleName ▁( ▁) ▁, ▁Stream ▁. ▁of ▁( ▁beans Names ▁) ▁. ▁map ▁( ▁registry ▁:: ▁getBean Definition ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toList ▁( ▁) ▁) ▁) ▁) ▁; ▁} ▁} ▁private ▁boolean ▁is Configured Application Config BeanName ▁( ▁Environment ▁environment ▁, ▁String ▁beanName ▁) ▁{ ▁boolean ▁removed ▁= ▁BeanFactory Utils ▁. ▁is Generated BeanName ▁( ▁beanName ▁) ▁|| ▁Objects ▁. ▁equals ▁( ▁beanName ▁, ▁environment ▁. ▁getProperty ▁( ▁STR ▁) ▁) ▁; ▁if ▁( ▁removed ▁) ▁{ ▁if ▁( ▁logger ▁. ▁isDebugEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁debug ▁( ▁STR ▁, ▁Application Config ▁. ▁class ▁. ▁getSimpleName ▁( ▁) ▁, ▁beanName ▁) ▁; ▁} ▁} ▁return ▁removed ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getOrder ▁( ▁) ▁{ ▁return ▁LOWEST _ PRECEDENCE ▁; ▁} ▁}
▁protected ▁void ▁set Fetch Size ▁( ▁Statement ▁stmt ▁) ▁throws ▁SQLException ▁{ ▁Integer ▁fetch Size ▁= ▁mapped Statement ▁. ▁getF etch Size ▁( ▁) ▁; ▁if ▁( ▁fetch Size ▁!= ▁null ▁) ▁{ ▁stmt ▁. ▁set Fetch Size ▁( ▁fetch Size ▁) ▁; ▁return ▁; ▁} ▁Integer ▁default Fetch Size ▁= ▁configuration ▁. ▁getDefault Fetch Size ▁( ▁) ▁; ▁if ▁( ▁default Fetch Size ▁!= ▁null ▁) ▁{ ▁stmt ▁. ▁set Fetch Size ▁( ▁default Fetch Size ▁) ▁; ▁} ▁} ▁protected ▁void ▁close Statement ▁( ▁Statement ▁statement ▁) ▁{ ▁try ▁{ ▁if ▁( ▁statement ▁!= ▁null ▁) ▁{ ▁statement ▁. ▁close ▁( ▁) ▁; ▁} ▁} ▁catch ▁( ▁SQLException ▁e ▁) ▁{ ▁} ▁} ▁protected ▁void ▁generate Keys ▁( ▁Object ▁parameter ▁) ▁{ ▁Key Generator ▁key Generator ▁= ▁mapped Statement ▁. ▁getKey Generator ▁( ▁) ▁; ▁Error Context ▁. ▁instance ▁( ▁) ▁. ▁store ▁( ▁) ▁; ▁key Generator ▁. ▁process Before ▁( ▁executor ▁, ▁mapped Statement ▁, ▁null ▁, ▁parameter ▁) ▁; ▁Error Context ▁. ▁instance ▁( ▁) ▁. ▁rec all ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁Fake AttributeMapper ▁implements ▁Attribute Map ▁{ ▁private ▁final ▁Map ▁< ▁String ▁, ▁Fake AttributeMapper Entry ▁< ▁? ▁> ▁> ▁attrs ▁; ▁private ▁Fake AttributeMapper ▁( ▁Map ▁< ▁String ▁, ▁Fake AttributeMapper Entry ▁< ▁? ▁> ▁> ▁attrs ▁) ▁{ ▁this ▁. ▁attrs ▁= ▁ImmutableMap ▁. ▁copyOf ▁( ▁attrs ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁Label ▁getLabel ▁( ▁) ▁{ ▁return ▁Label ▁. ▁parseAbsolute Unchecked ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getRule ClassName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁has ▁( ▁String ▁attr Name ▁) ▁{ ▁return ▁attrs ▁. ▁containsKey ▁( ▁attr Name ▁) ▁; ▁} ▁@ ▁Override ▁public ▁< ▁T ▁> ▁boolean ▁has ▁( ▁String ▁attr Name ▁, ▁Type ▁< ▁T ▁> ▁type ▁) ▁{ ▁Fake AttributeMapper Entry ▁< ▁? ▁> ▁entry ▁= ▁attrs ▁. ▁get ▁( ▁attr Name ▁) ▁; ▁if ▁( ▁entry ▁== ▁null ▁) ▁{ ▁return ▁false ▁; ▁} ▁return ▁entry ▁. ▁type ▁. ▁equals ▁( ▁type ▁) ▁; ▁} ▁@ ▁Override ▁@ ▁Nullable ▁public ▁< ▁T ▁> ▁T ▁get ▁( ▁String ▁attributeName ▁, ▁Type ▁< ▁T ▁> ▁type ▁) ▁{ ▁Fake AttributeMapper Entry ▁< ▁? ▁> ▁entry ▁= ▁attrs ▁. ▁get ▁( ▁attributeName ▁) ▁; ▁if ▁( ▁entry ▁== ▁null ▁) ▁{ ▁assert WithMessage ▁( ▁STR ▁+ ▁attributeName ▁+ ▁STR ▁) ▁. ▁fail ▁( ▁) ▁; ▁return ▁null ▁; ▁} ▁return ▁entry ▁. ▁validate AndGet ▁( ▁type ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is Configur able ▁( ▁String ▁attributeName ▁) ▁{ ▁return ▁false ▁; ▁} ▁@ ▁Override ▁public ▁Iterable ▁< ▁String ▁> ▁getAttribute Names ▁( ▁) ▁{ ▁return ▁attrs ▁. ▁keySet ▁( ▁) ▁; ▁} ▁@ ▁Nullable ▁@ ▁Override ▁public ▁Type ▁< ▁? ▁> ▁getAttribute Type ▁( ▁String ▁attr Name ▁) ▁{ ▁Fake AttributeMapper Entry ▁< ▁? ▁> ▁entry ▁= ▁attrs ▁. ▁get ▁( ▁attr Name ▁) ▁; ▁return ▁entry ▁== ▁null ▁? ▁null ▁: ▁entry ▁. ▁type ▁; ▁} ▁@ ▁Nullable ▁@ ▁Override ▁public ▁Attribute ▁getAttribute Definition ▁( ▁String ▁attr Name ▁) ▁{ ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is AttributeValue Explicit ly Specified ▁( ▁String ▁attributeName ▁) ▁{ ▁return ▁attrs ▁. ▁containsKey ▁( ▁attributeName ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁visit All Labels ▁( ▁BiConsumer ▁< ▁Attribute ▁, ▁Label ▁> ▁consumer ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁visit Labels ▁( ▁Attribute ▁attribute ▁, ▁Consumer ▁< ▁Label ▁> ▁consumer ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁visit Labels ▁( ▁Dependency Filter ▁filter ▁, ▁BiConsumer ▁< ▁Attribute ▁, ▁Label ▁> ▁consumer ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁String ▁getPackage Default Hdr s Check ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁Boolean ▁getPackage Default Test Only ▁( ▁) ▁{ ▁return ▁false ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getPackage Default Deprecation ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁ImmutableList ▁< ▁String ▁> ▁getPackage Default Co pt s ▁( ▁) ▁{ ▁return ▁ImmutableList ▁. ▁of ▁( ▁) ▁; ▁} ▁public ▁static ▁Fake AttributeMapper ▁empty ▁( ▁) ▁{ ▁return ▁builder ▁( ▁) ▁. ▁build ▁( ▁) ▁;
▁public ▁class ▁Oracle CreateTableTest 22 ▁extends ▁OracleTest ▁{ ▁public ▁void ▁test _ types ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁sql ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁; ▁Oracle StatementParser ▁parser ▁= ▁new ▁Oracle StatementParser ▁( ▁sql ▁) ▁; ▁List ▁< ▁SQLStatement ▁> ▁statementList ▁= ▁parser ▁. ▁parseStatement List ▁( ▁) ▁; ▁SQLStatement ▁stmt ▁= ▁statementList ▁. ▁get ▁( ▁0 ▁) ▁; ▁print ▁( ▁statementList ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁1 ▁, ▁statementList ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁, ▁SQLUtils ▁. ▁toSQLString ▁( ▁stmt ▁, ▁JdbcConstants ▁. ▁ORACLE ▁) ▁) ▁; ▁OracleSchema StatVisitor ▁visitor ▁= ▁new ▁OracleSchema StatVisitor ▁( ▁) ▁; ▁stmt ▁. ▁accept ▁( ▁visitor ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁visitor ▁. ▁getTables ▁( ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁visitor ▁. ▁getColumns ▁( ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁visitor ▁. ▁getConditions ▁( ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁visitor ▁. ▁getRe lationships ▁( ▁) ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁visitor ▁. ▁getOrderBy Columns ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁1 ▁, ▁visitor ▁. ▁getTables ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁6 ▁, ▁visitor ▁. ▁getColumns ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁visitor ▁. ▁getColumns ▁( ▁) ▁. ▁contains ▁( ▁new ▁TableStat ▁. ▁Column ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁; ▁} ▁}
▁public ▁static ▁boolean ▁test Double Array With PE AS nippet 0 ▁( ▁) ▁{ ▁return ▁Arrays ▁. ▁equals ▁( ▁new ▁double ▁[ ▁] ▁{ ▁0.0 d ▁} ▁, ▁new ▁double ▁[ ▁] ▁{ ▁- ▁0.0 d ▁} ▁) ▁; ▁} ▁public ▁static ▁boolean ▁test Double Array With PE AS nippet 1 ▁( ▁) ▁{ ▁return ▁Arrays ▁. ▁equals ▁( ▁new ▁double ▁[ ▁] ▁{ ▁Double ▁. ▁long BitsTo Double ▁( ▁0 x 7 ff 8 00000000 0000 L ▁) ▁} ▁, ▁new ▁double ▁[ ▁] ▁{ ▁Double ▁. ▁long BitsTo Double ▁( ▁0 x 7 ff 8 00000000 0000 L ▁) ▁} ▁) ▁; ▁} ▁public ▁static ▁boolean ▁test Double Array With PE AS nippet 2 ▁( ▁) ▁{ ▁return ▁Arrays ▁. ▁equals ▁( ▁new ▁double ▁[ ▁] ▁{ ▁Double ▁. ▁long BitsTo Double ▁( ▁0 x 7 ff 8 00000000 0000 L ▁) ▁} ▁, ▁new ▁double ▁[ ▁] ▁{ ▁Double ▁. ▁long BitsTo Double ▁( ▁0 x 7 ff 00000000 0000 1 L ▁) ▁} ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Double Array With PE A ▁( ▁) ▁{ ▁test ▁( ▁STR ▁) ▁; ▁test ▁( ▁STR ▁) ▁; ▁test ▁( ▁STR ▁) ▁; ▁} ▁public ▁static ▁final ▁float ▁[ ▁] ▁FLOAT _ ARRAY 1 ▁= ▁new ▁float ▁[ ▁] ▁{ ▁0.0 f ▁} ▁; ▁public ▁static ▁final ▁float ▁[ ▁] ▁FLOAT _ ARRAY 2 ▁= ▁new ▁float ▁[ ▁] ▁{ ▁- ▁0.0 f ▁} ▁; ▁public ▁static ▁final ▁float ▁[ ▁] ▁FLOAT _ ARRAY 3 ▁= ▁new ▁float ▁[ ▁] ▁{ ▁Float ▁. ▁int BitsTo Float ▁( ▁0 x 7 fc 00000 ▁) ▁} ▁; ▁public ▁static ▁final ▁float ▁[ ▁] ▁FLOAT _ ARRAY 4 ▁= ▁new ▁float ▁[ ▁] ▁{ ▁Float ▁. ▁int BitsTo Float ▁( ▁0 x 7 f 8 0000 1 ▁) ▁} ▁; ▁public ▁static ▁final ▁double ▁[ ▁] ▁DOUBLE _ ARRAY 1 ▁= ▁new ▁double ▁[ ▁] ▁{ ▁0.0 d ▁} ▁; ▁public ▁static ▁final ▁double ▁[ ▁] ▁DOUBLE _ ARRAY 2 ▁= ▁new ▁double ▁[ ▁] ▁{ ▁- ▁0.0 d ▁} ▁; ▁public ▁static ▁final ▁double ▁[ ▁] ▁DOUBLE _ ARRAY 3 ▁= ▁new ▁double ▁[ ▁] ▁{ ▁Double ▁. ▁long BitsTo Double ▁( ▁0 x 7 ff 8 00000000 0000 L ▁) ▁} ▁; ▁public ▁static ▁final ▁double ▁[ ▁] ▁DOUBLE _ ARRAY 4 ▁= ▁new ▁double ▁[ ▁] ▁{ ▁Double ▁. ▁long BitsTo Double ▁( ▁0 x 7 ff 00000000 0000 1 L ▁) ▁} ▁; ▁public ▁static ▁boolean ▁test Stable Float Array Snippet 0 ▁( ▁) ▁{ ▁return ▁Arrays ▁. ▁equals ▁( ▁FLOAT _ ARRAY 1 ▁, ▁FLOAT _ ARRAY 2 ▁) ▁; ▁} ▁public ▁static ▁boolean ▁test Stable Float Array Snippet 1 ▁( ▁) ▁{ ▁return ▁Arrays ▁. ▁equals ▁( ▁FLOAT _ ARRAY 1 ▁, ▁FLOAT _ ARRAY 2 ▁) ▁; ▁} ▁public ▁static ▁boolean ▁test Stable Double Array Snippet 0 ▁( ▁) ▁{ ▁return ▁Arrays ▁. ▁equals ▁( ▁DOUBLE _ ARRAY 1 ▁, ▁DOUBLE _ ARRAY 2 ▁) ▁; ▁}
▁public ▁class ▁Remove From ClusterNode Labels ResponsePBImpl ▁extends ▁Remove From ClusterNode Labels Response ▁{ ▁Remove From ClusterNode Labels ResponseProto ▁proto ▁= ▁Remove From ClusterNode Labels ResponseProto ▁. ▁getDefault Instance ▁( ▁) ▁; ▁Remove From ClusterNode Labels ResponseProto ▁. ▁Builder ▁builder ▁= ▁null ▁; ▁boolean ▁viaProto ▁= ▁false ▁; ▁public ▁Remove From ClusterNode Labels ResponsePBImpl ▁( ▁) ▁{ ▁builder ▁= ▁Remove From ClusterNode Labels ResponseProto ▁. ▁newBuilder ▁( ▁) ▁; ▁} ▁public ▁Remove From ClusterNode Labels ResponsePBImpl ▁( ▁Remove From ClusterNode Labels ResponseProto ▁proto ▁) ▁{ ▁this ▁. ▁proto ▁= ▁proto ▁; ▁viaProto ▁= ▁true ▁; ▁} ▁public ▁Remove From ClusterNode Labels ResponseProto ▁getProto ▁( ▁) ▁{ ▁proto ▁= ▁viaProto ▁? ▁proto ▁: ▁builder ▁. ▁build ▁( ▁) ▁; ▁viaProto ▁= ▁true ▁; ▁return ▁proto ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁getProto ▁( ▁) ▁. ▁hashCode ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁other ▁) ▁{ ▁if ▁( ▁other ▁== ▁null ▁) ▁return ▁false ▁; ▁if ▁( ▁other ▁. ▁getClass ▁( ▁) ▁. ▁isAssignable From ▁( ▁this ▁. ▁getClass ▁( ▁) ▁) ▁) ▁{ ▁return ▁this ▁. ▁getProto ▁( ▁) ▁. ▁equals ▁( ▁this ▁. ▁getClass ▁( ▁) ▁. ▁cast ▁( ▁other ▁) ▁. ▁getProto ▁( ▁) ▁) ▁; ▁} ▁return ▁false ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁TextFormat ▁. ▁short DebugString ▁( ▁getProto ▁( ▁) ▁) ▁; ▁} ▁}
▁for ▁( ▁int ▁i ▁= ▁CONTENT _ LENGTH ▁; ▁i ▁> ▁1 ▁; ▁i ▁-- ▁) ▁{ ▁Http Content ▁c ▁= ▁channel ▁. ▁readInbound ▁( ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁c ▁. ▁content ▁( ▁) ▁. ▁readableBytes ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁content ▁[ ▁content ▁. ▁length ▁- ▁i ▁] ▁, ▁c ▁. ▁content ▁( ▁) ▁. ▁readByte ▁( ▁) ▁) ▁; ▁c ▁. ▁release ▁( ▁) ▁; ▁} ▁Last Http Content ▁c ▁= ▁channel ▁. ▁readInbound ▁( ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁c ▁. ▁content ▁( ▁) ▁. ▁readableBytes ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁content ▁[ ▁content ▁. ▁length ▁- ▁1 ▁] ▁, ▁c ▁. ▁content ▁( ▁) ▁. ▁readByte ▁( ▁) ▁) ▁; ▁c ▁. ▁release ▁( ▁) ▁; ▁assertFalse ▁( ▁channel ▁. ▁finish ▁( ▁) ▁) ▁; ▁assertNull ▁( ▁channel ▁. ▁readInbound ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Multi Line Header ▁( ▁) ▁{ ▁EmbeddedChannel ▁channel ▁= ▁new ▁EmbeddedChannel ▁( ▁new ▁HttpRequest Decoder ▁( ▁) ▁) ▁; ▁String ▁c rl f ▁= ▁STR ▁; ▁String ▁request ▁= ▁STR ▁+ ▁c rl f ▁+ ▁STR ▁+ ▁c rl f ▁+ ▁STR ▁+ ▁c rl f ▁+ ▁STR ▁+ ▁c rl f ▁+ ▁STR ▁+ ▁c rl f ▁+ ▁STR ▁+ ▁c rl f ▁+ ▁c rl f ▁; ▁assertTrue ▁( ▁channel ▁. ▁writeInbound ▁( ▁Unpooled ▁. ▁copied Buffer ▁( ▁request ▁, ▁CharsetUtil ▁. ▁US _ ASCII ▁) ▁) ▁) ▁; ▁HttpRequest ▁req ▁= ▁channel ▁. ▁readInbound ▁( ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁req ▁. ▁headers ▁( ▁) ▁. ▁get ▁( ▁of ▁( ▁STR ▁) ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁req ▁. ▁headers ▁( ▁) ▁. ▁get ▁( ▁of ▁( ▁STR ▁) ▁) ▁) ▁; ▁Last Http Content ▁c ▁= ▁channel ▁. ▁readInbound ▁( ▁) ▁; ▁c ▁. ▁release ▁( ▁) ▁; ▁assertFalse ▁( ▁channel ▁. ▁finish ▁( ▁) ▁) ▁; ▁assertNull ▁( ▁channel ▁. ▁readInbound ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testEmpty HeaderValue ▁( ▁) ▁{ ▁EmbeddedChannel ▁channel ▁= ▁new ▁EmbeddedChannel ▁( ▁new ▁HttpRequest Decoder ▁( ▁) ▁) ▁; ▁String ▁c rl f ▁= ▁STR ▁; ▁String ▁request ▁= ▁STR ▁+ ▁c rl f ▁+ ▁STR ▁+ ▁c rl f ▁+ ▁STR ▁+ ▁c rl f ▁+ ▁c rl f ▁; ▁channel ▁. ▁writeInbound ▁( ▁Unpooled ▁. ▁copied Buffer ▁( ▁request ▁, ▁CharsetUtil ▁. ▁US _ ASCII ▁) ▁) ▁; ▁HttpRequest ▁req ▁= ▁channel ▁. ▁readInbound ▁( ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁req ▁. ▁headers ▁( ▁) ▁. ▁get ▁( ▁of ▁( ▁STR ▁) ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test 100 Continue ▁( ▁) ▁{ ▁HttpRequest Decoder ▁decoder ▁= ▁new ▁HttpRequest Decoder ▁( ▁) ▁; ▁EmbeddedChannel ▁channel ▁= ▁new ▁EmbeddedChannel ▁( ▁decoder ▁) ▁; ▁String ▁over s ized ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁; ▁channel ▁. ▁writeInbound ▁( ▁Unpooled ▁. ▁copied Buffer ▁( ▁over s ized ▁, ▁CharsetUtil ▁. ▁US _ ASCII ▁) ▁) ▁; ▁assertThat ▁( ▁channel ▁. ▁readInbound ▁( ▁) ▁, ▁is ▁( ▁instanceOf ▁( ▁HttpRequest ▁. ▁class ▁) ▁) ▁) ▁;
▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁class ▁Scope Legacy Test ▁extends ▁Abstract Par amet riz ed Library Test ▁{ ▁@ ▁Parameterized ▁. ▁Parameters ▁( ▁name ▁= ▁STR ▁) ▁public ▁static ▁List ▁< ▁Test Run ▁> ▁data ▁( ▁) ▁{ ▁return ▁Arrays ▁. ▁asList ▁( ▁Test Run ▁. ▁C A CHED ▁, ▁Test Run ▁. ▁UN CA CHED ▁, ▁Test Run ▁. ▁DI SP ATCH ED _ CA CHED ▁, ▁Test Run ▁. ▁DI SP ATCH ED _ UN CA CHED ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Receiver ▁( ▁) ▁throws ▁Exception ▁{ ▁setup Scope s ▁( ▁com ▁. ▁oracle ▁. ▁truffle ▁. ▁api ▁. ▁Scope ▁. ▁newBuilder ▁( ▁STR ▁, ▁create Variables ▁( ▁) ▁) ▁. ▁receiver ▁( ▁STR ▁, ▁42 ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁Node ▁location ▁= ▁new ▁S coped View Legacy Test ▁. ▁Test Instrument able Node ▁( ▁) ▁; ▁S coped View Legacy Test ▁. ▁Test RootNode ▁root ▁= ▁create Root ▁( ▁language ▁) ▁; ▁root ▁. ▁set Child ▁( ▁location ▁) ▁; ▁Node Library ▁node Library ▁= ▁create Library ▁( ▁Node Library ▁. ▁class ▁, ▁location ▁) ▁; ▁assertTrue ▁( ▁node Library ▁. ▁has Receiver Member ▁( ▁location ▁, ▁null ▁) ▁) ▁; ▁Object ▁receiver Member ▁= ▁node Library ▁. ▁getRe ceiver Member ▁( ▁location ▁, ▁null ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁InteropLibrary ▁. ▁getUncached ▁( ▁) ▁. ▁asString ▁( ▁receiver Member ▁) ▁) ▁; ▁Object ▁scope ▁= ▁node Library ▁. ▁getScope ▁( ▁location ▁, ▁null ▁, ▁true ▁) ▁; ▁check Scope ▁( ▁scope ▁, ▁STR ▁, ▁STR ▁, ▁42 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Variables ▁( ▁) ▁throws ▁Exception ▁{ ▁setup Scope s ▁( ▁com ▁. ▁oracle ▁. ▁truffle ▁. ▁api ▁. ▁Scope ▁. ▁newBuilder ▁( ▁STR ▁, ▁create Variables ▁( ▁STR ▁, ▁10 ▁, ▁STR ▁, ▁11 ▁) ▁) ▁. ▁build ▁( ▁) ▁, ▁com ▁. ▁oracle ▁. ▁truffle ▁. ▁api ▁. ▁Scope ▁. ▁newBuilder ▁( ▁STR ▁, ▁create Variables ▁( ▁STR ▁, ▁20 ▁, ▁STR ▁, ▁21 ▁) ▁) ▁. ▁build ▁( ▁) ▁, ▁com ▁. ▁oracle ▁. ▁truffle ▁. ▁api ▁. ▁Scope ▁. ▁newBuilder ▁( ▁STR ▁, ▁create Variables ▁( ▁STR ▁, ▁30 ▁, ▁STR ▁, ▁31 ▁, ▁STR ▁, ▁32 ▁) ▁) ▁. ▁build ▁( ▁) ▁, ▁com ▁. ▁oracle ▁. ▁truffle ▁. ▁api ▁. ▁Scope ▁. ▁newBuilder ▁( ▁STR ▁, ▁create Variables ▁( ▁STR ▁, ▁40 ▁, ▁STR ▁, ▁41 ▁) ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁Node ▁location ▁= ▁new ▁S coped View Legacy Test ▁. ▁Test Instrument able Node ▁( ▁) ▁; ▁S coped View Legacy Test ▁. ▁Test RootNode ▁root ▁= ▁create Root ▁( ▁language ▁) ▁; ▁root ▁. ▁set Child ▁( ▁location ▁) ▁; ▁Node Library ▁node Library ▁= ▁create Library ▁( ▁Node Library ▁. ▁class ▁, ▁location ▁) ▁; ▁Object ▁scope ▁= ▁node Library ▁. ▁getScope ▁( ▁location ▁, ▁null ▁, ▁true ▁) ▁;
▁public ▁class ▁Simple Entity Content Provider ▁extends ▁Content Provider ▁{ ▁public ▁static ▁final ▁String ▁AUTH ORITY ▁= ▁STR ▁; ▁public ▁static ▁final ▁String ▁BASE _ PATH ▁= ▁STR ▁; ▁public ▁static ▁final ▁Uri ▁CONTENT _ URI ▁= ▁Uri ▁. ▁parse ▁( ▁STR ▁+ ▁AUTH ORITY ▁+ ▁STR ▁+ ▁BASE _ PATH ▁) ▁; ▁public ▁static ▁final ▁String ▁CONTENT _ TYPE ▁= ▁Content Resolver ▁. ▁C UR S OR _ DIR _ BASE _ TYPE ▁+ ▁STR ▁+ ▁BASE _ PATH ▁; ▁public ▁static ▁final ▁String ▁CONTENT _ ITEM _ TYPE ▁= ▁Content Resolver ▁. ▁C UR S OR _ ITEM _ BASE _ TYPE ▁+ ▁STR ▁+ ▁BASE _ PATH ▁; ▁private ▁static ▁final ▁String ▁TABLE NAME ▁= ▁Simple EntityDao ▁. ▁TABLE NAME ▁; ▁private ▁static ▁final ▁String ▁P K ▁= ▁Simple EntityDao ▁. ▁Properties ▁. ▁Id ▁. ▁columnName ▁; ▁private ▁static ▁final ▁int ▁SIMPLE ENT ITY _ DIR ▁= ▁0 ▁; ▁private ▁static ▁final ▁int ▁SIMPLE ENT ITY _ ID ▁= ▁1 ▁; ▁private ▁static ▁final ▁Uri Matcher ▁s URI Matcher ▁; ▁static ▁{ ▁s URI Matcher ▁= ▁new ▁Uri Matcher ▁( ▁Uri Matcher ▁. ▁NO _ MATCH ▁) ▁; ▁s URI Matcher ▁. ▁add URI ▁( ▁AUTH ORITY ▁, ▁BASE _ PATH ▁, ▁SIMPLE ENT ITY _ DIR ▁) ▁; ▁s URI Matcher ▁. ▁add URI ▁( ▁AUTH ORITY ▁, ▁BASE _ PATH ▁+ ▁STR ▁, ▁SIMPLE ENT ITY _ ID ▁) ▁; ▁} ▁public ▁static ▁Dao Session ▁dao Session ▁; ▁@ ▁Override ▁public ▁boolean ▁onCreate ▁( ▁) ▁{ ▁Dao Log ▁. ▁d ▁( ▁STR ▁+ ▁CONTENT _ URI ▁) ▁; ▁return ▁true ▁; ▁} ▁protected ▁Database ▁getDatabase ▁( ▁) ▁{ ▁if ▁( ▁dao Session ▁== ▁null ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁} ▁return ▁dao Session ▁. ▁getDatabase ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Uri ▁insert ▁( ▁Uri ▁uri ▁, ▁Content Values ▁values ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁delete ▁( ▁Uri ▁uri ▁, ▁String ▁selection ▁, ▁String ▁[ ▁] ▁selection Args ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁update ▁( ▁Uri ▁uri ▁, ▁Content Values ▁values ▁, ▁String ▁selection ▁, ▁String ▁[ ▁] ▁selection Args ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Cursor ▁query ▁( ▁Uri ▁uri ▁, ▁String ▁[ ▁] ▁projection ▁, ▁String ▁selection ▁, ▁String ▁[ ▁] ▁selection Args ▁, ▁String ▁sortOrder ▁) ▁{ ▁SQLite QueryBuilder ▁queryBuilder ▁= ▁new ▁SQLite QueryBuilder ▁( ▁) ▁; ▁int ▁uri Type ▁= ▁s URI Matcher ▁. ▁match ▁( ▁uri ▁) ▁; ▁switch ▁( ▁uri Type ▁) ▁{ ▁case ▁SIMPLE ENT ITY _ DIR ▁: ▁queryBuilder ▁. ▁set Tables ▁( ▁TABLE NAME ▁) ▁; ▁break ▁; ▁case ▁SIMPLE ENT ITY _ ID ▁: ▁queryBuilder ▁. ▁set Tables ▁( ▁TABLE NAME ▁) ▁; ▁queryBuilder ▁. ▁append Where ▁( ▁P K ▁+ ▁STR ▁+ ▁uri ▁. ▁getLast Path Segment ▁( ▁) ▁) ▁; ▁break ▁; ▁default ▁: ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁uri ▁) ▁; ▁}
▁public ▁abstract ▁class ▁Base IntegrationTest ▁{ ▁protected ▁static ▁final ▁int ▁PORT ▁= ▁find Free Port ▁( ▁) ▁; ▁private ▁Server ▁server ▁; ▁protected ▁Server ▁startServer With Handlers ▁( ▁Context Handler ▁... ▁handlers ▁) ▁throws ▁Exception ▁{ ▁server ▁= ▁new ▁Server ▁( ▁PORT ▁) ▁; ▁Context Handler Collection ▁contexts ▁= ▁new ▁Context Handler Collection ▁( ▁) ▁; ▁contexts ▁. ▁set Handlers ▁( ▁handlers ▁) ▁; ▁server ▁. ▁set Handler ▁( ▁contexts ▁) ▁; ▁server ▁. ▁start ▁( ▁) ▁; ▁return ▁server ▁; ▁} ▁@ ▁After ▁public ▁void ▁tearDown ▁( ▁) ▁throws ▁Exception ▁{ ▁if ▁( ▁server ▁!= ▁null ▁&& ▁server ▁. ▁is Started ▁( ▁) ▁) ▁{ ▁server ▁. ▁stop ▁( ▁) ▁; ▁} ▁} ▁Context Handler ▁mock ServerHandler ▁( ▁final ▁int ▁statusCode ▁, ▁final ▁String ▁response ▁) ▁{ ▁Context Handler ▁context ▁= ▁new ▁Context Handler ▁( ▁STR ▁) ▁; ▁context ▁. ▁set Handler ▁( ▁new ▁Abstract Handler ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁handle ▁( ▁String ▁target ▁, ▁Request ▁base Request ▁, ▁HttpServlet Request ▁request ▁, ▁HttpServlet Response ▁response ▁) ▁throws ▁IOException ▁, ▁Servlet Exception ▁{ ▁response ▁. ▁setContentType ▁( ▁STR ▁) ▁; ▁response ▁. ▁setStatus ▁( ▁statusCode ▁) ▁; ▁response ▁. ▁getWriter ▁( ▁) ▁. ▁println ▁( ▁response ▁) ▁; ▁base Request ▁. ▁set Handled ▁( ▁true ▁) ▁; ▁} ▁} ▁) ▁; ▁return ▁context ▁; ▁} ▁static ▁int ▁find Free Port ▁( ▁) ▁{ ▁ServerSocket ▁socket ▁= ▁null ▁; ▁try ▁{ ▁socket ▁= ▁new ▁ServerSocket ▁( ▁0 ▁) ▁; ▁socket ▁. ▁setRe use Address ▁( ▁true ▁) ▁; ▁int ▁port ▁= ▁socket ▁. ▁getLocal Port ▁( ▁) ▁; ▁try ▁{ ▁socket ▁. ▁close ▁( ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁} ▁return ▁port ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁} ▁finally ▁{ ▁if ▁( ▁socket ▁!= ▁null ▁) ▁{ ▁try ▁{ ▁socket ▁. ▁close ▁( ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁} ▁} ▁} ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁} ▁}
▁public ▁abstract ▁class ▁Str ength en Graph s ▁extends ▁Abstract Analysis Results Builder ▁{ ▁public ▁Str ength en Graph s ▁( ▁BigBang ▁bb ▁, ▁Un iverse ▁converter ▁) ▁{ ▁super ▁( ▁bb ▁, ▁converter ▁) ▁; ▁} ▁@ ▁Override ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁Static Analysis Results ▁make Or Apply Results ▁( ▁AnalysisMethod ▁method ▁) ▁{ ▁StructuredGraph ▁graph ▁= ▁method ▁. ▁get Analyz ed Graph ▁( ▁) ▁; ▁if ▁( ▁graph ▁!= ▁null ▁) ▁{ ▁DebugContext ▁debug ▁= ▁new ▁DebugContext ▁. ▁Builder ▁( ▁bb ▁. ▁getOptions ▁( ▁) ▁, ▁new ▁Graal Debug Handlers Factory ▁( ▁bb ▁. ▁get Providers ▁( ▁) ▁. ▁getS nippet Reflection ▁( ▁) ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁graph ▁. ▁reset Debug ▁( ▁debug ▁) ▁; ▁try ▁( ▁DebugContext ▁. ▁Scope ▁s ▁= ▁debug ▁. ▁scope ▁( ▁STR ▁, ▁graph ▁) ▁; ▁DebugContext ▁. ▁Activation ▁a ▁= ▁debug ▁. ▁activate ▁( ▁) ▁) ▁{ ▁Canonicalizer Phase ▁. ▁create ▁( ▁) ▁. ▁copy With Custom S impl ification ▁( ▁new ▁Str ength en S impl ifier ▁( ▁method ▁, ▁graph ▁) ▁) ▁. ▁apply ▁( ▁graph ▁, ▁bb ▁. ▁get Providers ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁ex ▁) ▁{ ▁debug ▁. ▁handle ▁( ▁ex ▁) ▁; ▁} ▁} ▁return ▁Static Analysis Results ▁. ▁NO _ RESULT S ▁; ▁} ▁@ ▁Override ▁public ▁JavaType Profile ▁make Type Profile ▁( ▁Analysis Field ▁field ▁) ▁{ ▁return ▁null ▁; ▁} ▁protected ▁abstract ▁Analysis Type ▁getSingle Implementor Type ▁( ▁Analysis Type ▁original Type ▁) ▁; ▁protected ▁abstract ▁Analysis Type ▁getStr ength en Stamp Type ▁( ▁Analysis Type ▁original Type ▁) ▁; ▁protected ▁abstract ▁FixedNode ▁createUn re achable ▁( ▁StructuredGraph ▁graph ▁, ▁CoreProviders ▁providers ▁, ▁Supplier ▁< ▁String ▁> ▁message ▁) ▁; ▁protected ▁abstract ▁void ▁set Invoke Profiles ▁( ▁Invoke ▁invoke ▁, ▁JavaType Profile ▁type Profile ▁, ▁Java Method Profile ▁method Profile ▁) ▁; ▁class ▁Str ength en S impl ifier ▁implements ▁Custom S impl ification ▁{ ▁private ▁final ▁StructuredGraph ▁graph ▁; ▁private ▁final ▁Method TypeFlow ▁method Flow ▁; ▁private ▁final ▁Method Flows Graph ▁original Flows ▁; ▁private ▁final ▁Node Bit Map ▁created P i Nodes ▁; ▁Str ength en S impl ifier ▁( ▁AnalysisMethod ▁method ▁, ▁StructuredGraph ▁graph ▁) ▁{ ▁this ▁. ▁graph ▁= ▁graph ▁; ▁this ▁. ▁method Flow ▁= ▁method ▁. ▁getType Flow ▁( ▁) ▁; ▁this ▁. ▁original Flows ▁= ▁method Flow ▁. ▁getOriginal Method Flows ▁( ▁) ▁; ▁this ▁. ▁created P i Nodes ▁= ▁new ▁Node Bit Map ▁( ▁graph ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁s impl ify ▁( ▁Node ▁n ▁, ▁Simpl ifier Tool ▁tool ▁) ▁{ ▁if ▁( ▁n ▁instanceof ▁ValueNode ▁&& ▁! ▁( ▁n ▁instanceof ▁Limited Value Proxy ▁) ▁&& ▁! ▁( ▁n ▁instanceof ▁Ph i Node ▁) ▁) ▁{ ▁ValueNode ▁node ▁= ▁( ▁ValueNode ▁) ▁n ▁; ▁node ▁. ▁infer Stamp ▁( ▁) ▁; ▁update Stamp In Place ▁( ▁node ▁, ▁str ength en Stamp ▁( ▁node ▁. ▁stamp ▁( ▁NodeView ▁. ▁DEFAULT ▁) ▁) ▁, ▁tool ▁) ▁; ▁}
▁@ ▁Configuration ▁( ▁proxyBean Methods ▁= ▁false ▁) ▁@ ▁ConditionalOn Class ▁( ▁{ ▁Spring Component Provider ▁. ▁class ▁, ▁Servlet Registration ▁. ▁class ▁} ▁) ▁@ ▁ConditionalOn Bean ▁( ▁type ▁= ▁STR ▁) ▁@ ▁ConditionalOn WebApplication ▁( ▁type ▁= ▁Type ▁. ▁SER V LET ▁) ▁@ ▁AutoConfigure Order ▁( ▁Ordered ▁. ▁HIGH EST _ PRECEDENCE ▁) ▁@ ▁AutoConfigure Before ▁( ▁Dispatcher Servlet Auto Configuration ▁. ▁class ▁) ▁@ ▁AutoConfigure After ▁( ▁Jackson Auto Configuration ▁. ▁class ▁) ▁@ ▁Enable Configuration Properties ▁( ▁Jersey Properties ▁. ▁class ▁) ▁public ▁class ▁Jersey Auto Configuration ▁implements ▁ServletContext Aware ▁{ ▁private ▁static ▁final ▁Log ▁logger ▁= ▁LogFactory ▁. ▁getLog ▁( ▁Jersey Auto Configuration ▁. ▁class ▁) ▁; ▁private ▁final ▁Jersey Properties ▁j ersey ▁; ▁private ▁final ▁Resource Config ▁config ▁; ▁public ▁Jersey Auto Configuration ▁( ▁Jersey Properties ▁j ersey ▁, ▁Resource Config ▁config ▁, ▁ObjectProvider ▁< ▁Resource Config Customizer ▁> ▁customizers ▁) ▁{ ▁this ▁. ▁j ersey ▁= ▁j ersey ▁; ▁this ▁. ▁config ▁= ▁config ▁; ▁customizers ▁. ▁ordered Stream ▁( ▁) ▁. ▁forEach ▁( ▁( ▁customizer ▁) ▁-> ▁customizer ▁. ▁customize ▁( ▁this ▁. ▁config ▁) ▁) ▁; ▁} ▁@ ▁Bean ▁@ ▁ConditionalOn Missing Filter Bean ▁( ▁RequestContext Filter ▁. ▁class ▁) ▁public ▁Filter RegistrationBean ▁< ▁RequestContext Filter ▁> ▁request Context Filter ▁( ▁) ▁{ ▁Filter RegistrationBean ▁< ▁RequestContext Filter ▁> ▁registration ▁= ▁new ▁Filter RegistrationBean ▁< ▁> ▁( ▁) ▁; ▁registration ▁. ▁setFilter ▁( ▁new ▁RequestContext Filter ▁( ▁) ▁) ▁; ▁registration ▁. ▁setOrder ▁( ▁this ▁. ▁j ersey ▁. ▁getFilter ▁( ▁) ▁. ▁getOrder ▁( ▁) ▁- ▁1 ▁) ▁; ▁registration ▁. ▁setName ▁( ▁STR ▁) ▁; ▁return ▁registration ▁; ▁} ▁@ ▁Bean ▁@ ▁ConditionalOn MissingBean ▁public ▁Jersey Application Path ▁j ersey Application Path ▁( ▁) ▁{ ▁return ▁new ▁Default J ersey Application Path ▁( ▁this ▁. ▁j ersey ▁. ▁getApplication Path ▁( ▁) ▁, ▁this ▁. ▁config ▁) ▁; ▁} ▁@ ▁Bean ▁@ ▁ConditionalOn MissingBean ▁( ▁name ▁= ▁STR ▁) ▁@ ▁ConditionalOn Property ▁( ▁prefix ▁= ▁STR ▁, ▁name ▁= ▁STR ▁, ▁having Value ▁= ▁STR ▁) ▁public ▁Filter RegistrationBean ▁< ▁Servlet Container ▁> ▁j ersey Filter Registration ▁( ▁Jersey Application Path ▁application Path ▁) ▁{ ▁Filter RegistrationBean ▁< ▁Servlet Container ▁> ▁registration ▁= ▁new ▁Filter RegistrationBean ▁< ▁> ▁( ▁) ▁; ▁registration ▁. ▁setFilter ▁( ▁new ▁Servlet Container ▁( ▁this ▁. ▁config ▁) ▁) ▁; ▁registration ▁. ▁setUrl Patterns ▁( ▁Collections ▁. ▁singletonList ▁( ▁application Path ▁. ▁getUrl Mapping ▁( ▁) ▁) ▁) ▁; ▁registration ▁. ▁setOrder ▁( ▁this ▁. ▁j ersey ▁. ▁getFilter ▁( ▁) ▁. ▁getOrder ▁( ▁) ▁) ▁; ▁registration ▁. ▁add Init Parameter ▁( ▁Servlet Properties ▁. ▁FILTER _ CONTEXT _ PATH ▁, ▁strip Pattern ▁( ▁application Path ▁. ▁getPath ▁( ▁) ▁) ▁) ▁; ▁add Init Parameters ▁( ▁registration ▁) ▁; ▁registration ▁. ▁setName ▁( ▁STR ▁) ▁; ▁registration ▁. ▁set Dispatcher Types ▁( ▁EnumSet ▁. ▁allOf ▁( ▁Dispatcher Type ▁. ▁class ▁) ▁) ▁; ▁return ▁registration ▁; ▁}
▁try ▁{ ▁addInput Sorted ▁( ▁new ▁Un iform Record Generator ▁( ▁key Cnt 1 ▁, ▁val Cnt 1 ▁, ▁false ▁) ▁, ▁this ▁. ▁comparator 1 ▁. ▁duplicate ▁( ▁) ▁) ▁; ▁addInput Sorted ▁( ▁new ▁Un iform Record Generator ▁( ▁key Cnt 2 ▁, ▁val Cnt 2 ▁, ▁false ▁) ▁, ▁this ▁. ▁comparator 2 ▁. ▁duplicate ▁( ▁) ▁) ▁; ▁test Driver ▁( ▁test Task ▁, ▁Mock Match Stub ▁. ▁class ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁e ▁. ▁printStackTrace ▁( ▁) ▁; ▁Assert ▁. ▁fail ▁( ▁STR ▁) ▁; ▁} ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁exp Cnt ▁, ▁this ▁. ▁output ▁. ▁getNumberOf Records ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test External Hash 1 Match Task ▁( ▁) ▁{ ▁final ▁int ▁key Cnt 1 ▁= ▁32 76 8 ▁; ▁final ▁int ▁val Cnt 1 ▁= ▁8 ▁; ▁final ▁int ▁key Cnt 2 ▁= ▁655 36 ▁; ▁final ▁int ▁val Cnt 2 ▁= ▁8 ▁; ▁final ▁int ▁exp Cnt ▁= ▁val Cnt 1 ▁ * ▁val Cnt 2 ▁ * ▁Math ▁. ▁min ▁( ▁key Cnt 1 ▁, ▁key Cnt 2 ▁) ▁; ▁addInput ▁( ▁new ▁Un iform Record Generator ▁( ▁key Cnt 1 ▁, ▁val Cnt 1 ▁, ▁false ▁) ▁) ▁; ▁addInput ▁( ▁new ▁Un iform Record Generator ▁( ▁key Cnt 2 ▁, ▁val Cnt 2 ▁, ▁false ▁) ▁) ▁; ▁add Driver Comparator ▁( ▁this ▁. ▁comparator 1 ▁) ▁; ▁add Driver Comparator ▁( ▁this ▁. ▁comparator 2 ▁) ▁; ▁getTask Config ▁( ▁) ▁. ▁setDriver Pair Comparator ▁( ▁Record Pair Comparator Factory ▁. ▁get ▁( ▁) ▁) ▁; ▁setOutput ▁( ▁this ▁. ▁output ▁) ▁; ▁getTask Config ▁( ▁) ▁. ▁setDriver Strategy ▁( ▁DriverStrategy ▁. ▁H Y BR ID HASH _ BU ILD _ FIRST ▁) ▁; ▁getTask Config ▁( ▁) ▁. ▁set Relative Memory Driver ▁( ▁hash _ f rac ▁) ▁; ▁Join Driver ▁< ▁Record ▁, ▁Record ▁, ▁Record ▁> ▁test Task ▁= ▁new ▁Join Driver ▁< ▁> ▁( ▁) ▁; ▁try ▁{ ▁test Driver ▁( ▁test Task ▁, ▁Mock Match Stub ▁. ▁class ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁e ▁. ▁printStackTrace ▁( ▁) ▁; ▁Assert ▁. ▁fail ▁( ▁STR ▁) ▁; ▁} ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁exp Cnt ▁, ▁this ▁. ▁output ▁. ▁getNumberOf Records ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test External Hash 2 Match Task ▁( ▁) ▁{ ▁final ▁int ▁key Cnt 1 ▁= ▁32 76 8 ▁; ▁final ▁int ▁val Cnt 1 ▁= ▁8 ▁; ▁final ▁int ▁key Cnt 2 ▁= ▁655 36 ▁; ▁final ▁int ▁val Cnt 2 ▁= ▁8 ▁; ▁final ▁int ▁exp Cnt ▁= ▁val Cnt 1 ▁ * ▁val Cnt 2 ▁ * ▁Math ▁. ▁min ▁( ▁key Cnt 1 ▁, ▁key Cnt 2 ▁) ▁; ▁addInput ▁( ▁new ▁Un iform Record Generator ▁( ▁key Cnt 1 ▁, ▁val Cnt 1 ▁, ▁false ▁) ▁) ▁; ▁addInput ▁( ▁new ▁Un iform Record Generator ▁( ▁key Cnt 2 ▁, ▁val Cnt 2 ▁, ▁false ▁) ▁) ▁;
▁else ▁{ ▁dispose Inner ▁( ▁) ▁; ▁errors ▁. ▁try Terminate Consumer ▁( ▁downstream ▁) ▁; ▁} ▁} ▁} ▁@ ▁Override ▁public ▁void ▁onComplete ▁( ▁) ▁{ ▁done ▁= ▁true ▁; ▁if ▁( ▁inner ▁. ▁get ▁( ▁) ▁== ▁null ▁) ▁{ ▁errors ▁. ▁try Terminate Consumer ▁( ▁downstream ▁) ▁; ▁} ▁} ▁void ▁dispose Inner ▁( ▁) ▁{ ▁Switch Map Inner Observer ▁o ▁= ▁inner ▁. ▁getAndSet ▁( ▁IN NER _ DIS PO SED ▁) ▁; ▁if ▁( ▁o ▁!= ▁null ▁&& ▁o ▁!= ▁IN NER _ DIS PO SED ▁) ▁{ ▁o ▁. ▁dispose ▁( ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁dispose ▁( ▁) ▁{ ▁upstream ▁. ▁cancel ▁( ▁) ▁; ▁dispose Inner ▁( ▁) ▁; ▁errors ▁. ▁try Terminate And Report ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁isDisposed ▁( ▁) ▁{ ▁return ▁inner ▁. ▁get ▁( ▁) ▁== ▁IN NER _ DIS PO SED ▁; ▁} ▁void ▁inner Error ▁( ▁Switch Map Inner Observer ▁sender ▁, ▁Throwable ▁error ▁) ▁{ ▁if ▁( ▁inner ▁. ▁compareAndSet ▁( ▁sender ▁, ▁null ▁) ▁) ▁{ ▁if ▁( ▁errors ▁. ▁try Add Throwable Or Report ▁( ▁error ▁) ▁) ▁{ ▁if ▁( ▁delay Errors ▁) ▁{ ▁if ▁( ▁done ▁) ▁{ ▁errors ▁. ▁try Terminate Consumer ▁( ▁downstream ▁) ▁; ▁} ▁} ▁else ▁{ ▁upstream ▁. ▁cancel ▁( ▁) ▁; ▁dispose Inner ▁( ▁) ▁; ▁errors ▁. ▁try Terminate Consumer ▁( ▁downstream ▁) ▁; ▁} ▁} ▁} ▁else ▁{ ▁RxJavaPlugins ▁. ▁onError ▁( ▁error ▁) ▁; ▁} ▁} ▁void ▁inner Complete ▁( ▁Switch Map Inner Observer ▁sender ▁) ▁{ ▁if ▁( ▁inner ▁. ▁compareAndSet ▁( ▁sender ▁, ▁null ▁) ▁) ▁{ ▁if ▁( ▁done ▁) ▁{ ▁errors ▁. ▁try Terminate Consumer ▁( ▁downstream ▁) ▁; ▁} ▁} ▁} ▁static ▁final ▁class ▁Switch Map Inner Observer ▁extends ▁AtomicReference ▁< ▁Disposable ▁> ▁implements ▁Completable Observer ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁- ▁8 00 34 04 46 00 84 76 02 87 L ▁; ▁final ▁Switch Map Completable Observer ▁< ▁? ▁> ▁parent ▁; ▁Switch Map Inner Observer ▁( ▁Switch Map Completable Observer ▁< ▁? ▁> ▁parent ▁) ▁{ ▁this ▁. ▁parent ▁= ▁parent ▁; ▁} ▁@ ▁Override ▁public ▁void ▁onSubscribe ▁( ▁Disposable ▁d ▁) ▁{ ▁Disposable Helper ▁. ▁setOnce ▁( ▁this ▁, ▁d ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁onError ▁( ▁Throwable ▁e ▁) ▁{ ▁parent ▁. ▁inner Error ▁( ▁this ▁, ▁e ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁onComplete ▁( ▁) ▁{ ▁parent ▁. ▁inner Complete ▁( ▁this ▁) ▁; ▁} ▁void ▁dispose ▁( ▁) ▁{ ▁Disposable Helper ▁. ▁dispose ▁( ▁this ▁) ▁; ▁} ▁} ▁} ▁}
▁@ ▁StarlarkBuiltin ▁( ▁name ▁= ▁STR ▁, ▁doc ▁= ▁STR ▁, ▁documented ▁= ▁false ▁) ▁public ▁interface ▁TestEnvironment InfoApi ▁extends ▁Struct Api ▁{ ▁@ ▁StarlarkMethod ▁( ▁name ▁= ▁STR ▁, ▁doc ▁= ▁STR ▁, ▁structField ▁= ▁true ▁) ▁Map ▁< ▁String ▁, ▁String ▁> ▁getEnvironment ▁( ▁) ▁; ▁}
▁public ▁class ▁NodeList Dangling Indices Response ▁extends ▁Base Node Response ▁{ ▁private ▁final ▁List ▁< ▁D angling Index Info ▁> ▁index MetaData ▁; ▁public ▁List ▁< ▁D angling Index Info ▁> ▁getD angling Indices ▁( ▁) ▁{ ▁return ▁this ▁. ▁index MetaData ▁; ▁} ▁public ▁NodeList Dangling Indices Response ▁( ▁DiscoveryNode ▁node ▁, ▁List ▁< ▁D angling Index Info ▁> ▁index MetaData ▁) ▁{ ▁super ▁( ▁node ▁) ▁; ▁this ▁. ▁index MetaData ▁= ▁index MetaData ▁; ▁} ▁protected ▁NodeList Dangling Indices Response ▁( ▁StreamInput ▁in ▁) ▁throws ▁IOException ▁{ ▁super ▁( ▁in ▁) ▁; ▁this ▁. ▁index MetaData ▁= ▁in ▁. ▁readList ▁( ▁D angling Index Info ▁:: ▁new ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁writeTo ▁( ▁StreamOutput ▁out ▁) ▁throws ▁IOException ▁{ ▁super ▁. ▁writeTo ▁( ▁out ▁) ▁; ▁out ▁. ▁write List ▁( ▁this ▁. ▁index MetaData ▁) ▁; ▁} ▁}
▁tmp Map ▁. ▁put ▁( ▁_ Fields ▁. ▁DE AD LOCK ED _ THREAD _ LIST ▁, ▁new ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁meta _ data ▁. ▁Field MetaData ▁( ▁STR ▁, ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁T Field Requirement Type ▁. ▁OPTION AL ▁, ▁new ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁meta _ data ▁. ▁List MetaData ▁( ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁protocol ▁. ▁T Type ▁. ▁LIST ▁, ▁new ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁meta _ data ▁. ▁Struct MetaData ▁( ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁protocol ▁. ▁T Type ▁. ▁STR UCT ▁, ▁com ▁. ▁n aver c or p ▁. ▁pinpoint ▁. ▁thrift ▁. ▁dto ▁. ▁command ▁. ▁T ThreadDump ▁. ▁class ▁) ▁) ▁) ▁) ▁; ▁metaData Map ▁= ▁java ▁. ▁util ▁. ▁Collections ▁. ▁unmodifiableMap ▁( ▁tmp Map ▁) ▁; ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁meta _ data ▁. ▁Field MetaData ▁. ▁add Struct MetaData Map ▁( ▁T Deadlock ▁. ▁class ▁, ▁metaData Map ▁) ▁; ▁} ▁public ▁T Deadlock ▁( ▁) ▁{ ▁} ▁public ▁T Deadlock ▁( ▁T Deadlock ▁other ▁) ▁{ ▁__ iss et _ bit field ▁= ▁other ▁. ▁__ iss et _ bit field ▁; ▁this ▁. ▁deadlock ed ThreadCount ▁= ▁other ▁. ▁deadlock ed ThreadCount ▁; ▁if ▁( ▁other ▁. ▁isSet Deadlock ed Thread List ▁( ▁) ▁) ▁{ ▁java ▁. ▁util ▁. ▁List ▁< ▁com ▁. ▁n aver c or p ▁. ▁pinpoint ▁. ▁thrift ▁. ▁dto ▁. ▁command ▁. ▁T ThreadDump ▁> ▁__ th is __ de adlock ed Thread List ▁= ▁new ▁java ▁. ▁util ▁. ▁ArrayList ▁< ▁com ▁. ▁n aver c or p ▁. ▁pinpoint ▁. ▁thrift ▁. ▁dto ▁. ▁command ▁. ▁T ThreadDump ▁> ▁( ▁other ▁. ▁deadlock ed Thread List ▁. ▁size ▁( ▁) ▁) ▁; ▁for ▁( ▁com ▁. ▁n aver c or p ▁. ▁pinpoint ▁. ▁thrift ▁. ▁dto ▁. ▁command ▁. ▁T ThreadDump ▁other _ element ▁: ▁other ▁. ▁deadlock ed Thread List ▁) ▁{ ▁__ th is __ de adlock ed Thread List ▁. ▁add ▁( ▁new ▁com ▁. ▁n aver c or p ▁. ▁pinpoint ▁. ▁thrift ▁. ▁dto ▁. ▁command ▁. ▁T ThreadDump ▁( ▁other _ element ▁) ▁) ▁; ▁} ▁this ▁. ▁deadlock ed Thread List ▁= ▁__ th is __ de adlock ed Thread List ▁; ▁} ▁} ▁public ▁T Deadlock ▁deep Copy ▁( ▁) ▁{ ▁return ▁new ▁T Deadlock ▁( ▁this ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁clear ▁( ▁) ▁{ ▁set Deadlock ed ThreadCount Is Set ▁( ▁false ▁) ▁; ▁this ▁. ▁deadlock ed ThreadCount ▁= ▁0 ▁; ▁this ▁. ▁deadlock ed Thread List ▁= ▁null ▁; ▁} ▁public ▁int ▁get Deadlock ed ThreadCount ▁( ▁) ▁{ ▁return ▁this ▁. ▁deadlock ed ThreadCount ▁; ▁} ▁public ▁void ▁set Deadlock ed ThreadCount ▁( ▁int ▁deadlock ed ThreadCount ▁) ▁{ ▁this ▁. ▁deadlock ed ThreadCount ▁= ▁deadlock ed ThreadCount ▁; ▁set Deadlock ed ThreadCount Is Set ▁( ▁true ▁) ▁; ▁}
▁public ▁class ▁Hystrix Utilization Stream ▁{ ▁private ▁final ▁int ▁interval In Milliseconds ▁; ▁private ▁final ▁Observable ▁< ▁Hystrix Utilization ▁> ▁all Utilization Stream ▁; ▁private ▁final ▁AtomicBoolean ▁is Source Current ly Sub scribed ▁= ▁new ▁AtomicBoolean ▁( ▁false ▁) ▁; ▁private ▁static ▁final ▁Dynamic Int Property ▁data E mission Interval InMs ▁= ▁Dynamic Property Factory ▁. ▁getInstance ▁( ▁) ▁. ▁getInt Property ▁( ▁STR ▁, ▁500 ▁) ▁; ▁private ▁static ▁final ▁Func 1 ▁< ▁Long ▁, ▁Hystrix Utilization ▁> ▁getAll Utilization ▁= ▁new ▁Func 1 ▁< ▁Long ▁, ▁Hystrix Utilization ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Hystrix Utilization ▁call ▁( ▁Long ▁timestamp ▁) ▁{ ▁return ▁Hystrix Utilization ▁. ▁from ▁( ▁getAll Command Utilization ▁. ▁call ▁( ▁timestamp ▁) ▁, ▁getAll ThreadPool Utilization ▁. ▁call ▁( ▁timestamp ▁) ▁) ▁; ▁} ▁} ▁; ▁@ ▁Deprecated ▁public ▁Hystrix Utilization Stream ▁( ▁final ▁int ▁interval In Milliseconds ▁) ▁{ ▁this ▁. ▁interval In Milliseconds ▁= ▁interval In Milliseconds ▁; ▁this ▁. ▁all Utilization Stream ▁= ▁Observable ▁. ▁interval ▁( ▁interval In Milliseconds ▁, ▁TimeUnit ▁. ▁MILLISECONDS ▁) ▁. ▁map ▁( ▁getAll Utilization ▁) ▁. ▁doOn Subscribe ▁( ▁new ▁Action 0 ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁call ▁( ▁) ▁{ ▁is Source Current ly Sub scribed ▁. ▁set ▁( ▁true ▁) ▁; ▁} ▁} ▁) ▁. ▁doOn Unsub scribe ▁( ▁new ▁Action 0 ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁call ▁( ▁) ▁{ ▁is Source Current ly Sub scribed ▁. ▁set ▁( ▁false ▁) ▁; ▁} ▁} ▁) ▁. ▁sh are ▁( ▁) ▁. ▁on Back pressure Drop ▁( ▁) ▁; ▁} ▁private ▁static ▁final ▁Hystrix Utilization Stream ▁INSTANCE ▁= ▁new ▁Hystrix Utilization Stream ▁( ▁data E mission Interval InMs ▁. ▁get ▁( ▁) ▁) ▁; ▁public ▁static ▁Hystrix Utilization Stream ▁getInstance ▁( ▁) ▁{ ▁return ▁INSTANCE ▁; ▁} ▁static ▁Hystrix Utilization Stream ▁getNon Singleton Instance Only Used In Unit Tests ▁( ▁int ▁delay InMs ▁) ▁{ ▁return ▁new ▁Hystrix Utilization Stream ▁( ▁delay InMs ▁) ▁; ▁} ▁public ▁Observable ▁< ▁Hystrix Utilization ▁> ▁observe ▁( ▁) ▁{ ▁return ▁all Utilization Stream ▁; ▁} ▁public ▁Observable ▁< ▁Map ▁< ▁HystrixCommand Key ▁, ▁HystrixCommand Utilization ▁> ▁> ▁observe Command Utilization ▁( ▁) ▁{ ▁return ▁all Utilization Stream ▁. ▁map ▁( ▁getOnly Command Utilization ▁) ▁; ▁} ▁public ▁Observable ▁< ▁Map ▁< ▁Hystrix ThreadPool Key ▁, ▁Hystrix ThreadPool Utilization ▁> ▁> ▁observe ThreadPool Utilization ▁( ▁) ▁{ ▁return ▁all Utilization Stream ▁. ▁map ▁( ▁getOnly ThreadPool Utilization ▁) ▁; ▁} ▁public ▁int ▁get Interval In Milliseconds ▁( ▁) ▁{ ▁return ▁this ▁. ▁interval In Milliseconds ▁; ▁} ▁public ▁boolean ▁is Source Current ly Sub scribed ▁( ▁) ▁{ ▁return ▁is Source Current ly Sub scribed ▁. ▁get ▁( ▁) ▁; ▁} ▁private ▁static ▁HystrixCommand Utilization ▁sample Command Utilization ▁( ▁HystrixCommand Metrics ▁command Metrics ▁) ▁{ ▁return ▁HystrixCommand Utilization ▁. ▁sample ▁( ▁command Metrics ▁) ▁; ▁} ▁private ▁static ▁Hystrix ThreadPool Utilization ▁sample ThreadPool Utilization ▁( ▁Hystrix ThreadPool Metrics ▁threadPool Metrics ▁) ▁{ ▁return ▁Hystrix ThreadPool Utilization ▁. ▁sample ▁( ▁threadPool Metrics ▁) ▁; ▁}
▁@ ▁Override ▁@ ▁Deprecated ▁public ▁BigDecimal ▁getBig Decimal ▁( ▁int ▁parameterIndex ▁, ▁int ▁scale ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁getBig Decimal ▁( ▁parameterIndex ▁, ▁scale ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁byte ▁[ ▁] ▁getBytes ▁( ▁int ▁parameterIndex ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁getBytes ▁( ▁parameterIndex ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁java ▁. ▁sql ▁. ▁Date ▁getDate ▁( ▁int ▁parameterIndex ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁getDate ▁( ▁parameterIndex ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁java ▁. ▁sql ▁. ▁Time ▁getTime ▁( ▁int ▁parameterIndex ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁getTime ▁( ▁parameterIndex ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁java ▁. ▁sql ▁. ▁Timestamp ▁getTimestamp ▁( ▁int ▁parameterIndex ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁getTimestamp ▁( ▁parameterIndex ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁Object ▁getObject ▁( ▁int ▁parameterIndex ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁Object ▁obj ▁= ▁stmt ▁. ▁getObject ▁( ▁parameterIndex ▁) ▁; ▁return ▁wrap Object ▁( ▁obj ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁private ▁Object ▁wrap Object ▁( ▁Object ▁obj ▁) ▁{ ▁if ▁( ▁obj ▁instanceof ▁ResultSet ▁) ▁{ ▁ResultSet ▁rs ▁= ▁( ▁ResultSet ▁) ▁obj ▁; ▁DruidPooled ResultSet ▁pool able ResultSet ▁= ▁new ▁DruidPooled ResultSet ▁( ▁this ▁, ▁rs ▁) ▁; ▁add ResultSet Trace ▁( ▁pool able ResultSet ▁) ▁; ▁obj ▁= ▁pool able ResultSet ▁; ▁} ▁return ▁obj ▁; ▁} ▁@ ▁Override ▁public ▁BigDecimal ▁getBig Decimal ▁( ▁int ▁parameterIndex ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁getBig Decimal ▁( ▁parameterIndex ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁Object ▁getObject ▁( ▁int ▁parameterIndex ▁, ▁java ▁. ▁util ▁. ▁Map ▁< ▁String ▁, ▁Class ▁< ▁? ▁> ▁> ▁map ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁Object ▁obj ▁= ▁stmt ▁. ▁getObject ▁( ▁parameterIndex ▁, ▁map ▁) ▁; ▁return ▁wrap Object ▁( ▁obj ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁Ref ▁getRef ▁( ▁int ▁parameterIndex ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁getRef ▁( ▁parameterIndex ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁Blob ▁getBlob ▁( ▁int ▁parameterIndex ▁) ▁throws ▁SQLException ▁{ ▁try ▁{ ▁return ▁stmt ▁. ▁getBlob ▁( ▁parameterIndex ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throw ▁check Exception ▁( ▁t ▁) ▁; ▁} ▁}
▁public ▁final ▁class ▁Blaze Workspace ▁{ ▁public ▁static ▁final ▁String ▁DO _ NOT _ BU ILD _ FILE _ NAME ▁= ▁STR ▁; ▁private ▁static ▁final ▁Google Logger ▁logger ▁= ▁Google Logger ▁. ▁for Enclosing Class ▁( ▁) ▁; ▁private ▁final ▁Blaze Runtime ▁runtime ▁; ▁private ▁final ▁Subscriber ExceptionHandler ▁eventBus ExceptionHandler ▁; ▁private ▁final ▁Workspace StatusAction ▁. ▁Factory ▁workspace StatusAction Factory ▁; ▁private ▁final ▁B in Tools ▁bin Tools ▁; ▁@ ▁Nullable ▁private ▁final ▁Allocation Tracker ▁allocation Tracker ▁; ▁private ▁final ▁Blaze Directories ▁direct ories ▁; ▁private ▁final ▁Sky frameExecutor ▁sky frameExecutor ▁; ▁@ ▁Nullable ▁private ▁Action Cache ▁action Cache ▁; ▁@ ▁Nullable ▁private ▁Range ▁< ▁Long ▁> ▁last Execution Range ▁= ▁null ▁; ▁private ▁final ▁String ▁output Base Files ystem TypeName ▁; ▁public ▁Blaze Workspace ▁( ▁Blaze Runtime ▁runtime ▁, ▁Blaze Directories ▁direct ories ▁, ▁Sky frameExecutor ▁sky frameExecutor ▁, ▁Subscriber ExceptionHandler ▁eventBus ExceptionHandler ▁, ▁Workspace StatusAction ▁. ▁Factory ▁workspace StatusAction Factory ▁, ▁B in Tools ▁bin Tools ▁, ▁@ ▁Nullable ▁Allocation Tracker ▁allocation Tracker ▁) ▁{ ▁this ▁. ▁runtime ▁= ▁runtime ▁; ▁this ▁. ▁eventBus ExceptionHandler ▁= ▁Preconditions ▁. ▁checkNotNull ▁( ▁eventBus ExceptionHandler ▁) ▁; ▁this ▁. ▁workspace StatusAction Factory ▁= ▁workspace StatusAction Factory ▁; ▁this ▁. ▁bin Tools ▁= ▁bin Tools ▁; ▁this ▁. ▁allocation Tracker ▁= ▁allocation Tracker ▁; ▁this ▁. ▁direct ories ▁= ▁direct ories ▁; ▁this ▁. ▁sky frameExecutor ▁= ▁sky frameExecutor ▁; ▁if ▁( ▁direct ories ▁. ▁in Workspace ▁( ▁) ▁) ▁{ ▁write Output Base Read me File ▁( ▁) ▁; ▁write Do Not Build Here File ▁( ▁) ▁; ▁} ▁this ▁. ▁output Base Files ystem TypeName ▁= ▁FileSystemUtils ▁. ▁getFileSystem ▁( ▁getOutput Base ▁( ▁) ▁) ▁; ▁} ▁public ▁Blaze Runtime ▁getRuntime ▁( ▁) ▁{ ▁return ▁runtime ▁; ▁} ▁public ▁Blaze Directories ▁get Directories ▁( ▁) ▁{ ▁return ▁direct ories ▁; ▁} ▁public ▁Sky frameExecutor ▁getS ky frameExecutor ▁( ▁) ▁{ ▁return ▁sky frameExecutor ▁; ▁} ▁public ▁Workspace StatusAction ▁. ▁Factory ▁getWorkspace StatusAction Factory ▁( ▁) ▁{ ▁return ▁workspace StatusAction Factory ▁; ▁} ▁public ▁B in Tools ▁getB in Tools ▁( ▁) ▁{ ▁return ▁bin Tools ▁; ▁} ▁public ▁Path ▁getWorkspace ▁( ▁) ▁{ ▁return ▁direct ories ▁. ▁getWork ingDirectory ▁( ▁) ▁; ▁} ▁public ▁Path ▁getOutput Base ▁( ▁) ▁{ ▁return ▁direct ories ▁. ▁getOutput Base ▁( ▁) ▁; ▁} ▁public ▁String ▁getOutput Base Files ystem TypeName ▁( ▁) ▁{ ▁return ▁output Base Files ystem TypeName ▁; ▁} ▁public ▁Path ▁getIn st all Base ▁( ▁) ▁{ ▁return ▁direct ories ▁. ▁getIn st all Base ▁( ▁) ▁; ▁} ▁private ▁Path ▁getCache Directory ▁( ▁) ▁{ ▁return ▁getOutput Base ▁( ▁) ▁. ▁getChild ▁( ▁STR ▁) ▁; ▁} ▁void ▁record Last Execution Time ▁( ▁long ▁command StartTime ▁) ▁{ ▁long ▁current TimeMillis ▁= ▁runtime ▁. ▁getC lock ▁( ▁) ▁. ▁current TimeMillis ▁( ▁) ▁; ▁last Execution Range ▁= ▁current TimeMillis ▁>= ▁command StartTime ▁? ▁Range ▁. ▁closed ▁( ▁command StartTime ▁, ▁current TimeMillis ▁) ▁: ▁null ▁; ▁} ▁@ ▁Nullable ▁public ▁Range ▁< ▁Long ▁> ▁getLast Execution Time Range ▁( ▁) ▁{ ▁return ▁last Execution Range ▁; ▁}
▁public ▁class ▁Final izable Subclass Test ▁extends ▁Graal CompilerTest ▁{ ▁public ▁static ▁class ▁No Finalizer E ver A A A A ▁{ ▁} ▁public ▁static ▁class ▁No Finalizer Yet A A A A ▁{ ▁} ▁public ▁static ▁final ▁class ▁With Finalizer A A A A ▁extends ▁No Finalizer Yet A A A A ▁{ ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁@ ▁Override ▁protected ▁void ▁finalize ▁( ▁) ▁throws ▁Throwable ▁{ ▁super ▁. ▁finalize ▁( ▁) ▁; ▁} ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁private ▁StructuredGraph ▁parse And Process ▁( ▁Class ▁< ▁? ▁> ▁cl ▁, ▁Allow Assumptions ▁allow Assumptions ▁) ▁{ ▁Constructor ▁< ▁? ▁> ▁[ ▁] ▁construct ors ▁= ▁cl ▁. ▁getConstructors ▁( ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁construct ors ▁. ▁length ▁== ▁1 ▁) ▁; ▁final ▁ResolvedJava Method ▁java Method ▁= ▁getMetaAccess ▁( ▁) ▁. ▁lookup JavaMethod ▁( ▁construct ors ▁[ ▁0 ▁] ▁) ▁; ▁OptionValues ▁options ▁= ▁getInitial Options ▁( ▁) ▁; ▁DebugContext ▁debug ▁= ▁getDebug Context ▁( ▁options ▁, ▁null ▁, ▁java Method ▁) ▁; ▁StructuredGraph ▁graph ▁= ▁new ▁StructuredGraph ▁. ▁Builder ▁( ▁options ▁, ▁debug ▁, ▁allow Assumptions ▁) ▁. ▁method ▁( ▁java Method ▁) ▁. ▁build ▁( ▁) ▁; ▁try ▁( ▁DebugContext ▁. ▁Scope ▁s ▁= ▁debug ▁. ▁scope ▁( ▁STR ▁, ▁graph ▁) ▁) ▁{ ▁GraphBuilder Configuration ▁conf ▁= ▁GraphBuilder Configuration ▁. ▁getS nippet Default ▁( ▁getDefault GraphBuilder Plugins ▁( ▁) ▁) ▁; ▁new ▁GraphBuilder Phase ▁. ▁Instance ▁( ▁get Providers ▁( ▁) ▁, ▁conf ▁, ▁Optim istic Optim izations ▁. ▁ALL ▁, ▁null ▁) ▁. ▁apply ▁( ▁graph ▁) ▁; ▁High TierContext ▁context ▁= ▁new ▁High TierContext ▁( ▁get Providers ▁( ▁) ▁, ▁getDefault GraphBuilder Suite ▁( ▁) ▁, ▁Optim istic Optim izations ▁. ▁ALL ▁) ▁; ▁create Inlining Phase ▁( ▁) ▁. ▁apply ▁( ▁graph ▁, ▁context ▁) ▁; ▁Canonicalizer Phase ▁canonical izer ▁= ▁create Canonical izer Phase ▁( ▁) ▁; ▁canonical izer ▁. ▁apply ▁( ▁graph ▁, ▁context ▁) ▁; ▁new ▁Lowering Phase ▁( ▁canonical izer ▁, ▁Lowering Tool ▁. ▁Standard Lowering Stage ▁. ▁HIGH _ TI ER ▁) ▁. ▁apply ▁( ▁graph ▁, ▁context ▁) ▁; ▁return ▁graph ▁; ▁} ▁catch ▁( ▁Throwable ▁e ▁) ▁{ ▁throw ▁debug ▁. ▁handle ▁( ▁e ▁) ▁; ▁} ▁} ▁private ▁void ▁checkFor Register Final ize Node ▁( ▁Class ▁< ▁? ▁> ▁cl ▁, ▁Allow Assumptions ▁allow Assumptions ▁, ▁boolean ▁should Contain Finalizer ▁, ▁boolean ▁should Contain Dynamic Check ▁) ▁{ ▁assert ▁! ▁should Contain Dynamic Check ▁|| ▁should Contain Finalizer ▁; ▁StructuredGraph ▁graph ▁= ▁parse And Process ▁( ▁cl ▁, ▁allow Assumptions ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁graph ▁. ▁getNodes ▁( ▁) ▁. ▁filter ▁( ▁Register Finalizer Node ▁. ▁class ▁) ▁. ▁count ▁( ▁) ▁== ▁( ▁should Contain Finalizer ▁? ▁1 ▁: ▁0 ▁) ▁) ▁; ▁int ▁no Finalizer Assumption ▁= ▁0 ▁; ▁Ass umptions ▁ass umptions ▁= ▁graph ▁. ▁getAss umptions ▁( ▁) ▁; ▁if ▁( ▁ass umptions ▁!= ▁null ▁) ▁{ ▁for ▁( ▁Assumption ▁a ▁: ▁ass umptions ▁) ▁{ ▁if ▁( ▁a ▁instanceof ▁No Final izable Subclass ▁) ▁{ ▁no Finalizer Assumption ▁++ ▁; ▁}
▁compareTo Method ▁. ▁getBody ▁( ▁) ▁. ▁append ▁( ▁block ▁) ▁; ▁} ▁compareTo Method ▁. ▁getBody ▁( ▁) ▁. ▁push ▁( ▁0 ▁) ▁. ▁ret Int ▁( ▁) ▁; ▁} ▁public ▁Page With Position Comparator ▁compile Page With Position Comparator ▁( ▁List ▁< ▁Type ▁> ▁sort Types ▁, ▁List ▁< ▁Integer ▁> ▁sort Channels ▁, ▁List ▁< ▁SortOrder ▁> ▁sortOrder s ▁) ▁{ ▁requireNonNull ▁( ▁sort Types ▁, ▁STR ▁) ▁; ▁requireNonNull ▁( ▁sort Channels ▁, ▁STR ▁) ▁; ▁requireNonNull ▁( ▁sortOrder s ▁, ▁STR ▁) ▁; ▁return ▁page With Position Comparator s ▁. ▁getUn checked ▁( ▁new ▁Pages Index Comparator CacheKey ▁( ▁sort Types ▁, ▁sort Channels ▁, ▁sortOrder s ▁) ▁) ▁; ▁} ▁private ▁Page With Position Comparator ▁internal Compile Page With Position Comparator ▁( ▁List ▁< ▁Type ▁> ▁types ▁, ▁List ▁< ▁Integer ▁> ▁sort Channels ▁, ▁List ▁< ▁SortOrder ▁> ▁sortOrder s ▁) ▁{ ▁Page With Position Comparator ▁comparator ▁; ▁try ▁{ ▁Class ▁< ▁? ▁extends ▁Page With Position Comparator ▁> ▁page With Positions Comparator Class ▁= ▁generate Page With Position Comparator Class ▁( ▁types ▁, ▁sort Channels ▁, ▁sortOrder s ▁) ▁; ▁comparator ▁= ▁page With Positions Comparator Class ▁. ▁getConstructor ▁( ▁) ▁. ▁newInstance ▁( ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁log ▁. ▁error ▁( ▁t ▁, ▁STR ▁, ▁sort Channels ▁, ▁sort Channels ▁) ▁; ▁comparator ▁= ▁new ▁Simple Page With Position Comparator ▁( ▁types ▁, ▁sort Channels ▁, ▁sortOrder s ▁) ▁; ▁} ▁return ▁comparator ▁; ▁} ▁private ▁Class ▁< ▁? ▁extends ▁Page With Position Comparator ▁> ▁generate Page With Position Comparator Class ▁( ▁List ▁< ▁Type ▁> ▁sort Types ▁, ▁List ▁< ▁Integer ▁> ▁sort Channels ▁, ▁List ▁< ▁SortOrder ▁> ▁sortOrder s ▁) ▁{ ▁Call Site Binder ▁call Site Binder ▁= ▁new ▁Call Site Binder ▁( ▁) ▁; ▁Class Definition ▁class Definition ▁= ▁new ▁Class Definition ▁( ▁a ▁( ▁PUBLIC ▁, ▁FIN AL ▁) ▁, ▁make ClassName ▁( ▁STR ▁) ▁, ▁type ▁( ▁Object ▁. ▁class ▁) ▁, ▁type ▁( ▁Page With Position Comparator ▁. ▁class ▁) ▁) ▁; ▁class Definition ▁. ▁declare Default Constructor ▁( ▁a ▁( ▁PUBLIC ▁) ▁) ▁; ▁generate Merge Sort Compare To ▁( ▁class Definition ▁, ▁call Site Binder ▁, ▁sort Types ▁, ▁sort Channels ▁, ▁sortOrder s ▁) ▁; ▁return ▁define Class ▁( ▁class Definition ▁, ▁Page With Position Comparator ▁. ▁class ▁, ▁call Site Binder ▁. ▁getBind ings ▁( ▁) ▁, ▁getClass ▁( ▁) ▁. ▁getClassLoader ▁( ▁) ▁) ▁; ▁} ▁private ▁void ▁generate Merge Sort Compare To ▁( ▁Class Definition ▁class Definition ▁, ▁Call Site Binder ▁call Site Binder ▁, ▁List ▁< ▁Type ▁> ▁types ▁, ▁List ▁< ▁Integer ▁> ▁sort Channels ▁, ▁List ▁< ▁SortOrder ▁> ▁sortOrder s ▁) ▁{ ▁Parameter ▁left Page ▁= ▁arg ▁( ▁STR ▁, ▁Page ▁. ▁class ▁) ▁; ▁Parameter ▁left Position ▁= ▁arg ▁( ▁STR ▁, ▁int ▁. ▁class ▁) ▁; ▁Parameter ▁right Page ▁= ▁arg ▁( ▁STR ▁, ▁Page ▁. ▁class ▁) ▁; ▁Parameter ▁right Position ▁= ▁arg ▁( ▁STR ▁, ▁int ▁. ▁class ▁) ▁;
▁public ▁class ▁Cli Stream Header ▁implements ▁StructConverter ▁, ▁Pe Markup able ▁{ ▁private ▁static ▁String ▁NAME ▁= ▁STR ▁; ▁private ▁static ▁String ▁PATH ▁= ▁STR ▁; ▁private ▁Cli Metadata Root ▁metadata Root ▁; ▁private ▁Cli Abstract Stream ▁stream ▁; ▁private ▁int ▁offset ▁; ▁private ▁int ▁size ▁; ▁private ▁String ▁name ▁; ▁private ▁int ▁name Len ▁; ▁public ▁Cli Stream Header ▁( ▁Cli Metadata Root ▁metadata Root ▁, ▁BinaryReader ▁reader ▁) ▁throws ▁IOException ▁{ ▁this ▁. ▁metadata Root ▁= ▁metadata Root ▁; ▁long ▁header StartIndex ▁= ▁reader ▁. ▁getPointerIndex ▁( ▁) ▁; ▁this ▁. ▁offset ▁= ▁reader ▁. ▁readNextInt ▁( ▁) ▁; ▁this ▁. ▁size ▁= ▁reader ▁. ▁readNextInt ▁( ▁) ▁; ▁long ▁startIndex ▁= ▁reader ▁. ▁getPointerIndex ▁( ▁) ▁; ▁this ▁. ▁name ▁= ▁reader ▁. ▁readNext Ascii String ▁( ▁) ▁; ▁long ▁endIndex ▁= ▁reader ▁. ▁getPointerIndex ▁( ▁) ▁; ▁long ▁string Bytes ▁= ▁endIndex ▁- ▁startIndex ▁; ▁long ▁bytesTo Round Up ▁= ▁0 ▁; ▁if ▁( ▁( ▁string Bytes ▁ % ▁4 ▁) ▁!= ▁0 ▁) ▁{ ▁bytesTo Round Up ▁+= ▁4 ▁- ▁( ▁string Bytes ▁ % ▁4 ▁) ▁; ▁} ▁this ▁. ▁name Len ▁= ▁( ▁int ▁) ▁( ▁string Bytes ▁+ ▁bytesTo Round Up ▁) ▁; ▁int ▁total Len ▁= ▁2 ▁ * ▁D Word DataType ▁. ▁dataType ▁. ▁getLength ▁( ▁) ▁+ ▁this ▁. ▁name Len ▁; ▁reader ▁. ▁setPointerIndex ▁( ▁header StartIndex ▁+ ▁total Len ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁markup ▁( ▁Program ▁program ▁, ▁boolean ▁is Binary ▁, ▁TaskMonitor ▁monitor ▁, ▁MessageLog ▁log ▁, ▁N T Header ▁nt Header ▁) ▁throws ▁Duplicate NameException ▁, ▁IOException ▁, ▁Memory AccessException ▁{ ▁if ▁( ▁stream ▁!= ▁null ▁) ▁{ ▁stream ▁. ▁markup ▁( ▁program ▁, ▁is Binary ▁, ▁monitor ▁, ▁log ▁, ▁nt Header ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁DataType ▁toDataType ▁( ▁) ▁throws ▁Duplicate NameException ▁, ▁IOException ▁{ ▁Structure ▁struct ▁= ▁new ▁Structure DataType ▁( ▁NAME ▁+ ▁STR ▁+ ▁name ▁, ▁0 ▁) ▁; ▁struct ▁. ▁setCategoryPath ▁( ▁new ▁CategoryPath ▁( ▁PATH ▁) ▁) ▁; ▁struct ▁. ▁add ▁( ▁DWORD ▁, ▁STR ▁, ▁null ▁) ▁; ▁struct ▁. ▁add ▁( ▁DWORD ▁, ▁STR ▁, ▁null ▁) ▁; ▁struct ▁. ▁add ▁( ▁new ▁ArrayDataType ▁( ▁Char DataType ▁. ▁dataType ▁, ▁this ▁. ▁name Len ▁, ▁1 ▁) ▁, ▁STR ▁, ▁null ▁) ▁; ▁return ▁struct ▁; ▁} ▁public ▁Cli Metadata Root ▁getMetadata Root ▁( ▁) ▁{ ▁return ▁metadata Root ▁; ▁} ▁public ▁Cli Abstract Stream ▁getStream ▁( ▁) ▁{ ▁return ▁stream ▁; ▁} ▁public ▁int ▁getOffset ▁( ▁) ▁{ ▁return ▁offset ▁; ▁} ▁public ▁int ▁getSize ▁( ▁) ▁{ ▁return ▁size ▁; ▁} ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁name ▁; ▁} ▁public ▁int ▁getName Length ▁( ▁) ▁{ ▁return ▁name Len ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁getName ▁( ▁) ▁; ▁} ▁protected ▁void ▁set Stream ▁( ▁Cli Abstract Stream ▁stream ▁) ▁{ ▁this ▁. ▁stream ▁= ▁stream ▁; ▁} ▁}
▁int ▁value ▁= ▁entry ▁. ▁getArray Element ▁( ▁1 ▁) ▁. ▁asInt ▁( ▁) ▁; ▁int ▁expectedValue ▁= ▁expected 2 ▁. ▁remove ▁( ▁key ▁) ▁; ▁assertEquals ▁( ▁expectedValue ▁, ▁value ▁) ▁; ▁} ▁assertTrue ▁( ▁expected 2 ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁iterator ▁= ▁hash ▁. ▁getHash Keys Iterator ▁( ▁) ▁; ▁while ▁( ▁iterator ▁. ▁has Iterator Next Element ▁( ▁) ▁) ▁{ ▁Object ▁key ▁= ▁key Factory ▁. ▁un box ▁( ▁iterator ▁. ▁get Iterator Next Element ▁( ▁) ▁) ▁; ▁assertTrue ▁( ▁expected Keys ▁. ▁remove ▁( ▁key ▁) ▁) ▁; ▁} ▁assertTrue ▁( ▁expected Keys ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁iterator ▁= ▁hash ▁. ▁getHash Values Iterator ▁( ▁) ▁; ▁while ▁( ▁iterator ▁. ▁has Iterator Next Element ▁( ▁) ▁) ▁{ ▁int ▁value ▁= ▁iterator ▁. ▁get Iterator Next Element ▁( ▁) ▁. ▁asInt ▁( ▁) ▁; ▁assertTrue ▁( ▁expectedValues ▁. ▁remove ▁( ▁value ▁) ▁) ▁; ▁} ▁assertTrue ▁( ▁expectedValues ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁count ▁; ▁i ▁+= ▁inc ▁) ▁{ ▁Object ▁key ▁= ▁key Factory ▁. ▁create ▁( ▁i ▁) ▁; ▁hash ▁. ▁remove Hash Entry ▁( ▁key ▁) ▁; ▁assertFalse ▁( ▁hash ▁. ▁has Hash Entry ▁( ▁key ▁) ▁) ▁; ▁} ▁assertEquals ▁( ▁0 ▁, ▁hash ▁. ▁getHash Size ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁void ▁test P olyglot Map ▁( ▁) ▁{ ▁setup Env ▁( ▁Context ▁. ▁newBuilder ▁( ▁) ▁. ▁allow All Access ▁( ▁true ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁for ▁( ▁Key Factory ▁< ▁? ▁> ▁factory ▁: ▁Key Factory ▁. ▁ALL ▁) ▁{ ▁test P olyglot Map Impl ▁( ▁context ▁. ▁as Value ▁( ▁new ▁Hash ▁( ▁) ▁) ▁, ▁( ▁Key Factory ▁< ▁Object ▁> ▁) ▁factory ▁, ▁context ▁) ▁; ▁test P olyglot Map Impl ▁( ▁context ▁. ▁as Value ▁( ▁new ▁Proxy Hash Object ▁( ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁, ▁Collections ▁. ▁singletonMap ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁, ▁( ▁Key Factory ▁< ▁Object ▁> ▁) ▁factory ▁, ▁context ▁) ▁; ▁test P olyglot Map Impl ▁( ▁context ▁. ▁as Value ▁( ▁Proxy HashMap ▁. ▁from ▁( ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁) ▁) ▁, ▁( ▁Key Factory ▁< ▁Object ▁> ▁) ▁factory ▁, ▁context ▁) ▁; ▁} ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁private ▁static ▁void ▁test P olyglot Map Impl ▁( ▁Value ▁hash ▁, ▁Key Factory ▁< ▁Object ▁> ▁key Factory ▁, ▁Context ▁context ▁) ▁{ ▁final ▁int ▁count ▁= ▁100 ▁; ▁final ▁int ▁inc ▁= ▁2 ▁; ▁assertTrue ▁( ▁hash ▁. ▁has Hash Entries ▁( ▁) ▁) ▁; ▁Map ▁< ▁Object ▁, ▁Object ▁> ▁map ▁= ▁hash ▁. ▁as ▁( ▁Map ▁. ▁class ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁count ▁; ▁i ▁+= ▁inc ▁) ▁{ ▁Object ▁key ▁= ▁key Factory ▁. ▁create ▁( ▁i ▁) ▁; ▁Object ▁value ▁= ▁i ▁; ▁assertFalse ▁( ▁map ▁. ▁containsKey ▁( ▁key ▁) ▁) ▁;
▁public ▁final ▁class ▁JDBC Order Item Repository Impl ▁implements ▁OrderItem Repository ▁{ ▁private ▁final ▁DataSource ▁dataSource ▁; ▁private ▁final ▁Connection ▁connection ▁; ▁public ▁JDBC Order Item Repository Impl ▁( ▁final ▁DataSource ▁dataSource ▁) ▁throws ▁SQLException ▁{ ▁this ▁. ▁dataSource ▁= ▁dataSource ▁; ▁this ▁. ▁connection ▁= ▁dataSource ▁. ▁getConnection ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁createTable IfNot Exists ▁( ▁) ▁{ ▁String ▁sql ▁= ▁STR ▁+ ▁STR ▁; ▁try ▁( ▁Statement ▁statement ▁= ▁connection ▁. ▁createStatement ▁( ▁) ▁) ▁{ ▁statement ▁. ▁executeUpdate ▁( ▁sql ▁) ▁; ▁} ▁catch ▁( ▁final ▁SQLException ▁ignored ▁) ▁{ ▁ignored ▁. ▁printStackTrace ▁( ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁drop Table ▁( ▁) ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁try ▁( ▁Statement ▁statement ▁= ▁connection ▁. ▁createStatement ▁( ▁) ▁) ▁{ ▁statement ▁. ▁executeUpdate ▁( ▁sql ▁) ▁; ▁} ▁catch ▁( ▁final ▁SQLException ▁ignored ▁) ▁{ ▁} ▁} ▁@ ▁Override ▁public ▁void ▁truncate Table ▁( ▁) ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁try ▁( ▁Statement ▁statement ▁= ▁connection ▁. ▁createStatement ▁( ▁) ▁) ▁{ ▁statement ▁. ▁executeUpdate ▁( ▁sql ▁) ▁; ▁} ▁catch ▁( ▁final ▁SQLException ▁ignored ▁) ▁{ ▁} ▁} ▁@ ▁Override ▁public ▁Long ▁insert ▁( ▁final ▁OrderItem ▁order Item ▁) ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁try ▁( ▁Pre paredStatement ▁pre paredStatement ▁= ▁connection ▁. ▁prepare Statement ▁( ▁sql ▁, ▁Statement ▁. ▁RETURN _ GENER ATED _ KEYS ▁) ▁) ▁{ ▁pre paredStatement ▁. ▁setLong ▁( ▁1 ▁, ▁order Item ▁. ▁getOrder Id ▁( ▁) ▁) ▁; ▁pre paredStatement ▁. ▁setInt ▁( ▁2 ▁, ▁order Item ▁. ▁getUserId ▁( ▁) ▁) ▁; ▁pre paredStatement ▁. ▁setString ▁( ▁3 ▁, ▁order Item ▁. ▁getStatus ▁( ▁) ▁) ▁; ▁pre paredStatement ▁. ▁executeUpdate ▁( ▁) ▁; ▁try ▁( ▁ResultSet ▁resultSet ▁= ▁pre paredStatement ▁. ▁get Generated Keys ▁( ▁) ▁) ▁{ ▁if ▁( ▁resultSet ▁. ▁next ▁( ▁) ▁) ▁{ ▁order Item ▁. ▁setOrder Item Id ▁( ▁resultSet ▁. ▁getLong ▁( ▁1 ▁) ▁) ▁; ▁} ▁} ▁} ▁catch ▁( ▁final ▁SQLException ▁ignored ▁) ▁{ ▁} ▁return ▁order Item ▁. ▁getOrder Item Id ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁delete ▁( ▁final ▁Long ▁order Item Id ▁) ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁try ▁( ▁Pre paredStatement ▁pre paredStatement ▁= ▁connection ▁. ▁prepare Statement ▁( ▁sql ▁) ▁) ▁{ ▁pre paredStatement ▁. ▁setLong ▁( ▁1 ▁, ▁order Item Id ▁) ▁; ▁pre paredStatement ▁. ▁executeUpdate ▁( ▁sql ▁) ▁; ▁} ▁catch ▁( ▁final ▁SQLException ▁ignored ▁) ▁{ ▁} ▁} ▁@ ▁Override ▁public ▁List ▁< ▁OrderItem ▁> ▁selectAll ▁( ▁) ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁return ▁getOrder Items ▁( ▁sql ▁) ▁; ▁} ▁@ ▁Override ▁public ▁List ▁< ▁OrderItem ▁> ▁select Range ▁( ▁) ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁return ▁getOrder Items ▁( ▁sql ▁) ▁; ▁} ▁private ▁List ▁< ▁OrderItem ▁> ▁getOrder Items ▁( ▁final ▁String ▁sql ▁) ▁{ ▁List ▁< ▁OrderItem ▁> ▁result ▁= ▁new ▁LinkedList ▁< ▁> ▁( ▁) ▁; ▁try ▁( ▁Pre paredStatement ▁pre paredStatement ▁= ▁connection ▁. ▁prepare Statement ▁( ▁sql ▁) ▁;
▁public ▁static ▁Listener And Text ▁for File ▁( ▁File ▁f ▁, ▁Task Action ▁context ▁) ▁throws ▁IOException ▁{ ▁return ▁new ▁Listener And Text ▁( ▁new ▁StreamTask Listener ▁( ▁f ▁) ▁, ▁new ▁Annotated Large Text ▁< ▁> ▁( ▁f ▁, ▁Charset ▁. ▁defaultCharset ▁( ▁) ▁, ▁false ▁, ▁context ▁) ▁) ▁; ▁} ▁} ▁}
▁if ▁( ▁! ▁success ▁) ▁{ ▁do Multi Files Compact ▁( ▁partition ▁, ▁paths ▁, ▁target ▁) ▁; ▁} ▁double ▁cost Seconds ▁= ▁( ▁( ▁double ▁) ▁( ▁System ▁. ▁current TimeMillis ▁( ▁) ▁- ▁start Millis ▁) ▁) ▁ / ▁1000 ▁; ▁LOG ▁. ▁info ▁( ▁STR ▁, ▁cost Seconds ▁, ▁target ▁, ▁paths ▁) ▁; ▁} ▁private ▁boolean ▁do Single File Move ▁( ▁Path ▁src ▁, ▁Path ▁dst ▁) ▁throws ▁IOException ▁{ ▁Re coverable Writer ▁writer ▁; ▁try ▁{ ▁writer ▁= ▁fileSystem ▁. ▁create Recoverable Writer ▁( ▁) ▁; ▁} ▁catch ▁( ▁Unsupported Operation Exception ▁ignore ▁) ▁{ ▁return ▁false ▁; ▁} ▁Re coverable Fs Data OutputStream ▁out ▁= ▁writer ▁. ▁open ▁( ▁dst ▁) ▁; ▁try ▁( ▁FSData InputStream ▁in ▁= ▁fileSystem ▁. ▁open ▁( ▁src ▁) ▁) ▁{ ▁IOUtils ▁. ▁copy Bytes ▁( ▁in ▁, ▁out ▁, ▁false ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁out ▁. ▁close ▁( ▁) ▁; ▁throw ▁t ▁; ▁} ▁out ▁. ▁close For Commit ▁( ▁) ▁. ▁commit ▁( ▁) ▁; ▁return ▁true ▁; ▁} ▁private ▁void ▁do Multi Files Compact ▁( ▁String ▁partition ▁, ▁List ▁< ▁Path ▁> ▁files ▁, ▁Path ▁dst ▁) ▁throws ▁IOException ▁{ ▁Configuration ▁config ▁= ▁get Containing Task ▁( ▁) ▁. ▁getEnvironment ▁( ▁) ▁. ▁getTask Manager Info ▁( ▁) ▁. ▁get Configuration ▁( ▁) ▁; ▁Compact Writer ▁< ▁T ▁> ▁writer ▁= ▁writer Factory ▁. ▁create ▁( ▁Compact Context ▁. ▁create ▁( ▁config ▁, ▁fileSystem ▁, ▁partition ▁, ▁dst ▁) ▁) ▁; ▁for ▁( ▁Path ▁path ▁: ▁files ▁) ▁{ ▁try ▁( ▁Compact Reader ▁< ▁T ▁> ▁reader ▁= ▁reader Factory ▁. ▁create ▁( ▁Compact Context ▁. ▁create ▁( ▁config ▁, ▁fileSystem ▁, ▁partition ▁, ▁path ▁) ▁) ▁) ▁{ ▁T ▁record ▁; ▁while ▁( ▁( ▁record ▁= ▁reader ▁. ▁read ▁( ▁) ▁) ▁!= ▁null ▁) ▁{ ▁writer ▁. ▁write ▁( ▁record ▁) ▁; ▁} ▁} ▁} ▁writer ▁. ▁commit ▁( ▁) ▁; ▁} ▁private ▁void ▁check Exist ▁( ▁List ▁< ▁Path ▁> ▁candidates ▁) ▁throws ▁IOException ▁{ ▁for ▁( ▁Path ▁path ▁: ▁candidates ▁) ▁{ ▁if ▁( ▁! ▁fileSystem ▁. ▁exists ▁( ▁path ▁) ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁STR ▁+ ▁path ▁) ▁; ▁} ▁} ▁} ▁private ▁static ▁Path ▁create Compact ed File ▁( ▁List ▁< ▁Path ▁> ▁un comp act ed Files ▁) ▁{ ▁Path ▁path ▁= ▁convertFrom Un comp act ed ▁( ▁un comp act ed Files ▁. ▁get ▁( ▁0 ▁) ▁) ▁; ▁return ▁new ▁Path ▁( ▁path ▁. ▁getParent ▁( ▁) ▁, ▁COMP AC TED _ PREFIX ▁+ ▁path ▁. ▁getName ▁( ▁) ▁) ▁; ▁} ▁public ▁static ▁String ▁convertTo Un comp act ed ▁( ▁String ▁path ▁) ▁{ ▁return ▁UN COMP AC TED _ PREFIX ▁+ ▁path ▁; ▁} ▁public ▁static ▁Path ▁convertFrom Un comp act ed ▁( ▁Path ▁path ▁) ▁{ ▁Preconditions ▁. ▁checkArgument ▁( ▁path ▁. ▁getName ▁( ▁) ▁. ▁startsWith ▁( ▁UN COMP AC TED _ PREFIX ▁) ▁, ▁STR ▁+ ▁path ▁) ▁;
▁if ▁( ▁! ▁r en amed ▁) ▁{ ▁Logger ▁. ▁warning ▁( ▁STR ▁+ ▁file ▁. ▁getAbsolutePath ▁( ▁) ▁+ ▁STR ▁+ ▁newFile ▁. ▁getAbsolutePath ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁} ▁@ ▁Nullable ▁private ▁File ▁getCached File ▁( ▁String ▁url ▁) ▁throws ▁FileNot FoundException ▁{ ▁File ▁json File ▁= ▁new ▁File ▁( ▁parent Dir ▁( ▁) ▁, ▁filename For Url ▁( ▁url ▁, ▁File Extension ▁. ▁JSON ▁, ▁false ▁) ▁) ▁; ▁if ▁( ▁json File ▁. ▁exists ▁( ▁) ▁) ▁{ ▁return ▁json File ▁; ▁} ▁File ▁zipFile ▁= ▁new ▁File ▁( ▁parent Dir ▁( ▁) ▁, ▁filename For Url ▁( ▁url ▁, ▁File Extension ▁. ▁ Z IP ▁, ▁false ▁) ▁) ▁; ▁if ▁( ▁zipFile ▁. ▁exists ▁( ▁) ▁) ▁{ ▁return ▁zipFile ▁; ▁} ▁return ▁null ▁; ▁} ▁private ▁File ▁parent Dir ▁( ▁) ▁{ ▁File ▁file ▁= ▁cache Provider ▁. ▁getCache Dir ▁( ▁) ▁; ▁if ▁( ▁file ▁. ▁isFile ▁( ▁) ▁) ▁{ ▁file ▁. ▁delete ▁( ▁) ▁; ▁} ▁if ▁( ▁! ▁file ▁. ▁exists ▁( ▁) ▁) ▁{ ▁file ▁. ▁mkdirs ▁( ▁) ▁; ▁} ▁return ▁file ▁; ▁} ▁private ▁static ▁String ▁filename For Url ▁( ▁String ▁url ▁, ▁File Extension ▁extension ▁, ▁boolean ▁is Temp ▁) ▁{ ▁return ▁STR ▁+ ▁url ▁. ▁replaceAll ▁( ▁STR ▁, ▁STR ▁) ▁+ ▁( ▁is Temp ▁? ▁extension ▁. ▁temp Extension ▁( ▁) ▁: ▁extension ▁. ▁extension ▁) ▁; ▁} ▁}
▁@ ▁RunWith ▁( ▁S uite ▁. ▁class ▁) ▁@ ▁S uite Classes ▁( ▁{ ▁With out Platform s ▁. ▁class ▁, ▁With Platform s ▁. ▁class ▁} ▁) ▁public ▁abstract ▁class ▁Android Resources Test ▁extends ▁Resource TestBase ▁{ ▁@ ▁RunWith ▁( ▁JUnit 4 ▁. ▁class ▁) ▁public ▁static ▁class ▁With out Platform s ▁extends ▁Android Resources Test ▁{ ▁} ▁@ ▁RunWith ▁( ▁JUnit 4 ▁. ▁class ▁) ▁public ▁static ▁class ▁With Platform s ▁extends ▁Android Resources Test ▁{ ▁@ ▁Override ▁protected ▁boolean ▁platform Based Toolchain s ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁private ▁static ▁final ▁PathFragment ▁DEFAULT _ RESOURCE _ ROOT ▁= ▁PathFragment ▁. ▁create ▁( ▁RESOURCE _ ROOT ▁) ▁; ▁private ▁static ▁final ▁ImmutableList ▁< ▁PathFragment ▁> ▁RESOURCE S _ ROOT S ▁= ▁ImmutableList ▁. ▁of ▁( ▁DEFAULT _ RESOURCE _ ROOT ▁) ▁; ▁@ ▁Before ▁public ▁void ▁setup Cc Toolchain ▁( ▁) ▁throws ▁Exception ▁{ ▁get Analysis Mock ▁( ▁) ▁. ▁cc Support ▁( ▁) ▁. ▁setup Cc Toolchain Config For Cpu ▁( ▁mock Tool sConfig ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Before ▁@ ▁Test ▁public ▁void ▁testGet Resource Root s No Resources ▁( ▁) ▁throws ▁Exception ▁{ ▁assertThat ▁( ▁getResource Root s ▁( ▁) ▁) ▁. ▁isEmpty ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testGet Resource Root s Invalid Resource Directory ▁( ▁) ▁throws ▁Exception ▁{ ▁try ▁{ ▁getResource Root s ▁( ▁STR ▁) ▁; ▁assert WithMessage ▁( ▁STR ▁) ▁. ▁fail ▁( ▁) ▁; ▁} ▁catch ▁( ▁Rule ErrorException ▁e ▁) ▁{ ▁} ▁error Consumer ▁. ▁assert Attribute Error ▁( ▁STR ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testGet Resource Root s Multiple Root s ▁( ▁) ▁throws ▁Exception ▁{ ▁try ▁{ ▁getResource Root s ▁( ▁STR ▁, ▁STR ▁) ▁; ▁assert WithMessage ▁( ▁STR ▁) ▁. ▁fail ▁( ▁) ▁; ▁} ▁catch ▁( ▁Rule ErrorException ▁e ▁) ▁{ ▁} ▁error Consumer ▁. ▁assert Attribute Error ▁( ▁STR ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testGet Resource Root s ▁( ▁) ▁throws ▁Exception ▁{ ▁assertThat ▁( ▁getResource Root s ▁( ▁STR ▁, ▁STR ▁) ▁) ▁. ▁isEqualTo ▁( ▁RESOURCE S _ ROOT S ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testGet Resource Root s Common Sub direct ory ▁( ▁) ▁throws ▁Exception ▁{ ▁assertThat ▁( ▁getResource Root s ▁( ▁STR ▁, ▁STR ▁) ▁) ▁. ▁containsExactly ▁( ▁DEFAULT _ RESOURCE _ ROOT ▁. ▁getRelative ▁( ▁STR ▁) ▁) ▁; ▁} ▁private ▁ImmutableList ▁< ▁PathFragment ▁> ▁getResource Root s ▁( ▁String ▁... ▁path Resource Strings ▁) ▁throws ▁Exception ▁{ ▁return ▁getResource Root s ▁( ▁getResources ▁( ▁path Resource Strings ▁) ▁) ▁; ▁} ▁private ▁ImmutableList ▁< ▁PathFragment ▁> ▁getResource Root s ▁( ▁ImmutableList ▁< ▁Artifact ▁> ▁artifact s ▁) ▁throws ▁Exception ▁{ ▁return ▁Android Resources ▁. ▁getResource Root s ▁( ▁error Consumer ▁, ▁artifact s ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Filter Empty ▁( ▁) ▁throws ▁Exception ▁{ ▁assert Filter ▁( ▁ImmutableList ▁. ▁of ▁( ▁) ▁, ▁ImmutableList ▁. ▁of ▁( ▁) ▁) ▁; ▁}
▁public ▁class ▁No OutputStream ing Streaming Simple HttpRequest Factory Tests ▁extends ▁Abstract HttpRequest Factory Tests ▁{ ▁@ ▁Override ▁protected ▁Client HttpRequest Factory ▁createRequest Factory ▁( ▁) ▁{ ▁Simple Client HttpRequest Factory ▁factory ▁= ▁new ▁Simple Client HttpRequest Factory ▁( ▁) ▁; ▁factory ▁. ▁set Buffer RequestBody ▁( ▁false ▁) ▁; ▁factory ▁. ▁set OutputStream ing ▁( ▁false ▁) ▁; ▁return ▁factory ▁; ▁} ▁}
▁@ ▁Test ▁public ▁void ▁test D u pe Index Corruption ▁( ▁) ▁throws ▁Exception ▁{ ▁setup Test Content ▁( ▁) ▁; ▁assertThat ▁( ▁data Path ▁. ▁exists ▁( ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁assertThat ▁( ▁journal Path ▁. ▁exists ▁( ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁assert Index ▁( ▁9 ▁, ▁STR ▁) ▁; ▁ps i ▁. ▁save ▁( ▁) ▁; ▁assertThat ▁( ▁data Path ▁. ▁exists ▁( ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁assertThat ▁( ▁journal Path ▁. ▁exists ▁( ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁byte ▁[ ▁] ▁content ▁= ▁FileSystemUtils ▁. ▁read Content ▁( ▁data Path ▁) ▁; ▁assertThat ▁( ▁data Path ▁. ▁delete ▁( ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁content ▁[ ▁content ▁. ▁length ▁- ▁1 ▁] ▁= ▁content ▁[ ▁content ▁. ▁length ▁- ▁1 ▁] ▁== ▁1 ▁? ▁( ▁byte ▁) ▁2 ▁: ▁( ▁byte ▁) ▁1 ▁; ▁FileSystemUtils ▁. ▁write Content ▁( ▁journal Path ▁, ▁content ▁) ▁; ▁IOException ▁e ▁= ▁assertThrows ▁( ▁IOException ▁. ▁class ▁, ▁( ▁) ▁-> ▁ps i ▁= ▁Persistent String Indexer ▁. ▁new Persistent String Indexer ▁( ▁data Path ▁, ▁clock ▁) ▁) ▁; ▁assertThat ▁( ▁e ▁) ▁. ▁hasMessageThat ▁( ▁) ▁. ▁contains ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test De ferred IO Failure ▁( ▁) ▁throws ▁Exception ▁{ ▁assertThat ▁( ▁data Path ▁. ▁exists ▁( ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁assertThat ▁( ▁journal Path ▁. ▁exists ▁( ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁setup Test Content ▁( ▁) ▁; ▁assertThat ▁( ▁data Path ▁. ▁exists ▁( ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁assertThat ▁( ▁journal Path ▁. ▁exists ▁( ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁FileSystemUtils ▁. ▁createDirectory And Parent s ▁( ▁journal Path ▁) ▁; ▁clock ▁. ▁advance ▁( ▁4 ▁) ▁; ▁assert Index ▁( ▁9 ▁, ▁STR ▁) ▁; ▁assertThat ▁( ▁data Path ▁. ▁exists ▁( ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁clock ▁. ▁advance ▁( ▁4 ▁) ▁; ▁assert Index ▁( ▁10 ▁, ▁STR ▁) ▁; ▁IOException ▁e ▁= ▁assertThrows ▁( ▁IOException ▁. ▁class ▁, ▁( ▁) ▁-> ▁ps i ▁. ▁save ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁e ▁) ▁. ▁hasMessageThat ▁( ▁) ▁. ▁contains ▁( ▁journal Path ▁. ▁getPath String ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁}
▁public ▁class ▁Workspace Status Function ▁implements ▁SkyFunction ▁{ ▁interface ▁Workspace StatusAction Factory ▁{ ▁Workspace StatusAction ▁create ▁( ▁String ▁workspace Name ▁) ▁; ▁} ▁private ▁final ▁Workspace StatusAction Factory ▁workspace StatusAction Factory ▁; ▁Workspace Status Function ▁( ▁Workspace StatusAction Factory ▁workspace StatusAction Factory ▁) ▁{ ▁this ▁. ▁workspace StatusAction Factory ▁= ▁workspace StatusAction Factory ▁; ▁} ▁@ ▁Override ▁public ▁SkyValue ▁compute ▁( ▁SkyKey ▁skyKey ▁, ▁Environment ▁env ▁) ▁throws ▁Interrupted Exception ▁{ ▁Preconditions ▁. ▁checkState ▁( ▁Workspace Status Value ▁. ▁BUILD _ INFO _ KEY ▁. ▁equals ▁( ▁skyKey ▁) ▁, ▁Workspace Status Value ▁. ▁BUILD _ INFO _ KEY ▁) ▁; ▁Workspace Name Value ▁workspace Name Value ▁= ▁( ▁Workspace Name Value ▁) ▁env ▁. ▁getValue ▁( ▁Workspace Name Value ▁. ▁key ▁( ▁) ▁) ▁; ▁if ▁( ▁env ▁. ▁values Missing ▁( ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁Workspace StatusAction ▁action ▁= ▁workspace StatusAction Factory ▁. ▁create ▁( ▁workspace Name Value ▁. ▁getName ▁( ▁) ▁) ▁; ▁return ▁new ▁Workspace Status Value ▁( ▁action ▁. ▁getSt able Status ▁( ▁) ▁, ▁action ▁. ▁getV olatile Status ▁( ▁) ▁, ▁action ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁extract Tag ▁( ▁SkyKey ▁skyKey ▁) ▁{ ▁return ▁null ▁; ▁} ▁}
▁if ▁( ▁new Size ▁> ▁Integer ▁. ▁MAX _ VALUE ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁return ▁( ▁int ▁) ▁new Size ▁; ▁} ▁private ▁int ▁getNum Tile s At Precision ▁( ▁int ▁final Precision ▁, ▁int ▁current Precision ▁) ▁{ ▁final ▁long ▁num Tile s At Precision ▁= ▁Math ▁. ▁min ▁( ▁( ▁long ▁) ▁Math ▁. ▁pow ▁( ▁32 ▁, ▁final Precision ▁- ▁current Precision ▁) ▁+ ▁1 ▁, ▁getMax Cell s ▁( ▁) ▁) ▁; ▁if ▁( ▁num Tile s At Precision ▁> ▁Integer ▁. ▁MAX _ VALUE ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁return ▁( ▁int ▁) ▁num Tile s At Precision ▁; ▁} ▁protected ▁int ▁set Values For Fully Contained Tile ▁( ▁String ▁hash ▁, ▁GeoShape Cell Values ▁values ▁, ▁int ▁values Index ▁, ▁int ▁target Precision ▁) ▁{ ▁String ▁[ ▁] ▁hash es ▁= ▁Geo hash ▁. ▁getSub Geo hash es ▁( ▁hash ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁hash es ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁valid Hash ▁( ▁hash es ▁[ ▁i ▁] ▁) ▁) ▁{ ▁if ▁( ▁hash es ▁[ ▁i ▁] ▁. ▁length ▁( ▁) ▁== ▁target Precision ▁) ▁{ ▁values ▁. ▁add ▁( ▁values Index ▁++ ▁, ▁Geo hash ▁. ▁long Encode ▁( ▁hash es ▁[ ▁i ▁] ▁) ▁) ▁; ▁} ▁else ▁{ ▁values Index ▁= ▁set Values For Fully Contained Tile ▁( ▁hash es ▁[ ▁i ▁] ▁, ▁values ▁, ▁values Index ▁, ▁target Precision ▁) ▁; ▁} ▁} ▁} ▁return ▁values Index ▁; ▁} ▁}
▁public ▁abstract ▁class ▁Wasm Node ▁extends ▁Node ▁implements ▁Wasm Node Interface ▁{ ▁private ▁final ▁Wasm Instance ▁w asm Instance ▁; ▁private ▁final ▁Wasm Code Entry ▁code Entry ▁; ▁@ ▁Compilation Final ▁private ▁int ▁byte Length ▁; ▁public ▁Wasm Node ▁( ▁Wasm Instance ▁w asm Instance ▁, ▁Wasm Code Entry ▁code Entry ▁, ▁int ▁byte Length ▁) ▁{ ▁this ▁. ▁w asm Instance ▁= ▁w asm Instance ▁; ▁this ▁. ▁code Entry ▁= ▁code Entry ▁; ▁this ▁. ▁byte Length ▁= ▁byte Length ▁; ▁} ▁public ▁abstract ▁int ▁execute ▁( ▁Wasm Context ▁context ▁, ▁VirtualFrame ▁frame ▁, ▁long ▁[ ▁] ▁stack loc als ▁) ▁; ▁public ▁abstract ▁byte ▁returnType Id ▁( ▁) ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁protected ▁final ▁void ▁initialize ▁( ▁int ▁byte Length ▁) ▁{ ▁this ▁. ▁byte Length ▁= ▁byte Length ▁; ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁int ▁input Length ▁( ▁) ▁{ ▁return ▁0 ▁; ▁} ▁public ▁int ▁return Length ▁( ▁) ▁{ ▁switch ▁( ▁returnType Id ▁( ▁) ▁) ▁{ ▁case ▁0 x 00 ▁: ▁case ▁0 x 40 ▁: ▁return ▁0 ▁; ▁default ▁: ▁return ▁1 ▁; ▁} ▁} ▁@ ▁Override ▁public ▁final ▁Wasm Code Entry ▁code Entry ▁( ▁) ▁{ ▁return ▁code Entry ▁; ▁} ▁public ▁final ▁Wasm Instance ▁instance ▁( ▁) ▁{ ▁return ▁w asm Instance ▁; ▁} ▁int ▁byte Length ▁( ▁) ▁{ ▁return ▁byte Length ▁; ▁} ▁abstract ▁int ▁int Constant Length ▁( ▁) ▁; ▁abstract ▁int ▁branch Table Length ▁( ▁) ▁; ▁abstract ▁int ▁profile Count ▁( ▁) ▁; ▁}
▁@ ▁Interface Audience ▁. ▁Private ▁public ▁class ▁K MS WebApp ▁implements ▁ServletContext Listener ▁{ ▁private ▁static ▁final ▁Logger ▁LOG ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁K MS WebApp ▁. ▁class ▁) ▁; ▁private ▁static ▁final ▁String ▁METR ICS _ PREFIX ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁ADMIN _ CAL LS _ ME TER ▁= ▁METR ICS _ PREFIX ▁+ ▁STR ▁; ▁private ▁static ▁final ▁String ▁KEY _ CAL LS _ ME TER ▁= ▁METR ICS _ PREFIX ▁+ ▁STR ▁; ▁private ▁static ▁final ▁String ▁INVALID _ CAL LS _ ME TER ▁= ▁METR ICS _ PREFIX ▁+ ▁STR ▁; ▁private ▁static ▁final ▁String ▁UN AUTHORI Z ED _ CAL LS _ ME TER ▁= ▁METR ICS _ PREFIX ▁+ ▁STR ▁; ▁private ▁static ▁final ▁String ▁UN AUTH ENTIC ATED _ CAL LS _ ME TER ▁= ▁METR ICS _ PREFIX ▁+ ▁STR ▁; ▁private ▁static ▁final ▁String ▁GENER ATE _ EE K _ ME TER ▁= ▁METR ICS _ PREFIX ▁+ ▁STR ▁; ▁private ▁static ▁final ▁String ▁DE CRYPT _ EE K _ ME TER ▁= ▁METR ICS _ PREFIX ▁+ ▁STR ▁; ▁private ▁static ▁final ▁String ▁RE EN CRYPT _ EE K _ ME TER ▁= ▁METR ICS _ PREFIX ▁+ ▁STR ▁; ▁private ▁static ▁final ▁String ▁RE EN CRYPT _ EE K _ B ATCH _ ME TER ▁= ▁METR ICS _ PREFIX ▁+ ▁STR ▁; ▁private ▁static ▁MetricRegistry ▁metric Registry ▁; ▁private ▁Jmx Reporter ▁jmx Reporter ▁; ▁private ▁static ▁Configuration ▁k ms Conf ▁; ▁private ▁static ▁K MS ACLs ▁k ms Acls ▁; ▁private ▁static ▁Meter ▁admin Calls Meter ▁; ▁private ▁static ▁Meter ▁key Calls Meter ▁; ▁private ▁static ▁Meter ▁un auth orized Calls Meter ▁; ▁private ▁static ▁Meter ▁un auth enticated Calls Meter ▁; ▁private ▁static ▁Meter ▁decrypt EE K Calls Meter ▁; ▁private ▁static ▁Meter ▁re enc rypt EE K Calls Meter ▁; ▁private ▁static ▁Meter ▁re enc rypt EE K Batch Calls Meter ▁; ▁private ▁static ▁Meter ▁generate EE K Calls Meter ▁; ▁private ▁static ▁Meter ▁invalid Calls Meter ▁; ▁private ▁static ▁K MS Audit ▁k ms Audit ▁; ▁private ▁static ▁Key Provider Crypto Extension ▁key Provider Crypto Extension ▁; ▁static ▁{ ▁SL F 4 J Bridge Handler ▁. ▁remove Handlers For Root Logger ▁( ▁) ▁; ▁SL F 4 J Bridge Handler ▁. ▁install ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁context Initialized ▁( ▁ServletContext Event ▁s ce ▁) ▁{ ▁try ▁{ ▁k ms Conf ▁= ▁K MS Configuration ▁. ▁getK MS Conf ▁( ▁) ▁; ▁UserGroup Information ▁. ▁set Configuration ▁( ▁k ms Conf ▁) ▁; ▁LOG ▁. ▁info ▁( ▁STR ▁) ▁; ▁LOG ▁. ▁info ▁( ▁STR ▁, ▁System ▁. ▁getProperty ▁( ▁STR ▁) ▁) ▁; ▁LOG ▁. ▁info ▁( ▁STR ▁, ▁System ▁. ▁getProperty ▁( ▁STR ▁) ▁) ▁; ▁LOG ▁. ▁info ▁( ▁STR ▁+ ▁Version Info ▁. ▁getVersion ▁( ▁) ▁) ▁; ▁LOG ▁. ▁info ▁( ▁STR ▁) ▁; ▁k ms Acls ▁= ▁new ▁K MS ACLs ▁( ▁) ▁; ▁k ms Acls ▁. ▁start Re loader ▁( ▁) ▁; ▁metric Registry ▁= ▁new ▁MetricRegistry ▁( ▁) ▁;
▁public ▁class ▁None CircuitBreaker Service ▁extends ▁CircuitBreaker Service ▁{ ▁private ▁final ▁CircuitBreaker ▁break er ▁= ▁new ▁Noop CircuitBreaker ▁( ▁CircuitBreaker ▁. ▁FIELD DATA ▁) ▁; ▁public ▁None CircuitBreaker Service ▁( ▁) ▁{ ▁super ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁CircuitBreaker ▁getB reak er ▁( ▁String ▁name ▁) ▁{ ▁return ▁break er ▁; ▁} ▁@ ▁Override ▁public ▁All CircuitBreaker Stats ▁stats ▁( ▁) ▁{ ▁return ▁new ▁All CircuitBreaker Stats ▁( ▁new ▁CircuitBreaker Stats ▁[ ▁] ▁{ ▁stats ▁( ▁CircuitBreaker ▁. ▁FIELD DATA ▁) ▁} ▁) ▁; ▁} ▁@ ▁Override ▁public ▁CircuitBreaker Stats ▁stats ▁( ▁String ▁name ▁) ▁{ ▁return ▁new ▁CircuitBreaker Stats ▁( ▁CircuitBreaker ▁. ▁FIELD DATA ▁, ▁- ▁1 ▁, ▁- ▁1 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁} ▁}
▁return ▁new ▁Column Chunk ▁( ▁row Block ▁, ▁column Chunk ▁. ▁get Definition Levels ▁( ▁) ▁, ▁column Chunk ▁. ▁getRe petition Levels ▁( ▁) ▁) ▁; ▁} ▁private ▁Column Chunk ▁read Primitive ▁( ▁Primitive Field ▁field ▁) ▁throws ▁IOException ▁{ ▁Column Descriptor ▁column Descriptor ▁= ▁field ▁. ▁getDescriptor ▁( ▁) ▁; ▁int ▁field Id ▁= ▁field ▁. ▁getId ▁( ▁) ▁; ▁Column Reader ▁column Reader ▁= ▁column Re aders ▁[ ▁field Id ▁] ▁; ▁if ▁( ▁! ▁column Reader ▁. ▁isInitialized ▁( ▁) ▁) ▁{ ▁validate Par quet ▁( ▁current Block Metadata ▁. ▁getRowCount ▁( ▁) ▁> ▁0 ▁, ▁STR ▁) ▁; ▁Column Chunk MetaData ▁metadata ▁= ▁getColumn Chunk MetaData ▁( ▁column Descriptor ▁) ▁; ▁long ▁starting Position ▁= ▁metadata ▁. ▁getStart ing Pos ▁( ▁) ▁; ▁int ▁totalSize ▁= ▁toIntExact ▁( ▁metadata ▁. ▁getTotal Size ▁( ▁) ▁) ▁; ▁byte ▁[ ▁] ▁buffer ▁= ▁allocate Block ▁( ▁totalSize ▁) ▁; ▁dataSource ▁. ▁readFully ▁( ▁starting Position ▁, ▁buffer ▁) ▁; ▁Column Chunk Descriptor ▁descriptor ▁= ▁new ▁Column Chunk Descriptor ▁( ▁column Descriptor ▁, ▁metadata ▁, ▁totalSize ▁) ▁; ▁Parquet Column Chunk ▁column Chunk ▁= ▁new ▁Parquet Column Chunk ▁( ▁descriptor ▁, ▁buffer ▁, ▁0 ▁) ▁; ▁column Reader ▁. ▁init ▁( ▁column Chunk ▁. ▁readAll Pages ▁( ▁) ▁, ▁field ▁) ▁; ▁if ▁( ▁enable Verification ▁) ▁{ ▁Column Reader ▁verification Column Reader ▁= ▁verification Column Re aders ▁[ ▁field ▁. ▁getId ▁( ▁) ▁] ▁; ▁Parquet Column Chunk ▁column Chunk Ver f ication ▁= ▁new ▁Parquet Column Chunk ▁( ▁descriptor ▁, ▁buffer ▁, ▁0 ▁) ▁; ▁verification Column Reader ▁. ▁init ▁( ▁column Chunk Ver f ication ▁. ▁readAll Pages ▁( ▁) ▁, ▁field ▁) ▁; ▁} ▁} ▁Column Chunk ▁column Chunk ▁= ▁column Reader ▁. ▁readNext ▁( ▁) ▁; ▁column Chunk ▁= ▁type Coer c ion ▁( ▁column Chunk ▁, ▁field ▁. ▁getDescriptor ▁( ▁) ▁. ▁getP rimitive Type ▁( ▁) ▁. ▁getP rimitive TypeName ▁( ▁) ▁, ▁field ▁. ▁getType ▁( ▁) ▁) ▁; ▁if ▁( ▁enable Verification ▁) ▁{ ▁Column Reader ▁verification Column Reader ▁= ▁verification Column Re aders ▁[ ▁field ▁. ▁getId ▁( ▁) ▁] ▁; ▁Column Chunk ▁expected ▁= ▁verification Column Reader ▁. ▁readNext ▁( ▁) ▁; ▁Parquet Result Verifier Utils ▁. ▁verify Column Chunks ▁( ▁column Chunk ▁, ▁expected ▁, ▁column Descriptor ▁. ▁getPath ▁( ▁) ▁. ▁length ▁> ▁1 ▁, ▁field ▁, ▁dataSource ▁. ▁getId ▁( ▁) ▁) ▁; ▁} ▁long ▁bytes Per Cell ▁= ▁column Chunk ▁. ▁getBlock ▁( ▁) ▁. ▁getSizeInBytes ▁( ▁) ▁ / ▁batchSize ▁; ▁if ▁( ▁maxBytes Per Cell ▁[ ▁field Id ▁] ▁< ▁bytes Per Cell ▁) ▁{ ▁max Combined Bytes Per Row ▁= ▁max Combined Bytes Per Row ▁- ▁maxBytes Per Cell ▁[ ▁field Id ▁] ▁+ ▁bytes Per Cell ▁; ▁max BatchSize ▁= ▁toIntExact ▁( ▁min ▁( ▁max BatchSize ▁, ▁max ▁( ▁1 ▁, ▁max Read Block Bytes ▁ / ▁max Combined Bytes Per Row ▁) ▁) ▁) ▁; ▁maxBytes Per Cell ▁[ ▁field Id ▁] ▁= ▁bytes Per Cell ▁; ▁} ▁return ▁column Chunk ▁; ▁}
▁sb ▁. ▁append ▁( ▁STR ▁) ▁. ▁append ▁( ▁to In d ented String ▁( ▁code ▁) ▁) ▁. ▁append ▁( ▁STR ▁) ▁; ▁sb ▁. ▁append ▁( ▁STR ▁) ▁. ▁append ▁( ▁to In d ented String ▁( ▁type ▁) ▁) ▁. ▁append ▁( ▁STR ▁) ▁; ▁sb ▁. ▁append ▁( ▁STR ▁) ▁. ▁append ▁( ▁to In d ented String ▁( ▁message ▁) ▁) ▁. ▁append ▁( ▁STR ▁) ▁; ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁return ▁sb ▁. ▁toString ▁( ▁) ▁; ▁} ▁private ▁String ▁to In d ented String ▁( ▁java ▁. ▁lang ▁. ▁Object ▁o ▁) ▁{ ▁if ▁( ▁o ▁== ▁null ▁) ▁{ ▁return ▁STR ▁; ▁} ▁return ▁o ▁. ▁toString ▁( ▁) ▁. ▁replace ▁( ▁STR ▁, ▁STR ▁) ▁; ▁} ▁}
▁@ ▁SpringBoot Application ▁public ▁class ▁Application ▁{ ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Spring Application ▁. ▁run ▁( ▁Application ▁. ▁class ▁, ▁args ▁) ▁; ▁} ▁}
▁public ▁class ▁F tp ▁extends ▁Abstract F tp ▁{ ▁public ▁static ▁final ▁int ▁DEFAULT _ PORT ▁= ▁21 ▁; ▁private ▁F T P Client ▁client ▁; ▁private ▁F tp Mode ▁mode ▁; ▁private ▁boolean ▁back To P wd ▁; ▁public ▁F tp ▁( ▁String ▁host ▁) ▁{ ▁this ▁( ▁host ▁, ▁DEFAULT _ PORT ▁) ▁; ▁} ▁public ▁F tp ▁( ▁String ▁host ▁, ▁int ▁port ▁) ▁{ ▁this ▁( ▁host ▁, ▁port ▁, ▁STR ▁, ▁STR ▁) ▁; ▁} ▁public ▁F tp ▁( ▁String ▁host ▁, ▁int ▁port ▁, ▁String ▁user ▁, ▁String ▁password ▁) ▁{ ▁this ▁( ▁host ▁, ▁port ▁, ▁user ▁, ▁password ▁, ▁CharsetUtil ▁. ▁CHARSET _ UTF _8 ▁) ▁; ▁} ▁public ▁F tp ▁( ▁String ▁host ▁, ▁int ▁port ▁, ▁String ▁user ▁, ▁String ▁password ▁, ▁Charset ▁charset ▁) ▁{ ▁this ▁( ▁host ▁, ▁port ▁, ▁user ▁, ▁password ▁, ▁charset ▁, ▁null ▁, ▁null ▁) ▁; ▁} ▁public ▁F tp ▁( ▁String ▁host ▁, ▁int ▁port ▁, ▁String ▁user ▁, ▁String ▁password ▁, ▁Charset ▁charset ▁, ▁String ▁server Language Code ▁, ▁String ▁system Key ▁) ▁{ ▁this ▁( ▁host ▁, ▁port ▁, ▁user ▁, ▁password ▁, ▁charset ▁, ▁server Language Code ▁, ▁system Key ▁, ▁null ▁) ▁; ▁} ▁public ▁F tp ▁( ▁String ▁host ▁, ▁int ▁port ▁, ▁String ▁user ▁, ▁String ▁password ▁, ▁Charset ▁charset ▁, ▁String ▁server Language Code ▁, ▁String ▁system Key ▁, ▁F tp Mode ▁mode ▁) ▁{ ▁this ▁( ▁new ▁F tp Config ▁( ▁host ▁, ▁port ▁, ▁user ▁, ▁password ▁, ▁charset ▁, ▁server Language Code ▁, ▁system Key ▁) ▁, ▁mode ▁) ▁; ▁} ▁public ▁F tp ▁( ▁F tp Config ▁config ▁, ▁F tp Mode ▁mode ▁) ▁{ ▁super ▁( ▁config ▁) ▁; ▁this ▁. ▁mode ▁= ▁mode ▁; ▁this ▁. ▁init ▁( ▁) ▁; ▁} ▁public ▁F tp ▁init ▁( ▁) ▁{ ▁return ▁this ▁. ▁init ▁( ▁this ▁. ▁f tp Config ▁, ▁this ▁. ▁mode ▁) ▁; ▁} ▁public ▁F tp ▁init ▁( ▁String ▁host ▁, ▁int ▁port ▁, ▁String ▁user ▁, ▁String ▁password ▁) ▁{ ▁return ▁this ▁. ▁init ▁( ▁host ▁, ▁port ▁, ▁user ▁, ▁password ▁, ▁null ▁) ▁; ▁} ▁public ▁F tp ▁init ▁( ▁String ▁host ▁, ▁int ▁port ▁, ▁String ▁user ▁, ▁String ▁password ▁, ▁F tp Mode ▁mode ▁) ▁{ ▁return ▁init ▁( ▁new ▁F tp Config ▁( ▁host ▁, ▁port ▁, ▁user ▁, ▁password ▁, ▁this ▁. ▁f tp Config ▁. ▁getCharset ▁( ▁) ▁, ▁null ▁, ▁null ▁) ▁, ▁mode ▁) ▁; ▁} ▁public ▁F tp ▁init ▁( ▁F tp Config ▁config ▁, ▁F tp Mode ▁mode ▁) ▁{ ▁final ▁F T P Client ▁client ▁= ▁new ▁F T P Client ▁( ▁) ▁; ▁client ▁. ▁set Remote Verification Enabled ▁( ▁false ▁) ▁; ▁final ▁Charset ▁charset ▁= ▁config ▁. ▁getCharset ▁( ▁) ▁; ▁if ▁( ▁null ▁!= ▁charset ▁) ▁{ ▁client ▁. ▁set Control Encoding ▁( ▁charset ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁client ▁. ▁set ConnectTimeout ▁( ▁( ▁int ▁) ▁config ▁. ▁getConnection Timeout ▁( ▁) ▁) ▁;
▁concurrent In coming Recover ies ▁= ▁CLUSTER _ R OUT ING _ AL LOCATION _ NODE _ CON CURRENT _ IN COM ING _ RE CO VER IES _ SETTING ▁. ▁get ▁( ▁settings ▁) ▁; ▁concurrent Out going Recover ies ▁= ▁CLUSTER _ R OUT ING _ AL LOCATION _ NODE _ CON CURRENT _ OUT G O ING _ RE CO VER IES _ SETTING ▁. ▁get ▁( ▁settings ▁) ▁; ▁cluster Settings ▁. ▁add Settings Update Consumer ▁( ▁CLUSTER _ R OUT ING _ AL LOCATION _ NODE _ INIT IAL _ PRI MAR IES _ RE CO VER IES _ SETTING ▁, ▁this ▁:: ▁setP rim aries Initial Recover ies ▁) ▁; ▁cluster Settings ▁. ▁add Settings Update Consumer ▁( ▁CLUSTER _ R OUT ING _ AL LOCATION _ NODE _ CON CURRENT _ IN COM ING _ RE CO VER IES _ SETTING ▁, ▁this ▁:: ▁set Concurrent In coming Recover ries ▁) ▁; ▁cluster Settings ▁. ▁add Settings Update Consumer ▁( ▁CLUSTER _ R OUT ING _ AL LOCATION _ NODE _ CON CURRENT _ OUT G O ING _ RE CO VER IES _ SETTING ▁, ▁this ▁:: ▁set Concurrent Out going Recover ries ▁) ▁; ▁logger ▁. ▁debug ▁( ▁STR ▁+ ▁STR ▁, ▁concurrent Out going Recover ies ▁, ▁concurrent In coming Recover ies ▁, ▁p rim aries Initial Recover ies ▁) ▁; ▁} ▁private ▁void ▁set Concurrent In coming Recover ries ▁( ▁int ▁concurrent In coming Recover ies ▁) ▁{ ▁this ▁. ▁concurrent In coming Recover ies ▁= ▁concurrent In coming Recover ies ▁; ▁} ▁private ▁void ▁set Concurrent Out going Recover ries ▁( ▁int ▁concurrent Out going Recover ies ▁) ▁{ ▁this ▁. ▁concurrent Out going Recover ies ▁= ▁concurrent Out going Recover ies ▁; ▁} ▁private ▁void ▁setP rim aries Initial Recover ies ▁( ▁int ▁p rim aries Initial Recover ies ▁) ▁{ ▁this ▁. ▁p rim aries Initial Recover ies ▁= ▁p rim aries Initial Recover ies ▁; ▁} ▁@ ▁Override ▁public ▁Decision ▁can Allocate ▁( ▁ShardRouting ▁shardRouting ▁, ▁Rout ingNode ▁node ▁, ▁Routing Allocation ▁allocation ▁) ▁{ ▁if ▁( ▁shardRouting ▁. ▁primary ▁( ▁) ▁&& ▁shardRouting ▁. ▁un assigned ▁( ▁) ▁) ▁{ ▁assert ▁init ializing Shard ▁( ▁shardRouting ▁, ▁node ▁. ▁nodeId ▁( ▁) ▁) ▁. ▁recovery Source ▁( ▁) ▁. ▁getType ▁( ▁) ▁!= ▁Recovery Source ▁. ▁Type ▁. ▁PE ER ▁; ▁int ▁p rim aries In Recovery ▁= ▁0 ▁; ▁for ▁( ▁ShardRouting ▁shard ▁: ▁node ▁. ▁shard sWith State ▁( ▁ShardRouting State ▁. ▁INIT IALI Z ING ▁) ▁) ▁{ ▁if ▁( ▁shard ▁. ▁primary ▁( ▁) ▁&& ▁shard ▁. ▁reloc ating NodeId ▁( ▁) ▁== ▁null ▁) ▁{ ▁p rim aries In Recovery ▁++ ▁; ▁} ▁}
▁@ ▁GwtCompatible ▁( ▁emulated ▁= ▁true ▁) ▁public ▁class ▁ByteArray AsList Test ▁extends ▁TestCase ▁{ ▁private ▁static ▁List ▁< ▁Byte ▁> ▁asList ▁( ▁Byte ▁[ ▁] ▁values ▁) ▁{ ▁byte ▁[ ▁] ▁temp ▁= ▁new ▁byte ▁[ ▁values ▁. ▁length ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁values ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁temp ▁[ ▁i ▁] ▁= ▁checkNotNull ▁( ▁values ▁[ ▁i ▁] ▁) ▁; ▁} ▁return ▁Bytes ▁. ▁asList ▁( ▁temp ▁) ▁; ▁} ▁@ ▁GwtIncompatible ▁public ▁static ▁Test ▁suite ▁( ▁) ▁{ ▁List ▁< ▁List TestSuiteBuilder ▁< ▁Byte ▁> ▁> ▁builder s ▁= ▁ImmutableList ▁. ▁of ▁( ▁List TestSuiteBuilder ▁. ▁using ▁( ▁new ▁Bytes As ListGenerator ▁( ▁) ▁) ▁. ▁named ▁( ▁STR ▁) ▁, ▁List TestSuiteBuilder ▁. ▁using ▁( ▁new ▁Bytes AsList Head Sub ListGenerator ▁( ▁) ▁) ▁. ▁named ▁( ▁STR ▁) ▁, ▁List TestSuiteBuilder ▁. ▁using ▁( ▁new ▁Bytes AsList Tail Sub ListGenerator ▁( ▁) ▁) ▁. ▁named ▁( ▁STR ▁) ▁, ▁List TestSuiteBuilder ▁. ▁using ▁( ▁new ▁Bytes AsList Middle Sub ListGenerator ▁( ▁) ▁) ▁. ▁named ▁( ▁STR ▁) ▁) ▁; ▁TestSuite ▁suite ▁= ▁new ▁TestSuite ▁( ▁) ▁; ▁for ▁( ▁List TestSuiteBuilder ▁< ▁Byte ▁> ▁builder ▁: ▁builder s ▁) ▁{ ▁suite ▁. ▁addTest ▁( ▁builder ▁. ▁withFeatures ▁( ▁CollectionSize ▁. ▁ONE ▁, ▁CollectionSize ▁. ▁SEVER AL ▁, ▁Collection Feature ▁. ▁RE STR ICT S _ ELEMENT S ▁, ▁List Feature ▁. ▁SUPPORTS _ SET ▁) ▁. ▁createTest Suite ▁( ▁) ▁) ▁; ▁} ▁return ▁suite ▁; ▁} ▁public ▁static ▁final ▁class ▁Bytes As ListGenerator ▁extends ▁Test Byte ListGenerator ▁{ ▁@ ▁Override ▁protected ▁List ▁< ▁Byte ▁> ▁create ▁( ▁Byte ▁[ ▁] ▁elements ▁) ▁{ ▁return ▁asList ▁( ▁elements ▁) ▁; ▁} ▁} ▁public ▁static ▁final ▁class ▁Bytes AsList Head Sub ListGenerator ▁extends ▁Test Byte ListGenerator ▁{ ▁@ ▁Override ▁protected ▁List ▁< ▁Byte ▁> ▁create ▁( ▁Byte ▁[ ▁] ▁elements ▁) ▁{ ▁Byte ▁[ ▁] ▁suffix ▁= ▁{ ▁Byte ▁. ▁MIN _ VALUE ▁, ▁Byte ▁. ▁MAX _ VALUE ▁} ▁; ▁Byte ▁[ ▁] ▁all ▁= ▁concat ▁( ▁elements ▁, ▁suffix ▁) ▁; ▁return ▁asList ▁( ▁all ▁) ▁. ▁subList ▁( ▁0 ▁, ▁elements ▁. ▁length ▁) ▁; ▁} ▁} ▁public ▁static ▁final ▁class ▁Bytes AsList Tail Sub ListGenerator ▁extends ▁Test Byte ListGenerator ▁{ ▁@ ▁Override ▁protected ▁List ▁< ▁Byte ▁> ▁create ▁( ▁Byte ▁[ ▁] ▁elements ▁) ▁{ ▁Byte ▁[ ▁] ▁prefix ▁= ▁{ ▁( ▁byte ▁) ▁8 6 ▁, ▁( ▁byte ▁) ▁99 ▁} ▁; ▁Byte ▁[ ▁] ▁all ▁= ▁concat ▁( ▁prefix ▁, ▁elements ▁) ▁; ▁return ▁asList ▁( ▁all ▁) ▁. ▁subList ▁( ▁2 ▁, ▁elements ▁. ▁length ▁+ ▁2 ▁) ▁; ▁} ▁} ▁public ▁static ▁final ▁class ▁Bytes AsList Middle Sub ListGenerator ▁extends ▁Test Byte ListGenerator ▁{ ▁@ ▁Override ▁protected ▁List ▁< ▁Byte ▁> ▁create ▁( ▁Byte ▁[ ▁] ▁elements ▁) ▁{ ▁Byte ▁[ ▁] ▁prefix ▁= ▁{ ▁Byte ▁. ▁MIN _ VALUE ▁, ▁Byte ▁. ▁MAX _ VALUE ▁} ▁; ▁Byte ▁[ ▁] ▁suffix ▁= ▁{ ▁( ▁byte ▁) ▁8 6 ▁, ▁( ▁byte ▁) ▁99 ▁} ▁;
▁if ▁( ▁max Out st anding Read Requests ▁!= ▁null ▁&& ▁max Out st anding Read Requests ▁< ▁1 ▁) ▁{ ▁e ▁= ▁add ValidationError ▁( ▁MAX _ OUT ST AND ING _ READ _ REQUEST S ▁. ▁getPreferred Name ▁( ▁) ▁+ ▁STR ▁, ▁e ▁) ▁; ▁} ▁if ▁( ▁max WriteRequest Operation Count ▁!= ▁null ▁&& ▁max WriteRequest Operation Count ▁< ▁1 ▁) ▁{ ▁e ▁= ▁add ValidationError ▁( ▁MAX _ WRITE _ REQUEST _ OPERATION _ COUNT ▁. ▁getPreferred Name ▁( ▁) ▁+ ▁STR ▁, ▁e ▁) ▁; ▁} ▁if ▁( ▁max WriteRequest Size ▁!= ▁null ▁&& ▁max WriteRequest Size ▁. ▁compareTo ▁( ▁ByteSizeValue ▁. ▁ Z ERO ▁) ▁<= ▁0 ▁) ▁{ ▁e ▁= ▁add ValidationError ▁( ▁MAX _ WRITE _ REQUEST _ SI Z E ▁. ▁getPreferred Name ▁( ▁) ▁+ ▁STR ▁, ▁e ▁) ▁; ▁} ▁if ▁( ▁max Out st anding Write Requests ▁!= ▁null ▁&& ▁max Out st anding Write Requests ▁< ▁1 ▁) ▁{ ▁e ▁= ▁add ValidationError ▁( ▁MAX _ OUT ST AND ING _ WRITE _ REQUEST S ▁. ▁getPreferred Name ▁( ▁) ▁+ ▁STR ▁, ▁e ▁) ▁; ▁} ▁if ▁( ▁max Write Buffer Count ▁!= ▁null ▁&& ▁max Write Buffer Count ▁< ▁1 ▁) ▁{ ▁e ▁= ▁add ValidationError ▁( ▁MAX _ WRITE _ BUFFER _ COUNT ▁. ▁getPreferred Name ▁( ▁) ▁+ ▁STR ▁, ▁e ▁) ▁; ▁} ▁if ▁( ▁max Write BufferSize ▁!= ▁null ▁&& ▁max Write BufferSize ▁. ▁compareTo ▁( ▁ByteSizeValue ▁. ▁ Z ERO ▁) ▁<= ▁0 ▁) ▁{ ▁e ▁= ▁add ValidationError ▁( ▁MAX _ WRITE _ BUFFER _ SI Z E ▁. ▁getPreferred Name ▁( ▁) ▁+ ▁STR ▁, ▁e ▁) ▁; ▁} ▁if ▁( ▁max Retry Delay ▁!= ▁null ▁&& ▁max Retry Delay ▁. ▁millis ▁( ▁) ▁<= ▁0 ▁) ▁{ ▁String ▁message ▁= ▁STR ▁+ ▁MAX _ RETRY _ DELAY ▁. ▁getPreferred Name ▁( ▁) ▁+ ▁STR ▁+ ▁max Retry Delay ▁. ▁getString Rep ▁( ▁) ▁+ ▁STR ▁; ▁e ▁= ▁add ValidationError ▁( ▁message ▁, ▁e ▁) ▁; ▁} ▁if ▁( ▁max Retry Delay ▁!= ▁null ▁&& ▁max Retry Delay ▁. ▁millis ▁( ▁) ▁> ▁RETRY _ DELAY _ MAX ▁. ▁millis ▁( ▁) ▁) ▁{ ▁String ▁message ▁= ▁STR ▁+ ▁MAX _ RETRY _ DELAY ▁. ▁getPreferred Name ▁( ▁) ▁+ ▁STR ▁+ ▁RETRY _ DELAY _ MAX ▁. ▁getString Rep ▁( ▁) ▁+ ▁STR ▁+ ▁max Retry Delay ▁. ▁getString Rep ▁( ▁) ▁+ ▁STR ▁; ▁e ▁= ▁add ValidationError ▁( ▁message ▁, ▁e ▁) ▁; ▁} ▁return ▁e ▁; ▁} ▁public ▁Follow Parameters ▁( ▁StreamInput ▁in ▁) ▁throws ▁IOException ▁{ ▁from Stream Input ▁( ▁in ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁writeTo ▁( ▁StreamOutput ▁out ▁) ▁throws ▁IOException ▁{ ▁out ▁. ▁writeOptional VInt ▁( ▁max Read Request Operation Count ▁) ▁; ▁out ▁. ▁writeOptional VInt ▁( ▁max Out st anding Read Requests ▁) ▁; ▁out ▁. ▁writeOptional Writeable ▁( ▁max Read Request Size ▁) ▁; ▁out ▁. ▁writeOptional VInt ▁( ▁max WriteRequest Operation Count ▁) ▁;
▁public ▁void ▁install ▁( ▁) ▁throws ▁IOException ▁{ ▁assert ▁archive ▁!= ▁null ▁: ▁STR ▁; ▁install Content ▁( ▁) ▁; ▁install Finish ▁( ▁) ▁; ▁} ▁void ▁install Content ▁( ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁archive ▁== ▁null ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁un pack Files ▁( ▁) ▁; ▁archive ▁. ▁complete Metadata ▁( ▁component Info ▁) ▁; ▁process Permissions ▁( ▁) ▁; ▁create Symlink s ▁( ▁) ▁; ▁List ▁< ▁String ▁> ▁ll ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁get Tracked Paths ▁( ▁) ▁) ▁; ▁Collections ▁. ▁sort ▁( ▁ll ▁) ▁; ▁component Info ▁. ▁set Paths ▁( ▁ll ▁) ▁; ▁re build P olyglot ▁= ▁component Info ▁. ▁isP olyglot Re build ▁( ▁) ▁|| ▁ll ▁. ▁stream ▁( ▁) ▁. ▁filter ▁( ▁p ▁-> ▁p ▁. ▁startsWith ▁( ▁Common Constants ▁. ▁PATH _ POL Y G LO T _ REG ISTRY ▁) ▁) ▁. ▁find Any ▁( ▁) ▁. ▁isPresent ▁( ▁) ▁; ▁} ▁void ▁install Finish ▁( ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁! ▁isD ry Run ▁( ▁) ▁) ▁{ ▁registry ▁. ▁add Component ▁( ▁getComponent Info ▁( ▁) ▁) ▁; ▁} ▁} ▁void ▁un pack Files ▁( ▁) ▁throws ▁IOException ▁{ ▁final ▁String ▁storage Prefix ▁= ▁Common Constants ▁. ▁PATH _ COMP ONENT _ STORAGE ▁+ ▁STR ▁; ▁for ▁( ▁Archive ▁. ▁File Entry ▁entry ▁: ▁archive ▁) ▁{ ▁String ▁path ▁= ▁entry ▁. ▁getName ▁( ▁) ▁; ▁if ▁( ▁! ▁allow Files In Component Dir ▁&& ▁path ▁. ▁startsWith ▁( ▁storage Prefix ▁) ▁&& ▁path ▁. ▁length ▁( ▁) ▁> ▁storage Prefix ▁. ▁length ▁( ▁) ▁) ▁{ ▁if ▁( ▁path ▁. ▁indexOf ▁( ▁CHAR ▁, ▁storage Prefix ▁. ▁length ▁( ▁) ▁) ▁== ▁- ▁1 ▁) ▁{ ▁continue ▁; ▁} ▁} ▁install One Entry ▁( ▁entry ▁) ▁; ▁} ▁} ▁void ▁ensure Path Exists ▁( ▁Path ▁target Path ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁! ▁visited Paths ▁. ▁add ▁( ▁target Path ▁) ▁) ▁{ ▁return ▁; ▁} ▁Path ▁parent ▁= ▁getIn st all Path ▁( ▁) ▁; ▁if ▁( ▁! ▁target Path ▁. ▁normalize ▁( ▁) ▁. ▁startsWith ▁( ▁parent ▁) ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁feedback ▁. ▁l 10 n ▁( ▁STR ▁, ▁target Path ▁) ▁) ▁; ▁} ▁Path ▁relative ▁= ▁getIn st all Path ▁( ▁) ▁. ▁re lat iv ize ▁( ▁target Path ▁) ▁; ▁Path ▁relative Sub path ▁; ▁int ▁count ▁= ▁0 ▁; ▁for ▁( ▁Path ▁n ▁: ▁relative ▁) ▁{ ▁count ▁++ ▁; ▁relative Sub path ▁= ▁relative ▁. ▁sub path ▁( ▁0 ▁, ▁count ▁) ▁; ▁Path ▁dir ▁= ▁file Ops ▁. ▁m aterialize ▁( ▁parent ▁. ▁resolve ▁( ▁n ▁) ▁, ▁true ▁) ▁; ▁String ▁path String ▁= ▁System Utils ▁. ▁to Common Path ▁( ▁relative Sub path ▁) ▁+ ▁STR ▁; ▁if ▁( ▁! ▁Files ▁. ▁exists ▁( ▁dir ▁) ▁|| ▁getComponent Directories ▁( ▁) ▁. ▁contains ▁( ▁path String ▁) ▁) ▁{ ▁feedback ▁. ▁verbose Output ▁( ▁STR ▁, ▁dir ▁) ▁;
▁public ▁class ▁Hash Test ▁extends ▁AbstractP olyglot Test ▁{ ▁@ ▁Test ▁public ▁void ▁test Truffle Object Interop Messages ▁( ▁) ▁throws ▁Interop Exception ▁{ ▁setup Env ▁( ▁) ▁; ▁for ▁( ▁Key Factory ▁< ▁? ▁> ▁factory ▁: ▁Key Factory ▁. ▁ALL ▁) ▁{ ▁test Interop Messages ▁( ▁new ▁Hash ▁( ▁) ▁, ▁factory ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Host Object Interop Messages ▁( ▁) ▁throws ▁Interop Exception ▁{ ▁setup Env ▁( ▁Context ▁. ▁newBuilder ▁( ▁) ▁. ▁allow All Access ▁( ▁true ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁Access or ▁accessor ▁= ▁new ▁Access or ▁( ▁) ▁; ▁Value ▁accessor Value ▁= ▁context ▁. ▁as Value ▁( ▁accessor ▁) ▁; ▁for ▁( ▁Key Factory ▁< ▁? ▁> ▁factory ▁: ▁Key Factory ▁. ▁ALL ▁) ▁{ ▁accessor Value ▁. ▁execute ▁( ▁context ▁. ▁as Value ▁( ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁) ▁) ▁; ▁test Interop Messages ▁( ▁accessor ▁. ▁object ▁, ▁factory ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test P olyglot Proxy Interop Messages ▁( ▁) ▁throws ▁Interop Exception ▁{ ▁setup Env ▁( ▁) ▁; ▁Access or ▁accessor ▁= ▁new ▁Access or ▁( ▁) ▁; ▁Value ▁accessor Value ▁= ▁context ▁. ▁as Value ▁( ▁accessor ▁) ▁; ▁for ▁( ▁Key Factory ▁< ▁? ▁> ▁factory ▁: ▁Key Factory ▁. ▁ALL ▁) ▁{ ▁accessor Value ▁. ▁execute ▁( ▁context ▁. ▁as Value ▁( ▁Proxy HashMap ▁. ▁from ▁( ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁) ▁) ▁) ▁; ▁test Interop Messages ▁( ▁accessor ▁. ▁object ▁, ▁factory ▁) ▁; ▁} ▁} ▁private ▁static ▁void ▁test Interop Messages ▁( ▁Object ▁hash ▁, ▁Key Factory ▁< ▁? ▁> ▁key Factory ▁) ▁throws ▁Interop Exception ▁{ ▁final ▁int ▁count ▁= ▁100 ▁; ▁final ▁int ▁inc ▁= ▁2 ▁; ▁InteropLibrary ▁interop ▁= ▁InteropLibrary ▁. ▁getUncached ▁( ▁) ▁; ▁assertTrue ▁( ▁interop ▁. ▁has Hash Entries ▁( ▁hash ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁count ▁; ▁i ▁+= ▁inc ▁) ▁{ ▁Object ▁key ▁= ▁key Factory ▁. ▁create ▁( ▁i ▁) ▁; ▁Object ▁value ▁= ▁i ▁; ▁assert Non Existing ▁( ▁hash ▁, ▁key ▁, ▁interop ▁) ▁; ▁interop ▁. ▁write Hash Entry ▁( ▁hash ▁, ▁key ▁, ▁value ▁) ▁; ▁} ▁assertEquals ▁( ▁( ▁count ▁ / ▁inc ▁) ▁, ▁interop ▁. ▁getHash Size ▁( ▁hash ▁) ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁count ▁; ▁i ▁++ ▁) ▁{ ▁Object ▁key ▁= ▁key Factory ▁. ▁create ▁( ▁i ▁) ▁; ▁if ▁( ▁( ▁i ▁& ▁1 ▁) ▁== ▁0 ▁) ▁{ ▁Object ▁expectedValue ▁= ▁i ▁; ▁assert Existing ▁( ▁hash ▁, ▁key ▁, ▁interop ▁) ▁; ▁assertEquals ▁( ▁expectedValue ▁, ▁interop ▁. ▁read Hash Value ▁( ▁hash ▁, ▁key ▁) ▁) ▁; ▁assertEquals ▁( ▁expectedValue ▁, ▁interop ▁. ▁read Hash Value OrDefault ▁( ▁hash ▁, ▁key ▁, ▁STR ▁) ▁) ▁; ▁} ▁else ▁{ ▁assert Non Existing ▁( ▁hash ▁, ▁key ▁, ▁interop ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁interop ▁. ▁read Hash Value OrDefault ▁( ▁hash ▁, ▁key ▁, ▁STR ▁) ▁) ▁; ▁}
▁public ▁final ▁class ▁Tra v is Download Cache ▁extends ▁Abstract Download Cache ▁{ ▁private ▁static ▁final ▁String ▁CACHE _ FILE _ NAME _ DELIMITER ▁= ▁STR ▁; ▁private ▁static ▁final ▁Pattern ▁CACHE _ FILE _ NAME _ PATTERN ▁= ▁Pattern ▁. ▁compile ▁( ▁STR ▁+ ▁CACHE _ FILE _ NAME _ DELIMITER ▁+ ▁STR ▁+ ▁CACHE _ FILE _ NAME _ DELIMITER ▁+ ▁STR ▁) ▁; ▁private ▁final ▁int ▁ttl ▁; ▁private ▁final ▁int ▁build Number ▁; ▁public ▁Tra v is Download Cache ▁( ▁final ▁Path ▁path ▁, ▁final ▁int ▁ttl ▁, ▁final ▁int ▁build Number ▁) ▁{ ▁super ▁( ▁path ▁) ▁; ▁this ▁. ▁ttl ▁= ▁ttl ▁; ▁this ▁. ▁build Number ▁= ▁build Number ▁; ▁} ▁@ ▁Override ▁Matcher ▁create Cache File Matcher ▁( ▁final ▁String ▁cache FileName ▁) ▁{ ▁return ▁CACHE _ FILE _ NAME _ PATTERN ▁. ▁matcher ▁( ▁cache FileName ▁) ▁; ▁} ▁@ ▁Override ▁String ▁generate Cache FileName ▁( ▁final ▁String ▁url ▁, ▁final ▁String ▁fileName ▁) ▁{ ▁final ▁String ▁hash ▁= ▁String ▁. ▁valueOf ▁( ▁url ▁. ▁hashCode ▁( ▁) ▁) ▁; ▁return ▁hash ▁+ ▁CACHE _ FILE _ NAME _ DELIMITER ▁+ ▁build Number ▁+ ▁CACHE _ FILE _ NAME _ DELIMITER ▁+ ▁fileName ▁; ▁} ▁@ ▁Override ▁String ▁reg ener ate Original FileName ▁( ▁final ▁Matcher ▁matcher ▁) ▁{ ▁return ▁matcher ▁. ▁group ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁boolean ▁ex ceed s Time To Live ▁( ▁final ▁Matcher ▁matcher ▁) ▁{ ▁int ▁cached Build Number ▁= ▁Integer ▁. ▁parseInt ▁( ▁matcher ▁. ▁group ▁( ▁STR ▁) ▁) ▁; ▁return ▁build Number ▁- ▁cached Build Number ▁> ▁ttl ▁; ▁} ▁@ ▁Override ▁boolean ▁matches Cached File ▁( ▁final ▁Matcher ▁matcher ▁, ▁final ▁String ▁url ▁) ▁{ ▁final ▁String ▁hash ▁= ▁matcher ▁. ▁group ▁( ▁STR ▁) ▁; ▁return ▁url ▁. ▁hashCode ▁( ▁) ▁== ▁Integer ▁. ▁parseInt ▁( ▁hash ▁) ▁; ▁} ▁}
▁public ▁class ▁Mongo Span Helper ▁{ ▁private ▁Mongo Span Helper ▁( ▁) ▁{ ▁} ▁public ▁static ▁void ▁create Exit Span ▁( ▁String ▁execute Method ▁, ▁String ▁remote Peer ▁, ▁Object ▁operation ▁) ▁{ ▁AbstractSpan ▁span ▁= ▁ContextManager ▁. ▁create Exit Span ▁( ▁Mongo Constants ▁. ▁M ONG O _ DB _ OP _ PREFIX ▁+ ▁execute Method ▁, ▁new ▁ContextCarrier ▁( ▁) ▁, ▁remote Peer ▁) ▁; ▁span ▁. ▁setComponent ▁( ▁Components Define ▁. ▁M ONG O _ DRIVER ▁) ▁; ▁Tags ▁. ▁DB _ TYPE ▁. ▁set ▁( ▁span ▁, ▁Mongo Constants ▁. ▁DB _ TYPE ▁) ▁; ▁SpanLayer ▁. ▁as DB ▁( ▁span ▁) ▁; ▁if ▁( ▁Mongo PluginConfig ▁. ▁Plugin ▁. ▁Mongo DB ▁. ▁TRACE _ PARAM ▁) ▁{ ▁Tags ▁. ▁DB _ BIND _ VARIABLE S ▁. ▁set ▁( ▁span ▁, ▁Mongo Operation Helper ▁. ▁getTrace Param ▁( ▁operation ▁) ▁) ▁; ▁} ▁} ▁}
▁public ▁void ▁ok ▁( ▁String ▁sql ▁, ▁String ▁expected Sql ▁) ▁{ ▁SQLStatement ▁stmt ▁= ▁SQLUtils ▁. ▁parseSingle Mysql Statement ▁( ▁sql ▁) ▁; ▁assertEquals ▁( ▁expected Sql ▁, ▁stmt ▁. ▁toString ▁( ▁Visitor Feature ▁. ▁Output Distributed Literal In CreateTable Stmt ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁Rolling Collapser BatchSize Distribution Stream Test ▁extends ▁Command Stream Test ▁{ ▁Rolling Collapser BatchSize Distribution Stream ▁stream ▁; ▁HystrixRequest Context ▁context ▁; ▁@ ▁Before ▁public ▁void ▁setUp ▁( ▁) ▁{ ▁context ▁= ▁HystrixRequest Context ▁. ▁initialize Context ▁( ▁) ▁; ▁} ▁@ ▁After ▁public ▁void ▁tearDown ▁( ▁) ▁{ ▁stream ▁. ▁unsubscribe ▁( ▁) ▁; ▁context ▁. ▁shutdown ▁( ▁) ▁; ▁Rolling Collapser BatchSize Distribution Stream ▁. ▁reset ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testEmpty Stream Produce s Empty Dist ribut ions ▁( ▁) ▁{ ▁Hystrix Collapser Key ▁key ▁= ▁Hystrix Collapser Key ▁. ▁Factory ▁. ▁as Key ▁( ▁STR ▁) ▁; ▁stream ▁= ▁Rolling Collapser BatchSize Distribution Stream ▁. ▁getInstance ▁( ▁key ▁, ▁10 ▁, ▁100 ▁) ▁; ▁stream ▁. ▁start Caching Stream Values If Un st arted ▁( ▁) ▁; ▁final ▁CountDownLatch ▁latch ▁= ▁new ▁CountDownLatch ▁( ▁1 ▁) ▁; ▁stream ▁. ▁observe ▁( ▁) ▁. ▁skip ▁( ▁10 ▁) ▁. ▁take ▁( ▁10 ▁) ▁. ▁subscribe ▁( ▁new ▁Subscriber ▁< ▁Cached Values Histogram ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁onCompleted ▁( ▁) ▁{ ▁latch ▁. ▁countDown ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁onError ▁( ▁Throwable ▁e ▁) ▁{ ▁fail ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁onNext ▁( ▁Cached Values Histogram ▁distribution ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁System ▁. ▁current TimeMillis ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁0 ▁, ▁distribution ▁. ▁getTotal Count ▁( ▁) ▁) ▁; ▁} ▁} ▁) ▁; ▁try ▁{ ▁assertTrue ▁( ▁latch ▁. ▁await ▁( ▁10000 ▁, ▁TimeUnit ▁. ▁MILLISECONDS ▁) ▁) ▁; ▁} ▁catch ▁( ▁Interrupted Exception ▁ex ▁) ▁{ ▁fail ▁( ▁STR ▁) ▁; ▁} ▁assertEquals ▁( ▁0 ▁, ▁stream ▁. ▁getLatest ▁( ▁) ▁. ▁getTotal Count ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Batches ▁( ▁) ▁{ ▁Hystrix Collapser Key ▁key ▁= ▁Hystrix Collapser Key ▁. ▁Factory ▁. ▁as Key ▁( ▁STR ▁) ▁; ▁stream ▁= ▁Rolling Collapser BatchSize Distribution Stream ▁. ▁getInstance ▁( ▁key ▁, ▁10 ▁, ▁100 ▁) ▁; ▁stream ▁. ▁start Caching Stream Values If Un st arted ▁( ▁) ▁; ▁final ▁CountDownLatch ▁latch ▁= ▁new ▁CountDownLatch ▁( ▁1 ▁) ▁; ▁stream ▁. ▁observe ▁( ▁) ▁. ▁take ▁( ▁10 ▁) ▁. ▁subscribe ▁( ▁new ▁Subscriber ▁< ▁Cached Values Histogram ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁onCompleted ▁( ▁) ▁{ ▁latch ▁. ▁countDown ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁onError ▁( ▁Throwable ▁e ▁) ▁{ ▁fail ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁onNext ▁( ▁Cached Values Histogram ▁distribution ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁System ▁. ▁current TimeMillis ▁( ▁) ▁) ▁; ▁} ▁} ▁) ▁; ▁Col lapser ▁. ▁from ▁( ▁key ▁, ▁1 ▁) ▁. ▁observe ▁( ▁) ▁; ▁Col lapser ▁. ▁from ▁( ▁key ▁, ▁2 ▁) ▁. ▁observe ▁( ▁) ▁; ▁Col lapser ▁. ▁from ▁( ▁key ▁, ▁3 ▁) ▁. ▁observe ▁( ▁) ▁; ▁try ▁{ ▁Thread ▁. ▁sleep ▁( ▁250 ▁) ▁; ▁}
▁public ▁class ▁Geo Line Aggregation Builder ▁extends ▁Multi ValuesSource Aggregation Builder ▁. ▁Leaf Only ▁< ▁Geo Line Aggregation Builder ▁> ▁{ ▁static ▁final ▁ParseField ▁PO INT _ FIELD ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁static ▁final ▁ParseField ▁S ORT _ FIELD ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁static ▁final ▁ParseField ▁ORDER _ FIELD ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁static ▁final ▁ParseField ▁IN CLUDE _ S ORT _ FIELD ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁static ▁final ▁ParseField ▁SI Z E _ FIELD ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁public ▁static ▁final ▁String ▁NAME ▁= ▁STR ▁; ▁public ▁static ▁final ▁ObjectParser ▁< ▁Geo Line Aggregation Builder ▁, ▁String ▁> ▁PARSER ▁= ▁ObjectParser ▁. ▁from Builder ▁( ▁NAME ▁, ▁Geo Line Aggregation Builder ▁:: ▁new ▁) ▁; ▁static ▁{ ▁Multi ValuesSource Parse Helper ▁. ▁declare Common ▁( ▁PARSER ▁, ▁true ▁, ▁ValueType ▁. ▁NUMERIC ▁) ▁; ▁Multi ValuesSource Parse Helper ▁. ▁declareField ▁( ▁PO INT _ FIELD ▁. ▁getPreferred Name ▁( ▁) ▁, ▁PARSER ▁, ▁true ▁, ▁false ▁, ▁false ▁, ▁false ▁) ▁; ▁Multi ValuesSource Parse Helper ▁. ▁declareField ▁( ▁S ORT _ FIELD ▁. ▁getPreferred Name ▁( ▁) ▁, ▁PARSER ▁, ▁true ▁, ▁false ▁, ▁false ▁, ▁false ▁) ▁; ▁PARSER ▁. ▁declareString ▁( ▁( ▁builder ▁, ▁order ▁) ▁-> ▁builder ▁. ▁sortOrder ▁( ▁SortOrder ▁. ▁fromString ▁( ▁order ▁) ▁) ▁, ▁ORDER _ FIELD ▁) ▁; ▁PARSER ▁. ▁declareBoolean ▁( ▁Geo Line Aggregation Builder ▁:: ▁include Sort ▁, ▁IN CLUDE _ S ORT _ FIELD ▁) ▁; ▁PARSER ▁. ▁declare Int ▁( ▁Geo Line Aggregation Builder ▁:: ▁size ▁, ▁SI Z E _ FIELD ▁) ▁; ▁} ▁private ▁boolean ▁include Sort ▁; ▁private ▁SortOrder ▁sortOrder ▁= ▁SortOrder ▁. ▁ASC ▁; ▁private ▁int ▁size ▁= ▁MAX _ PATH _ SI Z E ▁; ▁static ▁final ▁int ▁MAX _ PATH _ SI Z E ▁= ▁10000 ▁; ▁public ▁static ▁void ▁register Usage ▁( ▁ValuesSource Registry ▁. ▁Builder ▁builder ▁) ▁{ ▁builder ▁. ▁register Usage ▁( ▁NAME ▁, ▁Core ValuesSourceType ▁. ▁G EO POINT ▁) ▁; ▁} ▁public ▁Geo Line Aggregation Builder ▁( ▁String ▁name ▁) ▁{ ▁super ▁( ▁name ▁) ▁; ▁} ▁private ▁Geo Line Aggregation Builder ▁( ▁Geo Line Aggregation Builder ▁clone ▁, ▁Aggregator Factories ▁. ▁Builder ▁factories Builder ▁, ▁Map ▁< ▁String ▁, ▁Object ▁> ▁metaData ▁) ▁{ ▁super ▁( ▁clone ▁, ▁factories Builder ▁, ▁metaData ▁) ▁; ▁} ▁public ▁Geo Line Aggregation Builder ▁( ▁StreamInput ▁in ▁) ▁throws ▁IOException ▁{ ▁super ▁( ▁in ▁) ▁; ▁sortOrder ▁= ▁SortOrder ▁. ▁readFrom Stream ▁( ▁in ▁) ▁; ▁include Sort ▁= ▁in ▁. ▁readBoolean ▁( ▁) ▁; ▁size ▁= ▁in ▁. ▁readVInt ▁( ▁) ▁; ▁} ▁public ▁Geo Line Aggregation Builder ▁include Sort ▁( ▁boolean ▁include Sort ▁) ▁{ ▁this ▁. ▁include Sort ▁= ▁include Sort ▁; ▁return ▁this ▁; ▁} ▁public ▁Geo Line Aggregation Builder ▁sortOrder ▁( ▁SortOrder ▁sortOrder ▁) ▁{ ▁this ▁. ▁sortOrder ▁= ▁sortOrder ▁; ▁return ▁this ▁; ▁}
▁Field Fetcher ▁nested Sub Field Fetcher ▁= ▁Field Fetcher ▁. ▁create ▁( ▁context ▁, ▁field And Formats ▁, ▁n arrow ed Scope Nested Mappings ▁, ▁nested Field Path ▁) ▁; ▁field Contexts ▁. ▁put ▁( ▁nested Field Path ▁, ▁new ▁Field Context ▁( ▁nested Field Path ▁, ▁new ▁Nested Value Fetcher ▁( ▁nested Field Path ▁, ▁nested Sub Field Fetcher ▁) ▁) ▁) ▁; ▁} ▁Character Run Aut omaton ▁unm apped Fields Fetch Aut omaton ▁= ▁null ▁; ▁Map ▁< ▁Boolean ▁, ▁List ▁< ▁String ▁> ▁> ▁partitions ▁= ▁unm apped Fetch Pattern ▁. ▁stream ▁( ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁partitioning By ▁( ▁( ▁s ▁-> ▁Regex ▁. ▁is Simple Match Pattern ▁( ▁s ▁) ▁) ▁) ▁) ▁; ▁List ▁< ▁String ▁> ▁unm apped Wildcard Pattern ▁= ▁partitions ▁. ▁get ▁( ▁true ▁) ▁; ▁List ▁< ▁String ▁> ▁unm apped Con crete Fields ▁= ▁partitions ▁. ▁get ▁( ▁false ▁) ▁; ▁if ▁( ▁unm apped Wildcard Pattern ▁. ▁isEmpty ▁( ▁) ▁== ▁false ▁) ▁{ ▁unm apped Fields Fetch Aut omaton ▁= ▁new ▁Character Run Aut omaton ▁( ▁Regex ▁. ▁simple Match To Aut omaton ▁( ▁unm apped Wildcard Pattern ▁. ▁toArray ▁( ▁new ▁String ▁[ ▁unm apped Wildcard Pattern ▁. ▁size ▁( ▁) ▁] ▁) ▁) ▁, ▁A UT OM AT ON _ MAX _ DE TERMIN I Z ED _ STATE S ▁) ▁; ▁} ▁return ▁new ▁Field Fetcher ▁( ▁field Contexts ▁, ▁unm apped Fields Fetch Aut omaton ▁, ▁unm apped Con crete Fields ▁) ▁; ▁} ▁private ▁final ▁Map ▁< ▁String ▁, ▁Field Context ▁> ▁field Contexts ▁; ▁private ▁final ▁Character Run Aut omaton ▁unm apped Fields Fetch Aut omaton ▁; ▁private ▁final ▁List ▁< ▁String ▁> ▁unm apped Con crete Fields ▁; ▁private ▁Field Fetcher ▁( ▁Map ▁< ▁String ▁, ▁Field Context ▁> ▁field Contexts ▁, ▁@ ▁Nullable ▁Character Run Aut omaton ▁unm apped Fields Fetch Aut omaton ▁, ▁@ ▁Nullable ▁List ▁< ▁String ▁> ▁unm apped Con crete Fields ▁) ▁{ ▁this ▁. ▁field Contexts ▁= ▁field Contexts ▁; ▁this ▁. ▁unm apped Fields Fetch Aut omaton ▁= ▁unm apped Fields Fetch Aut omaton ▁; ▁this ▁. ▁unm apped Con crete Fields ▁= ▁unm apped Con crete Fields ▁; ▁} ▁public ▁Map ▁< ▁String ▁, ▁Document Field ▁> ▁fetch ▁( ▁Source Lookup ▁source Lookup ▁) ▁throws ▁IOException ▁{ ▁Map ▁< ▁String ▁, ▁Document Field ▁> ▁document Fields ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁Field Context ▁context ▁: ▁field Contexts ▁. ▁values ▁( ▁) ▁) ▁{ ▁String ▁field ▁= ▁context ▁. ▁fieldName ▁; ▁Value Fetcher ▁value Fetcher ▁= ▁context ▁. ▁value Fetcher ▁; ▁List ▁< ▁Object ▁> ▁parsed Values ▁= ▁value Fetcher ▁. ▁fetch Values ▁( ▁source Lookup ▁) ▁; ▁if ▁( ▁parsed Values ▁. ▁isEmpty ▁( ▁) ▁== ▁false ▁) ▁{ ▁document Fields ▁. ▁put ▁( ▁field ▁, ▁new ▁Document Field ▁( ▁field ▁, ▁parsed Values ▁) ▁) ▁; ▁} ▁} ▁collect Unm apped ▁( ▁document Fields ▁, ▁source Lookup ▁. ▁source ▁( ▁) ▁, ▁STR ▁, ▁0 ▁) ▁; ▁return ▁document Fields ▁; ▁}
▁public ▁class ▁Redis Loading Exception ▁extends ▁Redis Exception ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁- ▁256 53 35 188 50 33 54 6 60 L ▁; ▁public ▁Redis Loading Exception ▁( ▁String ▁message ▁) ▁{ ▁super ▁( ▁message ▁) ▁; ▁} ▁}
▁public ▁class ▁Component Library Catalog Service ▁implements ▁I Component Library Catalog Service ▁{ ▁private ▁static ▁final ▁Logger ▁LOGGER ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Component Library Catalog Service ▁. ▁class ▁) ▁; ▁private ▁static ▁final ▁String ▁COMPONENT _ SERVER _ MAPPING _ SECTION ▁= ▁STR ▁; ▁private ▁Map ▁< ▁String ▁, ▁Integer ▁> ▁component Name 2 Id ▁; ▁private ▁Map ▁< ▁Integer ▁, ▁String ▁> ▁component Id 2 Name ▁; ▁private ▁Map ▁< ▁Integer ▁, ▁Integer ▁> ▁component Id 2 Server Id ▁; ▁public ▁Component Library Catalog Service ▁( ▁) ▁throws ▁Initial Component Catalog Exception ▁{ ▁init ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getComponent Id ▁( ▁String ▁component Name ▁) ▁{ ▁return ▁component Name 2 Id ▁. ▁get ▁( ▁component Name ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getServer Id Based On Component ▁( ▁int ▁component Id ▁) ▁{ ▁Integer ▁server Component Id ▁= ▁component Id 2 Server Id ▁. ▁get ▁( ▁component Id ▁) ▁; ▁return ▁server Component Id ▁== ▁null ▁? ▁component Id ▁: ▁server Component Id ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getComponent Name ▁( ▁int ▁component Id ▁) ▁{ ▁String ▁component Name ▁= ▁component Id 2 Name ▁. ▁get ▁( ▁component Id ▁) ▁; ▁return ▁component Name ▁== ▁null ▁? ▁component Id 2 Name ▁. ▁get ▁( ▁0 ▁) ▁: ▁component Name ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getServer Name Based On Component ▁( ▁int ▁component Id ▁) ▁{ ▁Integer ▁server Component Id ▁= ▁component Id 2 Server Id ▁. ▁get ▁( ▁component Id ▁) ▁; ▁return ▁server Component Id ▁== ▁null ▁? ▁getComponent Name ▁( ▁component Id ▁) ▁: ▁getComponent Name ▁( ▁server Component Id ▁) ▁; ▁} ▁private ▁void ▁init ▁( ▁) ▁throws ▁Initial Component Catalog Exception ▁{ ▁component Name 2 Id ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁component Name 2 Id ▁. ▁put ▁( ▁STR ▁, ▁0 ▁) ▁; ▁component Id 2 Name ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁component Id 2 Name ▁. ▁put ▁( ▁0 ▁, ▁STR ▁) ▁; ▁component Id 2 Server Id ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁Map ▁< ▁String ▁, ▁String ▁> ▁name Mapping ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁try ▁{ ▁Reader ▁application Reader ▁= ▁ResourceUtils ▁. ▁read ▁( ▁STR ▁) ▁; ▁Yaml ▁yaml ▁= ▁new ▁Yaml ▁( ▁) ▁; ▁Map ▁map ▁= ▁yaml ▁. ▁load As ▁( ▁application Reader ▁, ▁Map ▁. ▁class ▁) ▁; ▁map ▁. ▁forEach ▁( ▁( ▁component Name ▁, ▁setting Collection ▁) ▁-> ▁{ ▁Map ▁settings ▁= ▁( ▁Map ▁) ▁setting Collection ▁; ▁if ▁( ▁COMPONENT _ SERVER _ MAPPING _ SECTION ▁. ▁equals ▁( ▁component Name ▁) ▁) ▁{ ▁settings ▁. ▁forEach ▁( ▁( ▁name ▁, ▁server Name ▁) ▁-> ▁{ ▁name Mapping ▁. ▁put ▁( ▁( ▁String ▁) ▁name ▁, ▁( ▁String ▁) ▁server Name ▁) ▁; ▁} ▁) ▁; ▁} ▁else ▁{ ▁Integer ▁component Id ▁= ▁( ▁Integer ▁) ▁settings ▁. ▁get ▁( ▁STR ▁) ▁; ▁component Name 2 Id ▁. ▁put ▁( ▁( ▁String ▁) ▁component Name ▁, ▁component Id ▁) ▁;
▁class ▁ImmutableMap Codec ▁< ▁V ▁> ▁implements ▁Object Codec ▁< ▁ImmutableMap ▁< ▁? ▁, ▁V ▁> ▁> ▁{ ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁@ ▁Serialization Constant ▁static ▁final ▁Comparator ▁< ▁? ▁> ▁ORDER ING _ N AT UR AL ▁= ▁Ordering ▁. ▁natural ▁( ▁) ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁@ ▁Serialization Constant ▁static ▁final ▁Comparator ▁< ▁? ▁> ▁COMP ARATOR _ N AT UR AL _ ORDER ▁= ▁Comparator ▁. ▁natural Order ▁( ▁) ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁@ ▁Override ▁public ▁Class ▁< ▁ImmutableMap ▁< ▁? ▁, ▁V ▁> ▁> ▁getEncoded Class ▁( ▁) ▁{ ▁return ▁( ▁Class ▁< ▁ImmutableMap ▁< ▁? ▁, ▁V ▁> ▁> ▁) ▁( ▁( ▁Class ▁< ▁? ▁> ▁) ▁ImmutableMap ▁. ▁class ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁serialize ▁( ▁Serialization Context ▁context ▁, ▁ImmutableMap ▁< ▁? ▁, ▁V ▁> ▁map ▁, ▁Coded OutputStream ▁coded Out ▁) ▁throws ▁Serialization Exception ▁, ▁IOException ▁{ ▁coded Out ▁. ▁writeInt 32 No Tag ▁( ▁map ▁. ▁size ▁( ▁) ▁) ▁; ▁Comparator ▁< ▁? ▁> ▁comparator ▁= ▁map ▁instanceof ▁Immutable SortedMap ▁? ▁( ▁( ▁Immutable SortedMap ▁< ▁? ▁, ▁? ▁> ▁) ▁map ▁) ▁. ▁comparator ▁( ▁) ▁: ▁null ▁; ▁context ▁. ▁serialize ▁( ▁comparator ▁, ▁coded Out ▁) ▁; ▁serialize Entries ▁( ▁context ▁, ▁map ▁. ▁entrySet ▁( ▁) ▁, ▁coded Out ▁) ▁; ▁} ▁static ▁< ▁K ▁, ▁V ▁> ▁void ▁serialize Entries ▁( ▁Serialization Context ▁context ▁, ▁Iterable ▁< ▁? ▁extends ▁Map ▁. ▁Entry ▁< ▁K ▁, ▁V ▁> ▁> ▁entrySet ▁, ▁Coded OutputStream ▁coded Out ▁) ▁throws ▁IOException ▁, ▁Serialization Exception ▁{ ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁? ▁, ▁? ▁> ▁entry ▁: ▁entrySet ▁) ▁{ ▁context ▁. ▁serialize ▁( ▁entry ▁. ▁getKey ▁( ▁) ▁, ▁coded Out ▁) ▁; ▁try ▁{ ▁context ▁. ▁serialize ▁( ▁entry ▁. ▁getValue ▁( ▁) ▁, ▁coded Out ▁) ▁; ▁} ▁catch ▁( ▁Serialization Exception ▁| ▁IOException ▁e ▁) ▁{ ▁throw ▁Serialization Exception ▁. ▁propagate ▁( ▁String ▁. ▁format ▁( ▁STR ▁, ▁entry ▁. ▁getValue ▁( ▁) ▁. ▁getClass ▁( ▁) ▁. ▁getName ▁( ▁) ▁, ▁entry ▁. ▁getKey ▁( ▁) ▁) ▁, ▁e ▁) ▁; ▁} ▁} ▁} ▁@ ▁Override ▁public ▁ImmutableMap ▁< ▁? ▁, ▁V ▁> ▁deserialize ▁( ▁Deserialization Context ▁context ▁, ▁Coded InputStream ▁coded In ▁) ▁throws ▁Serialization Exception ▁, ▁IOException ▁{ ▁int ▁length ▁= ▁coded In ▁. ▁readInt 32 ▁( ▁) ▁; ▁if ▁( ▁length ▁< ▁0 ▁) ▁{ ▁throw ▁new ▁Serialization Exception ▁( ▁STR ▁+ ▁length ▁) ▁; ▁} ▁ImmutableMap ▁. ▁Builder ▁< ▁? ▁, ▁V ▁> ▁builder ▁; ▁Comparator ▁< ▁? ▁> ▁comparator ▁= ▁context ▁. ▁deserialize ▁( ▁coded In ▁) ▁; ▁if ▁( ▁comparator ▁!= ▁null ▁) ▁{ ▁builder ▁= ▁deserialize Entries ▁( ▁Immutable SortedMap ▁. ▁ordered By ▁( ▁comparator ▁) ▁, ▁length ▁, ▁context ▁, ▁coded In ▁) ▁; ▁} ▁else ▁{ ▁builder ▁= ▁deserialize Entries ▁( ▁ImmutableMap ▁. ▁builder With Expected Size ▁( ▁length ▁) ▁, ▁length ▁, ▁context ▁, ▁coded In ▁) ▁; ▁} ▁try ▁{ ▁return ▁builder ▁. ▁build ▁( ▁) ▁; ▁}
▁long ▁sc r Value ▁= ▁P s Duration Reader ▁. ▁read Sc r Value From Pack ▁( ▁packet Buffer ▁) ▁; ▁if ▁( ▁sc r Value ▁!= ▁C ▁. ▁TIME _ UNSET ▁) ▁{ ▁long ▁sc r TimeUs ▁= ▁sc r Timestamp Adj uster ▁. ▁adjust Ts Timestamp ▁( ▁sc r Value ▁) ▁; ▁if ▁( ▁sc r TimeUs ▁> ▁target Sc r TimeUs ▁) ▁{ ▁if ▁( ▁last Sc r TimeUs InRange ▁== ▁C ▁. ▁TIME _ UNSET ▁) ▁{ ▁return ▁Timestamp SearchResult ▁. ▁over est im ated Result ▁( ▁sc r TimeUs ▁, ▁buffer Start Offset ▁) ▁; ▁} ▁else ▁{ ▁return ▁Timestamp SearchResult ▁. ▁target Found Result ▁( ▁buffer Start Offset ▁+ ▁start Of Last Packet Position ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁sc r TimeUs ▁+ ▁SE E K _ TO LER ANCE _ US ▁> ▁target Sc r TimeUs ▁) ▁{ ▁long ▁start Of Packet In Stream ▁= ▁buffer Start Offset ▁+ ▁packet Buffer ▁. ▁getPosition ▁( ▁) ▁; ▁return ▁Timestamp SearchResult ▁. ▁target Found Result ▁( ▁start Of Packet In Stream ▁) ▁; ▁} ▁last Sc r TimeUs InRange ▁= ▁sc r TimeUs ▁; ▁start Of Last Packet Position ▁= ▁packet Buffer ▁. ▁getPosition ▁( ▁) ▁; ▁} ▁skip To EndOf Current Pack ▁( ▁packet Buffer ▁) ▁; ▁endOf Last Packet Position ▁= ▁packet Buffer ▁. ▁getPosition ▁( ▁) ▁; ▁} ▁if ▁( ▁last Sc r TimeUs InRange ▁!= ▁C ▁. ▁TIME _ UNSET ▁) ▁{ ▁long ▁endOf Last Packet Position In Stream ▁= ▁buffer Start Offset ▁+ ▁endOf Last Packet Position ▁; ▁return ▁Timestamp SearchResult ▁. ▁under est im ated Result ▁( ▁last Sc r TimeUs InRange ▁, ▁endOf Last Packet Position In Stream ▁) ▁; ▁} ▁else ▁{ ▁return ▁Timestamp SearchResult ▁. ▁NO _ TIMESTAMP _ IN _ RANGE _ RESULT ▁; ▁} ▁} ▁private ▁static ▁void ▁skip To EndOf Current Pack ▁( ▁Parsable ByteArray ▁packet Buffer ▁) ▁{ ▁int ▁limit ▁= ▁packet Buffer ▁. ▁limit ▁( ▁) ▁; ▁if ▁( ▁packet Buffer ▁. ▁bytes Left ▁( ▁) ▁< ▁10 ▁) ▁{ ▁packet Buffer ▁. ▁setPosition ▁( ▁limit ▁) ▁; ▁return ▁; ▁} ▁packet Buffer ▁. ▁skipBytes ▁( ▁9 ▁) ▁; ▁int ▁pack St uff ing Length ▁= ▁packet Buffer ▁. ▁readUnsigned Byte ▁( ▁) ▁& ▁0 x 07 ▁; ▁if ▁( ▁packet Buffer ▁. ▁bytes Left ▁( ▁) ▁< ▁pack St uff ing Length ▁) ▁{ ▁packet Buffer ▁. ▁setPosition ▁( ▁limit ▁) ▁; ▁return ▁; ▁} ▁packet Buffer ▁. ▁skipBytes ▁( ▁pack St uff ing Length ▁) ▁; ▁if ▁( ▁packet Buffer ▁. ▁bytes Left ▁( ▁) ▁< ▁4 ▁) ▁{ ▁packet Buffer ▁. ▁setPosition ▁( ▁limit ▁) ▁; ▁return ▁; ▁} ▁int ▁next Start Code ▁= ▁peek Int At Position ▁( ▁packet Buffer ▁. ▁data ▁, ▁packet Buffer ▁. ▁getPosition ▁( ▁) ▁) ▁; ▁if ▁( ▁next Start Code ▁== ▁P s Extractor ▁. ▁SYSTEM _ HEADER _ START _ CODE ▁) ▁{ ▁packet Buffer ▁. ▁skipBytes ▁( ▁4 ▁) ▁; ▁int ▁system Header Length ▁= ▁packet Buffer ▁. ▁readUnsigned Short ▁( ▁) ▁;
▁@ ▁Interface Audience ▁. ▁Private ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁class ▁Startup Progress Servlet ▁extends ▁D fs Servlet ▁{ ▁private ▁static ▁final ▁String ▁COUNT ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁EL AP SED _ TIME ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁FILE ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁NAME ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁DESC ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁PER CENT _ COMP LETE ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁P H ASE S ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁SI Z E ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁STATUS ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁S TE PS ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁TOTAL ▁= ▁STR ▁; ▁public ▁static ▁final ▁String ▁PATH _ SPEC ▁= ▁STR ▁; ▁@ ▁Override ▁protected ▁void ▁doGet ▁( ▁HttpServlet Request ▁req ▁, ▁HttpServlet Response ▁resp ▁) ▁throws ▁IOException ▁{ ▁resp ▁. ▁setContentType ▁( ▁STR ▁) ▁; ▁Startup Progress ▁prog ▁= ▁NameNode HttpServer ▁. ▁getStart up Progress From Context ▁( ▁get ServletContext ▁( ▁) ▁) ▁; ▁Startup Progress View ▁view ▁= ▁prog ▁. ▁create View ▁( ▁) ▁; ▁JsonGenerator ▁json ▁= ▁new ▁Json Factory ▁( ▁) ▁. ▁create Generator ▁( ▁resp ▁. ▁getWriter ▁( ▁) ▁) ▁; ▁try ▁{ ▁json ▁. ▁writeStart Object ▁( ▁) ▁; ▁json ▁. ▁writeNumber Field ▁( ▁EL AP SED _ TIME ▁, ▁view ▁. ▁get ElapsedTime ▁( ▁) ▁) ▁; ▁json ▁. ▁writeNumber Field ▁( ▁PER CENT _ COMP LETE ▁, ▁view ▁. ▁getPer cent Complete ▁( ▁) ▁) ▁; ▁json ▁. ▁write Array Field Start ▁( ▁P H ASE S ▁) ▁; ▁for ▁( ▁Phase ▁phase ▁: ▁view ▁. ▁getPh ases ▁( ▁) ▁) ▁{ ▁json ▁. ▁writeStart Object ▁( ▁) ▁; ▁json ▁. ▁writeString Field ▁( ▁NAME ▁, ▁phase ▁. ▁getName ▁( ▁) ▁) ▁; ▁json ▁. ▁writeString Field ▁( ▁DESC ▁, ▁phase ▁. ▁getDescription ▁( ▁) ▁) ▁; ▁json ▁. ▁writeString Field ▁( ▁STATUS ▁, ▁view ▁. ▁getStatus ▁( ▁phase ▁) ▁. ▁toString ▁( ▁) ▁) ▁; ▁json ▁. ▁writeNumber Field ▁( ▁PER CENT _ COMP LETE ▁, ▁view ▁. ▁getPer cent Complete ▁( ▁phase ▁) ▁) ▁; ▁json ▁. ▁writeNumber Field ▁( ▁EL AP SED _ TIME ▁, ▁view ▁. ▁get ElapsedTime ▁( ▁phase ▁) ▁) ▁; ▁writeString Field If NotNull ▁( ▁json ▁, ▁FILE ▁, ▁view ▁. ▁getFile ▁( ▁phase ▁) ▁) ▁; ▁writeNumber Field If Defined ▁( ▁json ▁, ▁SI Z E ▁, ▁view ▁. ▁getSize ▁( ▁phase ▁) ▁) ▁; ▁json ▁. ▁write Array Field Start ▁( ▁S TE PS ▁) ▁; ▁for ▁( ▁Step ▁step ▁: ▁view ▁. ▁getS te ps ▁( ▁phase ▁) ▁) ▁{ ▁json ▁. ▁writeStart Object ▁( ▁) ▁; ▁Step Type ▁type ▁= ▁step ▁. ▁getType ▁( ▁) ▁; ▁if ▁( ▁type ▁!= ▁null ▁) ▁{ ▁json ▁. ▁writeString Field ▁( ▁NAME ▁, ▁type ▁. ▁getName ▁( ▁) ▁) ▁; ▁json ▁. ▁writeString Field ▁( ▁DESC ▁, ▁type ▁. ▁getDescription ▁( ▁) ▁) ▁; ▁} ▁json ▁. ▁writeNumber Field ▁( ▁COUNT ▁, ▁view ▁. ▁getCount ▁( ▁phase ▁, ▁step ▁) ▁) ▁;
▁public ▁enum ▁SortOrder ▁implements ▁Writeable ▁{ ▁ASC ▁{ ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁int ▁reverse Mul ▁( ▁) ▁{ ▁return ▁1 ▁; ▁} ▁@ ▁Override ▁public ▁< ▁T ▁> ▁Comparator ▁< ▁T ▁> ▁wrap ▁( ▁Comparator ▁< ▁T ▁> ▁delegate ▁) ▁{ ▁return ▁delegate ▁; ▁} ▁} ▁, ▁DESC ▁{ ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁int ▁reverse Mul ▁( ▁) ▁{ ▁return ▁- ▁1 ▁; ▁} ▁@ ▁Override ▁public ▁< ▁T ▁> ▁Comparator ▁< ▁T ▁> ▁wrap ▁( ▁Comparator ▁< ▁T ▁> ▁delegate ▁) ▁{ ▁return ▁delegate ▁. ▁re versed ▁( ▁) ▁; ▁} ▁} ▁; ▁public ▁static ▁SortOrder ▁readFrom Stream ▁( ▁StreamInput ▁in ▁) ▁throws ▁IOException ▁{ ▁return ▁in ▁. ▁read Enum ▁( ▁SortOrder ▁. ▁class ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁writeTo ▁( ▁StreamOutput ▁out ▁) ▁throws ▁IOException ▁{ ▁out ▁. ▁write Enum ▁( ▁this ▁) ▁; ▁} ▁public ▁static ▁SortOrder ▁fromString ▁( ▁String ▁op ▁) ▁{ ▁return ▁valueOf ▁( ▁op ▁. ▁toUpperCase ▁( ▁Locale ▁. ▁ROOT ▁) ▁) ▁; ▁} ▁public ▁abstract ▁int ▁reverse Mul ▁( ▁) ▁; ▁public ▁abstract ▁< ▁T ▁> ▁Comparator ▁< ▁T ▁> ▁wrap ▁( ▁Comparator ▁< ▁T ▁> ▁delegate ▁) ▁; ▁}
▁public ▁class ▁Orc FileSystem FilterTest ▁{ ▁@ ▁Test ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁void ▁test Apply Predicate ▁( ▁) ▁{ ▁List ▁< ▁Resolved Expression ▁> ▁args ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁Field Reference Expression ▁field Reference Expression ▁= ▁new ▁Field Reference Expression ▁( ▁STR ▁, ▁DataTypes ▁. ▁BIGINT ▁( ▁) ▁, ▁0 ▁, ▁0 ▁) ▁; ▁Value Literal Expression ▁value Literal Expression ▁= ▁new ▁Value Literal Expression ▁( ▁10 ▁) ▁; ▁args ▁. ▁add ▁( ▁field Reference Expression ▁) ▁; ▁args ▁. ▁add ▁( ▁value Literal Expression ▁) ▁; ▁CallExpression ▁equal Expression ▁= ▁new ▁CallExpression ▁( ▁BuiltIn Function Definitions ▁. ▁EQUAL S ▁, ▁args ▁, ▁DataTypes ▁. ▁BOOLEAN ▁( ▁) ▁) ▁; ▁Orc Filters ▁. ▁Predicate ▁predicate 1 ▁= ▁Orc Filters ▁. ▁to Orc Predicate ▁( ▁equal Expression ▁) ▁; ▁Orc Filters ▁. ▁Predicate ▁predicate 2 ▁= ▁new ▁Orc Filters ▁. ▁Equals ▁( ▁STR ▁, ▁Predicate Leaf ▁. ▁Type ▁. ▁LONG ▁, ▁10 ▁) ▁; ▁assertTrue ▁( ▁predicate 1 ▁. ▁toString ▁( ▁) ▁. ▁equals ▁( ▁predicate 2 ▁. ▁toString ▁( ▁) ▁) ▁) ▁; ▁CallExpression ▁g reater Expression ▁= ▁new ▁CallExpression ▁( ▁BuiltIn Function Definitions ▁. ▁GRE ATER _ THAN ▁, ▁args ▁, ▁DataTypes ▁. ▁BOOLEAN ▁( ▁) ▁) ▁; ▁Orc Filters ▁. ▁Predicate ▁predicate 3 ▁= ▁Orc Filters ▁. ▁to Orc Predicate ▁( ▁g reater Expression ▁) ▁; ▁Orc Filters ▁. ▁Predicate ▁predicate 4 ▁= ▁new ▁Orc Filters ▁. ▁Not ▁( ▁new ▁Orc Filters ▁. ▁L ess Than Equals ▁( ▁STR ▁, ▁Predicate Leaf ▁. ▁Type ▁. ▁LONG ▁, ▁10 ▁) ▁) ▁; ▁assertTrue ▁( ▁predicate 3 ▁. ▁toString ▁( ▁) ▁. ▁equals ▁( ▁predicate 4 ▁. ▁toString ▁( ▁) ▁) ▁) ▁; ▁CallExpression ▁less Expression ▁= ▁new ▁CallExpression ▁( ▁BuiltIn Function Definitions ▁. ▁LE SS _ THAN ▁, ▁args ▁, ▁DataTypes ▁. ▁BOOLEAN ▁( ▁) ▁) ▁; ▁Orc Filters ▁. ▁Predicate ▁predicate 5 ▁= ▁Orc Filters ▁. ▁to Orc Predicate ▁( ▁less Expression ▁) ▁; ▁Orc Filters ▁. ▁Predicate ▁predicate 6 ▁= ▁new ▁Orc Filters ▁. ▁L ess Than ▁( ▁STR ▁, ▁Predicate Leaf ▁. ▁Type ▁. ▁LONG ▁, ▁10 ▁) ▁; ▁assertTrue ▁( ▁predicate 5 ▁. ▁toString ▁( ▁) ▁. ▁equals ▁( ▁predicate 6 ▁. ▁toString ▁( ▁) ▁) ▁) ▁; ▁} ▁}
▁query ▁. ▁visit ▁( ▁new ▁Query Visitor ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁consume Terms ▁( ▁Query ▁query ▁, ▁Term ▁... ▁terms ▁) ▁{ ▁all Terms ▁. ▁addAll ▁( ▁Arrays ▁. ▁asList ▁( ▁terms ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁consume Terms Matching ▁( ▁Query ▁query ▁, ▁String ▁field ▁, ▁Supplier ▁< ▁Byte Run Aut omaton ▁> ▁aut omaton ▁) ▁{ ▁fail ▁( ▁) ▁; ▁} ▁} ▁) ▁; ▁assertThat ▁( ▁all Terms ▁, ▁equalTo ▁( ▁query ▁. ▁terms ▁( ▁) ▁. ▁stream ▁( ▁) ▁. ▁map ▁( ▁t ▁-> ▁new ▁Term ▁( ▁query ▁. ▁fieldName ▁( ▁) ▁, ▁t ▁) ▁) ▁. ▁collect ▁( ▁to Collection ▁( ▁TreeSet ▁:: ▁new ▁) ▁) ▁) ▁) ▁; ▁} ▁}
▁final ▁long ▁segment Id ▁; ▁if ▁( ▁segment Separator ▁== ▁CHAR ▁) ▁{ ▁try ▁{ ▁segment Id ▁= ▁formatter ▁. ▁parse ▁( ▁segment Id String ▁) ▁. ▁getTime ▁( ▁) ▁ / ▁segment Interval ▁; ▁} ▁catch ▁( ▁final ▁ParseException ▁e ▁) ▁{ ▁log ▁. ▁warn ▁( ▁STR ▁, ▁segment Name ▁) ▁; ▁return ▁- ▁1 L ▁; ▁} ▁rename Segment File ▁( ▁parent ▁, ▁segment Name ▁, ▁segment Id ▁) ▁; ▁} ▁else ▁{ ▁try ▁{ ▁segment Id ▁= ▁Long ▁. ▁parseLong ▁( ▁segment Id String ▁) ▁ / ▁segment Interval ▁; ▁} ▁catch ▁( ▁final ▁Number FormatException ▁e ▁) ▁{ ▁throw ▁new ▁Processor StateException ▁( ▁STR ▁+ ▁segment Name ▁) ▁; ▁} ▁if ▁( ▁segment Separator ▁== ▁CHAR ▁) ▁{ ▁rename Segment File ▁( ▁parent ▁, ▁segment Name ▁, ▁segment Id ▁) ▁; ▁} ▁} ▁return ▁segment Id ▁; ▁} ▁private ▁void ▁rename Segment File ▁( ▁final ▁File ▁parent ▁, ▁final ▁String ▁segment Name ▁, ▁final ▁long ▁segment Id ▁) ▁{ ▁final ▁File ▁newName ▁= ▁new ▁File ▁( ▁parent ▁, ▁segment Name ▁( ▁segment Id ▁) ▁) ▁; ▁final ▁File ▁oldName ▁= ▁new ▁File ▁( ▁parent ▁, ▁segment Name ▁) ▁; ▁if ▁( ▁! ▁oldName ▁. ▁rename To ▁( ▁newName ▁) ▁) ▁{ ▁throw ▁new ▁Processor StateException ▁( ▁STR ▁+ ▁oldName ▁+ ▁STR ▁+ ▁newName ▁) ▁; ▁} ▁} ▁}
▁@ ▁Configuration ▁( ▁proxyBean Methods ▁= ▁false ▁) ▁class ▁Jackson Http MessageConverter s Configuration ▁{ ▁@ ▁Configuration ▁( ▁proxyBean Methods ▁= ▁false ▁) ▁@ ▁ConditionalOn Class ▁( ▁ObjectMapper ▁. ▁class ▁) ▁@ ▁ConditionalOn Bean ▁( ▁ObjectMapper ▁. ▁class ▁) ▁@ ▁ConditionalOn Property ▁( ▁name ▁= ▁Http MessageConverter s Auto Configuration ▁. ▁PREFERRED _ MAP PER _ PROPERTY ▁, ▁having Value ▁= ▁STR ▁, ▁match IfMissing ▁= ▁true ▁) ▁static ▁class ▁Mapping Jackson 2 Http MessageConverter Configuration ▁{ ▁@ ▁Bean ▁@ ▁ConditionalOn MissingBean ▁( ▁value ▁= ▁Mapping Jackson 2 Http MessageConverter ▁. ▁class ▁, ▁ignored Type ▁= ▁{ ▁STR ▁, ▁STR ▁} ▁) ▁Mapping Jackson 2 Http MessageConverter ▁mapping Jackson 2 Http MessageConverter ▁( ▁ObjectMapper ▁objectMapper ▁) ▁{ ▁return ▁new ▁Mapping Jackson 2 Http MessageConverter ▁( ▁objectMapper ▁) ▁; ▁} ▁} ▁@ ▁Configuration ▁( ▁proxyBean Methods ▁= ▁false ▁) ▁@ ▁ConditionalOn Class ▁( ▁Xml Mapper ▁. ▁class ▁) ▁@ ▁ConditionalOn Bean ▁( ▁Jackson 2 ObjectMapper Builder ▁. ▁class ▁) ▁protected ▁static ▁class ▁Mapping Jackson 2 Xml Http MessageConverter Configuration ▁{ ▁@ ▁Bean ▁@ ▁ConditionalOn MissingBean ▁public ▁Mapping Jackson 2 Xml Http MessageConverter ▁mapping Jackson 2 Xml Http MessageConverter ▁( ▁Jackson 2 ObjectMapper Builder ▁builder ▁) ▁{ ▁return ▁new ▁Mapping Jackson 2 Xml Http MessageConverter ▁( ▁builder ▁. ▁create Xml Mapper ▁( ▁true ▁) ▁. ▁build ▁( ▁) ▁) ▁; ▁} ▁} ▁}
▁boolean ▁has K w args ▁; ▁Function ▁< ▁Integer ▁, ▁String ▁> ▁getDefaultValue ▁= ▁( ▁i ▁) ▁-> ▁null ▁; ▁} ▁private ▁static ▁Value ▁. ▁Builder ▁signature To Value ▁( ▁Signature ▁sig ▁) ▁{ ▁Value ▁. ▁Builder ▁value ▁= ▁Value ▁. ▁newBuilder ▁( ▁) ▁; ▁value ▁. ▁setName ▁( ▁sig ▁. ▁name ▁) ▁; ▁int ▁n params ▁= ▁sig ▁. ▁parameter Names ▁. ▁size ▁( ▁) ▁; ▁int ▁k w args Index ▁= ▁sig ▁. ▁has K w args ▁? ▁-- ▁n params ▁: ▁- ▁1 ▁; ▁int ▁var args Index ▁= ▁sig ▁. ▁has Varargs ▁? ▁-- ▁n params ▁: ▁- ▁1 ▁; ▁Callable ▁. ▁Builder ▁callable ▁= ▁Callable ▁. ▁newBuilder ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁sig ▁. ▁parameter Names ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁String ▁name ▁= ▁sig ▁. ▁parameter Names ▁. ▁get ▁( ▁i ▁) ▁; ▁Param ▁. ▁Builder ▁param ▁= ▁Param ▁. ▁newBuilder ▁( ▁) ▁; ▁if ▁( ▁i ▁== ▁var args Index ▁) ▁{ ▁param ▁. ▁setName ▁( ▁STR ▁+ ▁name ▁) ▁; ▁param ▁. ▁setIs St ar Arg ▁( ▁true ▁) ▁; ▁} ▁else ▁if ▁( ▁i ▁== ▁k w args Index ▁) ▁{ ▁param ▁. ▁setName ▁( ▁STR ▁+ ▁name ▁) ▁; ▁param ▁. ▁setIs St ar St ar Arg ▁( ▁true ▁) ▁; ▁} ▁else ▁{ ▁param ▁. ▁setName ▁( ▁name ▁) ▁; ▁String ▁v ▁= ▁sig ▁. ▁getDefaultValue ▁. ▁apply ▁( ▁i ▁) ▁; ▁if ▁( ▁v ▁!= ▁null ▁) ▁{ ▁param ▁. ▁setDefault Value ▁( ▁v ▁) ▁; ▁} ▁else ▁{ ▁param ▁. ▁setIs M andatory ▁( ▁true ▁) ▁; ▁} ▁} ▁callable ▁. ▁add Param ▁( ▁param ▁) ▁; ▁} ▁value ▁. ▁set Callable ▁( ▁callable ▁) ▁; ▁return ▁value ▁; ▁} ▁private ▁static ▁Value ▁. ▁Builder ▁collect MethodInfo ▁( ▁StarlarkMethod Doc ▁met h ▁) ▁{ ▁Value ▁. ▁Builder ▁field ▁= ▁Value ▁. ▁newBuilder ▁( ▁) ▁; ▁field ▁. ▁setName ▁( ▁met h ▁. ▁getShort Name ▁( ▁) ▁) ▁; ▁field ▁. ▁set Doc ▁( ▁met h ▁. ▁get Documentation ▁( ▁) ▁) ▁; ▁if ▁( ▁met h ▁. ▁is Callable ▁( ▁) ▁) ▁{ ▁Callable ▁. ▁Builder ▁callable ▁= ▁Callable ▁. ▁newBuilder ▁( ▁) ▁; ▁for ▁( ▁Starlark Param Doc ▁par ▁: ▁met h ▁. ▁getParams ▁( ▁) ▁) ▁{ ▁Param ▁. ▁Builder ▁param ▁= ▁new Param ▁( ▁par ▁. ▁getName ▁( ▁) ▁, ▁par ▁. ▁getDefaultValue ▁( ▁) ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁param ▁. ▁setType ▁( ▁par ▁. ▁getType ▁( ▁) ▁) ▁; ▁param ▁. ▁set Doc ▁( ▁par ▁. ▁get Documentation ▁( ▁) ▁) ▁; ▁param ▁. ▁setDefault Value ▁( ▁par ▁. ▁getDefaultValue ▁( ▁) ▁) ▁; ▁callable ▁. ▁add Param ▁( ▁param ▁) ▁; ▁} ▁callable ▁. ▁set ReturnType ▁( ▁met h ▁. ▁getReturnType ▁( ▁) ▁) ▁; ▁field ▁. ▁set Callable ▁( ▁callable ▁) ▁; ▁} ▁else ▁{ ▁field ▁. ▁setType ▁( ▁met h ▁. ▁getReturnType ▁( ▁) ▁) ▁; ▁} ▁return ▁field ▁; ▁}
▁@ ▁U sed By Generated Code ▁public ▁static ▁boolean ▁distinct Short Short ▁( ▁long ▁left ▁, ▁boolean ▁left Null ▁, ▁long ▁right ▁, ▁boolean ▁right Null ▁) ▁{ ▁if ▁( ▁left Null ▁!= ▁right Null ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁left Null ▁) ▁{ ▁return ▁false ▁; ▁} ▁return ▁primitive Short Short ▁( ▁left ▁, ▁right ▁, ▁IS _ RESULT _ NOT _ EQUAL ▁) ▁; ▁} ▁@ ▁U sed By Generated Code ▁public ▁static ▁boolean ▁distinct Long Long ▁( ▁Slice ▁left ▁, ▁boolean ▁left Null ▁, ▁Slice ▁right ▁, ▁boolean ▁right Null ▁) ▁{ ▁if ▁( ▁left Null ▁!= ▁right Null ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁left Null ▁) ▁{ ▁return ▁false ▁; ▁} ▁return ▁primitive Long Long ▁( ▁left ▁, ▁right ▁, ▁IS _ RESULT _ NOT _ EQUAL ▁) ▁; ▁} ▁private ▁static ▁boolean ▁invoke Get Result ▁( ▁MethodHandle ▁getResult MethodHandle ▁, ▁int ▁comp arison Result ▁) ▁{ ▁try ▁{ ▁return ▁( ▁boolean ▁) ▁getResult MethodHandle ▁. ▁invoke Exact ▁( ▁comp arison Result ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁throwIf InstanceOf ▁( ▁t ▁, ▁Error ▁. ▁class ▁) ▁; ▁throwIf InstanceOf ▁( ▁t ▁, ▁PrestoException ▁. ▁class ▁) ▁; ▁throw ▁new ▁PrestoException ▁( ▁GENERIC _ INTERNAL _ ERROR ▁, ▁t ▁) ▁; ▁} ▁} ▁private ▁static ▁Sql ScalarFunction ▁between Operator ▁( ▁) ▁{ ▁Signature ▁signature ▁= ▁Signature Builder ▁. ▁builder ▁( ▁) ▁. ▁kind ▁( ▁S CAL AR ▁) ▁. ▁operator Type ▁( ▁B ET WE EN ▁) ▁. ▁argumentTypes ▁( ▁DECIMAL _ SIGNATURE ▁, ▁DECIMAL _ SIGNATURE ▁, ▁DECIMAL _ SIGNATURE ▁) ▁. ▁returnType ▁( ▁parse TypeSignature ▁( ▁BOOLEAN ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁return ▁Sql ScalarFunction ▁. ▁builder ▁( ▁Decimal In equal ity Operators ▁. ▁class ▁, ▁B ET WE EN ▁) ▁. ▁signature ▁( ▁signature ▁) ▁. ▁determ in istic ▁( ▁true ▁) ▁. ▁choice ▁( ▁choice ▁-> ▁choice ▁. ▁implementation ▁( ▁methods Group ▁-> ▁methods Group ▁. ▁methods ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁@ ▁U sed By Generated Code ▁public ▁static ▁boolean ▁between Short Short Short ▁( ▁long ▁value ▁, ▁long ▁low ▁, ▁long ▁high ▁) ▁{ ▁return ▁low ▁<= ▁value ▁&& ▁value ▁<= ▁high ▁; ▁} ▁@ ▁U sed By Generated Code ▁public ▁static ▁boolean ▁between Long Long Long ▁( ▁Slice ▁value ▁, ▁Slice ▁low ▁, ▁Slice ▁high ▁) ▁{ ▁return ▁compare ▁( ▁low ▁, ▁value ▁) ▁<= ▁0 ▁&& ▁compare ▁( ▁value ▁, ▁high ▁) ▁<= ▁0 ▁; ▁} ▁}
▁when ▁( ▁remote Cache ▁. ▁download Action Result ▁( ▁any ▁( ▁Remote Action ExecutionContext ▁. ▁class ▁) ▁, ▁any ▁( ▁Action Key ▁. ▁class ▁) ▁, ▁eq ▁( ▁false ▁) ▁) ▁) ▁. ▁then Answer ▁( ▁new ▁Answer ▁< ▁Action Result ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Action Result ▁answer ▁( ▁Invocation OnMock ▁invocation ▁) ▁{ ▁Remote Action ExecutionContext ▁context ▁= ▁invocation ▁. ▁getArgument ▁( ▁0 ▁) ▁; ▁Request Metadata ▁meta ▁= ▁context ▁. ▁getRequest Metadata ▁( ▁) ▁; ▁assertThat ▁( ▁meta ▁. ▁getC orre lated Invocations Id ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁BUILD _ REQUEST _ ID ▁) ▁; ▁assertThat ▁( ▁meta ▁. ▁getTool Invocation Id ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁COM MAND _ ID ▁) ▁; ▁return ▁action Result ▁; ▁} ▁} ▁) ▁; ▁Mockito ▁. ▁doAnswer ▁( ▁new ▁Answer ▁< ▁Void ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Void ▁answer ▁( ▁Invocation OnMock ▁invocation ▁) ▁{ ▁Remote Action ExecutionContext ▁context ▁= ▁invocation ▁. ▁getArgument ▁( ▁0 ▁) ▁; ▁Request Metadata ▁meta ▁= ▁context ▁. ▁getRequest Metadata ▁( ▁) ▁; ▁assertThat ▁( ▁meta ▁. ▁getC orre lated Invocations Id ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁BUILD _ REQUEST _ ID ▁) ▁; ▁assertThat ▁( ▁meta ▁. ▁getTool Invocation Id ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁COM MAND _ ID ▁) ▁; ▁return ▁null ▁; ▁} ▁} ▁) ▁. ▁when ▁( ▁remote Cache ▁) ▁. ▁download ▁( ▁any ▁( ▁) ▁, ▁any ▁( ▁) ▁, ▁eq ▁( ▁action Result ▁) ▁, ▁eq ▁( ▁out Err ▁) ▁, ▁any ▁( ▁) ▁, ▁any ▁( ▁) ▁) ▁; ▁Cache Handle ▁entry ▁= ▁cache ▁. ▁lookup ▁( ▁simple Spawn ▁, ▁simple Policy ▁) ▁; ▁assertThat ▁( ▁entry ▁. ▁has Result ▁( ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁Spawn Result ▁result ▁= ▁entry ▁. ▁getResult ▁( ▁) ▁; ▁verify ▁( ▁remote Cache ▁) ▁. ▁download ▁( ▁any ▁( ▁) ▁, ▁any ▁( ▁) ▁, ▁eq ▁( ▁action Result ▁) ▁, ▁eq ▁( ▁out Err ▁) ▁, ▁any ▁( ▁) ▁, ▁any ▁( ▁) ▁) ▁; ▁verify ▁( ▁remote Cache ▁, ▁never ▁( ▁) ▁) ▁. ▁upload ▁( ▁any ▁( ▁Remote Action ExecutionContext ▁. ▁class ▁) ▁, ▁any ▁( ▁Remote Path Resolver ▁. ▁class ▁) ▁, ▁any ▁( ▁Action Key ▁. ▁class ▁) ▁, ▁any ▁( ▁Action ▁. ▁class ▁) ▁, ▁any ▁( ▁Command ▁. ▁class ▁) ▁, ▁any ▁( ▁Collection ▁. ▁class ▁) ▁, ▁any ▁( ▁File Out Err ▁. ▁class ▁) ▁) ▁; ▁assertThat ▁( ▁result ▁. ▁setup Success ▁( ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁assertThat ▁( ▁result ▁. ▁exitCode ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁0 ▁) ▁; ▁assertThat ▁( ▁result ▁. ▁is Cache Hit ▁( ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁assertThat ▁( ▁out Err ▁. ▁has Rec orded Output ▁( ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁assertThat ▁( ▁out Err ▁. ▁has Rec orded St derr ▁( ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁assertThat ▁( ▁progress Updates ▁) ▁. ▁containsExactly ▁( ▁Spawn Checking Cache Event ▁. ▁create ▁( ▁STR ▁) ▁) ▁; ▁}
▁public ▁class ▁Ex chan ger UnitTest ▁{ ▁@ ▁Test ▁public ▁void ▁given Threads _ when Message Ex changed _ thenCorrect ▁( ▁) ▁{ ▁Ex chan ger ▁< ▁String ▁> ▁ex chan ger ▁= ▁new ▁Ex chan ger ▁< ▁> ▁( ▁) ▁; ▁Runnable ▁task A ▁= ▁( ▁) ▁-> ▁{ ▁try ▁{ ▁String ▁message ▁= ▁ex chan ger ▁. ▁exchange ▁( ▁STR ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁message ▁) ▁; ▁} ▁catch ▁( ▁Interrupted Exception ▁e ▁) ▁{ ▁Thread ▁. ▁currentThread ▁( ▁) ▁. ▁interrupt ▁( ▁) ▁; ▁throw ▁new ▁Runtime Exception ▁( ▁e ▁) ▁; ▁} ▁} ▁; ▁Runnable ▁task B ▁= ▁( ▁) ▁-> ▁{ ▁try ▁{ ▁String ▁message ▁= ▁ex chan ger ▁. ▁exchange ▁( ▁STR ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁message ▁) ▁; ▁} ▁catch ▁( ▁Interrupted Exception ▁e ▁) ▁{ ▁Thread ▁. ▁currentThread ▁( ▁) ▁. ▁interrupt ▁( ▁) ▁; ▁throw ▁new ▁Runtime Exception ▁( ▁e ▁) ▁; ▁} ▁} ▁; ▁Completable Future ▁. ▁allOf ▁( ▁run Async ▁( ▁task A ▁) ▁, ▁run Async ▁( ▁task B ▁) ▁) ▁. ▁join ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁given Thread _ When Ex changed Message _ thenCorrect ▁( ▁) ▁throws ▁Interrupted Exception ▁, ▁Execution Exception ▁{ ▁Ex chan ger ▁< ▁String ▁> ▁ex chan ger ▁= ▁new ▁Ex chan ger ▁< ▁> ▁( ▁) ▁; ▁Runnable ▁runner ▁= ▁( ▁) ▁-> ▁{ ▁try ▁{ ▁String ▁message ▁= ▁ex chan ger ▁. ▁exchange ▁( ▁STR ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁message ▁) ▁; ▁} ▁catch ▁( ▁Interrupted Exception ▁e ▁) ▁{ ▁Thread ▁. ▁currentThread ▁( ▁) ▁. ▁interrupt ▁( ▁) ▁; ▁throw ▁new ▁Runtime Exception ▁( ▁e ▁) ▁; ▁} ▁} ▁; ▁Completable Future ▁< ▁Void ▁> ▁result ▁= ▁Completable Future ▁. ▁run Async ▁( ▁runner ▁) ▁; ▁String ▁msg ▁= ▁ex chan ger ▁. ▁exchange ▁( ▁STR ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁msg ▁) ▁; ▁result ▁. ▁join ▁( ▁) ▁; ▁} ▁}
▁else ▁{ ▁return ▁source Order ▁== ▁target Order ▁&& ▁lower Than ▁( ▁source ▁. ▁get Advice ▁( ▁) ▁. ▁getClass ▁( ▁) ▁, ▁target ▁. ▁get Advice ▁( ▁) ▁. ▁getClass ▁( ▁) ▁) ▁; ▁} ▁} ▁public ▁static ▁boolean ▁high er Than ▁( ▁Adv isor ▁source ▁, ▁Adv isor ▁target ▁) ▁{ ▁int ▁source Order ▁= ▁getOrder ▁( ▁source ▁) ▁; ▁int ▁target Order ▁= ▁getOrder ▁( ▁target ▁) ▁; ▁if ▁( ▁high er Than ▁( ▁source Order ▁, ▁target Order ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁{ ▁return ▁source Order ▁== ▁target Order ▁&& ▁high er Than ▁( ▁source ▁. ▁get Advice ▁( ▁) ▁. ▁getClass ▁( ▁) ▁, ▁target ▁. ▁get Advice ▁( ▁) ▁. ▁getClass ▁( ▁) ▁) ▁; ▁} ▁} ▁public ▁static ▁boolean ▁lower Or Equals ▁( ▁Adv isor ▁source ▁, ▁Adv isor ▁target ▁) ▁{ ▁int ▁source Order ▁= ▁getOrder ▁( ▁source ▁) ▁; ▁int ▁target Order ▁= ▁getOrder ▁( ▁target ▁) ▁; ▁if ▁( ▁lower Than ▁( ▁source Order ▁, ▁target Order ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁{ ▁return ▁source Order ▁== ▁target Order ▁&& ▁lower Or Equals ▁( ▁source ▁. ▁get Advice ▁( ▁) ▁. ▁getClass ▁( ▁) ▁, ▁target ▁. ▁get Advice ▁( ▁) ▁. ▁getClass ▁( ▁) ▁) ▁; ▁} ▁} ▁public ▁static ▁boolean ▁high er Or Equals ▁( ▁Adv isor ▁source ▁, ▁Adv isor ▁target ▁) ▁{ ▁int ▁source Order ▁= ▁getOrder ▁( ▁source ▁) ▁; ▁int ▁target Order ▁= ▁getOrder ▁( ▁target ▁) ▁; ▁if ▁( ▁high er Than ▁( ▁source Order ▁, ▁target Order ▁) ▁) ▁{ ▁return ▁true ▁; ▁} ▁else ▁{ ▁return ▁source Order ▁== ▁target Order ▁&& ▁high er Or Equals ▁( ▁source ▁. ▁get Advice ▁( ▁) ▁. ▁getClass ▁( ▁) ▁, ▁target ▁. ▁get Advice ▁( ▁) ▁. ▁getClass ▁( ▁) ▁) ▁; ▁} ▁} ▁public ▁static ▁int ▁lower ▁( ▁Integer ▁order Source ▁, ▁int ▁offset ▁) ▁{ ▁if ▁( ▁offset ▁<= ▁0 ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁if ▁( ▁order Source ▁== ▁null ▁) ▁{ ▁order Source ▁= ▁Ordered ▁. ▁LOWEST _ PRECEDENCE ▁; ▁} ▁if ▁( ▁Ordered ▁. ▁LOWEST _ PRECEDENCE ▁- ▁offset ▁< ▁order Source ▁) ▁{ ▁return ▁Ordered ▁. ▁LOWEST _ PRECEDENCE ▁; ▁} ▁return ▁order Source ▁+ ▁offset ▁; ▁} ▁public ▁static ▁int ▁high er ▁( ▁Integer ▁order Source ▁, ▁int ▁offset ▁) ▁{ ▁if ▁( ▁offset ▁<= ▁0 ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁) ▁; ▁} ▁if ▁( ▁order Source ▁== ▁null ▁) ▁{ ▁order Source ▁= ▁Ordered ▁. ▁LOWEST _ PRECEDENCE ▁; ▁} ▁if ▁( ▁Ordered ▁. ▁HIGH EST _ PRECEDENCE ▁+ ▁offset ▁> ▁order Source ▁) ▁{ ▁return ▁Ordered ▁. ▁HIGH EST _ PRECEDENCE ▁; ▁} ▁return ▁order Source ▁- ▁offset ▁; ▁} ▁}
▁@ ▁Test ▁public ▁void ▁f used For Parallel ▁( ▁) ▁{ ▁Flowable ▁. ▁from Stream ▁( ▁IntStream ▁. ▁range Closed ▁( ▁1 ▁, ▁1000 ▁) ▁. ▁boxed ▁( ▁) ▁) ▁. ▁parallel ▁( ▁) ▁. ▁runOn ▁( ▁Schedulers ▁. ▁comp utation ▁( ▁) ▁, ▁1 ▁) ▁. ▁map ▁( ▁v ▁-> ▁v ▁+ ▁1 ▁) ▁. ▁se quential ▁( ▁) ▁. ▁test ▁( ▁) ▁. ▁await Done ▁( ▁5 ▁, ▁TimeUnit ▁. ▁SECONDS ▁) ▁. ▁assert ValueCount ▁( ▁1000 ▁) ▁. ▁assertNoErrors ▁( ▁) ▁. ▁assert Complete ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run To End Close Crash ▁( ▁) ▁throws ▁Throwable ▁{ ▁TestHelper ▁. ▁with Error Tracking ▁( ▁errors ▁-> ▁{ ▁Stream ▁< ▁Integer ▁> ▁stream ▁= ▁Stream ▁. ▁of ▁( ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁) ▁. ▁on Close ▁( ▁( ▁) ▁-> ▁{ ▁throw ▁new ▁TestException ▁( ▁) ▁; ▁} ▁) ▁; ▁Flowable ▁. ▁from Stream ▁( ▁stream ▁) ▁. ▁test ▁( ▁) ▁. ▁assertResult ▁( ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁) ▁; ▁TestHelper ▁. ▁assertUn deliver able ▁( ▁errors ▁, ▁0 ▁, ▁TestException ▁. ▁class ▁) ▁; ▁} ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁take Close Crash ▁( ▁) ▁throws ▁Throwable ▁{ ▁TestHelper ▁. ▁with Error Tracking ▁( ▁errors ▁-> ▁{ ▁Stream ▁< ▁Integer ▁> ▁stream ▁= ▁Stream ▁. ▁of ▁( ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁) ▁. ▁on Close ▁( ▁( ▁) ▁-> ▁{ ▁throw ▁new ▁TestException ▁( ▁) ▁; ▁} ▁) ▁; ▁Flowable ▁. ▁from Stream ▁( ▁stream ▁) ▁. ▁take ▁( ▁3 ▁) ▁. ▁test ▁( ▁) ▁. ▁assertResult ▁( ▁1 ▁, ▁2 ▁, ▁3 ▁) ▁; ▁TestHelper ▁. ▁assertUn deliver able ▁( ▁errors ▁, ▁0 ▁, ▁TestException ▁. ▁class ▁) ▁; ▁} ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁hasNext Crash ▁( ▁) ▁{ ▁AtomicInteger ▁v ▁= ▁new ▁AtomicInteger ▁( ▁) ▁; ▁Flowable ▁. ▁from Stream ▁( ▁Stream ▁. ▁< ▁Integer ▁> ▁generate ▁( ▁( ▁) ▁-> ▁{ ▁int ▁value ▁= ▁v ▁. ▁getAndIncrement ▁( ▁) ▁; ▁if ▁( ▁value ▁== ▁1 ▁) ▁{ ▁throw ▁new ▁TestException ▁( ▁) ▁; ▁} ▁return ▁value ▁; ▁} ▁) ▁) ▁. ▁test ▁( ▁) ▁. ▁assertFailure ▁( ▁TestException ▁. ▁class ▁, ▁0 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁hasNext Crash Conditional ▁( ▁) ▁{ ▁AtomicInteger ▁counter ▁= ▁new ▁AtomicInteger ▁( ▁) ▁; ▁Flowable ▁. ▁from Stream ▁( ▁Stream ▁. ▁< ▁Integer ▁> ▁generate ▁( ▁( ▁) ▁-> ▁{ ▁int ▁value ▁= ▁counter ▁. ▁getAndIncrement ▁( ▁) ▁; ▁if ▁( ▁value ▁== ▁1 ▁) ▁{ ▁throw ▁new ▁TestException ▁( ▁) ▁; ▁} ▁return ▁value ▁; ▁} ▁) ▁) ▁. ▁filter ▁( ▁v ▁-> ▁true ▁) ▁. ▁test ▁( ▁) ▁. ▁assertFailure ▁( ▁TestException ▁. ▁class ▁, ▁0 ▁) ▁; ▁} ▁void ▁request One By One Base ▁( ▁boolean ▁condition al ▁) ▁{ ▁List ▁< ▁Object ▁> ▁list ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁;
▁else ▁{ ▁arguments ▁. ▁add ▁( ▁Substit ution ▁. ▁of ▁( ▁Java Semantics ▁. ▁J A CO CO _ METADATA _ PLACE HOLDER ▁, ▁STR ▁) ▁) ▁; ▁arguments ▁. ▁add ▁( ▁Substit ution ▁. ▁of ▁( ▁Java Semantics ▁. ▁J A CO CO _ MAIN _ CLASS _ PLACE HOLDER ▁, ▁STR ▁) ▁) ▁; ▁arguments ▁. ▁add ▁( ▁Substit ution ▁. ▁of ▁( ▁Java Semantics ▁. ▁J A CO CO _ JAVA _ RUN FILES _ ROOT _ PLACE HOLDER ▁, ▁STR ▁) ▁) ▁; ▁} ▁arguments ▁. ▁add ▁( ▁Substit ution ▁. ▁of ▁( ▁STR ▁, ▁Shell Escaper ▁. ▁escape String ▁( ▁java Start Class ▁) ▁) ▁) ▁; ▁ImmutableList ▁< ▁String ▁> ▁jvm Flags List ▁= ▁ImmutableList ▁. ▁copyOf ▁( ▁jvm Flags ▁) ▁; ▁arguments ▁. ▁add ▁( ▁Substit ution ▁. ▁of Space Separ ated List ▁( ▁STR ▁, ▁jvm Flags List ▁) ▁) ▁; ▁if ▁( ▁OS ▁. ▁getCurrent ▁( ▁) ▁== ▁OS ▁. ▁WINDOWS ▁) ▁{ ▁List ▁< ▁String ▁> ▁jvm Flags For Launcher ▁= ▁jvm Flags List ▁; ▁try ▁{ ▁jvm Flags For Launcher ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁jvm Flags List ▁. ▁size ▁( ▁) ▁) ▁; ▁for ▁( ▁String ▁f ▁: ▁jvm Flags List ▁) ▁{ ▁Shell Utils ▁. ▁tokenize ▁( ▁jvm Flags For Launcher ▁, ▁f ▁) ▁; ▁} ▁} ▁catch ▁( ▁Token ization Exception ▁e ▁) ▁{ ▁ruleContext ▁. ▁attribute Error ▁( ▁STR ▁, ▁STR ▁+ ▁e ▁) ▁; ▁} ▁return ▁create Windows Ex e Launcher ▁( ▁ruleContext ▁, ▁java Executable ▁, ▁classpath ▁, ▁java Start Class ▁, ▁jvm Flags For Launcher ▁, ▁executable ▁) ▁; ▁} ▁ruleContext ▁. ▁register Action ▁( ▁new ▁Template Expansion Action ▁( ▁ruleContext ▁. ▁getAction Owner ▁( ▁) ▁, ▁executable ▁, ▁ST UB _ SCRIPT ▁, ▁arguments ▁, ▁true ▁) ▁) ▁; ▁return ▁executable ▁; ▁} ▁private ▁static ▁Artifact ▁create Windows Ex e Launcher ▁( ▁RuleContext ▁ruleContext ▁, ▁String ▁java Executable ▁, ▁NestedSet ▁< ▁Artifact ▁> ▁classpath ▁, ▁String ▁java Start Class ▁, ▁List ▁< ▁String ▁> ▁jvm Flags ▁, ▁Artifact ▁java Launcher ▁) ▁{ ▁Launch Info ▁launch Info ▁= ▁Launch Info ▁. ▁builder ▁( ▁) ▁. ▁add KeyValue Pair ▁( ▁STR ▁, ▁STR ▁) ▁. ▁add KeyValue Pair ▁( ▁STR ▁, ▁ruleContext ▁. ▁getWorkspace Name ▁( ▁) ▁) ▁. ▁add KeyValue Pair ▁( ▁STR ▁, ▁ruleContext ▁. ▁get Configuration ▁( ▁) ▁. ▁runfiles Enabled ▁( ▁) ▁? ▁STR ▁: ▁STR ▁) ▁. ▁add KeyValue Pair ▁( ▁STR ▁, ▁java Executable ▁) ▁. ▁add KeyValue Pair ▁( ▁STR ▁, ▁Java Common ▁. ▁getJava Executable ▁( ▁ruleContext ▁) ▁. ▁getParent Directory ▁( ▁) ▁. ▁getRelative ▁( ▁STR ▁) ▁. ▁getPath String ▁( ▁) ▁) ▁. ▁add KeyValue Pair ▁( ▁STR ▁, ▁java Start Class ▁) ▁. ▁add Join ed Values ▁( ▁STR ▁, ▁STR ▁, ▁Iterables ▁. ▁transform ▁( ▁classpath ▁. ▁toList ▁( ▁) ▁, ▁Artifact ▁. ▁R UN FILES _ PATH _ STRING ▁) ▁) ▁. ▁add Join ed Values ▁( ▁STR ▁, ▁STR ▁, ▁jvm Flags ▁) ▁. ▁build ▁( ▁) ▁;
▁public ▁class ▁Script Evaluate Engine ▁{ ▁private ▁final ▁SQL Script Context ▁script Context ▁; ▁private ▁final ▁J ex l Engine ▁j ex l Engine ▁; ▁private ▁final ▁Script Variables Context ▁variables Context ▁; ▁private ▁Script Evaluate Engine ▁( ▁SQL Script Context ▁script Context ▁) ▁{ ▁this ▁. ▁script Context ▁= ▁script Context ▁; ▁j ex l Engine ▁= ▁new ▁J ex l Builder ▁( ▁) ▁. ▁cache ▁( ▁100 ▁) ▁. ▁create ▁( ▁) ▁; ▁variables Context ▁= ▁new ▁Script Variables Context ▁( ▁script Context ▁) ▁; ▁} ▁public ▁Object ▁evaluate Expression ▁( ▁String ▁expr String ▁) ▁throws ▁DBException ▁{ ▁try ▁{ ▁J ex l Expression ▁expression ▁= ▁j ex l Engine ▁. ▁create Expression ▁( ▁expr String ▁) ▁; ▁return ▁expression ▁. ▁evaluate ▁( ▁variables Context ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁throw ▁new ▁DBException ▁( ▁STR ▁+ ▁expr String ▁+ ▁STR ▁, ▁e ▁) ▁; ▁} ▁} ▁public ▁static ▁Script Evaluate Engine ▁getEngine ▁( ▁SQL Script Context ▁script Context ▁) ▁{ ▁Script Evaluate Engine ▁engine ▁= ▁( ▁Script Evaluate Engine ▁) ▁script Context ▁. ▁getData ▁( ▁STR ▁) ▁; ▁if ▁( ▁engine ▁== ▁null ▁) ▁{ ▁engine ▁= ▁new ▁Script Evaluate Engine ▁( ▁script Context ▁) ▁; ▁script Context ▁. ▁setData ▁( ▁STR ▁, ▁engine ▁) ▁; ▁} ▁return ▁engine ▁; ▁} ▁}
▁public ▁class ▁Switch Canonical izer Test ▁extends ▁Graal CompilerTest ▁{ ▁public ▁int ▁div By Power Of 2 ▁( ▁int ▁n ▁) ▁{ ▁switch ▁( ▁n ▁ / ▁8 ▁) ▁{ ▁case ▁Integer ▁. ▁MAX _ VALUE ▁ / ▁8 ▁+ ▁1 ▁: ▁return ▁hashCode ▁( ▁) ▁; ▁default ▁: ▁return ▁1 ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Div By Power Of 2 ▁( ▁) ▁{ ▁should Fold Switch ▁( ▁STR ▁) ▁; ▁} ▁public ▁int ▁div By Non Power Of 2 ▁( ▁int ▁n ▁) ▁{ ▁switch ▁( ▁n ▁ / ▁7 ▁) ▁{ ▁case ▁Integer ▁. ▁MAX _ VALUE ▁ / ▁7 ▁+ ▁1 ▁: ▁return ▁hashCode ▁( ▁) ▁; ▁default ▁: ▁return ▁1 ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Div By Non Power Of 2 ▁( ▁) ▁{ ▁should Fold Switch ▁( ▁STR ▁) ▁; ▁} ▁public ▁int ▁rem By Power Of 2 ▁( ▁int ▁n ▁) ▁{ ▁switch ▁( ▁n ▁ % ▁8 ▁) ▁{ ▁case ▁9 ▁: ▁return ▁hashCode ▁( ▁) ▁; ▁default ▁: ▁return ▁1 ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Rem By Power Of 2 ▁( ▁) ▁{ ▁should Fold Switch ▁( ▁STR ▁) ▁; ▁} ▁public ▁int ▁rem By Power Of 2 Positive X ▁( ▁int ▁n ▁) ▁{ ▁int ▁n 0 ▁= ▁n ▁> ▁0 ▁? ▁8 ▁: ▁9 ▁; ▁switch ▁( ▁n 0 ▁ % ▁8 ▁) ▁{ ▁case ▁9 ▁: ▁return ▁hashCode ▁( ▁) ▁; ▁default ▁: ▁return ▁1 ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Rem By Power Of 2 Positive X ▁( ▁) ▁{ ▁should Fold Switch ▁( ▁STR ▁) ▁; ▁} ▁public ▁int ▁rem By Power Of 2 Negative X ▁( ▁int ▁n ▁) ▁{ ▁int ▁n 0 ▁= ▁n ▁> ▁0 ▁? ▁- ▁8 ▁: ▁- ▁9 ▁; ▁switch ▁( ▁n 0 ▁ % ▁8 ▁) ▁{ ▁case ▁9 ▁: ▁return ▁hashCode ▁( ▁) ▁; ▁default ▁: ▁return ▁1 ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Rem By Power Of 2 Negative X ▁( ▁) ▁{ ▁should Fold Switch ▁( ▁STR ▁) ▁; ▁} ▁public ▁int ▁rem By Non Power Of 2 ▁( ▁int ▁n ▁) ▁{ ▁switch ▁( ▁n ▁ % ▁7 ▁) ▁{ ▁case ▁9 ▁: ▁return ▁hashCode ▁( ▁) ▁; ▁default ▁: ▁return ▁1 ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Rem By Non Power Of 2 ▁( ▁) ▁{ ▁should Fold Switch ▁( ▁STR ▁) ▁; ▁} ▁private ▁void ▁should Fold Switch ▁( ▁String ▁methodName ▁) ▁{ ▁StructuredGraph ▁graph ▁= ▁parse For Compile ▁( ▁getResolved JavaMethod ▁( ▁methodName ▁) ▁) ▁; ▁create Canonical izer Phase ▁( ▁) ▁. ▁apply ▁( ▁graph ▁, ▁getDefault High TierContext ▁( ▁) ▁) ▁; ▁assertTrue ▁( ▁graph ▁. ▁getNodes ▁( ▁) ▁. ▁filter ▁( ▁Integer Switch Node ▁. ▁class ▁) ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁} ▁}
▁@ ▁Service ▁public ▁class ▁Application Transaction Service ▁implements ▁ApplicationStat Chart Service ▁{ ▁private ▁final ▁Application Transaction Dao ▁application Transaction Dao ▁; ▁public ▁Application Transaction Service ▁( ▁Application Transaction Dao ▁application Transaction Dao ▁) ▁{ ▁this ▁. ▁application Transaction Dao ▁= ▁Objects ▁. ▁requireNonNull ▁( ▁application Transaction Dao ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Stat Chart ▁select Application Chart ▁( ▁String ▁applicationId ▁, ▁TimeWindow ▁timeWindow ▁) ▁{ ▁Objects ▁. ▁requireNonNull ▁( ▁applicationId ▁, ▁STR ▁) ▁; ▁Objects ▁. ▁requireNonNull ▁( ▁timeWindow ▁, ▁STR ▁) ▁; ▁List ▁< ▁AggreJoin TransactionBo ▁> ▁aggreJoin Transaction BoList ▁= ▁this ▁. ▁application Transaction Dao ▁. ▁getApplication Stat List ▁( ▁applicationId ▁, ▁timeWindow ▁) ▁; ▁return ▁new ▁Application Transaction Chart ▁( ▁timeWindow ▁, ▁aggreJoin Transaction BoList ▁) ▁; ▁} ▁}
▁try ▁{ ▁saver ▁. ▁save ▁( ▁image File ▁, ▁compression ▁) ▁; ▁} ▁finally ▁{ ▁fs n ▁. ▁read Un lock ▁( ▁) ▁; ▁} ▁return ▁image File ▁; ▁} ▁private ▁void ▁load F SI mage From Temp File ▁( ▁File ▁image File ▁) ▁throws ▁IOException ▁{ ▁F SI mage Format ▁. ▁Loader De leg ator ▁loader ▁= ▁F SI mage Format ▁. ▁new Loader ▁( ▁conf ▁, ▁fs n ▁) ▁; ▁fs n ▁. ▁writeLock ▁( ▁) ▁; ▁fs n ▁. ▁getFS Directory ▁( ▁) ▁. ▁writeLock ▁( ▁) ▁; ▁try ▁{ ▁loader ▁. ▁load ▁( ▁image File ▁, ▁false ▁) ▁; ▁fs n ▁. ▁getFS Directory ▁( ▁) ▁. ▁update Count For Quota ▁( ▁) ▁; ▁} ▁finally ▁{ ▁fs n ▁. ▁getFS Directory ▁( ▁) ▁. ▁write Un lock ▁( ▁) ▁; ▁fs n ▁. ▁write Un lock ▁( ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Snapshot On Root ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁Path ▁root ▁= ▁new ▁Path ▁( ▁STR ▁) ▁; ▁hdfs ▁. ▁allow Snapshot ▁( ▁root ▁) ▁; ▁hdfs ▁. ▁create Snapshot ▁( ▁root ▁, ▁STR ▁) ▁; ▁cluster ▁. ▁shutdown ▁( ▁) ▁; ▁cluster ▁= ▁new ▁MiniDFSCluster ▁. ▁Builder ▁( ▁conf ▁) ▁. ▁format ▁( ▁false ▁) ▁. ▁numDataNodes ▁( ▁NUM _ DATANODE S ▁) ▁. ▁build ▁( ▁) ▁; ▁cluster ▁. ▁waitActive ▁( ▁) ▁; ▁fs n ▁= ▁cluster ▁. ▁getName system ▁( ▁) ▁; ▁hdfs ▁= ▁cluster ▁. ▁getFileSystem ▁( ▁) ▁; ▁hdfs ▁. ▁set SafeMode ▁( ▁Safe Mode Action ▁. ▁SA FE MODE _ ENTER ▁) ▁; ▁hdfs ▁. ▁save Namespace ▁( ▁) ▁; ▁hdfs ▁. ▁set SafeMode ▁( ▁Safe Mode Action ▁. ▁SA FE MODE _ LE A VE ▁) ▁; ▁cluster ▁. ▁shutdown ▁( ▁) ▁; ▁cluster ▁= ▁new ▁MiniDFSCluster ▁. ▁Builder ▁( ▁conf ▁) ▁. ▁format ▁( ▁false ▁) ▁. ▁numDataNodes ▁( ▁NUM _ DATANODE S ▁) ▁. ▁build ▁( ▁) ▁; ▁cluster ▁. ▁waitActive ▁( ▁) ▁; ▁fs n ▁= ▁cluster ▁. ▁getName system ▁( ▁) ▁; ▁hdfs ▁= ▁cluster ▁. ▁getFileSystem ▁( ▁) ▁; ▁INode Directory ▁rootNode ▁= ▁fs n ▁. ▁dir ▁. ▁getI Node 4 Write ▁( ▁root ▁. ▁toString ▁( ▁) ▁) ▁. ▁as Directory ▁( ▁) ▁; ▁assertTrue ▁( ▁STR ▁, ▁rootNode ▁. ▁getChildren List ▁( ▁Snapshot ▁. ▁CURRENT _ STATE _ ID ▁) ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁Diff List ▁< ▁Directory Diff ▁> ▁diff List ▁= ▁rootNode ▁. ▁get Diff s ▁( ▁) ▁. ▁asList ▁( ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁diff List ▁. ▁size ▁( ▁) ▁) ▁; ▁Snapshot ▁s 1 ▁= ▁rootNode ▁. ▁getSnapshot ▁( ▁DFS Util ▁. ▁string 2 Bytes ▁( ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁s 1 ▁. ▁getId ▁( ▁) ▁, ▁diff List ▁. ▁get ▁( ▁0 ▁) ▁. ▁getSnapshot Id ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁fs n ▁. ▁getSnapshot Manager ▁( ▁) ▁. ▁getNum Snapshot table Dirs ▁( ▁) ▁) ▁;
▁public ▁class ▁G Image ▁{ ▁private ▁int ▁width ▁; ▁private ▁int ▁height ▁; ▁private ▁int ▁[ ▁] ▁array ▁; ▁public ▁G Image ▁( ▁int ▁width ▁, ▁int ▁height ▁, ▁G Image Format ▁format ▁, ▁InputStream ▁data ▁, ▁long ▁data Length ▁) ▁throws ▁IOException ▁{ ▁this ▁. ▁width ▁= ▁width ▁; ▁this ▁. ▁height ▁= ▁height ▁; ▁this ▁. ▁array ▁= ▁pack Data Into Array ▁( ▁format ▁, ▁data ▁, ▁data Length ▁) ▁; ▁} ▁public ▁Icon ▁toP NG ▁( ▁) ▁throws ▁IOException ▁{ ▁Image Writer ▁image Writer ▁= ▁getImage Writer ▁( ▁STR ▁) ▁; ▁return ▁getIcon ▁( ▁image Writer ▁) ▁; ▁} ▁public ▁Icon ▁to G IF ▁( ▁) ▁throws ▁IOException ▁{ ▁Image Writer ▁image Writer ▁= ▁getImage Writer ▁( ▁STR ▁) ▁; ▁return ▁getIcon ▁( ▁image Writer ▁) ▁; ▁} ▁public ▁Icon ▁to J PE G ▁( ▁) ▁throws ▁IOException ▁{ ▁Image Writer ▁image Writer ▁= ▁getImage Writer ▁( ▁STR ▁) ▁; ▁return ▁getIcon ▁( ▁image Writer ▁) ▁; ▁} ▁private ▁Icon ▁getIcon ▁( ▁Image Writer ▁image Writer ▁) ▁throws ▁IOException ▁{ ▁Graphics Environment ▁g Env ▁= ▁Graphics Environment ▁. ▁getLocal Graph ics Environment ▁( ▁) ▁; ▁Graphics Device ▁g Dev ▁= ▁g Env ▁. ▁getDefault Screen Device ▁( ▁) ▁; ▁Graphics Configuration ▁g Config ▁= ▁g Dev ▁. ▁getDefault Configuration ▁( ▁) ▁; ▁BufferedImage ▁buffered Image ▁= ▁g Config ▁. ▁create Compatible Image ▁( ▁width ▁, ▁height ▁, ▁Trans par ency ▁. ▁TRANS LU CENT ▁) ▁; ▁buffered Image ▁. ▁setR GB ▁( ▁0 ▁, ▁0 ▁, ▁width ▁, ▁height ▁, ▁array ▁, ▁0 ▁, ▁width ▁) ▁; ▁OutputStream ▁out ▁= ▁new ▁ByteArray OutputStream ▁( ▁) ▁; ▁Image OutputStream ▁image Out ▁= ▁new ▁Memory Cache Image OutputStream ▁( ▁out ▁) ▁; ▁image Writer ▁. ▁setOutput ▁( ▁image Out ▁) ▁; ▁try ▁{ ▁image Writer ▁. ▁write ▁( ▁buffered Image ▁) ▁; ▁} ▁finally ▁{ ▁image Out ▁. ▁close ▁( ▁) ▁; ▁} ▁Icon ▁icon ▁= ▁new ▁ImageIcon ▁( ▁buffered Image ▁) ▁; ▁return ▁icon ▁; ▁} ▁private ▁Image Writer ▁getImage Writer ▁( ▁String ▁format ▁) ▁throws ▁IOException ▁{ ▁Iterator ▁< ▁Image Writer ▁> ▁image Writers ▁= ▁Image IO ▁. ▁getImage Writer sBy Format Name ▁( ▁format ▁) ▁; ▁if ▁( ▁! ▁image Writers ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁STR ▁) ▁; ▁} ▁Image Writer ▁image Writer ▁= ▁image Writers ▁. ▁next ▁( ▁) ▁; ▁return ▁image Writer ▁; ▁} ▁private ▁int ▁[ ▁] ▁pack Data Into Array ▁( ▁G Image Format ▁format ▁, ▁InputStream ▁data ▁, ▁long ▁data Length ▁) ▁throws ▁IOException ▁{ ▁int ▁offset ▁= ▁0 ▁; ▁int ▁[ ▁] ▁arr ▁= ▁new ▁int ▁[ ▁width ▁ * ▁height ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁arr ▁. ▁length ▁; ▁++ ▁i ▁) ▁{ ▁if ▁( ▁format ▁== ▁G Image Format ▁. ▁RGB _ AL PHA _4 BYTE ▁) ▁{ ▁int ▁blue ▁= ▁0 ▁; ▁int ▁green ▁= ▁0 ▁; ▁int ▁red ▁= ▁0 ▁; ▁int ▁alpha ▁= ▁0 ▁;
▁public ▁final ▁class ▁Gson Test ▁extends ▁TestCase ▁{ ▁private ▁static ▁final ▁Ex clu der ▁CUSTOM _ EX CLU DER ▁= ▁Ex clu der ▁. ▁DEFAULT ▁. ▁exclude Fields Without Ex pose Annotation ▁( ▁) ▁. ▁disable InnerClass Serialization ▁( ▁) ▁; ▁private ▁static ▁final ▁Field NamingStrategy ▁CUSTOM _ FIELD _ NAM ING _ STRATEGY ▁= ▁new ▁Field NamingStrategy ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁String ▁translate Name ▁( ▁Field ▁f ▁) ▁{ ▁return ▁STR ▁; ▁} ▁} ▁; ▁public ▁void ▁test Overrides Default Ex clu der ▁( ▁) ▁{ ▁Gson ▁gson ▁= ▁new ▁Gson ▁( ▁CUSTOM _ EX CLU DER ▁, ▁CUSTOM _ FIELD _ NAM ING _ STRATEGY ▁, ▁new ▁HashMap ▁< ▁Type ▁, ▁Instance Creator ▁< ▁? ▁> ▁> ▁( ▁) ▁, ▁true ▁, ▁false ▁, ▁true ▁, ▁false ▁, ▁true ▁, ▁true ▁, ▁false ▁, ▁Long Serialization Policy ▁. ▁DEFAULT ▁, ▁null ▁, ▁DateFormat ▁. ▁DEFAULT ▁, ▁DateFormat ▁. ▁DEFAULT ▁, ▁new ▁ArrayList ▁< ▁Type AdapterFactory ▁> ▁( ▁) ▁, ▁new ▁ArrayList ▁< ▁Type AdapterFactory ▁> ▁( ▁) ▁, ▁new ▁ArrayList ▁< ▁Type AdapterFactory ▁> ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁CUSTOM _ EX CLU DER ▁, ▁gson ▁. ▁ex clu der ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁CUSTOM _ FIELD _ NAM ING _ STRATEGY ▁, ▁gson ▁. ▁field NamingStrategy ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁true ▁, ▁gson ▁. ▁serialize Nulls ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁false ▁, ▁gson ▁. ▁html Safe ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁test Cl oned Type AdapterFactory Lists Are In de pend ent ▁( ▁) ▁{ ▁Gson ▁original ▁= ▁new ▁Gson ▁( ▁CUSTOM _ EX CLU DER ▁, ▁CUSTOM _ FIELD _ NAM ING _ STRATEGY ▁, ▁new ▁HashMap ▁< ▁Type ▁, ▁Instance Creator ▁< ▁? ▁> ▁> ▁( ▁) ▁, ▁true ▁, ▁false ▁, ▁true ▁, ▁false ▁, ▁true ▁, ▁true ▁, ▁false ▁, ▁Long Serialization Policy ▁. ▁DEFAULT ▁, ▁null ▁, ▁DateFormat ▁. ▁DEFAULT ▁, ▁DateFormat ▁. ▁DEFAULT ▁, ▁new ▁ArrayList ▁< ▁Type AdapterFactory ▁> ▁( ▁) ▁, ▁new ▁ArrayList ▁< ▁Type AdapterFactory ▁> ▁( ▁) ▁, ▁new ▁ArrayList ▁< ▁Type AdapterFactory ▁> ▁( ▁) ▁) ▁; ▁Gson ▁clone ▁= ▁original ▁. ▁newBuilder ▁( ▁) ▁. ▁register TypeAdapter ▁( ▁Object ▁. ▁class ▁, ▁new ▁Test TypeAdapter ▁( ▁) ▁) ▁. ▁create ▁( ▁) ▁; ▁assertEquals ▁( ▁original ▁. ▁factories ▁. ▁size ▁( ▁) ▁+ ▁1 ▁, ▁clone ▁. ▁factories ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁private ▁static ▁final ▁class ▁Test TypeAdapter ▁extends ▁Type Adapter ▁< ▁Object ▁> ▁{ ▁@ ▁Override ▁public ▁void ▁write ▁( ▁Json Writer ▁out ▁, ▁Object ▁value ▁) ▁throws ▁IOException ▁{ ▁} ▁@ ▁Override ▁public ▁Object ▁read ▁( ▁JsonReader ▁in ▁) ▁throws ▁IOException ▁{ ▁return ▁null ▁; ▁} ▁} ▁}
▁if ▁( ▁realm ▁. ▁name ▁( ▁) ▁. ▁equals ▁( ▁token Realm ▁) ▁== ▁false ▁) ▁{ ▁throw ▁Saml Utils ▁. ▁s aml Exception ▁( ▁STR ▁, ▁realm ▁, ▁token Realm ▁) ▁; ▁} ▁final ▁Saml Name Id ▁name Id ▁= ▁new ▁Saml Name Id ▁( ▁getMetadata String ▁( ▁token Metadata ▁, ▁Saml Realm ▁. ▁TOKEN _ METADATA _ NAME ID _ FORMAT ▁) ▁, ▁getMetadata String ▁( ▁token Metadata ▁, ▁Saml Realm ▁. ▁TOKEN _ METADATA _ NAME ID _ VALUE ▁) ▁, ▁getMetadata String ▁( ▁token Metadata ▁, ▁Saml Realm ▁. ▁TOKEN _ METADATA _ NAME ID _ QUAL IFIER ▁) ▁, ▁getMetadata String ▁( ▁token Metadata ▁, ▁Saml Realm ▁. ▁TOKEN _ METADATA _ NAME ID _ SP _ QUAL IFIER ▁) ▁, ▁getMetadata String ▁( ▁token Metadata ▁, ▁Saml Realm ▁. ▁TOKEN _ METADATA _ NAME ID _ SP _ PRO VID ED _ ID ▁) ▁) ▁; ▁final ▁String ▁session ▁= ▁getMetadata String ▁( ▁token Metadata ▁, ▁Saml Realm ▁. ▁TOKEN _ METADATA _ SESSION ▁) ▁; ▁final ▁Log out Request ▁logout ▁= ▁realm ▁. ▁build Logout Request ▁( ▁name Id ▁. ▁as Xml ▁( ▁) ▁, ▁session ▁) ▁; ▁if ▁( ▁logout ▁== ▁null ▁) ▁{ ▁return ▁new ▁Saml Logout Response ▁( ▁null ▁, ▁null ▁) ▁; ▁} ▁final ▁String ▁uri ▁= ▁new ▁Saml Redirect ▁( ▁logout ▁, ▁realm ▁. ▁getS ign ing Configuration ▁( ▁) ▁) ▁. ▁getRe direct Url ▁( ▁) ▁; ▁return ▁new ▁Saml Logout Response ▁( ▁logout ▁. ▁getID ▁( ▁) ▁, ▁uri ▁) ▁; ▁} ▁private ▁String ▁getMetadata String ▁( ▁Map ▁< ▁String ▁, ▁Object ▁> ▁metadata ▁, ▁String ▁key ▁) ▁{ ▁final ▁Object ▁value ▁= ▁metadata ▁. ▁get ▁( ▁key ▁) ▁; ▁if ▁( ▁value ▁== ▁null ▁) ▁{ ▁if ▁( ▁metadata ▁. ▁containsKey ▁( ▁key ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁throw ▁Saml Utils ▁. ▁s aml Exception ▁( ▁STR ▁, ▁key ▁) ▁; ▁} ▁if ▁( ▁value ▁instanceof ▁String ▁) ▁{ ▁return ▁( ▁String ▁) ▁value ▁; ▁} ▁else ▁{ ▁throw ▁Saml Utils ▁. ▁s aml Exception ▁( ▁STR ▁, ▁key ▁, ▁value ▁. ▁getClass ▁( ▁) ▁) ▁; ▁} ▁} ▁private ▁Saml Realm ▁find Realm ▁( ▁Authentication ▁authentication ▁) ▁{ ▁final ▁Authentication ▁. ▁Realm Ref ▁ref ▁= ▁authentication ▁. ▁getAuth enticated By ▁( ▁) ▁; ▁if ▁( ▁ref ▁== ▁null ▁|| ▁Strings ▁. ▁isNullOrEmpty ▁( ▁ref ▁. ▁getName ▁( ▁) ▁) ▁) ▁{ ▁throw ▁Saml Utils ▁. ▁s aml Exception ▁( ▁STR ▁, ▁authentication ▁) ▁; ▁} ▁final ▁Realm ▁realm ▁= ▁real ms ▁. ▁realm ▁( ▁ref ▁. ▁getName ▁( ▁) ▁) ▁; ▁if ▁( ▁realm ▁== ▁null ▁) ▁{ ▁throw ▁Saml Utils ▁. ▁s aml Exception ▁( ▁STR ▁, ▁ref ▁. ▁getName ▁( ▁) ▁) ▁; ▁} ▁if ▁( ▁realm ▁instanceof ▁Saml Realm ▁) ▁{ ▁return ▁( ▁Saml Realm ▁) ▁realm ▁; ▁} ▁else ▁{ ▁throw ▁Saml Utils ▁. ▁s aml Exception ▁( ▁STR ▁, ▁realm ▁) ▁; ▁} ▁} ▁}
▁public ▁abstract ▁class ▁A ms Task ▁extends ▁Future Task ▁< ▁Bundle ▁> ▁implements ▁Account Manager Future ▁< ▁Bundle ▁> ▁{ ▁protected ▁final ▁I Account Manager Response ▁m Response ▁; ▁final ▁Handler ▁m Handler ▁; ▁final ▁Account Manager Callback ▁< ▁Bundle ▁> ▁m Callback ▁; ▁final ▁Activity ▁m Activity ▁; ▁public ▁A ms Task ▁( ▁Activity ▁activity ▁, ▁Handler ▁handler ▁, ▁Account Manager Callback ▁< ▁Bundle ▁> ▁callback ▁) ▁{ ▁super ▁( ▁new ▁Callable ▁< ▁Bundle ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Bundle ▁call ▁( ▁) ▁throws ▁Exception ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁} ▁} ▁) ▁; ▁m Handler ▁= ▁handler ▁; ▁m Callback ▁= ▁callback ▁; ▁m Activity ▁= ▁activity ▁; ▁m Response ▁= ▁new ▁Response ▁( ▁) ▁; ▁} ▁public ▁final ▁Account Manager Future ▁< ▁Bundle ▁> ▁start ▁( ▁) ▁{ ▁try ▁{ ▁do Work ▁( ▁) ▁; ▁} ▁catch ▁( ▁RemoteException ▁e ▁) ▁{ ▁setException ▁( ▁e ▁) ▁; ▁} ▁return ▁this ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁set ▁( ▁Bundle ▁bundle ▁) ▁{ ▁if ▁( ▁bundle ▁== ▁null ▁) ▁{ ▁V Log ▁. ▁e ▁( ▁STR ▁, ▁STR ▁, ▁new ▁Exception ▁( ▁) ▁) ▁; ▁} ▁super ▁. ▁set ▁( ▁bundle ▁) ▁; ▁} ▁public ▁abstract ▁void ▁do Work ▁( ▁) ▁throws ▁RemoteException ▁; ▁private ▁Bundle ▁internal Get Result ▁( ▁Long ▁timeout ▁, ▁TimeUnit ▁unit ▁) ▁throws ▁Operation Canceled Exception ▁, ▁IOException ▁, ▁Auth enticator Exception ▁{ ▁try ▁{ ▁if ▁( ▁timeout ▁== ▁null ▁) ▁{ ▁return ▁get ▁( ▁) ▁; ▁} ▁else ▁{ ▁return ▁get ▁( ▁timeout ▁, ▁unit ▁) ▁; ▁} ▁} ▁catch ▁( ▁Cancel lation Exception ▁e ▁) ▁{ ▁throw ▁new ▁Operation Canceled Exception ▁( ▁) ▁; ▁} ▁catch ▁( ▁Timeout Exception ▁e ▁) ▁{ ▁} ▁catch ▁( ▁Interrupted Exception ▁e ▁) ▁{ ▁} ▁catch ▁( ▁Execution Exception ▁e ▁) ▁{ ▁final ▁Throwable ▁cause ▁= ▁e ▁. ▁getCause ▁( ▁) ▁; ▁if ▁( ▁cause ▁instanceof ▁IOException ▁) ▁{ ▁throw ▁( ▁IOException ▁) ▁cause ▁; ▁} ▁else ▁if ▁( ▁cause ▁instanceof ▁Unsupported Operation Exception ▁) ▁{ ▁throw ▁new ▁Auth enticator Exception ▁( ▁cause ▁) ▁; ▁} ▁else ▁if ▁( ▁cause ▁instanceof ▁Auth enticator Exception ▁) ▁{ ▁throw ▁( ▁Auth enticator Exception ▁) ▁cause ▁; ▁} ▁else ▁if ▁( ▁cause ▁instanceof ▁Runtime Exception ▁) ▁{ ▁throw ▁( ▁Runtime Exception ▁) ▁cause ▁; ▁} ▁else ▁if ▁( ▁cause ▁instanceof ▁Error ▁) ▁{ ▁throw ▁( ▁Error ▁) ▁cause ▁; ▁} ▁else ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁cause ▁) ▁; ▁} ▁} ▁finally ▁{ ▁cancel ▁( ▁true ▁) ▁; ▁} ▁throw ▁new ▁Operation Canceled Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Bundle ▁getResult ▁( ▁) ▁throws ▁Operation Canceled Exception ▁, ▁IOException ▁, ▁Auth enticator Exception ▁{ ▁return ▁internal Get Result ▁( ▁null ▁, ▁null ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Bundle ▁getResult ▁( ▁long ▁timeout ▁, ▁TimeUnit ▁unit ▁) ▁throws ▁Operation Canceled Exception ▁, ▁IOException ▁, ▁Auth enticator Exception ▁{ ▁return ▁internal Get Result ▁( ▁timeout ▁, ▁unit ▁) ▁; ▁}
▁private ▁long ▁parse Path ▁( ▁Timeline Data Manager ▁tdm ▁, ▁Path ▁log Path ▁, ▁boolean ▁app Completed ▁, ▁Json Factory ▁json Factory ▁, ▁ObjectMapper ▁obj Mapper ▁, ▁FileSystem ▁fs ▁) ▁throws ▁IOException ▁{ ▁UserGroup Information ▁ugi ▁= ▁UserGroup Information ▁. ▁create Remote User ▁( ▁user ▁) ▁; ▁FSData InputStream ▁in ▁= ▁fs ▁. ▁open ▁( ▁log Path ▁) ▁; ▁JsonParser ▁parser ▁= ▁null ▁; ▁try ▁{ ▁in ▁. ▁seek ▁( ▁offset ▁) ▁; ▁try ▁{ ▁parser ▁= ▁json Factory ▁. ▁createParser ▁( ▁( ▁InputStream ▁) ▁in ▁) ▁; ▁parser ▁. ▁configure ▁( ▁JsonParser ▁. ▁Feature ▁. ▁AUTO _ CLOSE _ SOURCE ▁, ▁false ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁if ▁( ▁app Completed ▁) ▁{ ▁throw ▁e ▁; ▁} ▁else ▁{ ▁LOG ▁. ▁debug ▁( ▁STR ▁, ▁e ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁return ▁doParse ▁( ▁tdm ▁, ▁parser ▁, ▁obj Mapper ▁, ▁ugi ▁, ▁app Completed ▁) ▁; ▁} ▁finally ▁{ ▁IOUtils ▁. ▁close Stream ▁( ▁parser ▁) ▁; ▁IOUtils ▁. ▁close Stream ▁( ▁in ▁) ▁; ▁} ▁} ▁protected ▁abstract ▁long ▁doParse ▁( ▁Timeline Data Manager ▁tdm ▁, ▁JsonParser ▁parser ▁, ▁ObjectMapper ▁obj Mapper ▁, ▁UserGroup Information ▁ugi ▁, ▁boolean ▁app Completed ▁) ▁throws ▁IOException ▁; ▁} ▁class ▁Entity Log Info ▁extends ▁Log Info ▁{ ▁private ▁static ▁final ▁Logger ▁LOG ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Entity Group F ST imeline Store ▁. ▁class ▁) ▁; ▁public ▁Entity Log Info ▁( ▁String ▁attempt Id ▁, ▁String ▁file ▁, ▁String ▁owner ▁) ▁{ ▁super ▁( ▁attempt Id ▁, ▁file ▁, ▁owner ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁long ▁doParse ▁( ▁Timeline Data Manager ▁tdm ▁, ▁JsonParser ▁parser ▁, ▁ObjectMapper ▁obj Mapper ▁, ▁UserGroup Information ▁ugi ▁, ▁boolean ▁app Completed ▁) ▁throws ▁IOException ▁{ ▁long ▁count ▁= ▁0 ▁; ▁Timeline Entities ▁entities ▁= ▁new ▁Timeline Entities ▁( ▁) ▁; ▁ArrayList ▁< ▁TimelineEntity ▁> ▁entity List ▁= ▁new ▁ArrayList ▁< ▁TimelineEntity ▁> ▁( ▁1 ▁) ▁; ▁long ▁bytes Parsed ▁; ▁long ▁bytes Parsed Last Batch ▁= ▁0 ▁; ▁boolean ▁post Error ▁= ▁false ▁; ▁try ▁{ ▁Mapping Iterator ▁< ▁TimelineEntity ▁> ▁iter ▁= ▁obj Mapper ▁. ▁read Values ▁( ▁parser ▁, ▁TimelineEntity ▁. ▁class ▁) ▁; ▁while ▁( ▁iter ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁TimelineEntity ▁entity ▁= ▁iter ▁. ▁next ▁( ▁) ▁; ▁String ▁et ype ▁= ▁entity ▁. ▁getEntity Type ▁( ▁) ▁; ▁String ▁eid ▁= ▁entity ▁. ▁getEntity Id ▁( ▁) ▁; ▁LOG ▁. ▁trace ▁( ▁STR ▁, ▁et ype ▁) ▁; ▁++ ▁count ▁; ▁bytes Parsed ▁= ▁parser ▁. ▁getCurrent Location ▁( ▁) ▁. ▁getChar Offset ▁( ▁) ▁+ ▁1 ▁; ▁LOG ▁. ▁trace ▁( ▁STR ▁, ▁bytes Parsed ▁) ▁; ▁try ▁{ ▁LOG ▁. ▁debug ▁( ▁STR ▁, ▁eid ▁, ▁et ype ▁) ▁; ▁entity List ▁. ▁add ▁( ▁entity ▁) ▁; ▁entities ▁. ▁set Entities ▁( ▁entity List ▁) ▁; ▁Timeline Put Response ▁response ▁= ▁tdm ▁. ▁post Entities ▁( ▁entities ▁, ▁ugi ▁) ▁;
▁private ▁static ▁final ▁TypeSerializer ▁< ▁RowData ▁> ▁OUT _ SERIALI Z ER _ WITH OUT _ R AN K _ NUMBER ▁= ▁new ▁RowData Serializer ▁( ▁OUTPUT _ TYPES _ WITH OUT _ R AN K _ NUMBER ▁) ▁; ▁private ▁static ▁final ▁RowData Harness Assert or ▁A SS ER TER _ WITH OUT _ R AN K _ NUMBER ▁= ▁new ▁RowData Harness Assert or ▁( ▁OUTPUT _ TYPES _ WITH OUT _ R AN K _ NUMBER ▁, ▁new ▁Generic Row Record Sort Comparator ▁( ▁0 ▁, ▁new ▁Var Char Type ▁( ▁Var Char Type ▁. ▁MAX _ LENGTH ▁) ▁) ▁) ▁; ▁private ▁static ▁final ▁ Z oneId ▁UTC _ Z ONE _ ID ▁= ▁ Z oneId ▁. ▁of ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁ Z oneId ▁SH ANG HA I _ Z ONE _ ID ▁= ▁ Z oneId ▁. ▁of ▁( ▁STR ▁) ▁; ▁private ▁final ▁ Z oneId ▁shift Time Z one ▁; ▁public ▁Window Rank Operator Test ▁( ▁ Z oneId ▁shift Time Z one ▁) ▁{ ▁this ▁. ▁shift Time Z one ▁= ▁shift Time Z one ▁; ▁} ▁@ ▁Parameterized ▁. ▁Parameters ▁( ▁name ▁= ▁STR ▁) ▁public ▁static ▁Collection ▁< ▁Object ▁[ ▁] ▁> ▁run Mode ▁( ▁) ▁{ ▁return ▁Arrays ▁. ▁asList ▁( ▁new ▁Object ▁[ ▁] ▁{ ▁UTC _ Z ONE _ ID ▁} ▁, ▁new ▁Object ▁[ ▁] ▁{ ▁SH ANG HA I _ Z ONE _ ID ▁} ▁) ▁; ▁} ▁private ▁static ▁OneInputStream Operator TestHarness ▁< ▁RowData ▁, ▁RowData ▁> ▁createTest Harness ▁( ▁Sl ic ingWindow Operator ▁< ▁RowData ▁, ▁? ▁> ▁operator ▁) ▁throws ▁Exception ▁{ ▁return ▁new ▁Keyed One InputStream Operator TestHarness ▁< ▁> ▁( ▁operator ▁, ▁KEY _ SE LE CTOR ▁, ▁KEY _ SE LE CTOR ▁. ▁getProduced Type ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Top 2 Windows ▁( ▁) ▁throws ▁Exception ▁{ ▁Sl ic ingWindow Operator ▁< ▁RowData ▁, ▁? ▁> ▁operator ▁= ▁Window Rank Operator Builder ▁. ▁builder ▁( ▁) ▁. ▁input Serializer ▁( ▁INPUT _ ROW _ SER ▁) ▁. ▁shift Time Z one ▁( ▁shift Time Z one ▁) ▁. ▁keySerializer ▁( ▁KEY _ SER ▁) ▁. ▁sort Key Comparator ▁( ▁GENER ATED _ S ORT _ KEY _ COMP ARATOR ▁) ▁. ▁sort KeySelector ▁( ▁S ORT _ KEY _ SE LE CTOR ▁) ▁. ▁output Rank Number ▁( ▁true ▁) ▁. ▁rank Start ▁( ▁1 ▁) ▁. ▁rank End ▁( ▁2 ▁) ▁. ▁window End Index ▁( ▁WINDO W _ END _ INDEX ▁) ▁. ▁build ▁( ▁) ▁; ▁OneInputStream Operator TestHarness ▁< ▁RowData ▁, ▁RowData ▁> ▁testHarness ▁= ▁createTest Harness ▁( ▁operator ▁) ▁; ▁testHarness ▁. ▁setup ▁( ▁OUT _ SERIALI Z ER ▁) ▁; ▁testHarness ▁. ▁open ▁( ▁) ▁; ▁Concurrent LinkedQueue ▁< ▁Object ▁> ▁expectedOutput ▁= ▁new ▁Concurrent LinkedQueue ▁< ▁> ▁( ▁) ▁; ▁testHarness ▁. ▁processElement ▁( ▁insert Record ▁( ▁STR ▁, ▁1 ▁, ▁to U tc Timestamp Mills ▁( ▁999 L ▁, ▁shift Time Z one ▁) ▁) ▁) ▁;
▁Assert ▁. ▁assertNotNull ▁( ▁thread ▁. ▁get ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertNotNull ▁( ▁throwable ▁. ▁get ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁thread ▁. ▁get ▁( ▁) ▁. ▁getName ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁expected ▁. ▁getClass ▁( ▁) ▁, ▁throwable ▁. ▁get ▁( ▁) ▁. ▁getClass ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁throwable ▁. ▁get ▁( ▁) ▁. ▁getMessage ▁( ▁) ▁) ▁; ▁} ▁}
▁@ ▁Override ▁public ▁Completable Future ▁< ▁Boolean ▁> ▁can Be Released ▁( ▁) ▁{ ▁return ▁Completable Future ▁. ▁completedFuture ▁( ▁shuffle Environment ▁. ▁getPartition s Occup y ing Local Resources ▁( ▁) ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Completable Future ▁< ▁Collection ▁< ▁Log Info ▁> ▁> ▁request Log List ▁( ▁Time ▁timeout ▁) ▁{ ▁return ▁Completable Future ▁. ▁sup ply Async ▁( ▁( ▁) ▁-> ▁{ ▁final ▁String ▁log Dir ▁= ▁taskManager Configuration ▁. ▁getTask Manager LogDir ▁( ▁) ▁; ▁if ▁( ▁log Dir ▁!= ▁null ▁) ▁{ ▁final ▁File ▁[ ▁] ▁log Files ▁= ▁new ▁File ▁( ▁log Dir ▁) ▁. ▁listFiles ▁( ▁) ▁; ▁if ▁( ▁log Files ▁== ▁null ▁) ▁{ ▁throw ▁new ▁Completion Exception ▁( ▁new ▁FlinkException ▁( ▁String ▁. ▁format ▁( ▁STR ▁, ▁log Dir ▁) ▁) ▁) ▁; ▁} ▁return ▁Arrays ▁. ▁stream ▁( ▁log Files ▁) ▁. ▁filter ▁( ▁File ▁:: ▁isFile ▁) ▁. ▁map ▁( ▁logFile ▁-> ▁new ▁Log Info ▁( ▁logFile ▁. ▁getName ▁( ▁) ▁, ▁logFile ▁. ▁length ▁( ▁) ▁) ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toList ▁( ▁) ▁) ▁; ▁} ▁return ▁Collections ▁. ▁emptyList ▁( ▁) ▁; ▁} ▁, ▁io Executor ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁onStart ▁( ▁) ▁throws ▁Exception ▁{ ▁try ▁{ ▁start TaskExecutor Services ▁( ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁t ▁) ▁{ ▁final ▁TaskManager Exception ▁exception ▁= ▁new ▁TaskManager Exception ▁( ▁String ▁. ▁format ▁( ▁STR ▁, ▁getAddress ▁( ▁) ▁) ▁, ▁t ▁) ▁; ▁on Fatal Error ▁( ▁exception ▁) ▁; ▁throw ▁exception ▁; ▁} ▁start Registration Timeout ▁( ▁) ▁; ▁} ▁private ▁void ▁start TaskExecutor Services ▁( ▁) ▁throws ▁Exception ▁{ ▁try ▁{ ▁resourceManager Leader Retriever ▁. ▁start ▁( ▁new ▁ResourceManager Leader Listener ▁( ▁) ▁) ▁; ▁task Slot Table ▁. ▁start ▁( ▁new ▁Slot Actions Impl ▁( ▁) ▁, ▁getMain ThreadExecutor ▁( ▁) ▁) ▁; ▁job Leader Service ▁. ▁start ▁( ▁getAddress ▁( ▁) ▁, ▁getRpc Service ▁( ▁) ▁, ▁ha Services ▁, ▁new ▁Job Leader Listener Impl ▁( ▁) ▁) ▁; ▁file Cache ▁= ▁new ▁File Cache ▁( ▁taskManager Configuration ▁. ▁getT mp Directories ▁( ▁) ▁, ▁blob Cache Service ▁. ▁getPerm anent Blob Service ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁handle Start TaskExecutor Services Exception ▁( ▁e ▁) ▁; ▁} ▁} ▁private ▁void ▁handle Start TaskExecutor Services Exception ▁( ▁Exception ▁e ▁) ▁throws ▁Exception ▁{ ▁try ▁{ ▁stop TaskExecutor Services ▁( ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁inner ▁) ▁{ ▁e ▁. ▁add Suppressed ▁( ▁inner ▁) ▁; ▁} ▁throw ▁e ▁; ▁} ▁@ ▁Override ▁public ▁Completable Future ▁< ▁Void ▁> ▁on Stop ▁( ▁) ▁{ ▁log ▁. ▁info ▁( ▁STR ▁, ▁getAddress ▁( ▁) ▁) ▁; ▁Throwable ▁jobManager Disconnect Throwable ▁= ▁null ▁; ▁FlinkException ▁cause ▁= ▁new ▁FlinkException ▁( ▁STR ▁) ▁; ▁close ResourceManager Connection ▁( ▁cause ▁) ▁; ▁for ▁( ▁Job Table ▁. ▁Job ▁job ▁: ▁job Table ▁. ▁getJob s ▁( ▁) ▁) ▁{ ▁try ▁{ ▁close Job ▁( ▁job ▁, ▁cause ▁) ▁; ▁}
▁final ▁class ▁Ch rom ium Url Fetcher ▁< ▁T ▁> ▁implements ▁Data Fetcher ▁< ▁T ▁> ▁, ▁Ch rom ium Request Serializer ▁. ▁Listener ▁{ ▁private ▁final ▁Ch rom ium Request Serializer ▁serializer ▁; ▁private ▁final ▁ByteBuffer Parser ▁< ▁T ▁> ▁parser ▁; ▁private ▁final ▁GlideUrl ▁url ▁; ▁private ▁Data Callback ▁< ▁? ▁super ▁T ▁> ▁callback ▁; ▁public ▁Ch rom ium Url Fetcher ▁( ▁Ch rom ium Request Serializer ▁serializer ▁, ▁ByteBuffer Parser ▁< ▁T ▁> ▁parser ▁, ▁GlideUrl ▁url ▁) ▁{ ▁this ▁. ▁serializer ▁= ▁serializer ▁; ▁this ▁. ▁parser ▁= ▁parser ▁; ▁this ▁. ▁url ▁= ▁url ▁; ▁} ▁@ ▁Override ▁public ▁void ▁load Data ▁( ▁Priority ▁priority ▁, ▁Data Callback ▁< ▁? ▁super ▁T ▁> ▁callback ▁) ▁{ ▁this ▁. ▁callback ▁= ▁callback ▁; ▁serializer ▁. ▁start Request ▁( ▁priority ▁, ▁url ▁, ▁this ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁cleanup ▁( ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁cancel ▁( ▁) ▁{ ▁serializer ▁. ▁cancel Request ▁( ▁url ▁, ▁this ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Class ▁< ▁T ▁> ▁getData Class ▁( ▁) ▁{ ▁return ▁parser ▁. ▁getData Class ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁DataSource ▁getDataSource ▁( ▁) ▁{ ▁return ▁DataSource ▁. ▁REMOTE ▁; ▁} ▁@ ▁Override ▁public ▁void ▁on Request Complete ▁( ▁ByteBuffer ▁byteBuffer ▁) ▁{ ▁callback ▁. ▁on Data Ready ▁( ▁parser ▁. ▁parse ▁( ▁byteBuffer ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁on Request Failed ▁( ▁@ ▁Nullable ▁Exception ▁e ▁) ▁{ ▁callback ▁. ▁onLoad Failed ▁( ▁e ▁) ▁; ▁} ▁}
▁public ▁class ▁Dis joint Set ▁< ▁T ▁> ▁{ ▁private ▁static ▁class ▁Entry ▁< ▁T ▁> ▁{ ▁private ▁T ▁parent ▁; ▁private ▁int ▁rank ▁; ▁public ▁Entry ▁( ▁) ▁{ ▁this ▁( ▁null ▁, ▁0 ▁) ▁; ▁} ▁public ▁Entry ▁( ▁Entry ▁< ▁T ▁> ▁entry ▁) ▁{ ▁this ▁( ▁entry ▁. ▁parent ▁, ▁entry ▁. ▁rank ▁) ▁; ▁} ▁private ▁Entry ▁( ▁T ▁parent ▁, ▁int ▁rank ▁) ▁{ ▁this ▁. ▁parent ▁= ▁parent ▁; ▁this ▁. ▁rank ▁= ▁rank ▁; ▁} ▁public ▁T ▁getParent ▁( ▁) ▁{ ▁return ▁parent ▁; ▁} ▁public ▁void ▁setParent ▁( ▁T ▁parent ▁) ▁{ ▁this ▁. ▁parent ▁= ▁parent ▁; ▁this ▁. ▁rank ▁= ▁- ▁1 ▁; ▁} ▁public ▁int ▁getR ank ▁( ▁) ▁{ ▁checkState ▁( ▁parent ▁== ▁null ▁) ▁; ▁return ▁rank ▁; ▁} ▁public ▁void ▁increment Rank ▁( ▁) ▁{ ▁checkState ▁( ▁parent ▁== ▁null ▁) ▁; ▁rank ▁++ ▁; ▁} ▁} ▁private ▁final ▁Map ▁< ▁T ▁, ▁Entry ▁< ▁T ▁> ▁> ▁map ▁; ▁public ▁Dis joint Set ▁( ▁) ▁{ ▁map ▁= ▁new ▁LinkedHashMap ▁< ▁> ▁( ▁) ▁; ▁} ▁public ▁boolean ▁find And Union ▁( ▁T ▁node 1 ▁, ▁T ▁node 2 ▁) ▁{ ▁return ▁union ▁( ▁find ▁( ▁node 1 ▁) ▁, ▁find ▁( ▁node 2 ▁) ▁) ▁; ▁} ▁public ▁T ▁find ▁( ▁T ▁element ▁) ▁{ ▁if ▁( ▁! ▁map ▁. ▁containsKey ▁( ▁element ▁) ▁) ▁{ ▁map ▁. ▁put ▁( ▁element ▁, ▁new ▁Entry ▁< ▁> ▁( ▁) ▁) ▁; ▁return ▁element ▁; ▁} ▁return ▁find Internal ▁( ▁element ▁) ▁; ▁} ▁private ▁boolean ▁union ▁( ▁T ▁root 1 ▁, ▁T ▁root 2 ▁) ▁{ ▁if ▁( ▁root 1 ▁. ▁equals ▁( ▁root 2 ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁Entry ▁< ▁T ▁> ▁entry 1 ▁= ▁map ▁. ▁get ▁( ▁root 1 ▁) ▁; ▁Entry ▁< ▁T ▁> ▁entry 2 ▁= ▁map ▁. ▁get ▁( ▁root 2 ▁) ▁; ▁int ▁entry 1 Rank ▁= ▁entry 1 ▁. ▁getR ank ▁( ▁) ▁; ▁int ▁entry 2 Rank ▁= ▁entry 2 ▁. ▁getR ank ▁( ▁) ▁; ▁verify ▁( ▁entry 1 Rank ▁>= ▁0 ▁) ▁; ▁verify ▁( ▁entry 2 Rank ▁>= ▁0 ▁) ▁; ▁if ▁( ▁entry 1 Rank ▁< ▁entry 2 Rank ▁) ▁{ ▁entry 1 ▁. ▁setParent ▁( ▁root 2 ▁) ▁; ▁} ▁else ▁{ ▁if ▁( ▁entry 1 Rank ▁== ▁entry 2 Rank ▁) ▁{ ▁entry 1 ▁. ▁increment Rank ▁( ▁) ▁; ▁} ▁entry 2 ▁. ▁setParent ▁( ▁root 1 ▁) ▁; ▁} ▁return ▁true ▁; ▁} ▁private ▁T ▁find Internal ▁( ▁T ▁element ▁) ▁{ ▁Entry ▁< ▁T ▁> ▁value ▁= ▁map ▁. ▁get ▁( ▁element ▁) ▁; ▁if ▁( ▁value ▁. ▁getParent ▁( ▁) ▁== ▁null ▁) ▁{ ▁return ▁element ▁; ▁} ▁else ▁{ ▁T ▁root ▁= ▁find Internal ▁( ▁value ▁. ▁getParent ▁( ▁) ▁) ▁; ▁value ▁. ▁setParent ▁( ▁root ▁) ▁; ▁return ▁root ▁; ▁} ▁}
▁public ▁class ▁Cache Loader IntegrationTest ▁{ ▁private ▁static ▁final ▁String ▁CACHE _ NAME ▁= ▁STR ▁; ▁private ▁Cache ▁< ▁Integer ▁, ▁String ▁> ▁cache ▁; ▁@ ▁Before ▁public ▁void ▁setup ▁( ▁) ▁{ ▁Caching Provider ▁caching Provider ▁= ▁Caching ▁. ▁getC aching Provider ▁( ▁STR ▁) ▁; ▁CacheManager ▁cacheManager ▁= ▁caching Provider ▁. ▁getCache Manager ▁( ▁) ▁; ▁Mutable Configuration ▁< ▁Integer ▁, ▁String ▁> ▁config ▁= ▁new ▁Mutable Configuration ▁< ▁Integer ▁, ▁String ▁> ▁( ▁) ▁. ▁setRead Through ▁( ▁true ▁) ▁. ▁setCache Loader Factory ▁( ▁new ▁Factory Builder ▁. ▁Singleton Factory ▁< ▁> ▁( ▁new ▁SimpleCache Loader ▁( ▁) ▁) ▁) ▁; ▁this ▁. ▁cache ▁= ▁cacheManager ▁. ▁create Cache ▁( ▁STR ▁, ▁config ▁) ▁; ▁} ▁@ ▁After ▁public ▁void ▁tearDown ▁( ▁) ▁{ ▁Caching ▁. ▁getC aching Provider ▁( ▁STR ▁) ▁. ▁getCache Manager ▁( ▁) ▁. ▁destroy Cache ▁( ▁CACHE _ NAME ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁when Reading From Storage _ thenCorrect ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁4 ▁; ▁i ▁++ ▁) ▁{ ▁String ▁value ▁= ▁cache ▁. ▁get ▁( ▁i ▁) ▁; ▁assertEquals ▁( ▁STR ▁+ ▁i ▁, ▁value ▁) ▁; ▁} ▁} ▁}
▁public ▁class ▁Field _ set 03 ▁extends ▁JTTTest ▁{ ▁private ▁static ▁class ▁TestClass ▁{ ▁public ▁byte ▁byte Field ▁; ▁public ▁short ▁short Field ▁; ▁public ▁char ▁char Field ▁; ▁public ▁int ▁int Field ▁; ▁public ▁long ▁long Field ▁; ▁public ▁float ▁float Field ▁; ▁public ▁double ▁double Field ▁; ▁public ▁boolean ▁boolean Field ▁; ▁} ▁private ▁static ▁final ▁TestClass ▁object ▁= ▁new ▁TestClass ▁( ▁) ▁; ▁public ▁static ▁boolean ▁test ▁( ▁int ▁arg ▁) ▁throws ▁NoSuch FieldException ▁, ▁Illegal AccessException ▁{ ▁if ▁( ▁arg ▁== ▁0 ▁) ▁{ ▁TestClass ▁. ▁class ▁. ▁getField ▁( ▁STR ▁) ▁. ▁set Byte ▁( ▁object ▁, ▁( ▁byte ▁) ▁11 ▁) ▁; ▁return ▁object ▁. ▁byte Field ▁== ▁11 ▁; ▁} ▁else ▁if ▁( ▁arg ▁== ▁1 ▁) ▁{ ▁TestClass ▁. ▁class ▁. ▁getField ▁( ▁STR ▁) ▁. ▁set Short ▁( ▁object ▁, ▁( ▁short ▁) ▁12 ▁) ▁; ▁return ▁object ▁. ▁short Field ▁== ▁12 ▁; ▁} ▁else ▁if ▁( ▁arg ▁== ▁2 ▁) ▁{ ▁TestClass ▁. ▁class ▁. ▁getField ▁( ▁STR ▁) ▁. ▁set Char ▁( ▁object ▁, ▁( ▁char ▁) ▁13 ▁) ▁; ▁return ▁object ▁. ▁char Field ▁== ▁13 ▁; ▁} ▁else ▁if ▁( ▁arg ▁== ▁3 ▁) ▁{ ▁TestClass ▁. ▁class ▁. ▁getField ▁( ▁STR ▁) ▁. ▁setInt ▁( ▁object ▁, ▁14 ▁) ▁; ▁return ▁object ▁. ▁int Field ▁== ▁14 ▁; ▁} ▁else ▁if ▁( ▁arg ▁== ▁4 ▁) ▁{ ▁TestClass ▁. ▁class ▁. ▁getField ▁( ▁STR ▁) ▁. ▁setLong ▁( ▁object ▁, ▁15 L ▁) ▁; ▁return ▁object ▁. ▁long Field ▁== ▁15 ▁; ▁} ▁else ▁if ▁( ▁arg ▁== ▁5 ▁) ▁{ ▁TestClass ▁. ▁class ▁. ▁getField ▁( ▁STR ▁) ▁. ▁set Float ▁( ▁object ▁, ▁16 ▁) ▁; ▁return ▁object ▁. ▁float Field ▁== ▁16 ▁; ▁} ▁else ▁if ▁( ▁arg ▁== ▁6 ▁) ▁{ ▁TestClass ▁. ▁class ▁. ▁getField ▁( ▁STR ▁) ▁. ▁set Double ▁( ▁object ▁, ▁17 ▁) ▁; ▁return ▁object ▁. ▁double Field ▁== ▁17 ▁; ▁} ▁else ▁if ▁( ▁arg ▁== ▁7 ▁) ▁{ ▁TestClass ▁. ▁class ▁. ▁getField ▁( ▁STR ▁) ▁. ▁setBoolean ▁( ▁object ▁, ▁true ▁) ▁; ▁return ▁object ▁. ▁boolean Field ▁== ▁true ▁; ▁} ▁return ▁false ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 0 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁0 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 1 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁1 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 2 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁2 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 3 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁3 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 4 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁4 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 5 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁5 ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁run 6 ▁( ▁) ▁throws ▁Throwable ▁{ ▁runTest ▁( ▁STR ▁, ▁6 ▁) ▁; ▁}
▁testHarness ▁. ▁processElement ▁( ▁new ▁StreamRecord ▁< ▁> ▁( ▁new Binary Row ▁( ▁true ▁, ▁STR ▁, ▁STR ▁, ▁1 L ▁, ▁1 L ▁) ▁, ▁initial Time ▁+ ▁2 ▁) ▁) ▁; ▁testHarness ▁. ▁processElement ▁( ▁new ▁StreamRecord ▁< ▁> ▁( ▁new Binary Row ▁( ▁true ▁, ▁STR ▁, ▁STR ▁, ▁2 L ▁, ▁10 L ▁) ▁, ▁initial Time ▁+ ▁3 ▁) ▁) ▁; ▁testHarness ▁. ▁processElement ▁( ▁new ▁StreamRecord ▁< ▁> ▁( ▁new Binary Row ▁( ▁true ▁, ▁STR ▁, ▁STR ▁, ▁3 L ▁, ▁2 L ▁) ▁, ▁initial Time ▁+ ▁3 ▁) ▁) ▁; ▁testHarness ▁. ▁process Watermark ▁( ▁new ▁Watermark ▁( ▁10000 L ▁) ▁) ▁; ▁expectedOutput ▁. ▁add ▁( ▁new ▁Watermark ▁( ▁10000 L ▁) ▁) ▁; ▁assertOutput Equals ▁( ▁STR ▁, ▁expectedOutput ▁, ▁testHarness ▁. ▁getOutput ▁( ▁) ▁) ▁; ▁testHarness ▁. ▁prepare Snapshot Pre Barrier ▁( ▁0 L ▁) ▁; ▁expectedOutput ▁. ▁add ▁( ▁new ▁StreamRecord ▁< ▁> ▁( ▁new Row ▁( ▁true ▁, ▁STR ▁, ▁STR ▁, ▁0 L ▁, ▁1 L ▁, ▁0 L ▁) ▁) ▁) ▁; ▁expectedOutput ▁. ▁add ▁( ▁new ▁StreamRecord ▁< ▁> ▁( ▁new Row ▁( ▁true ▁, ▁STR ▁, ▁STR ▁, ▁1 L ▁, ▁1 L ▁, ▁0 L ▁) ▁) ▁) ▁; ▁expectedOutput ▁. ▁add ▁( ▁new ▁StreamRecord ▁< ▁> ▁( ▁new Row ▁( ▁true ▁, ▁STR ▁, ▁STR ▁, ▁3 L ▁, ▁2 L ▁, ▁3 L ▁) ▁) ▁) ▁; ▁expectedOutput ▁. ▁add ▁( ▁new ▁StreamRecord ▁< ▁> ▁( ▁new Row ▁( ▁true ▁, ▁STR ▁, ▁STR ▁, ▁2 L ▁, ▁10 L ▁, ▁1 L ▁) ▁) ▁) ▁; ▁assertOutput Equals ▁( ▁STR ▁, ▁expectedOutput ▁, ▁testHarness ▁. ▁getOutput ▁( ▁) ▁) ▁; ▁testHarness ▁. ▁close ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Finish Bundle Triggered By Count ▁( ▁) ▁throws ▁Exception ▁{ ▁Configuration ▁conf ▁= ▁new ▁Configuration ▁( ▁) ▁; ▁conf ▁. ▁set Integer ▁( ▁Python Options ▁. ▁MAX _ B UN DLE _ SI Z E ▁, ▁6 ▁) ▁; ▁OneInputStream Operator TestHarness ▁< ▁RowData ▁, ▁RowData ▁> ▁testHarness ▁= ▁getTest Harness ▁( ▁conf ▁) ▁; ▁long ▁initial Time ▁= ▁0 L ▁; ▁Concurrent LinkedQueue ▁< ▁Object ▁> ▁expectedOutput ▁= ▁new ▁Concurrent LinkedQueue ▁< ▁> ▁( ▁) ▁; ▁testHarness ▁. ▁open ▁( ▁) ▁; ▁testHarness ▁. ▁processElement ▁( ▁new ▁StreamRecord ▁< ▁> ▁( ▁new Binary Row ▁( ▁true ▁, ▁STR ▁, ▁STR ▁, ▁0 L ▁, ▁1 L ▁) ▁, ▁initial Time ▁+ ▁1 ▁) ▁) ▁; ▁testHarness ▁. ▁processElement ▁( ▁new ▁StreamRecord ▁< ▁> ▁( ▁new Binary Row ▁( ▁true ▁, ▁STR ▁, ▁STR ▁, ▁1 L ▁, ▁1 L ▁) ▁, ▁initial Time ▁+ ▁2 ▁) ▁) ▁; ▁testHarness ▁. ▁processElement ▁( ▁new ▁StreamRecord ▁< ▁> ▁( ▁new Binary Row ▁( ▁true ▁, ▁STR ▁, ▁STR ▁, ▁2 L ▁, ▁10 L ▁) ▁, ▁initial Time ▁+ ▁3 ▁) ▁) ▁; ▁testHarness ▁. ▁processElement ▁( ▁new ▁StreamRecord ▁< ▁> ▁( ▁new Binary Row ▁( ▁true ▁, ▁STR ▁, ▁STR ▁, ▁3 L ▁, ▁2 L ▁) ▁, ▁initial Time ▁+ ▁3 ▁) ▁) ▁;
▁public ▁class ▁Sms Character Calculator ▁extends ▁Character Calculator ▁{ ▁private ▁static ▁final ▁String ▁TAG ▁= ▁Log ▁. ▁tag ▁( ▁Sms Character Calculator ▁. ▁class ▁) ▁; ▁@ ▁Override ▁public ▁Character State ▁calculate Characters ▁( ▁String ▁message Body ▁) ▁{ ▁int ▁[ ▁] ▁length ▁; ▁int ▁messages Sp ent ▁; ▁int ▁char acters Sp ent ▁; ▁int ▁char acters Remaining ▁; ▁try ▁{ ▁length ▁= ▁Sms Message ▁. ▁calculate Length ▁( ▁message Body ▁, ▁false ▁) ▁; ▁messages Sp ent ▁= ▁length ▁[ ▁0 ▁] ▁; ▁char acters Sp ent ▁= ▁length ▁[ ▁1 ▁] ▁; ▁char acters Remaining ▁= ▁length ▁[ ▁2 ▁] ▁; ▁} ▁catch ▁( ▁NullPointer Exception ▁e ▁) ▁{ ▁Log ▁. ▁w ▁( ▁TAG ▁, ▁e ▁) ▁; ▁messages Sp ent ▁= ▁1 ▁; ▁char acters Sp ent ▁= ▁message Body ▁. ▁length ▁( ▁) ▁; ▁char acters Remaining ▁= ▁1000 ▁; ▁} ▁int ▁max Message Size ▁; ▁if ▁( ▁messages Sp ent ▁> ▁0 ▁) ▁{ ▁max Message Size ▁= ▁( ▁char acters Sp ent ▁+ ▁char acters Remaining ▁) ▁ / ▁messages Sp ent ▁; ▁} ▁else ▁{ ▁max Message Size ▁= ▁( ▁char acters Sp ent ▁+ ▁char acters Remaining ▁) ▁; ▁} ▁return ▁new ▁Character State ▁( ▁messages Sp ent ▁, ▁char acters Remaining ▁, ▁max Message Size ▁, ▁max Message Size ▁) ▁; ▁} ▁}
▁sum ▁+= ▁this ▁. ▁value ▁. ▁getValue ▁( ▁) ▁; ▁} ▁element ▁. ▁getField ▁( ▁0 ▁, ▁this ▁. ▁key ▁) ▁; ▁this ▁. ▁value ▁. ▁setValue ▁( ▁sum ▁- ▁this ▁. ▁key ▁. ▁getValue ▁( ▁) ▁) ▁; ▁element ▁. ▁setField ▁( ▁1 ▁, ▁this ▁. ▁value ▁) ▁; ▁out ▁. ▁collect ▁( ▁element ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁combine ▁( ▁Iterable ▁< ▁Record ▁> ▁records ▁, ▁Collector ▁< ▁Record ▁> ▁out ▁) ▁{ ▁Record ▁element ▁= ▁null ▁; ▁int ▁sum ▁= ▁0 ▁; ▁for ▁( ▁Record ▁next ▁: ▁records ▁) ▁{ ▁element ▁= ▁next ▁; ▁element ▁. ▁getField ▁( ▁1 ▁, ▁this ▁. ▁combine Value ▁) ▁; ▁sum ▁+= ▁this ▁. ▁combine Value ▁. ▁getValue ▁( ▁) ▁; ▁} ▁this ▁. ▁combine Value ▁. ▁setValue ▁( ▁sum ▁) ▁; ▁element ▁. ▁setField ▁( ▁1 ▁, ▁this ▁. ▁combine Value ▁) ▁; ▁out ▁. ▁collect ▁( ▁element ▁) ▁; ▁} ▁} ▁public ▁static ▁class ▁Mock Fail ing Reduce Stub ▁extends ▁Rich Group Reduce Function ▁< ▁Record ▁, ▁Record ▁> ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁private ▁int ▁cnt ▁= ▁0 ▁; ▁private ▁final ▁IntValue ▁key ▁= ▁new ▁IntValue ▁( ▁) ▁; ▁private ▁final ▁IntValue ▁value ▁= ▁new ▁IntValue ▁( ▁) ▁; ▁@ ▁Override ▁public ▁void ▁reduce ▁( ▁Iterable ▁< ▁Record ▁> ▁records ▁, ▁Collector ▁< ▁Record ▁> ▁out ▁) ▁{ ▁Record ▁element ▁= ▁null ▁; ▁int ▁val Cnt ▁= ▁0 ▁; ▁for ▁( ▁Record ▁next ▁: ▁records ▁) ▁{ ▁element ▁= ▁next ▁; ▁val Cnt ▁++ ▁; ▁} ▁if ▁( ▁++ ▁this ▁. ▁cnt ▁>= ▁10 ▁) ▁{ ▁throw ▁new ▁Expected Test Exception ▁( ▁) ▁; ▁} ▁element ▁. ▁getField ▁( ▁0 ▁, ▁this ▁. ▁key ▁) ▁; ▁this ▁. ▁value ▁. ▁setValue ▁( ▁val Cnt ▁- ▁this ▁. ▁key ▁. ▁getValue ▁( ▁) ▁) ▁; ▁element ▁. ▁setField ▁( ▁1 ▁, ▁this ▁. ▁value ▁) ▁; ▁out ▁. ▁collect ▁( ▁element ▁) ▁; ▁} ▁} ▁public ▁static ▁class ▁Mock Delay ing Reduce Stub ▁extends ▁Rich Group Reduce Function ▁< ▁Record ▁, ▁Record ▁> ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁@ ▁Override ▁public ▁void ▁reduce ▁( ▁Iterable ▁< ▁Record ▁> ▁records ▁, ▁Collector ▁< ▁Record ▁> ▁out ▁) ▁{ ▁for ▁( ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁Record ▁r ▁: ▁records ▁) ▁{ ▁try ▁{ ▁Thread ▁. ▁sleep ▁( ▁100 ▁) ▁; ▁} ▁catch ▁( ▁Interrupted Exception ▁e ▁) ▁{ ▁} ▁} ▁} ▁} ▁}
▁else ▁{ ▁return ▁write Advance Loc 4 ▁( ▁offset ▁, ▁buffer ▁, ▁pos ▁) ▁; ▁} ▁} ▁protected ▁int ▁write Advance Loc 0 ▁( ▁byte ▁offset ▁, ▁byte ▁[ ▁] ▁buffer ▁, ▁int ▁pos ▁) ▁{ ▁byte ▁op ▁= ▁advance Loc 0 Op ▁( ▁offset ▁) ▁; ▁if ▁( ▁buffer ▁== ▁null ▁) ▁{ ▁return ▁pos ▁+ ▁putByte ▁( ▁op ▁, ▁scratch ▁, ▁0 ▁) ▁; ▁} ▁else ▁{ ▁return ▁putByte ▁( ▁op ▁, ▁buffer ▁, ▁pos ▁) ▁; ▁} ▁} ▁protected ▁int ▁write Advance Loc 1 ▁( ▁byte ▁offset ▁, ▁byte ▁[ ▁] ▁buffer ▁, ▁int ▁p ▁) ▁{ ▁int ▁pos ▁= ▁p ▁; ▁byte ▁op ▁= ▁D warf DebugInfo ▁. ▁DW _ C FA _ adv ance _ loc 1 ▁; ▁if ▁( ▁buffer ▁== ▁null ▁) ▁{ ▁pos ▁+= ▁putByte ▁( ▁op ▁, ▁scratch ▁, ▁0 ▁) ▁; ▁return ▁pos ▁+ ▁putByte ▁( ▁offset ▁, ▁scratch ▁, ▁0 ▁) ▁; ▁} ▁else ▁{ ▁pos ▁= ▁putByte ▁( ▁op ▁, ▁buffer ▁, ▁pos ▁) ▁; ▁return ▁putByte ▁( ▁offset ▁, ▁buffer ▁, ▁pos ▁) ▁; ▁} ▁} ▁protected ▁int ▁write Advance Loc 2 ▁( ▁short ▁offset ▁, ▁byte ▁[ ▁] ▁buffer ▁, ▁int ▁p ▁) ▁{ ▁byte ▁op ▁= ▁D warf DebugInfo ▁. ▁DW _ C FA _ adv ance _ loc 2 ▁; ▁int ▁pos ▁= ▁p ▁; ▁if ▁( ▁buffer ▁== ▁null ▁) ▁{ ▁pos ▁+= ▁putByte ▁( ▁op ▁, ▁scratch ▁, ▁0 ▁) ▁; ▁return ▁pos ▁+ ▁putShort ▁( ▁offset ▁, ▁scratch ▁, ▁0 ▁) ▁; ▁} ▁else ▁{ ▁pos ▁= ▁putByte ▁( ▁op ▁, ▁buffer ▁, ▁pos ▁) ▁; ▁return ▁putShort ▁( ▁offset ▁, ▁buffer ▁, ▁pos ▁) ▁; ▁} ▁} ▁protected ▁int ▁write Advance Loc 4 ▁( ▁int ▁offset ▁, ▁byte ▁[ ▁] ▁buffer ▁, ▁int ▁p ▁) ▁{ ▁byte ▁op ▁= ▁D warf DebugInfo ▁. ▁DW _ C FA _ adv ance _ loc 4 ▁; ▁int ▁pos ▁= ▁p ▁; ▁if ▁( ▁buffer ▁== ▁null ▁) ▁{ ▁pos ▁+= ▁putByte ▁( ▁op ▁, ▁scratch ▁, ▁0 ▁) ▁; ▁return ▁pos ▁+ ▁putInt ▁( ▁offset ▁, ▁scratch ▁, ▁0 ▁) ▁; ▁} ▁else ▁{ ▁pos ▁= ▁putByte ▁( ▁op ▁, ▁buffer ▁, ▁pos ▁) ▁; ▁return ▁putInt ▁( ▁offset ▁, ▁buffer ▁, ▁pos ▁) ▁; ▁} ▁} ▁protected ▁int ▁write Offset ▁( ▁int ▁register ▁, ▁int ▁offset ▁, ▁byte ▁[ ▁] ▁buffer ▁, ▁int ▁p ▁) ▁{ ▁byte ▁op ▁= ▁offset Op ▁( ▁register ▁) ▁; ▁int ▁pos ▁= ▁p ▁; ▁if ▁( ▁buffer ▁== ▁null ▁) ▁{ ▁pos ▁+= ▁putByte ▁( ▁op ▁, ▁scratch ▁, ▁0 ▁) ▁; ▁return ▁pos ▁+ ▁put ULE B ▁( ▁offset ▁, ▁scratch ▁, ▁0 ▁) ▁; ▁} ▁else ▁{ ▁pos ▁= ▁putByte ▁( ▁op ▁, ▁buffer ▁, ▁pos ▁) ▁; ▁return ▁put ULE B ▁( ▁offset ▁, ▁buffer ▁, ▁pos ▁) ▁; ▁} ▁} ▁protected ▁int ▁write Restore ▁( ▁int ▁register ▁, ▁byte ▁[ ▁] ▁buffer ▁, ▁int ▁p ▁) ▁{ ▁byte ▁op ▁= ▁restore Op ▁( ▁register ▁) ▁; ▁int ▁pos ▁= ▁p ▁;
▁@ ▁Override ▁public ▁void ▁onNext ▁( ▁Integer ▁t ▁) ▁{ ▁latch ▁. ▁countDown ▁( ▁) ▁; ▁request ▁( ▁Long ▁. ▁MAX _ VALUE ▁- ▁1 ▁) ▁; ▁} ▁} ▁) ▁; ▁assertTrue ▁( ▁latch ▁. ▁await ▁( ▁10 ▁, ▁TimeUnit ▁. ▁SECONDS ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁from Empty Iterable When Z ero Requested Should St ill Emit On Completed Eager ly ▁( ▁) ▁{ ▁final ▁AtomicBoolean ▁completed ▁= ▁new ▁AtomicBoolean ▁( ▁false ▁) ▁; ▁Flowable ▁. ▁from Iterable ▁( ▁Collections ▁. ▁emptyList ▁( ▁) ▁) ▁. ▁subscribe ▁( ▁new ▁Default Subscriber ▁< ▁Object ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁onStart ▁( ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁onComplete ▁( ▁) ▁{ ▁completed ▁. ▁set ▁( ▁true ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁onError ▁( ▁Throwable ▁e ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁onNext ▁( ▁Object ▁t ▁) ▁{ ▁} ▁} ▁) ▁; ▁assertTrue ▁( ▁completed ▁. ▁get ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁doesNot Call Iterator Has Next More Than Required With Back pressure ▁( ▁) ▁{ ▁final ▁AtomicBoolean ▁called ▁= ▁new ▁AtomicBoolean ▁( ▁false ▁) ▁; ▁Iterable ▁< ▁Integer ▁> ▁iterable ▁= ▁new ▁Iterable ▁< ▁Integer ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Iterator ▁< ▁Integer ▁> ▁iterator ▁( ▁) ▁{ ▁return ▁new ▁Iterator ▁< ▁Integer ▁> ▁( ▁) ▁{ ▁int ▁count ▁= ▁1 ▁; ▁@ ▁Override ▁public ▁void ▁remove ▁( ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁boolean ▁hasNext ▁( ▁) ▁{ ▁if ▁( ▁count ▁> ▁1 ▁) ▁{ ▁called ▁. ▁set ▁( ▁true ▁) ▁; ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁Integer ▁next ▁( ▁) ▁{ ▁return ▁count ▁++ ▁; ▁} ▁} ▁; ▁} ▁} ▁; ▁Flowable ▁. ▁from Iterable ▁( ▁iterable ▁) ▁. ▁take ▁( ▁1 ▁) ▁. ▁subscribe ▁( ▁) ▁; ▁assertFalse ▁( ▁called ▁. ▁get ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁doesNot Call Iterator Has Next More Than Required Fast Path ▁( ▁) ▁{ ▁final ▁AtomicBoolean ▁called ▁= ▁new ▁AtomicBoolean ▁( ▁false ▁) ▁; ▁Iterable ▁< ▁Integer ▁> ▁iterable ▁= ▁new ▁Iterable ▁< ▁Integer ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Iterator ▁< ▁Integer ▁> ▁iterator ▁( ▁) ▁{ ▁return ▁new ▁Iterator ▁< ▁Integer ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁remove ▁( ▁) ▁{ ▁} ▁int ▁count ▁= ▁1 ▁; ▁@ ▁Override ▁public ▁boolean ▁hasNext ▁( ▁) ▁{ ▁if ▁( ▁count ▁> ▁1 ▁) ▁{ ▁called ▁. ▁set ▁( ▁true ▁) ▁; ▁return ▁false ▁; ▁} ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁Integer ▁next ▁( ▁) ▁{ ▁return ▁count ▁++ ▁; ▁} ▁} ▁; ▁} ▁} ▁; ▁Flowable ▁. ▁from Iterable ▁( ▁iterable ▁) ▁. ▁subscribe ▁( ▁new ▁Default Subscriber ▁< ▁Integer ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁onComplete ▁( ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁onError ▁( ▁Throwable ▁e ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁onNext ▁( ▁Integer ▁t ▁) ▁{ ▁cancel ▁( ▁) ▁; ▁} ▁} ▁) ▁; ▁assertFalse ▁( ▁called ▁. ▁get ▁( ▁) ▁) ▁; ▁}
▁public ▁Lookup Outer Operator ▁( ▁OperatorContext ▁operatorContext ▁, ▁List enableFuture ▁< ▁Outer Position Iterator ▁> ▁outer Positions Future ▁, ▁List ▁< ▁Type ▁> ▁probe Output Types ▁, ▁List ▁< ▁Type ▁> ▁build Output Types ▁, ▁Runnable ▁on Close ▁) ▁{ ▁this ▁. ▁operatorContext ▁= ▁requireNonNull ▁( ▁operatorContext ▁, ▁STR ▁) ▁; ▁this ▁. ▁outer Positions Future ▁= ▁requireNonNull ▁( ▁outer Positions Future ▁, ▁STR ▁) ▁; ▁List ▁< ▁Type ▁> ▁types ▁= ▁ImmutableList ▁. ▁< ▁Type ▁> ▁builder ▁( ▁) ▁. ▁addAll ▁( ▁requireNonNull ▁( ▁probe Output Types ▁, ▁STR ▁) ▁) ▁. ▁addAll ▁( ▁requireNonNull ▁( ▁build Output Types ▁, ▁STR ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁this ▁. ▁probe Output Types ▁= ▁ImmutableList ▁. ▁copyOf ▁( ▁probe Output Types ▁) ▁; ▁this ▁. ▁pageBuilder ▁= ▁new ▁PageBuilder ▁( ▁types ▁) ▁; ▁this ▁. ▁on Close ▁= ▁requireNonNull ▁( ▁on Close ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁OperatorContext ▁getOperator Context ▁( ▁) ▁{ ▁return ▁operatorContext ▁; ▁} ▁@ ▁Override ▁public ▁List enableFuture ▁< ▁? ▁> ▁is Blocked ▁( ▁) ▁{ ▁return ▁outer Positions Future ▁; ▁} ▁@ ▁Override ▁public ▁void ▁finish ▁( ▁) ▁{ ▁close ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁isFinished ▁( ▁) ▁{ ▁return ▁closed ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁needs Input ▁( ▁) ▁{ ▁return ▁false ▁; ▁} ▁@ ▁Override ▁public ▁void ▁addInput ▁( ▁Page ▁page ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Page ▁getOutput ▁( ▁) ▁{ ▁if ▁( ▁outer Positions ▁== ▁null ▁) ▁{ ▁outer Positions ▁= ▁try Get Future Value ▁( ▁outer Positions Future ▁) ▁. ▁orElse ▁( ▁null ▁) ▁; ▁if ▁( ▁outer Positions ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁} ▁boolean ▁output Positions Finished ▁= ▁false ▁; ▁while ▁( ▁! ▁pageBuilder ▁. ▁isFull ▁( ▁) ▁) ▁{ ▁output Positions Finished ▁= ▁! ▁outer Positions ▁. ▁appendTo Next ▁( ▁pageBuilder ▁, ▁probe Output Types ▁. ▁size ▁( ▁) ▁) ▁; ▁if ▁( ▁output Positions Finished ▁) ▁{ ▁break ▁; ▁} ▁pageBuilder ▁. ▁declare Position ▁( ▁) ▁; ▁for ▁( ▁int ▁probe Channel ▁= ▁0 ▁; ▁probe Channel ▁< ▁probe Output Types ▁. ▁size ▁( ▁) ▁; ▁probe Channel ▁++ ▁) ▁{ ▁pageBuilder ▁. ▁getBlock Builder ▁( ▁probe Channel ▁) ▁. ▁appendNull ▁( ▁) ▁; ▁} ▁} ▁Page ▁page ▁= ▁null ▁; ▁if ▁( ▁pageBuilder ▁. ▁isFull ▁( ▁) ▁|| ▁( ▁output Positions Finished ▁&& ▁! ▁pageBuilder ▁. ▁isEmpty ▁( ▁) ▁) ▁) ▁{ ▁page ▁= ▁pageBuilder ▁. ▁build ▁( ▁) ▁; ▁pageBuilder ▁. ▁reset ▁( ▁) ▁; ▁} ▁if ▁( ▁output Positions Finished ▁) ▁{ ▁close ▁( ▁) ▁; ▁} ▁return ▁page ▁; ▁} ▁@ ▁Override ▁public ▁void ▁close ▁( ▁) ▁{ ▁if ▁( ▁closed ▁) ▁{ ▁return ▁; ▁} ▁closed ▁= ▁true ▁; ▁pageBuilder ▁. ▁reset ▁( ▁) ▁; ▁on Close ▁. ▁run ▁( ▁) ▁; ▁} ▁}
▁final ▁Elasticsearch 6 Dynamic Sink ▁test Sink ▁= ▁new ▁Elasticsearch 6 Dynamic Sink ▁( ▁new ▁Dummy Encoding Format ▁( ▁) ▁, ▁new ▁Elasticsearch 6 Configuration ▁( ▁configuration ▁, ▁this ▁. ▁getClass ▁( ▁) ▁. ▁getClassLoader ▁( ▁) ▁) ▁, ▁schema ▁, ▁provider ▁) ▁; ▁test Sink ▁. ▁getS ink Runtime Provider ▁( ▁new ▁Mock Sink Context ▁( ▁) ▁) ▁. ▁create SinkFunction ▁( ▁) ▁; ▁verify ▁( ▁provider ▁. ▁builder Spy ▁) ▁. ▁set Failure Handler ▁( ▁new ▁NoOp Failure Handler ▁( ▁) ▁) ▁; ▁verify ▁( ▁provider ▁. ▁builder Spy ▁) ▁. ▁setB ulk Flush Backoff ▁( ▁false ▁) ▁; ▁verify ▁( ▁provider ▁. ▁builder Spy ▁) ▁. ▁setB ulk Flush Interval ▁( ▁1000 ▁) ▁; ▁verify ▁( ▁provider ▁. ▁builder Spy ▁) ▁. ▁setB ulk Flush Max Actions ▁( ▁1000 ▁) ▁; ▁verify ▁( ▁provider ▁. ▁builder Spy ▁) ▁. ▁setB ulk Flush MaxSize M b ▁( ▁2 ▁) ▁; ▁verify ▁( ▁provider ▁. ▁builder Spy ▁) ▁. ▁set Rest ClientFactory ▁( ▁new ▁Elasticsearch 6 Dynamic Sink ▁. ▁Default Rest ClientFactory ▁( ▁null ▁) ▁) ▁; ▁verify ▁( ▁provider ▁. ▁sink Spy ▁, ▁never ▁( ▁) ▁) ▁. ▁disable Flush On Checkpoint ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Auth Config ▁( ▁) ▁{ ▁final ▁TableSchema ▁schema ▁= ▁createTest Schema ▁( ▁) ▁; ▁Configuration ▁configuration ▁= ▁new ▁Configuration ▁( ▁) ▁; ▁configuration ▁. ▁setString ▁( ▁Elasticsearch Connector Options ▁. ▁INDEX _ OPTION ▁. ▁key ▁( ▁) ▁, ▁INDEX ▁) ▁; ▁configuration ▁. ▁setString ▁( ▁Elasticsearch Connector Options ▁. ▁DO C UMENT _ TYPE _ OPTION ▁. ▁key ▁( ▁) ▁, ▁DO C _ TYPE ▁) ▁; ▁configuration ▁. ▁setString ▁( ▁Elasticsearch Connector Options ▁. ▁HOST S _ OPTION ▁. ▁key ▁( ▁) ▁, ▁SCHEMA ▁+ ▁STR ▁+ ▁HOST NAME ▁+ ▁STR ▁+ ▁PORT ▁) ▁; ▁configuration ▁. ▁setString ▁( ▁Elasticsearch Connector Options ▁. ▁USER NAME _ OPTION ▁. ▁key ▁( ▁) ▁, ▁USER NAME ▁) ▁; ▁configuration ▁. ▁setString ▁( ▁Elasticsearch Connector Options ▁. ▁PASSWORD _ OPTION ▁. ▁key ▁( ▁) ▁, ▁PASSWORD ▁) ▁; ▁Builder Provider ▁provider ▁= ▁new ▁Builder Provider ▁( ▁) ▁; ▁final ▁Elasticsearch 6 Dynamic Sink ▁test Sink ▁= ▁new ▁Elasticsearch 6 Dynamic Sink ▁( ▁new ▁Dummy Encoding Format ▁( ▁) ▁, ▁new ▁Elasticsearch 6 Configuration ▁( ▁configuration ▁, ▁this ▁. ▁getClass ▁( ▁) ▁. ▁getClassLoader ▁( ▁) ▁) ▁, ▁schema ▁, ▁provider ▁) ▁; ▁test Sink ▁. ▁getS ink Runtime Provider ▁( ▁new ▁Mock Sink Context ▁( ▁) ▁) ▁. ▁create SinkFunction ▁( ▁) ▁; ▁verify ▁( ▁provider ▁. ▁builder Spy ▁) ▁. ▁set Failure Handler ▁( ▁new ▁NoOp Failure Handler ▁( ▁) ▁) ▁; ▁verify ▁( ▁provider ▁. ▁builder Spy ▁) ▁. ▁setB ulk Flush Backoff ▁( ▁false ▁) ▁; ▁verify ▁( ▁provider ▁. ▁builder Spy ▁) ▁. ▁setB ulk Flush Interval ▁( ▁1000 ▁) ▁; ▁verify ▁( ▁provider ▁. ▁builder Spy ▁) ▁. ▁setB ulk Flush Max Actions ▁( ▁1000 ▁) ▁; ▁verify ▁( ▁provider ▁. ▁builder Spy ▁) ▁. ▁setB ulk Flush MaxSize M b ▁( ▁2 ▁) ▁;
▁public ▁class ▁Invalid RequestException ▁extends ▁IOException ▁{ ▁static ▁final ▁long ▁serial VersionUID ▁= ▁0 L ▁; ▁public ▁Invalid RequestException ▁( ▁String ▁str ▁) ▁{ ▁super ▁( ▁str ▁) ▁; ▁} ▁public ▁Invalid RequestException ▁( ▁String ▁message ▁, ▁Throwable ▁cause ▁) ▁{ ▁super ▁( ▁message ▁, ▁cause ▁) ▁; ▁} ▁}
▁public ▁class ▁Injector ▁{ ▁public ▁static ▁< ▁T ▁> ▁void ▁inject ▁( ▁Object ▁task ▁, ▁Class ▁< ▁T ▁> ▁value Class ▁, ▁T ▁value ▁) ▁{ ▁List ▁< ▁Field ▁> ▁all Fields ▁= ▁new ▁ArrayList ▁< ▁Field ▁> ▁( ▁) ▁; ▁Class ▁< ▁? ▁> ▁clazz ▁= ▁task ▁. ▁getClass ▁( ▁) ▁; ▁while ▁( ▁true ▁) ▁{ ▁if ▁( ▁clazz ▁!= ▁null ▁) ▁{ ▁Field ▁[ ▁] ▁fields ▁= ▁clazz ▁. ▁getDeclared Fields ▁( ▁) ▁; ▁all Fields ▁. ▁addAll ▁( ▁Arrays ▁. ▁asList ▁( ▁fields ▁) ▁) ▁; ▁} ▁else ▁{ ▁break ▁; ▁} ▁if ▁( ▁clazz ▁. ▁getSuperclass ▁( ▁) ▁!= ▁Object ▁. ▁class ▁) ▁{ ▁clazz ▁= ▁clazz ▁. ▁getSuperclass ▁( ▁) ▁; ▁} ▁else ▁{ ▁clazz ▁= ▁null ▁; ▁} ▁} ▁for ▁( ▁Field ▁field ▁: ▁all Fields ▁) ▁{ ▁if ▁( ▁value Class ▁. ▁isAssignable From ▁( ▁field ▁. ▁getType ▁( ▁) ▁) ▁&& ▁field ▁. ▁isAnnotation Present ▁( ▁R Inject ▁. ▁class ▁) ▁) ▁{ ▁field ▁. ▁setAccessible ▁( ▁true ▁) ▁; ▁try ▁{ ▁field ▁. ▁set ▁( ▁task ▁, ▁value ▁) ▁; ▁} ▁catch ▁( ▁Illegal AccessException ▁e ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁e ▁) ▁; ▁} ▁} ▁} ▁} ▁public ▁static ▁void ▁inject ▁( ▁Object ▁task ▁, ▁RedissonClient ▁redisson ▁) ▁{ ▁inject ▁( ▁task ▁, ▁RedissonClient ▁. ▁class ▁, ▁redisson ▁) ▁; ▁} ▁}
▁public ▁class ▁Html Unit Web Sc rap ing LiveTest ▁{ ▁private ▁WebClient ▁webClient ▁; ▁@ ▁Before ▁public ▁void ▁init ▁( ▁) ▁throws ▁Exception ▁{ ▁webClient ▁= ▁new ▁WebClient ▁( ▁) ▁; ▁} ▁@ ▁After ▁public ▁void ▁close ▁( ▁) ▁throws ▁Exception ▁{ ▁webClient ▁. ▁close ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁given B aeldung Archive _ when Ret ri ev ing Article _ then Has H 1 ▁( ▁) ▁throws ▁Exception ▁{ ▁webClient ▁. ▁getOptions ▁( ▁) ▁. ▁setC ss Enabled ▁( ▁false ▁) ▁; ▁webClient ▁. ▁getOptions ▁( ▁) ▁. ▁set Java Script Enabled ▁( ▁false ▁) ▁; ▁final ▁String ▁url ▁= ▁STR ▁; ▁final ▁HtmlPage ▁page ▁= ▁webClient ▁. ▁getPage ▁( ▁url ▁) ▁; ▁final ▁String ▁x path ▁= ▁STR ▁; ▁final ▁Html Anchor ▁latest Post Link ▁= ▁( ▁Html Anchor ▁) ▁page ▁. ▁getBy X Path ▁( ▁x path ▁) ▁. ▁get ▁( ▁0 ▁) ▁; ▁final ▁HtmlPage ▁post Page ▁= ▁latest Post Link ▁. ▁click ▁( ▁) ▁; ▁final ▁List ▁< ▁Object ▁> ▁h 1 ▁= ▁post Page ▁. ▁getBy X Path ▁( ▁STR ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁h 1 ▁. ▁size ▁( ▁) ▁> ▁0 ▁) ▁; ▁} ▁}
▁public ▁interface ▁Counter ▁extends ▁Meter ▁{ ▁long ▁increase ▁( ▁long ▁value ▁) ▁; ▁long ▁de crease ▁( ▁long ▁value ▁) ▁; ▁long ▁get ▁( ▁) ▁; ▁}
▁@ ▁Suppress Warnings ▁( ▁{ ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁} ▁) ▁@ ▁javax ▁. ▁annotation ▁. ▁Generated ▁( ▁value ▁= ▁STR ▁, ▁date ▁= ▁STR ▁) ▁public ▁class ▁T FA ct ive Trace ▁implements ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁TBase ▁< ▁T FA ct ive Trace ▁, ▁T FA ct ive Trace ▁. ▁_ Fields ▁> ▁, ▁java ▁. ▁io ▁. ▁Serializable ▁, ▁Clone able ▁, ▁Comparable ▁< ▁T FA ct ive Trace ▁> ▁{ ▁private ▁static ▁final ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁protocol ▁. ▁T Struct ▁STR UCT _ DESC ▁= ▁new ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁protocol ▁. ▁T Struct ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁protocol ▁. ▁T Field ▁H IST OGRAM _ FIELD _ DESC ▁= ▁new ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁protocol ▁. ▁T Field ▁( ▁STR ▁, ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁protocol ▁. ▁T Type ▁. ▁STR UCT ▁, ▁( ▁short ▁) ▁1 ▁) ▁; ▁private ▁static ▁final ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁scheme ▁. ▁S cheme Factory ▁STANDARD _ SCHEME _ FACTORY ▁= ▁new ▁T FA ct ive Trace Standard Scheme Factory ▁( ▁) ▁; ▁private ▁static ▁final ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁scheme ▁. ▁S cheme Factory ▁T UP LE _ SCHEME _ FACTORY ▁= ▁new ▁T FA ct ive Trace Tuple Scheme Factory ▁( ▁) ▁; ▁private ▁T FA ct ive Trace Histogram ▁histogram ▁; ▁public ▁enum ▁_ Fields ▁implements ▁org ▁. ▁apache ▁. ▁thrift ▁. ▁T Field Id Enum ▁{ ▁H IST OGRAM ▁( ▁( ▁short ▁) ▁1 ▁, ▁STR ▁) ▁; ▁private ▁static ▁final ▁java ▁. ▁util ▁. ▁Map ▁< ▁java ▁. ▁lang ▁. ▁String ▁, ▁_ Fields ▁> ▁byName ▁= ▁new ▁java ▁. ▁util ▁. ▁HashMap ▁< ▁java ▁. ▁lang ▁. ▁String ▁, ▁_ Fields ▁> ▁( ▁) ▁; ▁static ▁{ ▁for ▁( ▁_ Fields ▁field ▁: ▁java ▁. ▁util ▁. ▁EnumSet ▁. ▁allOf ▁( ▁_ Fields ▁. ▁class ▁) ▁) ▁{ ▁byName ▁. ▁put ▁( ▁field ▁. ▁getFieldName ▁( ▁) ▁, ▁field ▁) ▁; ▁} ▁} ▁public ▁static ▁_ Fields ▁findBy Thrift Id ▁( ▁int ▁field Id ▁) ▁{ ▁switch ▁( ▁field Id ▁) ▁{ ▁case ▁1 ▁: ▁return ▁H IST OGRAM ▁; ▁default ▁: ▁return ▁null ▁; ▁} ▁} ▁public ▁static ▁_ Fields ▁findBy Thrift Id OrThrow ▁( ▁int ▁field Id ▁) ▁{ ▁_ Fields ▁fields ▁= ▁findBy Thrift Id ▁( ▁field Id ▁) ▁; ▁if ▁( ▁fields ▁== ▁null ▁) ▁throw ▁new ▁java ▁. ▁lang ▁. ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁field Id ▁+ ▁STR ▁) ▁; ▁return ▁fields ▁; ▁} ▁public ▁static ▁_ Fields ▁findByName ▁( ▁java ▁. ▁lang ▁. ▁String ▁name ▁) ▁{ ▁return ▁byName ▁. ▁get ▁( ▁name ▁) ▁; ▁} ▁private ▁final ▁short ▁_ th rift Id ▁; ▁private ▁final ▁java ▁. ▁lang ▁. ▁String ▁_ field Name ▁; ▁_ Fields ▁( ▁short ▁thrift Id ▁, ▁java ▁. ▁lang ▁. ▁String ▁fieldName ▁) ▁{ ▁_ th rift Id ▁= ▁thrift Id ▁; ▁_ field Name ▁= ▁fieldName ▁; ▁}
▁if ▁( ▁source Position ▁. ▁getC aller ▁( ▁) ▁!= ▁null ▁) ▁{ ▁caller Absolute Offset ▁= ▁encode Source Positions ▁( ▁source Position ▁. ▁getC aller ▁( ▁) ▁, ▁source Position Start Offsets ▁, ▁encoding Buffer ▁) ▁; ▁} ▁long ▁start Absolute Offset ▁= ▁encoding Buffer ▁. ▁getBytes Written ▁( ▁) ▁; ▁long ▁caller Relative Offset ▁= ▁Deoptimization SourcePosition Decoder ▁. ▁NO _ CAL LER ▁; ▁if ▁( ▁source Position ▁. ▁getC aller ▁( ▁) ▁!= ▁null ▁) ▁{ ▁caller Relative Offset ▁= ▁start Absolute Offset ▁- ▁caller Absolute Offset ▁; ▁assert ▁caller Relative Offset ▁> ▁Deoptimization SourcePosition Decoder ▁. ▁NO _ CAL LER ▁; ▁} ▁encoding Buffer ▁. ▁put UV ▁( ▁caller Relative Offset ▁) ▁; ▁encoding Buffer ▁. ▁put SV ▁( ▁source Position ▁. ▁getB CI ▁( ▁) ▁) ▁; ▁encoding Buffer ▁. ▁put UV ▁( ▁object Constants ▁. ▁getIndex ▁( ▁source Position ▁. ▁getMethod ▁( ▁) ▁) ▁) ▁; ▁source Position Start Offsets ▁. ▁put ▁( ▁source Position ▁, ▁start Absolute Offset ▁) ▁; ▁return ▁start Absolute Offset ▁; ▁} ▁private ▁static ▁boolean ▁verify Encoding ▁( ▁List ▁< ▁Node SourcePosition ▁> ▁de opt Source Positions ▁, ▁Nonmovable Array ▁< ▁Integer ▁> ▁de opt Start Offsets ▁, ▁Nonmovable Array ▁< ▁Byte ▁> ▁de opt En c odings ▁, ▁Nonmovable ObjectArray ▁< ▁Object ▁> ▁de opt Object Constants ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁de opt Source Positions ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁Node SourcePosition ▁original SourcePosition ▁= ▁de opt Source Positions ▁. ▁get ▁( ▁i ▁) ▁; ▁Node SourcePosition ▁decoded SourcePosition ▁= ▁Deoptimization SourcePosition Decoder ▁. ▁decode ▁( ▁i ▁, ▁de opt Start Offsets ▁, ▁de opt En c odings ▁, ▁de opt Object Constants ▁) ▁; ▁verify SourcePosition ▁( ▁original SourcePosition ▁, ▁decoded SourcePosition ▁) ▁; ▁} ▁return ▁true ▁; ▁} ▁private ▁static ▁void ▁verify SourcePosition ▁( ▁Node SourcePosition ▁original Position ▁, ▁Node SourcePosition ▁decoded SourcePosition ▁) ▁{ ▁if ▁( ▁original Position ▁== ▁null ▁) ▁{ ▁assert ▁decoded SourcePosition ▁== ▁null ▁; ▁return ▁; ▁} ▁assert ▁original Position ▁. ▁getB CI ▁( ▁) ▁== ▁decoded SourcePosition ▁. ▁getB CI ▁( ▁) ▁; ▁assert ▁original Position ▁. ▁getMethod ▁( ▁) ▁. ▁equals ▁( ▁decoded SourcePosition ▁. ▁getMethod ▁( ▁) ▁) ▁; ▁verify SourcePosition ▁( ▁original Position ▁. ▁getC aller ▁( ▁) ▁, ▁decoded SourcePosition ▁. ▁getC aller ▁( ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁Aggregator Tests ▁extends ▁Value Aggregator Base Descriptor ▁{ ▁public ▁ArrayList ▁< ▁Entry ▁< ▁Text ▁, ▁Text ▁> ▁> ▁generate Key Val Pairs ▁( ▁Object ▁key ▁, ▁Object ▁val ▁) ▁{ ▁ArrayList ▁< ▁Entry ▁< ▁Text ▁, ▁Text ▁> ▁> ▁ret v ▁= ▁new ▁ArrayList ▁< ▁Entry ▁< ▁Text ▁, ▁Text ▁> ▁> ▁( ▁) ▁; ▁String ▁[ ▁] ▁words ▁= ▁val ▁. ▁toString ▁( ▁) ▁. ▁split ▁( ▁STR ▁) ▁; ▁String ▁count Type ▁; ▁String ▁id ▁; ▁Entry ▁< ▁Text ▁, ▁Text ▁> ▁e ▁; ▁for ▁( ▁String ▁word ▁: ▁words ▁) ▁{ ▁long ▁num Val ▁= ▁Long ▁. ▁parseLong ▁( ▁word ▁) ▁; ▁count Type ▁= ▁LONG _ VALUE _ SUM ▁; ▁id ▁= ▁STR ▁+ ▁word ▁; ▁e ▁= ▁generate Entry ▁( ▁count Type ▁, ▁id ▁, ▁Value Aggregator Descriptor ▁. ▁ONE ▁) ▁; ▁if ▁( ▁e ▁!= ▁null ▁) ▁{ ▁ret v ▁. ▁add ▁( ▁e ▁) ▁; ▁} ▁count Type ▁= ▁LONG _ VALUE _ MAX ▁; ▁id ▁= ▁STR ▁; ▁e ▁= ▁generate Entry ▁( ▁count Type ▁, ▁id ▁, ▁new ▁Text ▁( ▁word ▁) ▁) ▁; ▁if ▁( ▁e ▁!= ▁null ▁) ▁{ ▁ret v ▁. ▁add ▁( ▁e ▁) ▁; ▁} ▁count Type ▁= ▁LONG _ VALUE _ MIN ▁; ▁id ▁= ▁STR ▁; ▁e ▁= ▁generate Entry ▁( ▁count Type ▁, ▁id ▁, ▁new ▁Text ▁( ▁word ▁) ▁) ▁; ▁if ▁( ▁e ▁!= ▁null ▁) ▁{ ▁ret v ▁. ▁add ▁( ▁e ▁) ▁; ▁} ▁count Type ▁= ▁STRING _ VALUE _ MAX ▁; ▁id ▁= ▁STR ▁; ▁e ▁= ▁generate Entry ▁( ▁count Type ▁, ▁id ▁, ▁new ▁Text ▁( ▁STR ▁+ ▁num Val ▁) ▁) ▁; ▁if ▁( ▁e ▁!= ▁null ▁) ▁{ ▁ret v ▁. ▁add ▁( ▁e ▁) ▁; ▁} ▁count Type ▁= ▁STRING _ VALUE _ MIN ▁; ▁id ▁= ▁STR ▁; ▁e ▁= ▁generate Entry ▁( ▁count Type ▁, ▁id ▁, ▁new ▁Text ▁( ▁STR ▁+ ▁num Val ▁) ▁) ▁; ▁if ▁( ▁e ▁!= ▁null ▁) ▁{ ▁ret v ▁. ▁add ▁( ▁e ▁) ▁; ▁} ▁count Type ▁= ▁UNI Q _ VALUE _ COUNT ▁; ▁id ▁= ▁STR ▁; ▁e ▁= ▁generate Entry ▁( ▁count Type ▁, ▁id ▁, ▁new ▁Text ▁( ▁word ▁) ▁) ▁; ▁if ▁( ▁e ▁!= ▁null ▁) ▁{ ▁ret v ▁. ▁add ▁( ▁e ▁) ▁; ▁} ▁count Type ▁= ▁VALUE _ H IST OGRAM ▁; ▁id ▁= ▁STR ▁; ▁e ▁= ▁generate Entry ▁( ▁count Type ▁, ▁id ▁, ▁new ▁Text ▁( ▁word ▁) ▁) ▁; ▁if ▁( ▁e ▁!= ▁null ▁) ▁{ ▁ret v ▁. ▁add ▁( ▁e ▁) ▁; ▁} ▁} ▁return ▁ret v ▁; ▁} ▁}
▁else ▁{ ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁] ▁= ▁Math ▁. ▁max ▁( ▁matrix ▁[ ▁i ▁] ▁[ ▁j ▁- ▁1 ▁] ▁, ▁matrix ▁[ ▁i ▁- ▁1 ▁] ▁[ ▁j ▁] ▁) ▁; ▁} ▁} ▁} ▁char ▁[ ▁] ▁result ▁= ▁new ▁char ▁[ ▁matrix ▁[ ▁m ▁] ▁[ ▁n ▁] ▁] ▁; ▁int ▁currentIndex ▁= ▁result ▁. ▁length ▁- ▁1 ▁; ▁while ▁( ▁matrix ▁[ ▁m ▁] ▁[ ▁n ▁] ▁!= ▁0 ▁) ▁{ ▁if ▁( ▁matrix ▁[ ▁m ▁] ▁[ ▁n ▁] ▁== ▁matrix ▁[ ▁m ▁] ▁[ ▁n ▁- ▁1 ▁] ▁) ▁{ ▁n ▁-- ▁; ▁} ▁else ▁if ▁( ▁matrix ▁[ ▁m ▁] ▁[ ▁n ▁] ▁== ▁matrix ▁[ ▁m ▁- ▁1 ▁] ▁[ ▁n ▁] ▁) ▁{ ▁m ▁-- ▁; ▁} ▁else ▁{ ▁result ▁[ ▁currentIndex ▁] ▁= ▁str A ▁. ▁charAt ▁( ▁m ▁- ▁1 ▁) ▁; ▁currentIndex ▁-- ▁; ▁n ▁-- ▁; ▁m ▁-- ▁; ▁} ▁} ▁return ▁new ▁String ▁( ▁result ▁) ▁; ▁} ▁}
▁class ▁Integration Metrics Auto Configuration Tests ▁{ ▁private ▁final ▁Application ContextRunner ▁contextRunner ▁= ▁new ▁Application ContextRunner ▁( ▁) ▁. ▁with Configuration ▁( ▁Auto Configurations ▁. ▁of ▁( ▁Integration Auto Configuration ▁. ▁class ▁, ▁Integration Graph Endpoint Auto Configuration ▁. ▁class ▁, ▁Integration Metrics Auto Configuration ▁. ▁class ▁) ▁) ▁. ▁with ▁( ▁Metrics Run ▁. ▁simple ▁( ▁) ▁) ▁. ▁with PropertyValues ▁( ▁STR ▁) ▁; ▁@ ▁Test ▁void ▁in tegration Met ers Are In strumented ▁( ▁) ▁{ ▁this ▁. ▁contextRunner ▁. ▁run ▁( ▁( ▁context ▁) ▁-> ▁{ ▁MeterRegistry ▁registry ▁= ▁context ▁. ▁getBean ▁( ▁MeterRegistry ▁. ▁class ▁) ▁; ▁Gauge ▁gauge ▁= ▁registry ▁. ▁get ▁( ▁STR ▁) ▁. ▁tag ▁( ▁STR ▁, ▁STR ▁) ▁. ▁gauge ▁( ▁) ▁; ▁assertThat ▁( ▁gauge ▁) ▁. ▁isNotNull ▁( ▁) ▁. ▁extracting ▁( ▁Gauge ▁:: ▁value ▁) ▁. ▁isEqualTo ▁( ▁2.0 ▁) ▁; ▁} ▁) ▁; ▁} ▁}
▁@ ▁Internal ▁public ▁class ▁FileWriter ▁< ▁IN ▁> ▁implements ▁Sink Writer ▁< ▁IN ▁, ▁File Sink Commit table ▁, ▁FileWriter Bucket State ▁> ▁, ▁Sink ▁. ▁Processing TimeService ▁. ▁Processing Time Callback ▁{ ▁private ▁static ▁final ▁Logger ▁LOG ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁FileWriter ▁. ▁class ▁) ▁; ▁private ▁final ▁Path ▁basePath ▁; ▁private ▁final ▁FileWriter Bucket Factory ▁< ▁IN ▁> ▁bucket Factory ▁; ▁private ▁final ▁Bucket Assigner ▁< ▁IN ▁, ▁String ▁> ▁bucket Assigner ▁; ▁private ▁final ▁Bucket Writer ▁< ▁IN ▁, ▁String ▁> ▁bucket Writer ▁; ▁private ▁final ▁Rolling Policy ▁< ▁IN ▁, ▁String ▁> ▁rolling Policy ▁; ▁private ▁final ▁Sink ▁. ▁Processing TimeService ▁processing TimeService ▁; ▁private ▁final ▁long ▁bucket Check Interval ▁; ▁private ▁final ▁Bucket er Context ▁bucket er Context ▁; ▁private ▁final ▁Map ▁< ▁String ▁, ▁FileWriter Bucket ▁< ▁IN ▁> ▁> ▁active Buckets ▁; ▁private ▁final ▁Output File Config ▁outputFile Config ▁; ▁public ▁FileWriter ▁( ▁final ▁Path ▁basePath ▁, ▁final ▁Bucket Assigner ▁< ▁IN ▁, ▁String ▁> ▁bucket Assigner ▁, ▁final ▁FileWriter Bucket Factory ▁< ▁IN ▁> ▁bucket Factory ▁, ▁final ▁Bucket Writer ▁< ▁IN ▁, ▁String ▁> ▁bucket Writer ▁, ▁final ▁Rolling Policy ▁< ▁IN ▁, ▁String ▁> ▁rolling Policy ▁, ▁final ▁Output File Config ▁outputFile Config ▁, ▁final ▁Sink ▁. ▁Processing TimeService ▁processing TimeService ▁, ▁final ▁long ▁bucket Check Interval ▁) ▁{ ▁this ▁. ▁basePath ▁= ▁checkNotNull ▁( ▁basePath ▁) ▁; ▁this ▁. ▁bucket Assigner ▁= ▁checkNotNull ▁( ▁bucket Assigner ▁) ▁; ▁this ▁. ▁bucket Factory ▁= ▁checkNotNull ▁( ▁bucket Factory ▁) ▁; ▁this ▁. ▁bucket Writer ▁= ▁checkNotNull ▁( ▁bucket Writer ▁) ▁; ▁this ▁. ▁rolling Policy ▁= ▁checkNotNull ▁( ▁rolling Policy ▁) ▁; ▁this ▁. ▁outputFile Config ▁= ▁checkNotNull ▁( ▁outputFile Config ▁) ▁; ▁this ▁. ▁active Buckets ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁this ▁. ▁bucket er Context ▁= ▁new ▁Bucket er Context ▁( ▁) ▁; ▁this ▁. ▁processing TimeService ▁= ▁checkNotNull ▁( ▁processing TimeService ▁) ▁; ▁checkArgument ▁( ▁bucket Check Interval ▁> ▁0 ▁, ▁STR ▁) ▁; ▁this ▁. ▁bucket Check Interval ▁= ▁bucket Check Interval ▁; ▁} ▁public ▁void ▁initialize State ▁( ▁List ▁< ▁FileWriter Bucket State ▁> ▁bucket States ▁) ▁throws ▁IOException ▁{ ▁checkNotNull ▁( ▁bucket States ▁, ▁STR ▁) ▁; ▁for ▁( ▁FileWriter Bucket State ▁state ▁: ▁bucket States ▁) ▁{ ▁String ▁bucket Id ▁= ▁state ▁. ▁getBucket Id ▁( ▁) ▁; ▁if ▁( ▁LOG ▁. ▁isDebugEnabled ▁( ▁) ▁) ▁{ ▁LOG ▁. ▁debug ▁( ▁STR ▁, ▁state ▁) ▁; ▁} ▁FileWriter Bucket ▁< ▁IN ▁> ▁restored Bucket ▁= ▁bucket Factory ▁. ▁restore Bucket ▁( ▁bucket Writer ▁, ▁rolling Policy ▁, ▁state ▁, ▁outputFile Config ▁) ▁; ▁update Active Bucket Id ▁( ▁bucket Id ▁, ▁restored Bucket ▁) ▁; ▁} ▁register Next Bucket Ins pection Timer ▁( ▁) ▁; ▁} ▁private ▁void ▁update Active Bucket Id ▁( ▁String ▁bucket Id ▁, ▁FileWriter Bucket ▁< ▁IN ▁> ▁restored Bucket ▁) ▁throws ▁IOException ▁{ ▁final ▁FileWriter Bucket ▁< ▁IN ▁> ▁bucket ▁= ▁active Buckets ▁. ▁get ▁( ▁bucket Id ▁) ▁;
▁@ ▁Override ▁protected ▁org ▁. ▁elasticsearch ▁. ▁client ▁. ▁xpack ▁. ▁XPack InfoResponse ▁doParse To ClientInstance ▁( ▁XContentParser ▁parser ▁) ▁throws ▁IOException ▁{ ▁return ▁org ▁. ▁elasticsearch ▁. ▁client ▁. ▁xpack ▁. ▁XPack InfoResponse ▁. ▁fromXContent ▁( ▁parser ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁assert Instances ▁( ▁XPack InfoResponse ▁server TestInstance ▁, ▁org ▁. ▁elasticsearch ▁. ▁client ▁. ▁xpack ▁. ▁XPack InfoResponse ▁clientInstance ▁) ▁{ ▁XPack InfoResponse ▁server Instance ▁= ▁new ▁XPack InfoResponse ▁( ▁convert H l rc To Internal ▁( ▁clientInstance ▁. ▁getBuild Info ▁( ▁) ▁) ▁, ▁convert H l rc To Internal ▁( ▁clientInstance ▁. ▁getL icense Info ▁( ▁) ▁) ▁, ▁convert H l rc To Internal ▁( ▁clientInstance ▁. ▁get Feature Sets Info ▁( ▁) ▁) ▁) ▁; ▁assertEquals ▁( ▁server TestInstance ▁, ▁server Instance ▁) ▁; ▁} ▁}
▁public ▁class ▁H uber Tests ▁extends ▁Abstract Serializing TestCase ▁< ▁H uber ▁> ▁{ ▁@ ▁Override ▁protected ▁H uber ▁doParseInstance ▁( ▁XContentParser ▁parser ▁) ▁throws ▁IOException ▁{ ▁return ▁H uber ▁. ▁fromXContent ▁( ▁parser ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁H uber ▁createTest Instance ▁( ▁) ▁{ ▁return ▁createRandom ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Writeable ▁. ▁Reader ▁< ▁H uber ▁> ▁instanceReader ▁( ▁) ▁{ ▁return ▁H uber ▁:: ▁new ▁; ▁} ▁public ▁static ▁H uber ▁createRandom ▁( ▁) ▁{ ▁return ▁new ▁H uber ▁( ▁randomBoolean ▁( ▁) ▁? ▁randomDouble Between ▁( ▁0.0 ▁, ▁1000 .0 ▁, ▁false ▁) ▁: ▁null ▁) ▁; ▁} ▁public ▁void ▁test Evaluate ▁( ▁) ▁{ ▁Aggregations ▁aggs ▁= ▁new ▁Aggregations ▁( ▁Arrays ▁. ▁asList ▁( ▁mock SingleValue ▁( ▁STR ▁, ▁0. 812 3 ▁) ▁, ▁mock SingleValue ▁( ▁STR ▁, ▁0. 23 77 ▁) ▁) ▁) ▁; ▁H uber ▁h uber ▁= ▁new ▁H uber ▁( ▁( ▁Double ▁) ▁null ▁) ▁; ▁h uber ▁. ▁process ▁( ▁aggs ▁) ▁; ▁Evaluation Metric Result ▁result ▁= ▁h uber ▁. ▁getResult ▁( ▁) ▁. ▁get ▁( ▁) ▁; ▁String ▁expected ▁= ▁STR ▁; ▁assertThat ▁( ▁Strings ▁. ▁toString ▁( ▁result ▁) ▁, ▁equalTo ▁( ▁expected ▁) ▁) ▁; ▁} ▁public ▁void ▁test Evaluate _ Given Missing Aggs ▁( ▁) ▁{ ▁Aggregations ▁aggs ▁= ▁new ▁Aggregations ▁( ▁Collections ▁. ▁singletonList ▁( ▁mock SingleValue ▁( ▁STR ▁, ▁0. 23 77 ▁) ▁) ▁) ▁; ▁H uber ▁h uber ▁= ▁new ▁H uber ▁( ▁( ▁Double ▁) ▁null ▁) ▁; ▁h uber ▁. ▁process ▁( ▁aggs ▁) ▁; ▁Evaluation Metric Result ▁result ▁= ▁h uber ▁. ▁getResult ▁( ▁) ▁. ▁get ▁( ▁) ▁; ▁assertThat ▁( ▁result ▁, ▁equalTo ▁( ▁new ▁H uber ▁. ▁Result ▁( ▁0.0 ▁) ▁) ▁) ▁; ▁} ▁}
▁@ ▁RunWith ▁( ▁Robolectric TestRunner ▁. ▁class ▁) ▁public ▁class ▁Image Pipeline Config Test ▁{ ▁private ▁Uri ▁m Uri ▁; ▁@ ▁Before ▁public ▁void ▁setUp ▁( ▁) ▁{ ▁Mockito Annotations ▁. ▁initMocks ▁( ▁this ▁) ▁; ▁m Uri ▁= ▁mock ▁( ▁Uri ▁. ▁class ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testDefault Config Is False ByDefault ▁( ▁) ▁{ ▁Image Pipeline Config ▁. ▁reset Default Request Config ▁( ▁) ▁; ▁assertFalse ▁( ▁Image Pipeline Config ▁. ▁getDefault Image Request Config ▁( ▁) ▁. ▁is Progress ive Rendering Enabled ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testDefault Config Is True If Changed ▁( ▁) ▁{ ▁Image Pipeline Config ▁. ▁reset Default Request Config ▁( ▁) ▁; ▁Image Pipeline Config ▁. ▁getDefault Image Request Config ▁( ▁) ▁. ▁setProgress ive Rendering Enabled ▁( ▁true ▁) ▁; ▁assertTrue ▁( ▁Image Pipeline Config ▁. ▁getDefault Image Request Config ▁( ▁) ▁. ▁is Progress ive Rendering Enabled ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Image Request Default ▁( ▁) ▁{ ▁Image Pipeline Config ▁. ▁reset Default Request Config ▁( ▁) ▁; ▁final ▁ImageRequest ▁image Request ▁= ▁Image RequestBuilder ▁. ▁newBuilder With Source ▁( ▁m Uri ▁) ▁. ▁build ▁( ▁) ▁; ▁assertFalse ▁( ▁image Request ▁. ▁getProgress ive Rendering Enabled ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Image Request When Changed ▁( ▁) ▁{ ▁Image Pipeline Config ▁. ▁reset Default Request Config ▁( ▁) ▁; ▁Image Pipeline Config ▁. ▁getDefault Image Request Config ▁( ▁) ▁. ▁setProgress ive Rendering Enabled ▁( ▁true ▁) ▁; ▁final ▁ImageRequest ▁image Request ▁= ▁Image RequestBuilder ▁. ▁newBuilder With Source ▁( ▁m Uri ▁) ▁. ▁build ▁( ▁) ▁; ▁assertTrue ▁( ▁image Request ▁. ▁getProgress ive Rendering Enabled ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Image Request When Changed And Overrid en ▁( ▁) ▁{ ▁Image Pipeline Config ▁. ▁reset Default Request Config ▁( ▁) ▁; ▁final ▁ImageRequest ▁image Request ▁= ▁Image RequestBuilder ▁. ▁newBuilder With Source ▁( ▁m Uri ▁) ▁. ▁setProgress ive Rendering Enabled ▁( ▁true ▁) ▁. ▁build ▁( ▁) ▁; ▁assertTrue ▁( ▁image Request ▁. ▁getProgress ive Rendering Enabled ▁( ▁) ▁) ▁; ▁final ▁ImageRequest ▁image Request 2 ▁= ▁Image RequestBuilder ▁. ▁newBuilder With Source ▁( ▁m Uri ▁) ▁. ▁setProgress ive Rendering Enabled ▁( ▁false ▁) ▁. ▁build ▁( ▁) ▁; ▁assertFalse ▁( ▁image Request 2 ▁. ▁getProgress ive Rendering Enabled ▁( ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁Proxy Request Annotation Factory ▁{ ▁public ▁static ▁final ▁int ▁APP _ MAX _ LENGTH ▁= ▁32 ▁; ▁public ▁AnnotationKey ▁getAnnotation Key ▁( ▁) ▁{ ▁return ▁AnnotationKey ▁. ▁PROXY _ HTTP _ HEADER ▁; ▁} ▁public ▁Object ▁getAnnotation Value ▁( ▁final ▁int ▁code ▁, ▁final ▁Proxy RequestHeader ▁header ▁) ▁{ ▁if ▁( ▁header ▁. ▁getApp ▁( ▁) ▁!= ▁null ▁) ▁{ ▁return ▁new ▁Long Int Int Byte Byte StringValue ▁( ▁header ▁. ▁getRe ce ived TimeMillis ▁( ▁) ▁, ▁code ▁, ▁header ▁. ▁getDuration Time Micro seconds ▁( ▁) ▁, ▁header ▁. ▁getId le Percent ▁( ▁) ▁, ▁header ▁. ▁getB us y Percent ▁( ▁) ▁, ▁StringUtils ▁. ▁ab brev iate ▁( ▁header ▁. ▁getApp ▁( ▁) ▁, ▁APP _ MAX _ LENGTH ▁) ▁) ▁; ▁} ▁return ▁new ▁Long Int Int Byte Byte StringValue ▁( ▁header ▁. ▁getRe ce ived TimeMillis ▁( ▁) ▁, ▁code ▁, ▁header ▁. ▁getDuration Time Micro seconds ▁( ▁) ▁, ▁header ▁. ▁getId le Percent ▁( ▁) ▁, ▁header ▁. ▁getB us y Percent ▁( ▁) ▁, ▁null ▁) ▁; ▁} ▁}
▁protected ▁void ▁my Per form Action ▁( ▁DockingActionIf ▁a ▁) ▁{ ▁performAction ▁( ▁a ▁, ▁cb ▁. ▁getProvider ▁( ▁) ▁, ▁true ▁) ▁; ▁cb ▁. ▁update Now ▁( ▁) ▁; ▁} ▁protected ▁void ▁next Function ▁( ▁) ▁{ ▁performAction ▁( ▁next Function ▁, ▁cb ▁. ▁getProvider ▁( ▁) ▁, ▁true ▁) ▁; ▁} ▁protected ▁void ▁prev Function ▁( ▁) ▁{ ▁performAction ▁( ▁prev Function ▁, ▁cb ▁. ▁getProvider ▁( ▁) ▁, ▁true ▁) ▁; ▁} ▁protected ▁void ▁clear History ▁( ▁) ▁{ ▁performAction ▁( ▁clear History ▁, ▁cb ▁. ▁getProvider ▁( ▁) ▁, ▁true ▁) ▁; ▁} ▁protected ▁boolean ▁is Previous In History Enabled ▁( ▁) ▁{ ▁return ▁isEnabled ▁( ▁prev ▁) ▁; ▁} ▁protected ▁void ▁goTo ▁( ▁ProgramLocation ▁loc ▁) ▁{ ▁cb ▁. ▁goTo ▁( ▁loc ▁) ▁; ▁waitForSwing ▁( ▁) ▁; ▁} ▁protected ▁Table Component Provider ▁< ▁? ▁> ▁[ ▁] ▁get Providers ▁( ▁) ▁{ ▁Table Service Plugin ▁plugin ▁= ▁getPlugin ▁( ▁getTool ▁( ▁) ▁, ▁Table Service Plugin ▁. ▁class ▁) ▁; ▁return ▁plugin ▁. ▁get Managed Components ▁( ▁) ▁; ▁} ▁protected ▁GTable ▁waitFor Results ▁( ▁) ▁throws ▁Exception ▁{ ▁waitForSwing ▁( ▁) ▁; ▁int ▁i ▁= ▁0 ▁; ▁while ▁( ▁i ▁++ ▁< ▁50 ▁) ▁{ ▁Table Component Provider ▁< ▁? ▁> ▁[ ▁] ▁providers ▁= ▁get Providers ▁( ▁) ▁; ▁if ▁( ▁providers ▁. ▁length ▁> ▁0 ▁) ▁{ ▁G Threaded Table Panel ▁< ▁? ▁> ▁panel ▁= ▁( ▁G Threaded Table Panel ▁< ▁? ▁> ▁) ▁TestUtils ▁. ▁getInstance Field ▁( ▁STR ▁, ▁providers ▁[ ▁0 ▁] ▁) ▁; ▁GTable ▁table ▁= ▁panel ▁. ▁getTable ▁( ▁) ▁; ▁while ▁( ▁panel ▁. ▁is Busy ▁( ▁) ▁) ▁{ ▁Thread ▁. ▁sleep ▁( ▁50 ▁) ▁; ▁} ▁waitForSwing ▁( ▁) ▁; ▁return ▁table ▁; ▁} ▁Thread ▁. ▁sleep ▁( ▁50 ▁) ▁; ▁} ▁throw ▁new ▁Exception ▁( ▁STR ▁) ▁; ▁} ▁}
▁public ▁class ▁Apollo Ldap Authentication Provider ▁extends ▁Ldap Authentication Provider ▁{ ▁private ▁Ldap Extend Properties ▁properties ▁; ▁public ▁Apollo Ldap Authentication Provider ▁( ▁Ldap Authenticator ▁auth enticator ▁, ▁Ldap Auth orities Populator ▁authorities Populator ▁) ▁{ ▁super ▁( ▁auth enticator ▁, ▁authorities Populator ▁) ▁; ▁} ▁public ▁Apollo Ldap Authentication Provider ▁( ▁Ldap Authenticator ▁auth enticator ▁) ▁{ ▁super ▁( ▁auth enticator ▁) ▁; ▁} ▁public ▁Apollo Ldap Authentication Provider ▁( ▁Ldap Authenticator ▁auth enticator ▁, ▁Ldap Auth orities Populator ▁authorities Populator ▁, ▁Ldap Extend Properties ▁properties ▁) ▁{ ▁super ▁( ▁auth enticator ▁, ▁authorities Populator ▁) ▁; ▁this ▁. ▁properties ▁= ▁properties ▁; ▁} ▁public ▁Apollo Ldap Authentication Provider ▁( ▁Ldap Authenticator ▁auth enticator ▁, ▁Ldap Extend Properties ▁properties ▁) ▁{ ▁super ▁( ▁auth enticator ▁) ▁; ▁this ▁. ▁properties ▁= ▁properties ▁; ▁} ▁@ ▁Override ▁public ▁Authentication ▁authenticate ▁( ▁Authentication ▁authentication ▁) ▁throws ▁Authentication Exception ▁{ ▁Assert ▁. ▁isInstanceOf ▁( ▁Username Password Authentication Token ▁. ▁class ▁, ▁authentication ▁, ▁this ▁. ▁messages ▁. ▁getMessage ▁( ▁STR ▁, ▁STR ▁) ▁) ▁; ▁Username Password Authentication Token ▁user Token ▁= ▁( ▁Username Password Authentication Token ▁) ▁authentication ▁; ▁String ▁username ▁= ▁user Token ▁. ▁getName ▁( ▁) ▁; ▁String ▁password ▁= ▁( ▁String ▁) ▁authentication ▁. ▁getCredentials ▁( ▁) ▁; ▁if ▁( ▁this ▁. ▁logger ▁. ▁isDebugEnabled ▁( ▁) ▁) ▁{ ▁this ▁. ▁logger ▁. ▁debug ▁( ▁STR ▁+ ▁username ▁) ▁; ▁} ▁if ▁( ▁! ▁StringUtils ▁. ▁hasLength ▁( ▁username ▁) ▁) ▁{ ▁throw ▁new ▁Bad Credentials Exception ▁( ▁this ▁. ▁messages ▁. ▁getMessage ▁( ▁STR ▁, ▁STR ▁) ▁) ▁; ▁} ▁if ▁( ▁! ▁StringUtils ▁. ▁hasLength ▁( ▁password ▁) ▁) ▁{ ▁throw ▁new ▁Bad Credentials Exception ▁( ▁this ▁. ▁messages ▁. ▁getMessage ▁( ▁STR ▁, ▁STR ▁) ▁) ▁; ▁} ▁Assert ▁. ▁notNull ▁( ▁password ▁, ▁STR ▁) ▁; ▁Dir Context Operations ▁userData ▁= ▁this ▁. ▁do Authentication ▁( ▁user Token ▁) ▁; ▁String ▁login Id ▁= ▁userData ▁. ▁getString Attribute ▁( ▁properties ▁. ▁getM apping ▁( ▁) ▁. ▁getLogin Id ▁( ▁) ▁) ▁; ▁UserDetails ▁user ▁= ▁this ▁. ▁userDetails Context Mapper ▁. ▁map User From Context ▁( ▁userData ▁, ▁login Id ▁, ▁this ▁. ▁load User Auth orities ▁( ▁userData ▁, ▁login Id ▁, ▁( ▁String ▁) ▁authentication ▁. ▁getCredentials ▁( ▁) ▁) ▁) ▁; ▁return ▁this ▁. ▁create Successful Authentication ▁( ▁user Token ▁, ▁user ▁) ▁; ▁} ▁}
▁private ▁static ▁Bean Descriptor ▁describe Bean ▁( ▁String ▁name ▁, ▁BeanDefinition ▁definition ▁, ▁Configurable List ableBeanFactory ▁factory ▁) ▁{ ▁return ▁new ▁Bean Descriptor ▁( ▁factory ▁. ▁getA li ases ▁( ▁name ▁) ▁, ▁definition ▁. ▁getScope ▁( ▁) ▁, ▁factory ▁. ▁getType ▁( ▁name ▁) ▁, ▁definition ▁. ▁getResource Description ▁( ▁) ▁, ▁factory ▁. ▁getDependencies For Bean ▁( ▁name ▁) ▁) ▁; ▁} ▁private ▁static ▁boolean ▁is Bean El igible ▁( ▁String ▁beanName ▁, ▁BeanDefinition ▁bd ▁, ▁Configurable BeanFactory ▁bf ▁) ▁{ ▁return ▁( ▁bd ▁. ▁getRole ▁( ▁) ▁!= ▁BeanDefinition ▁. ▁ROLE _ IN FR AS TR UCT URE ▁&& ▁( ▁! ▁bd ▁. ▁is Lazy Init ▁( ▁) ▁|| ▁bf ▁. ▁contains Singleton ▁( ▁beanName ▁) ▁) ▁) ▁; ▁} ▁} ▁public ▁static ▁final ▁class ▁Bean Descriptor ▁{ ▁private ▁final ▁String ▁[ ▁] ▁aliases ▁; ▁private ▁final ▁String ▁scope ▁; ▁private ▁final ▁Class ▁< ▁? ▁> ▁type ▁; ▁private ▁final ▁String ▁resource ▁; ▁private ▁final ▁String ▁[ ▁] ▁dependencies ▁; ▁private ▁Bean Descriptor ▁( ▁String ▁[ ▁] ▁aliases ▁, ▁String ▁scope ▁, ▁Class ▁< ▁? ▁> ▁type ▁, ▁String ▁resource ▁, ▁String ▁[ ▁] ▁dependencies ▁) ▁{ ▁this ▁. ▁aliases ▁= ▁aliases ▁; ▁this ▁. ▁scope ▁= ▁( ▁StringUtils ▁. ▁hasText ▁( ▁scope ▁) ▁? ▁scope ▁: ▁BeanDefinition ▁. ▁SCOPE _ SING LETON ▁) ▁; ▁this ▁. ▁type ▁= ▁type ▁; ▁this ▁. ▁resource ▁= ▁resource ▁; ▁this ▁. ▁dependencies ▁= ▁dependencies ▁; ▁} ▁public ▁String ▁[ ▁] ▁getA li ases ▁( ▁) ▁{ ▁return ▁this ▁. ▁aliases ▁; ▁} ▁public ▁String ▁getScope ▁( ▁) ▁{ ▁return ▁this ▁. ▁scope ▁; ▁} ▁public ▁Class ▁< ▁? ▁> ▁getType ▁( ▁) ▁{ ▁return ▁this ▁. ▁type ▁; ▁} ▁public ▁String ▁getResource ▁( ▁) ▁{ ▁return ▁this ▁. ▁resource ▁; ▁} ▁public ▁String ▁[ ▁] ▁getDependencies ▁( ▁) ▁{ ▁return ▁this ▁. ▁dependencies ▁; ▁} ▁} ▁}
▁public ▁class ▁Test Queue Mappings ▁{ ▁private ▁static ▁final ▁Logger ▁LOG ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Test Queue Mappings ▁. ▁class ▁) ▁; ▁private ▁static ▁final ▁String ▁Q 1 ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁Q 2 ▁= ▁STR ▁; ▁private ▁final ▁static ▁String ▁Q 1_ PATH ▁= ▁Capacity Scheduler Configuration ▁. ▁ROOT ▁+ ▁STR ▁+ ▁Q 1 ▁; ▁private ▁final ▁static ▁String ▁Q 2_ PATH ▁= ▁Capacity Scheduler Configuration ▁. ▁ROOT ▁+ ▁STR ▁+ ▁Q 2 ▁; ▁private ▁Capacity Scheduler ▁cs ▁; ▁private ▁Yarn Configuration ▁conf ▁; ▁@ ▁Before ▁public ▁void ▁setup ▁( ▁) ▁{ ▁Capacity Scheduler Configuration ▁cs Conf ▁= ▁new ▁Capacity Scheduler Configuration ▁( ▁) ▁; ▁setup Queue Configuration ▁( ▁cs Conf ▁) ▁; ▁conf ▁= ▁new ▁Yarn Configuration ▁( ▁cs Conf ▁) ▁; ▁cs ▁= ▁new ▁Capacity Scheduler ▁( ▁) ▁; ▁RM Context ▁rm Context ▁= ▁TestUtils ▁. ▁getMock RM Context ▁( ▁) ▁; ▁cs ▁. ▁setConf ▁( ▁conf ▁) ▁; ▁cs ▁. ▁set RM Context ▁( ▁rm Context ▁) ▁; ▁cs ▁. ▁init ▁( ▁conf ▁) ▁; ▁cs ▁. ▁start ▁( ▁) ▁; ▁} ▁private ▁void ▁setup Queue Configuration ▁( ▁Capacity Scheduler Configuration ▁conf ▁) ▁{ ▁conf ▁. ▁set Queues ▁( ▁Capacity Scheduler Configuration ▁. ▁ROOT ▁, ▁new ▁String ▁[ ▁] ▁{ ▁Q 1 ▁, ▁Q 2 ▁} ▁) ▁; ▁conf ▁. ▁set Capacity ▁( ▁Q 1_ PATH ▁, ▁10 ▁) ▁; ▁conf ▁. ▁set Capacity ▁( ▁Q 2_ PATH ▁, ▁90 ▁) ▁; ▁LOG ▁. ▁info ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Queue Mapping Spec ify ing NotExist ed Queue ▁( ▁) ▁{ ▁conf ▁. ▁set ▁( ▁Capacity Scheduler Configuration ▁. ▁QUEUE _ MAPPING ▁, ▁STR ▁) ▁; ▁boolean ▁fail ▁= ▁false ▁; ▁try ▁{ ▁cs ▁. ▁re init ialize ▁( ▁conf ▁, ▁null ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁io ex ▁) ▁{ ▁fail ▁= ▁true ▁; ▁} ▁Assert ▁. ▁assertTrue ▁( ▁STR ▁, ▁fail ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Queue Mapping Trim Spaces ▁( ▁) ▁throws ▁IOException ▁{ ▁conf ▁. ▁set ▁( ▁Capacity Scheduler Configuration ▁. ▁QUEUE _ MAPPING ▁, ▁STR ▁+ ▁Q 1 ▁) ▁; ▁cs ▁. ▁re init ialize ▁( ▁conf ▁, ▁null ▁) ▁; ▁List ▁< ▁Mapping Rule ▁> ▁rules ▁= ▁cs ▁. ▁get Configuration ▁( ▁) ▁. ▁getM apping Rules ▁( ▁) ▁; ▁String ▁rule Str ▁= ▁rules ▁. ▁get ▁( ▁0 ▁) ▁. ▁toString ▁( ▁) ▁; ▁assert ▁( ▁rule Str ▁. ▁contains ▁( ▁STR ▁) ▁) ▁; ▁assert ▁( ▁rule Str ▁. ▁contains ▁( ▁STR ▁) ▁) ▁; ▁assert ▁( ▁rule Str ▁. ▁contains ▁( ▁STR ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Queue Mapping Path Parsing ▁( ▁) ▁{ ▁Queue Mapping ▁leaf Only ▁= ▁Queue Mapping ▁. ▁Queue Mapping Builder ▁. ▁create ▁( ▁) ▁. ▁parse Path String ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁leaf Only ▁. ▁getQueue ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁null ▁, ▁leaf Only ▁. ▁getParent Queue ▁( ▁) ▁) ▁;
▁public ▁class ▁Local Variables ▁implements ▁Runnable ▁{ ▁private ▁int ▁field ▁; ▁public ▁static ▁void ▁main ▁( ▁String ▁... ▁args ▁) ▁{ ▁Local Variables ▁target ▁= ▁new ▁Local Variables ▁( ▁) ▁; ▁new ▁Thread ▁( ▁target ▁) ▁. ▁start ▁( ▁) ▁; ▁new ▁Thread ▁( ▁target ▁) ▁. ▁start ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁run ▁( ▁) ▁{ ▁field ▁= ▁new ▁SecureRandom ▁( ▁) ▁. ▁nextInt ▁( ▁) ▁; ▁int ▁local ▁= ▁new ▁SecureRandom ▁( ▁) ▁. ▁nextInt ▁( ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁field ▁+ ▁STR ▁+ ▁local ▁) ▁; ▁} ▁}
▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁static ▁final ▁Mult icast Subscription ▁[ ▁] ▁TERMIN ATED ▁= ▁new ▁Mult icast Subscription ▁[ ▁0 ▁] ▁; ▁final ▁AtomicInteger ▁w ip ▁; ▁final ▁AtomicReference ▁< ▁Mult icast Subscription ▁< ▁T ▁> ▁[ ▁] ▁> ▁subscribers ▁; ▁final ▁int ▁prefetch ▁; ▁final ▁int ▁limit ▁; ▁final ▁boolean ▁delay Error ▁; ▁final ▁AtomicReference ▁< ▁Subscription ▁> ▁upstream ▁; ▁volatile ▁Simple Queue ▁< ▁T ▁> ▁queue ▁; ▁int ▁source Mode ▁; ▁volatile ▁boolean ▁done ▁; ▁Throwable ▁error ▁; ▁int ▁consumed ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁Mult icast Processor ▁( ▁int ▁prefetch ▁, ▁boolean ▁delay Error ▁) ▁{ ▁this ▁. ▁prefetch ▁= ▁prefetch ▁; ▁this ▁. ▁limit ▁= ▁prefetch ▁- ▁( ▁prefetch ▁>> ▁2 ▁) ▁; ▁this ▁. ▁delay Error ▁= ▁delay Error ▁; ▁this ▁. ▁w ip ▁= ▁new ▁AtomicInteger ▁( ▁) ▁; ▁this ▁. ▁upstream ▁= ▁new ▁AtomicReference ▁< ▁> ▁( ▁) ▁; ▁this ▁. ▁subscribers ▁= ▁new ▁AtomicReference ▁< ▁> ▁( ▁EMPTY ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁onSubscribe ▁( ▁Subscription ▁s ▁) ▁{ ▁if ▁( ▁Subscription Helper ▁. ▁setOnce ▁( ▁this ▁. ▁upstream ▁, ▁s ▁) ▁) ▁{ ▁if ▁( ▁s ▁instanceof ▁Queue Subscription ▁) ▁{ ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁Queue Subscription ▁< ▁T ▁> ▁q s ▁= ▁( ▁Queue Subscription ▁< ▁T ▁> ▁) ▁s ▁; ▁int ▁m ▁= ▁q s ▁. ▁request Fusion ▁( ▁Queue Subscription ▁. ▁ANY ▁) ▁; ▁if ▁( ▁m ▁== ▁Queue Subscription ▁. ▁SY NC ▁) ▁{ ▁source Mode ▁= ▁m ▁; ▁queue ▁= ▁q s ▁; ▁done ▁= ▁true ▁; ▁drain ▁( ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁m ▁== ▁Queue Subscription ▁. ▁ASYNC ▁) ▁{ ▁source Mode ▁= ▁m ▁; ▁queue ▁= ▁q s ▁; ▁Queue D rain Helper ▁. ▁request ▁( ▁s ▁, ▁prefetch ▁) ▁; ▁return ▁; ▁} ▁} ▁queue ▁= ▁Queue D rain Helper ▁. ▁create Queue ▁( ▁prefetch ▁) ▁; ▁Queue D rain Helper ▁. ▁request ▁( ▁s ▁, ▁prefetch ▁) ▁; ▁} ▁} ▁void ▁dispose ▁( ▁) ▁{ ▁if ▁( ▁! ▁done ▁) ▁{ ▁Subscription Helper ▁. ▁cancel ▁( ▁upstream ▁) ▁; ▁if ▁( ▁w ip ▁. ▁getAndIncrement ▁( ▁) ▁== ▁0 ▁) ▁{ ▁Simple Queue ▁< ▁T ▁> ▁q ▁= ▁queue ▁; ▁if ▁( ▁q ▁!= ▁null ▁) ▁{ ▁q ▁. ▁clear ▁( ▁) ▁; ▁} ▁} ▁} ▁} ▁boolean ▁isDisposed ▁( ▁) ▁{ ▁return ▁upstream ▁. ▁get ▁( ▁) ▁== ▁Subscription Helper ▁. ▁CANCELLED ▁; ▁} ▁@ ▁Override ▁public ▁void ▁onNext ▁( ▁T ▁t ▁) ▁{ ▁if ▁( ▁done ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁source Mode ▁== ▁Queue Subscription ▁. ▁NONE ▁&& ▁! ▁queue ▁. ▁offer ▁( ▁t ▁) ▁) ▁{ ▁upstream ▁. ▁get ▁( ▁) ▁. ▁cancel ▁( ▁) ▁; ▁onError ▁( ▁new ▁Missing Back pressure Exception ▁( ▁) ▁) ▁; ▁return ▁; ▁} ▁drain ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁onError ▁( ▁Throwable ▁t ▁) ▁{ ▁if ▁( ▁done ▁) ▁{ ▁RxJavaPlugins ▁. ▁onError ▁( ▁t ▁) ▁; ▁return ▁; ▁} ▁error ▁= ▁t ▁; ▁done ▁= ▁true ▁; ▁drain ▁( ▁) ▁; ▁}
▁catch ▁( ▁Throwable ▁ex ▁) ▁{ ▁composite ▁. ▁release ▁( ▁) ▁; ▁throw ▁ex ▁; ▁} ▁} ▁else ▁if ▁( ▁this ▁. ▁route ▁!= ▁null ▁) ▁{ ▁Assert ▁. ▁isTrue ▁( ▁entries ▁. ▁isEmpty ▁( ▁) ▁, ▁STR ▁) ▁; ▁String ▁routing MimeType ▁= ▁W ell Known MimeType ▁. ▁MESSAGE _ RS O CKET _ R OUT ING ▁. ▁getString ▁( ▁) ▁; ▁return ▁this ▁. ▁metadata MimeType ▁. ▁toString ▁( ▁) ▁. ▁equals ▁( ▁routing MimeType ▁) ▁? ▁as DataBuffer ▁( ▁encode Route ▁( ▁) ▁) ▁: ▁encode Entry ▁( ▁this ▁. ▁route ▁, ▁this ▁. ▁metadata MimeType ▁) ▁; ▁} ▁else ▁{ ▁Assert ▁. ▁isTrue ▁( ▁entries ▁. ▁size ▁( ▁) ▁== ▁1 ▁, ▁STR ▁) ▁; ▁Metadata Entry ▁entry ▁= ▁entries ▁. ▁get ▁( ▁0 ▁) ▁; ▁if ▁( ▁! ▁this ▁. ▁metadata MimeType ▁. ▁equals ▁( ▁entry ▁. ▁mimeType ▁( ▁) ▁) ▁) ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁STR ▁+ ▁this ▁. ▁metadata MimeType ▁+ ▁STR ▁+ ▁entries ▁+ ▁STR ▁) ▁; ▁} ▁return ▁encode Entry ▁( ▁entry ▁) ▁; ▁} ▁} ▁private ▁ByteBuf ▁encode Route ▁( ▁) ▁{ ▁return ▁io ▁. ▁rs ocket ▁. ▁metadata ▁. ▁Tag ging Metadata Codec ▁. ▁create Routing Metadata ▁( ▁this ▁. ▁allocator ▁, ▁Collections ▁. ▁singletonList ▁( ▁this ▁. ▁route ▁) ▁) ▁. ▁getContent ▁( ▁) ▁; ▁} ▁private ▁< ▁T ▁> ▁DataBuffer ▁encode Entry ▁( ▁Metadata Entry ▁entry ▁) ▁{ ▁return ▁encode Entry ▁( ▁entry ▁. ▁value ▁( ▁) ▁, ▁entry ▁. ▁mimeType ▁( ▁) ▁) ▁; ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁private ▁< ▁T ▁> ▁DataBuffer ▁encode Entry ▁( ▁Object ▁value ▁, ▁MimeType ▁mimeType ▁) ▁{ ▁if ▁( ▁value ▁instanceof ▁ByteBuf ▁) ▁{ ▁return ▁as DataBuffer ▁( ▁( ▁ByteBuf ▁) ▁value ▁) ▁; ▁} ▁ResolvableType ▁type ▁= ▁ResolvableType ▁. ▁for Instance ▁( ▁value ▁) ▁; ▁Encoder ▁< ▁T ▁> ▁encoder ▁= ▁this ▁. ▁str ategies ▁. ▁encoder ▁( ▁type ▁, ▁mimeType ▁) ▁; ▁Assert ▁. ▁notNull ▁( ▁encoder ▁, ▁( ▁) ▁-> ▁STR ▁+ ▁value ▁+ ▁STR ▁+ ▁mimeType ▁+ ▁STR ▁) ▁; ▁return ▁encoder ▁. ▁encode Value ▁( ▁( ▁T ▁) ▁value ▁, ▁bufferFactory ▁( ▁) ▁, ▁type ▁, ▁mimeType ▁, ▁Collections ▁. ▁emptyMap ▁( ▁) ▁) ▁; ▁} ▁private ▁DataBuffer ▁as DataBuffer ▁( ▁ByteBuf ▁byteBuf ▁) ▁{ ▁if ▁( ▁bufferFactory ▁( ▁) ▁instanceof ▁Netty DataBuffer Factory ▁) ▁{ ▁return ▁( ▁( ▁Netty DataBuffer Factory ▁) ▁bufferFactory ▁( ▁) ▁) ▁. ▁wrap ▁( ▁byteBuf ▁) ▁; ▁} ▁else ▁{ ▁DataBuffer ▁buffer ▁= ▁bufferFactory ▁( ▁) ▁. ▁wrap ▁( ▁byteBuf ▁. ▁nio Buffer ▁( ▁) ▁) ▁; ▁byteBuf ▁. ▁release ▁( ▁) ▁; ▁return ▁buffer ▁; ▁} ▁} ▁private ▁Mono ▁< ▁List ▁< ▁Metadata Entry ▁> ▁> ▁resolve Async Metadata ▁( ▁) ▁{ ▁Assert ▁. ▁state ▁( ▁this ▁. ▁has Async Values ▁, ▁STR ▁) ▁; ▁List ▁< ▁Mono ▁< ▁? ▁> ▁> ▁value Mon os ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁this ▁. ▁metadata Entries ▁. ▁forEach ▁( ▁entry ▁-> ▁{ ▁Object ▁v ▁= ▁entry ▁. ▁value ▁( ▁) ▁;
▁AbstractMap ▁. ▁Simple Entry ▁< ▁Integer ▁, ▁T ▁> ▁[ ▁] ▁adjust ed Old Indexed Items ▁= ▁new ▁AbstractMap ▁. ▁Simple Entry ▁[ ▁this ▁. ▁old Item Count ▁] ▁; ▁System ▁. ▁arraycopy ▁( ▁this ▁. ▁adjust ed Old Indexed Item sWith Orig Order ▁, ▁0 ▁, ▁adjust ed Old Indexed Items ▁, ▁0 ▁, ▁this ▁. ▁old Item Count ▁) ▁; ▁Arrays ▁. ▁sort ▁( ▁adjust ed Old Indexed Items ▁, ▁this ▁. ▁comparator For Item Diff ▁) ▁; ▁AbstractMap ▁. ▁Simple Entry ▁< ▁Integer ▁, ▁T ▁> ▁[ ▁] ▁adjust ed New Indexed Items ▁= ▁collect Section Items ▁( ▁this ▁. ▁new Dex ▁, ▁false ▁) ▁; ▁this ▁. ▁new Item Count ▁= ▁adjust ed New Indexed Items ▁. ▁length ▁; ▁Arrays ▁. ▁sort ▁( ▁adjust ed New Indexed Items ▁, ▁this ▁. ▁comparator For Item Diff ▁) ▁; ▁int ▁old Cursor ▁= ▁0 ▁; ▁int ▁new Cursor ▁= ▁0 ▁; ▁while ▁( ▁old Cursor ▁< ▁this ▁. ▁old Item Count ▁|| ▁new Cursor ▁< ▁this ▁. ▁new Item Count ▁) ▁{ ▁if ▁( ▁old Cursor ▁>= ▁this ▁. ▁old Item Count ▁) ▁{ ▁while ▁( ▁new Cursor ▁< ▁this ▁. ▁new Item Count ▁) ▁{ ▁AbstractMap ▁. ▁Simple Entry ▁< ▁Integer ▁, ▁T ▁> ▁new Indexed Item ▁= ▁adjust ed New Indexed Items ▁[ ▁new Cursor ▁++ ▁] ▁; ▁this ▁. ▁patch Operation List ▁. ▁add ▁( ▁new ▁P atch Operation ▁< ▁> ▁( ▁P atch Operation ▁. ▁OP _ ADD ▁, ▁new Indexed Item ▁. ▁getKey ▁( ▁) ▁, ▁new Indexed Item ▁. ▁getValue ▁( ▁) ▁) ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁new Cursor ▁>= ▁new Item Count ▁) ▁{ ▁while ▁( ▁old Cursor ▁< ▁old Item Count ▁) ▁{ ▁AbstractMap ▁. ▁Simple Entry ▁< ▁Integer ▁, ▁T ▁> ▁old Indexed Item ▁= ▁adjust ed Old Indexed Items ▁[ ▁old Cursor ▁++ ▁] ▁; ▁int ▁deleted Index ▁= ▁old Indexed Item ▁. ▁getKey ▁( ▁) ▁; ▁int ▁deleted Offset ▁= ▁getItem Offset Or Index ▁( ▁deleted Index ▁, ▁old Indexed Item ▁. ▁getValue ▁( ▁) ▁) ▁; ▁this ▁. ▁patch Operation List ▁. ▁add ▁( ▁new ▁P atch Operation ▁< ▁T ▁> ▁( ▁P atch Operation ▁. ▁OP _ DE L ▁, ▁deleted Index ▁) ▁) ▁; ▁mark Deleted Index Or Offset ▁( ▁this ▁. ▁old To Patch ed IndexMap ▁, ▁deleted Index ▁, ▁deleted Offset ▁) ▁; ▁} ▁} ▁else ▁{ ▁AbstractMap ▁. ▁Simple Entry ▁< ▁Integer ▁, ▁T ▁> ▁old Indexed Item ▁= ▁adjust ed Old Indexed Items ▁[ ▁old Cursor ▁] ▁; ▁AbstractMap ▁. ▁Simple Entry ▁< ▁Integer ▁, ▁T ▁> ▁new Indexed Item ▁= ▁adjust ed New Indexed Items ▁[ ▁new Cursor ▁] ▁; ▁int ▁cmp Res ▁= ▁old Indexed Item ▁. ▁getValue ▁( ▁) ▁. ▁compareTo ▁( ▁new Indexed Item ▁. ▁getValue ▁( ▁) ▁) ▁; ▁if ▁( ▁cmp Res ▁< ▁0 ▁) ▁{ ▁int ▁deleted Index ▁= ▁old Indexed Item ▁. ▁getKey ▁( ▁) ▁; ▁int ▁deleted Offset ▁= ▁getItem Offset Or Index ▁( ▁deleted Index ▁, ▁old Indexed Item ▁. ▁getValue ▁( ▁) ▁) ▁;
▁co sts ▁. ▁add He uristic Disk Cost ▁( ▁HE URI ST IC _ CO ST _ BASE ▁ * ▁100000 ▁) ▁; ▁co sts ▁. ▁add He uristic Cpu Cost ▁( ▁( ▁long ▁) ▁( ▁HE URI ST IC _ CO ST _ BASE ▁ * ▁100000 ▁ * ▁M ATER IALI Z ATION _ CPU _ FACTOR ▁) ▁) ▁; ▁co sts ▁. ▁multiply With ▁( ▁cost Weight ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁add Block Nested Loops Co sts ▁( ▁E stim ate Provider ▁outer Side ▁, ▁E stim ate Provider ▁inner Side ▁, ▁long ▁blockSize ▁, ▁Co sts ▁co sts ▁, ▁int ▁cost Weight ▁) ▁{ ▁long ▁is ▁= ▁inner Side ▁. ▁getEstimated Output Size ▁( ▁) ▁; ▁long ▁os ▁= ▁outer Side ▁. ▁getEstimated Output Size ▁( ▁) ▁; ▁if ▁( ▁is ▁> ▁0 ▁&& ▁os ▁> ▁0 ▁) ▁{ ▁long ▁l oops ▁= ▁Math ▁. ▁max ▁( ▁os ▁ / ▁blockSize ▁, ▁1 ▁) ▁; ▁co sts ▁. ▁add Disk Cost ▁( ▁l oops ▁ * ▁is ▁) ▁; ▁co sts ▁. ▁add Cpu Cost ▁( ▁( ▁long ▁) ▁( ▁l oops ▁ * ▁is ▁ * ▁M ATER IALI Z ATION _ CPU _ FACTOR ▁) ▁) ▁; ▁} ▁else ▁{ ▁co sts ▁. ▁set Disk Cost ▁( ▁Co sts ▁. ▁UNKNOWN ▁) ▁; ▁co sts ▁. ▁set Cpu Cost ▁( ▁Co sts ▁. ▁UNKNOWN ▁) ▁; ▁} ▁co sts ▁. ▁add He uristic Disk Cost ▁( ▁HE URI ST IC _ CO ST _ BASE ▁ * ▁1000 ▁) ▁; ▁co sts ▁. ▁add He uristic Cpu Cost ▁( ▁( ▁long ▁) ▁( ▁HE URI ST IC _ CO ST _ BASE ▁ * ▁1000 ▁ * ▁M ATER IALI Z ATION _ CPU _ FACTOR ▁) ▁) ▁; ▁co sts ▁. ▁multiply With ▁( ▁cost Weight ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁add Art ific ial D am Cost ▁( ▁E stim ate Provider ▁estim ates ▁, ▁long ▁bufferSize ▁, ▁Co sts ▁co sts ▁) ▁{ ▁final ▁long ▁s ▁= ▁estim ates ▁. ▁getEstimated Output Size ▁( ▁) ▁; ▁if ▁( ▁s ▁<= ▁0 ▁) ▁{ ▁co sts ▁. ▁set Disk Cost ▁( ▁Co sts ▁. ▁UNKNOWN ▁) ▁; ▁co sts ▁. ▁set Cpu Cost ▁( ▁Co sts ▁. ▁UNKNOWN ▁) ▁; ▁} ▁else ▁{ ▁co sts ▁. ▁add Disk Cost ▁( ▁2 ▁ * ▁s ▁) ▁; ▁co sts ▁. ▁set Cpu Cost ▁( ▁( ▁long ▁) ▁( ▁s ▁ * ▁M ATER IALI Z ATION _ CPU _ FACTOR ▁) ▁) ▁; ▁} ▁co sts ▁. ▁add He uristic Disk Cost ▁( ▁2 ▁ * ▁HE URI ST IC _ CO ST _ BASE ▁) ▁; ▁co sts ▁. ▁add He uristic Cpu Cost ▁( ▁( ▁long ▁) ▁( ▁HE URI ST IC _ CO ST _ BASE ▁ * ▁M ATER IALI Z ATION _ CPU _ FACTOR ▁) ▁) ▁; ▁} ▁}
▁test Object Serialization ▁( ▁( ▁float ▁) ▁Math ▁. ▁PI ▁) ▁; ▁test Object Serialization ▁( ▁Float ▁. ▁MIN _ VALUE ▁) ▁; ▁test Object Serialization ▁( ▁Float ▁. ▁MAX _ VALUE ▁) ▁; ▁test Object Serialization ▁( ▁Float ▁. ▁MIN _ NORMAL ▁) ▁; ▁test Object Serialization ▁( ▁Float ▁. ▁NaN ▁) ▁; ▁test Object Serialization ▁( ▁Float ▁. ▁NEGATIVE _ INFINITY ▁) ▁; ▁test Object Serialization ▁( ▁Float ▁. ▁POSITIVE _ INFINITY ▁) ▁; ▁test Object Serialization ▁( ▁0 d ▁) ▁; ▁test Object Serialization ▁( ▁1 d ▁) ▁; ▁test Object Serialization ▁( ▁( ▁double ▁) ▁- ▁1 ▁) ▁; ▁test Object Serialization ▁( ▁Math ▁. ▁E ▁) ▁; ▁test Object Serialization ▁( ▁Math ▁. ▁PI ▁) ▁; ▁test Object Serialization ▁( ▁Double ▁. ▁MIN _ VALUE ▁) ▁; ▁test Object Serialization ▁( ▁Double ▁. ▁MAX _ VALUE ▁) ▁; ▁test Object Serialization ▁( ▁Double ▁. ▁MIN _ NORMAL ▁) ▁; ▁test Object Serialization ▁( ▁Double ▁. ▁NaN ▁) ▁; ▁test Object Serialization ▁( ▁Double ▁. ▁NEGATIVE _ INFINITY ▁) ▁; ▁test Object Serialization ▁( ▁Double ▁. ▁POSITIVE _ INFINITY ▁) ▁; ▁test Object Serialization ▁( ▁STR ▁) ▁; ▁test Object Serialization ▁( ▁STR ▁) ▁; ▁test Object Serialization ▁( ▁STR ▁) ▁; ▁test Object Serialization ▁( ▁new ▁Simple Types ▁( ▁36 37 ▁, ▁5 48 7 64 86 54 8 L ▁, ▁( ▁byte ▁) ▁6 5 ▁, ▁STR ▁, ▁( ▁short ▁) ▁0 x 23 87 ▁, ▁2. 65 76 75 23 ▁) ▁) ▁; ▁test Object Serialization ▁( ▁new ▁Simple Types ▁( ▁70 56 08 7 24 ▁, ▁- ▁1 L ▁, ▁( ▁byte ▁) ▁- ▁6 5 ▁, ▁STR ▁, ▁( ▁short ▁) ▁Byte ▁. ▁MIN _ VALUE ▁, ▁0. 000000 1 ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Array Types ▁( ▁) ▁{ ▁{ ▁int ▁[ ▁] ▁array ▁= ▁new ▁int ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁test Object Serialization ▁( ▁array ▁) ▁; ▁} ▁{ ▁long ▁[ ▁] ▁array ▁= ▁new ▁long ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁test Object Serialization ▁( ▁array ▁) ▁; ▁} ▁{ ▁float ▁[ ▁] ▁array ▁= ▁new ▁float ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁test Object Serialization ▁( ▁array ▁) ▁; ▁} ▁{ ▁double ▁[ ▁] ▁array ▁= ▁new ▁double ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁; ▁test Object Serialization ▁( ▁array ▁) ▁; ▁} ▁{ ▁String ▁[ ▁] ▁array ▁= ▁new ▁String ▁[ ▁] ▁{ ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁} ▁; ▁test Object Serialization ▁( ▁array ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁testEmpty Array ▁( ▁) ▁{ ▁{ ▁int ▁[ ▁] ▁array ▁= ▁new ▁int ▁[ ▁0 ▁] ▁; ▁test Object Serialization ▁( ▁array ▁) ▁; ▁} ▁{ ▁long ▁[ ▁] ▁array ▁= ▁new ▁long ▁[ ▁0 ▁] ▁; ▁test Object Serialization ▁( ▁array ▁) ▁; ▁}
▁private ▁OneInputStream Operator TestHarness ▁< ▁IN ▁, ▁OUT ▁> ▁getTest Harness ▁( ▁Configuration ▁config ▁) ▁throws ▁Exception ▁{ ▁RowType ▁dataType ▁= ▁new ▁RowType ▁( ▁Arrays ▁. ▁asList ▁( ▁new ▁RowType ▁. ▁Row Field ▁( ▁STR ▁, ▁new ▁Var Char Type ▁( ▁) ▁) ▁, ▁new ▁RowType ▁. ▁Row Field ▁( ▁STR ▁, ▁new ▁Var Char Type ▁( ▁) ▁) ▁, ▁new ▁RowType ▁. ▁Row Field ▁( ▁STR ▁, ▁new ▁Big Int Type ▁( ▁) ▁) ▁) ▁) ▁; ▁AbstractP ython ScalarFunction Operator ▁operator ▁= ▁getTest Operator ▁( ▁config ▁, ▁new ▁Python Function Info ▁[ ▁] ▁{ ▁new ▁Python Function Info ▁( ▁Dummy Python Function ▁. ▁INSTANCE ▁, ▁new ▁Integer ▁[ ▁] ▁{ ▁0 ▁} ▁) ▁} ▁, ▁dataType ▁, ▁dataType ▁, ▁new ▁int ▁[ ▁] ▁{ ▁2 ▁} ▁, ▁new ▁int ▁[ ▁] ▁{ ▁0 ▁, ▁1 ▁} ▁) ▁; ▁OneInputStream Operator TestHarness ▁< ▁IN ▁, ▁OUT ▁> ▁testHarness ▁= ▁new ▁OneInputStream Operator TestHarness ▁( ▁operator ▁) ▁; ▁testHarness ▁. ▁getStream Config ▁( ▁) ▁. ▁set Managed Memory Fraction Operator Of Use Case ▁( ▁Managed Memory Use Case ▁. ▁PY TH ON ▁, ▁0.5 ▁) ▁; ▁testHarness ▁. ▁setup ▁( ▁getOutputType Serializer ▁( ▁dataType ▁) ▁) ▁; ▁return ▁testHarness ▁; ▁} ▁public ▁abstract ▁AbstractP ython ScalarFunction Operator ▁getTest Operator ▁( ▁Configuration ▁config ▁, ▁Python Function Info ▁[ ▁] ▁scalar Functions ▁, ▁RowType ▁inputType ▁, ▁RowType ▁outputType ▁, ▁int ▁[ ▁] ▁udf Input Offsets ▁, ▁int ▁[ ▁] ▁for warded Fields ▁) ▁; ▁public ▁abstract ▁IN ▁new Row ▁( ▁boolean ▁accumulate Msg ▁, ▁Object ▁... ▁fields ▁) ▁; ▁public ▁abstract ▁void ▁assertOutput Equals ▁( ▁String ▁message ▁, ▁Collection ▁< ▁Object ▁> ▁expected ▁, ▁Collection ▁< ▁Object ▁> ▁actual ▁) ▁; ▁public ▁abstract ▁Stream Table Environment ▁createTable Environment ▁( ▁StreamExecution Environment ▁env ▁) ▁; ▁public ▁abstract ▁TypeSerializer ▁< ▁OUT ▁> ▁getOutputType Serializer ▁( ▁RowType ▁dataType ▁) ▁; ▁public ▁static ▁class ▁Dummy Python Function ▁implements ▁Python Function ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁public ▁static ▁final ▁Python Function ▁INSTANCE ▁= ▁new ▁Dummy Python Function ▁( ▁) ▁; ▁@ ▁Override ▁public ▁byte ▁[ ▁] ▁getSerialized Python Function ▁( ▁) ▁{ ▁return ▁new ▁byte ▁[ ▁0 ▁] ▁; ▁} ▁@ ▁Override ▁public ▁Python Env ▁getP ython Env ▁( ▁) ▁{ ▁return ▁new ▁Python Env ▁( ▁Python Env ▁. ▁Exec Type ▁. ▁PROCESS ▁) ▁; ▁} ▁} ▁}
▁Cache DataSource ▁cache DataSource ▁= ▁new ▁Cache DataSource ▁( ▁cache ▁, ▁upstream DataSource ▁, ▁new ▁File DataSource ▁( ▁) ▁, ▁data Sink ▁, ▁0 ▁, ▁null ▁) ▁; ▁Caching Counters ▁counters ▁= ▁new ▁Caching Counters ▁( ▁) ▁; ▁Cache Writer ▁cache Writer ▁= ▁new ▁Cache Writer ▁( ▁cache DataSource ▁, ▁new ▁DataSpec ▁( ▁Uri ▁. ▁parse ▁( ▁STR ▁) ▁) ▁, ▁null ▁, ▁counters ▁) ▁; ▁assertThrows ▁( ▁IOException ▁. ▁class ▁, ▁cache Writer ▁:: ▁cache ▁) ▁; ▁counters ▁. ▁assert Values ▁( ▁0 ▁, ▁100 ▁, ▁100 ▁) ▁; ▁fail On Close ▁. ▁set ▁( ▁false ▁) ▁; ▁cache Writer ▁. ▁cache ▁( ▁) ▁; ▁counters ▁. ▁assert Values ▁( ▁0 ▁, ▁100 ▁, ▁100 ▁) ▁; ▁assert Cached Data ▁( ▁cache ▁, ▁fake DataSet ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁cache Polling ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁Caching Counters ▁counters ▁= ▁new ▁Caching Counters ▁( ▁) ▁; ▁Fake DataSet ▁fake DataSet ▁= ▁new ▁Fake DataSet ▁( ▁) ▁. ▁new Data ▁( ▁STR ▁) ▁. ▁append Read Data ▁( ▁TestUtil ▁. ▁build TestData ▁( ▁100 ▁) ▁) ▁. ▁append Read Action ▁( ▁( ▁) ▁-> ▁counters ▁. ▁assert Values ▁( ▁0 ▁, ▁100 ▁, ▁300 ▁) ▁) ▁. ▁append Read Data ▁( ▁TestUtil ▁. ▁build TestData ▁( ▁100 ▁) ▁) ▁. ▁append Read Action ▁( ▁( ▁) ▁-> ▁counters ▁. ▁assert Values ▁( ▁0 ▁, ▁200 ▁, ▁300 ▁) ▁) ▁. ▁append Read Data ▁( ▁TestUtil ▁. ▁build TestData ▁( ▁100 ▁) ▁) ▁. ▁end Data ▁( ▁) ▁; ▁Fake DataSource ▁dataSource ▁= ▁new ▁Fake DataSource ▁( ▁fake DataSet ▁) ▁; ▁Cache Writer ▁cache Writer ▁= ▁new ▁Cache Writer ▁( ▁new ▁Cache DataSource ▁( ▁cache ▁, ▁dataSource ▁) ▁, ▁new ▁DataSpec ▁( ▁Uri ▁. ▁parse ▁( ▁STR ▁) ▁) ▁, ▁null ▁, ▁counters ▁) ▁; ▁cache Writer ▁. ▁cache ▁( ▁) ▁; ▁counters ▁. ▁assert Values ▁( ▁0 ▁, ▁300 ▁, ▁300 ▁) ▁; ▁assert Cached Data ▁( ▁cache ▁, ▁fake DataSet ▁) ▁; ▁} ▁private ▁static ▁final ▁class ▁Caching Counters ▁implements ▁Cache Writer ▁. ▁Progress Listener ▁{ ▁private ▁long ▁contentLength ▁= ▁C ▁. ▁LENGTH _ UNSET ▁; ▁private ▁long ▁bytes Already Cached ▁; ▁private ▁long ▁bytes New ly Cached ▁; ▁private ▁boolean ▁seen First Progress Update ▁; ▁@ ▁Override ▁public ▁void ▁on Progress ▁( ▁long ▁contentLength ▁, ▁long ▁bytes Cached ▁, ▁long ▁new Bytes Cached ▁) ▁{ ▁this ▁. ▁contentLength ▁= ▁contentLength ▁; ▁if ▁( ▁! ▁seen First Progress Update ▁) ▁{ ▁bytes Already Cached ▁= ▁bytes Cached ▁; ▁seen First Progress Update ▁= ▁true ▁; ▁} ▁bytes New ly Cached ▁= ▁bytes Cached ▁- ▁bytes Already Cached ▁; ▁} ▁public ▁void ▁assert Values ▁( ▁int ▁bytes Already Cached ▁, ▁int ▁bytes New ly Cached ▁, ▁int ▁contentLength ▁) ▁{ ▁assertThat ▁( ▁this ▁. ▁bytes Already Cached ▁) ▁. ▁isEqualTo ▁( ▁bytes Already Cached ▁) ▁; ▁assertThat ▁( ▁this ▁. ▁bytes New ly Cached ▁) ▁. ▁isEqualTo ▁( ▁bytes New ly Cached ▁) ▁; ▁assertThat ▁( ▁this ▁. ▁contentLength ▁) ▁. ▁isEqualTo ▁( ▁contentLength ▁) ▁; ▁}
▁public ▁class ▁Push Execute Task ▁extends ▁Abstract Execute Task ▁{ ▁private ▁final ▁Service ▁service ▁; ▁private ▁final ▁Push DelayTask ExecuteEngine ▁delay Task Engine ▁; ▁private ▁final ▁Push DelayTask ▁delay Task ▁; ▁public ▁Push Execute Task ▁( ▁Service ▁service ▁, ▁Push DelayTask ExecuteEngine ▁delay Task Engine ▁, ▁Push DelayTask ▁delay Task ▁) ▁{ ▁this ▁. ▁service ▁= ▁service ▁; ▁this ▁. ▁delay Task Engine ▁= ▁delay Task Engine ▁; ▁this ▁. ▁delay Task ▁= ▁delay Task ▁; ▁} ▁@ ▁Override ▁public ▁void ▁run ▁( ▁) ▁{ ▁try ▁{ ▁Push Data Wrapper ▁wrapper ▁= ▁generate Push Data ▁( ▁) ▁; ▁for ▁( ▁String ▁each ▁: ▁getTarget Client Ids ▁( ▁) ▁) ▁{ ▁Client ▁client ▁= ▁delay Task Engine ▁. ▁getClient Manager ▁( ▁) ▁. ▁getClient ▁( ▁each ▁) ▁; ▁if ▁( ▁null ▁== ▁client ▁) ▁{ ▁continue ▁; ▁} ▁Subscriber ▁subscriber ▁= ▁delay Task Engine ▁. ▁getClient Manager ▁( ▁) ▁. ▁getClient ▁( ▁each ▁) ▁. ▁getSub scriber ▁( ▁service ▁) ▁; ▁delay Task Engine ▁. ▁getP ush Executor ▁( ▁) ▁. ▁do Push With Callback ▁( ▁each ▁, ▁subscriber ▁, ▁wrapper ▁, ▁new ▁Naming Push Callback ▁( ▁each ▁, ▁subscriber ▁, ▁wrapper ▁. ▁getOriginal Data ▁( ▁) ▁, ▁delay Task ▁. ▁is Push To All ▁( ▁) ▁) ▁) ▁; ▁} ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁Loggers ▁. ▁P U SH ▁. ▁error ▁( ▁STR ▁+ ▁service ▁. ▁getGroup ed ServiceName ▁( ▁) ▁+ ▁STR ▁, ▁e ▁) ▁; ▁delay Task Engine ▁. ▁addTask ▁( ▁service ▁, ▁new ▁Push DelayTask ▁( ▁service ▁, ▁1000 L ▁) ▁) ▁; ▁} ▁} ▁private ▁Push Data Wrapper ▁generate Push Data ▁( ▁) ▁{ ▁ServiceInfo ▁service Info ▁= ▁delay Task Engine ▁. ▁getService Storage ▁( ▁) ▁. ▁getP ush Data ▁( ▁service ▁) ▁; ▁Service Metadata ▁service Metadata ▁= ▁delay Task Engine ▁. ▁getMetadata Manager ▁( ▁) ▁. ▁getService Metadata ▁( ▁service ▁) ▁. ▁orElse ▁( ▁null ▁) ▁; ▁service Info ▁= ▁Service Util ▁. ▁select Instance sWith Healthy Prote ction ▁( ▁service Info ▁, ▁service Metadata ▁, ▁false ▁, ▁true ▁) ▁; ▁return ▁new ▁Push Data Wrapper ▁( ▁service Info ▁) ▁; ▁} ▁private ▁Collection ▁< ▁String ▁> ▁getTarget Client Ids ▁( ▁) ▁{ ▁return ▁delay Task ▁. ▁is Push To All ▁( ▁) ▁? ▁delay Task Engine ▁. ▁getIndex es Manager ▁( ▁) ▁. ▁getAll Clients Subscribe Service ▁( ▁service ▁) ▁: ▁delay Task ▁. ▁getTarget Clients ▁( ▁) ▁; ▁} ▁private ▁class ▁Naming Push Callback ▁implements ▁Push CallBack ▁{ ▁private ▁final ▁String ▁clientId ▁; ▁private ▁final ▁Subscriber ▁subscriber ▁; ▁private ▁final ▁ServiceInfo ▁service Info ▁; ▁private ▁final ▁long ▁execute StartTime ▁; ▁private ▁final ▁boolean ▁is Push To All ▁; ▁private ▁Naming Push Callback ▁( ▁String ▁clientId ▁, ▁Subscriber ▁subscriber ▁, ▁ServiceInfo ▁service Info ▁, ▁boolean ▁is Push To All ▁) ▁{ ▁this ▁. ▁clientId ▁= ▁clientId ▁; ▁this ▁. ▁subscriber ▁= ▁subscriber ▁; ▁this ▁. ▁service Info ▁= ▁service Info ▁; ▁this ▁. ▁is Push To All ▁= ▁is Push To All ▁; ▁this ▁. ▁execute StartTime ▁= ▁System ▁. ▁current TimeMillis ▁( ▁) ▁; ▁}
▁public ▁class ▁Rest Set Upgrade Mode Action ▁extends ▁BaseRestHandler ▁{ ▁@ ▁Override ▁public ▁List ▁< ▁Route ▁> ▁routes ▁( ▁) ▁{ ▁return ▁List ▁. ▁of ▁( ▁new ▁Route ▁( ▁POST ▁, ▁BASE _ PATH ▁+ ▁STR ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁protected ▁RestChannel Consumer ▁prepareRequest ▁( ▁RestRequest ▁restRequest ▁, ▁NodeClient ▁client ▁) ▁throws ▁IOException ▁{ ▁Set Upgrade Mode Action ▁. ▁Request ▁request ▁= ▁new ▁Set Upgrade Mode Action ▁. ▁Request ▁( ▁restRequest ▁. ▁paramAsBoolean ▁( ▁STR ▁, ▁false ▁) ▁) ▁; ▁request ▁. ▁timeout ▁( ▁restRequest ▁. ▁paramAsTime ▁( ▁STR ▁, ▁request ▁. ▁timeout ▁( ▁) ▁) ▁) ▁; ▁request ▁. ▁masterNode Timeout ▁( ▁restRequest ▁. ▁paramAsTime ▁( ▁STR ▁, ▁request ▁. ▁masterNode Timeout ▁( ▁) ▁) ▁) ▁; ▁return ▁channel ▁-> ▁client ▁. ▁execute ▁( ▁Set Upgrade Mode Action ▁. ▁INSTANCE ▁, ▁request ▁, ▁new ▁RestToXContent Listener ▁< ▁> ▁( ▁channel ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁Range Aggregation Builder ▁extends ▁Abstract Range Builder ▁< ▁Range Aggregation Builder ▁, ▁Range ▁> ▁{ ▁public ▁static ▁final ▁String ▁NAME ▁= ▁STR ▁; ▁public ▁static ▁final ▁ValuesSource Registry ▁. ▁Registry Key ▁< ▁Range Aggregator Supplier ▁> ▁REGISTRY _ KEY ▁= ▁new ▁ValuesSource Registry ▁. ▁Registry Key ▁< ▁> ▁( ▁NAME ▁, ▁Range Aggregator Supplier ▁. ▁class ▁) ▁; ▁public ▁static ▁final ▁ObjectParser ▁< ▁Range Aggregation Builder ▁, ▁String ▁> ▁PARSER ▁= ▁ObjectParser ▁. ▁from Builder ▁( ▁NAME ▁, ▁Range Aggregation Builder ▁:: ▁new ▁) ▁; ▁static ▁{ ▁ValuesSource Aggregation Builder ▁. ▁declare Fields ▁( ▁PARSER ▁, ▁true ▁, ▁true ▁, ▁false ▁) ▁; ▁PARSER ▁. ▁declareBoolean ▁( ▁Range Aggregation Builder ▁:: ▁keyed ▁, ▁Range Aggregator ▁. ▁KEY ED _ FIELD ▁) ▁; ▁PARSER ▁. ▁declare ObjectArray ▁( ▁( ▁agg ▁, ▁ranges ▁) ▁-> ▁{ ▁for ▁( ▁Range ▁range ▁: ▁ranges ▁) ▁{ ▁agg ▁. ▁add Range ▁( ▁range ▁) ▁; ▁} ▁} ▁, ▁( ▁p ▁, ▁c ▁) ▁-> ▁Range Aggregator ▁. ▁Range ▁. ▁PARSER ▁. ▁parse ▁( ▁p ▁, ▁null ▁) ▁, ▁Range Aggregator ▁. ▁R ANG ES _ FIELD ▁) ▁; ▁} ▁public ▁static ▁void ▁register Aggregator s ▁( ▁ValuesSource Registry ▁. ▁Builder ▁builder ▁) ▁{ ▁builder ▁. ▁register ▁( ▁REGISTRY _ KEY ▁, ▁List ▁. ▁of ▁( ▁Core ValuesSourceType ▁. ▁NUMERIC ▁, ▁Core ValuesSourceType ▁. ▁DATE ▁, ▁Core ValuesSourceType ▁. ▁BOOLEAN ▁) ▁, ▁Range Aggregator ▁:: ▁build ▁, ▁true ▁) ▁; ▁} ▁public ▁Range Aggregation Builder ▁( ▁String ▁name ▁) ▁{ ▁super ▁( ▁name ▁, ▁Internal Range ▁. ▁FACTORY ▁) ▁; ▁} ▁public ▁Range Aggregation Builder ▁( ▁StreamInput ▁in ▁) ▁throws ▁IOException ▁{ ▁super ▁( ▁in ▁, ▁Internal Range ▁. ▁FACTORY ▁, ▁Range ▁:: ▁new ▁) ▁; ▁} ▁protected ▁Range Aggregation Builder ▁( ▁Range Aggregation Builder ▁clone ▁, ▁Aggregator Factories ▁. ▁Builder ▁factories Builder ▁, ▁Map ▁< ▁String ▁, ▁Object ▁> ▁metadata ▁) ▁{ ▁super ▁( ▁clone ▁, ▁factories Builder ▁, ▁metadata ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Aggregation Builder ▁sh allow Copy ▁( ▁Aggregator Factories ▁. ▁Builder ▁factories Builder ▁, ▁Map ▁< ▁String ▁, ▁Object ▁> ▁metadata ▁) ▁{ ▁return ▁new ▁Range Aggregation Builder ▁( ▁this ▁, ▁factories Builder ▁, ▁metadata ▁) ▁; ▁} ▁public ▁Range Aggregation Builder ▁add Range ▁( ▁String ▁key ▁, ▁double ▁from ▁, ▁double ▁to ▁) ▁{ ▁add Range ▁( ▁new ▁Range ▁( ▁key ▁, ▁from ▁, ▁to ▁) ▁) ▁; ▁return ▁this ▁; ▁} ▁public ▁Range Aggregation Builder ▁add Range ▁( ▁double ▁from ▁, ▁double ▁to ▁) ▁{ ▁return ▁add Range ▁( ▁null ▁, ▁from ▁, ▁to ▁) ▁; ▁} ▁public ▁Range Aggregation Builder ▁add Un bounded To ▁( ▁String ▁key ▁, ▁double ▁to ▁) ▁{ ▁add Range ▁( ▁new ▁Range ▁( ▁key ▁, ▁null ▁, ▁to ▁) ▁) ▁; ▁return ▁this ▁; ▁} ▁public ▁Range Aggregation Builder ▁add Un bounded To ▁( ▁double ▁to ▁) ▁{ ▁return ▁add Un bounded To ▁( ▁null ▁, ▁to ▁) ▁; ▁} ▁public ▁Range Aggregation Builder ▁add Un bounded From ▁( ▁String ▁key ▁, ▁double ▁from ▁) ▁{ ▁add Range ▁( ▁new ▁Range ▁( ▁key ▁, ▁from ▁, ▁null ▁) ▁) ▁;
▁Instrument Utils ▁. ▁findMethod ▁( ▁target ▁, ▁STR ▁, ▁STR ▁) ▁. ▁add Scoped Interceptor ▁( ▁executeUpdate Interceptor ▁, ▁M ARI AD B _ SCOPE ▁) ▁; ▁Instrument Utils ▁. ▁findMethod ▁( ▁target ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁. ▁add Scoped Interceptor ▁( ▁executeUpdate Interceptor ▁, ▁M ARI AD B _ SCOPE ▁) ▁; ▁Instrument Utils ▁. ▁findMethod ▁( ▁target ▁, ▁STR ▁, ▁STR ▁) ▁. ▁add Scoped Interceptor ▁( ▁executeUpdate Interceptor ▁, ▁M ARI AD B _ SCOPE ▁) ▁; ▁Instrument Utils ▁. ▁findMethod ▁( ▁target ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁. ▁add Scoped Interceptor ▁( ▁executeUpdate Interceptor ▁, ▁M ARI AD B _ SCOPE ▁) ▁; ▁return ▁target ▁. ▁to Bytecode ▁( ▁) ▁; ▁} ▁} ▁; ▁private ▁void ▁add Callable Statement Transformer ▁( ▁) ▁{ ▁transform Template ▁. ▁transform ▁( ▁STR ▁, ▁Callable Statement Transformer ▁. ▁class ▁) ▁; ▁transform Template ▁. ▁transform ▁( ▁STR ▁, ▁Callable Statement Transformer ▁. ▁class ▁) ▁; ▁transform Template ▁. ▁transform ▁( ▁STR ▁, ▁Callable Statement Transformer ▁. ▁class ▁) ▁; ▁transform Template ▁. ▁transform ▁( ▁STR ▁, ▁Callable Statement Transformer ▁. ▁class ▁) ▁; ▁} ▁public ▁static ▁class ▁Callable Statement Transformer ▁implements ▁Transform Callback ▁{ ▁@ ▁Override ▁public ▁byte ▁[ ▁] ▁doIn Transform ▁( ▁Instrument or ▁instrument or ▁, ▁ClassLoader ▁loader ▁, ▁String ▁className ▁, ▁Class ▁< ▁? ▁> ▁class Be ing Re defined ▁, ▁Pro tectionDomain ▁prote ctionDomain ▁, ▁byte ▁[ ▁] ▁classfile Buffer ▁) ▁throws ▁Instrument Exception ▁{ ▁Instrument Class ▁target ▁= ▁instrument or ▁. ▁getInstrument Class ▁( ▁loader ▁, ▁className ▁, ▁classfile Buffer ▁) ▁; ▁target ▁. ▁addField ▁( ▁DatabaseInfo Accessor ▁. ▁class ▁) ▁; ▁target ▁. ▁addField ▁( ▁Parsing Result Accessor ▁. ▁class ▁) ▁; ▁target ▁. ▁addField ▁( ▁Bind Value Accessor ▁. ▁class ▁) ▁; ▁final ▁Class ▁< ▁? ▁extends ▁Interceptor ▁> ▁register Out Parameter Interceptor ▁= ▁Callable Statement Register Out Parameter Interceptor ▁. ▁class ▁; ▁Instrument Utils ▁. ▁findMethod ▁( ▁target ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁. ▁add Scoped Interceptor ▁( ▁register Out Parameter Interceptor ▁, ▁M ARI AD B _ SCOPE ▁) ▁; ▁Instrument Utils ▁. ▁findMethod ▁( ▁target ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁. ▁add Scoped Interceptor ▁( ▁register Out Parameter Interceptor ▁, ▁M ARI AD B _ SCOPE ▁) ▁; ▁Instrument Utils ▁. ▁findMethod ▁( ▁target ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁. ▁add Scoped Interceptor ▁( ▁register Out Parameter Interceptor ▁, ▁M ARI AD B _ SCOPE ▁) ▁; ▁return ▁target ▁. ▁to Bytecode ▁( ▁) ▁; ▁} ▁} ▁; ▁private ▁void ▁add _1 _3_ x _ Callable Statement Transformer ▁( ▁) ▁{ ▁transform Template ▁. ▁transform ▁( ▁STR ▁, ▁Callable Statement 1 _3_ x _ Transform ▁. ▁class ▁) ▁; ▁}
▁Split Block Dialog ▁d ▁= ▁waitFor Dialog Component ▁( ▁Split Block Dialog ▁. ▁class ▁) ▁; ▁Address Input ▁block One End ▁= ▁( ▁Address Input ▁) ▁find Component ByName ▁( ▁d ▁. ▁getComponent ▁( ▁) ▁, ▁STR ▁) ▁; ▁Register Field ▁block One Length ▁= ▁( ▁Register Field ▁) ▁find Component ByName ▁( ▁d ▁. ▁getComponent ▁( ▁) ▁, ▁STR ▁) ▁; ▁Address Input ▁block Two Start ▁= ▁( ▁Address Input ▁) ▁find Component ByName ▁( ▁d ▁. ▁getComponent ▁( ▁) ▁, ▁STR ▁) ▁; ▁JTextField ▁block Two End ▁= ▁( ▁JTextField ▁) ▁find Component ByName ▁( ▁d ▁. ▁getComponent ▁( ▁) ▁, ▁STR ▁) ▁; ▁Register Field ▁block Two Length ▁= ▁( ▁Register Field ▁) ▁find Component ByName ▁( ▁d ▁. ▁getComponent ▁( ▁) ▁, ▁STR ▁) ▁; ▁JButton ▁ok Button ▁= ▁find Button ▁( ▁d ▁. ▁getComponent ▁( ▁) ▁, ▁STR ▁) ▁; ▁runSwing ▁( ▁( ▁) ▁-> ▁block Two Start ▁. ▁setValue ▁( ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁0 x 2000 ▁, ▁block One Length ▁. ▁getValue ▁( ▁) ▁. ▁longValue ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁get Addr ▁( ▁0 x 01 00 2 fff ▁) ▁, ▁block One End ▁. ▁getAddress ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁block Two End ▁. ▁getText ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁0 x 46 00 ▁, ▁block Two Length ▁. ▁getValue ▁( ▁) ▁. ▁longValue ▁( ▁) ▁) ▁; ▁assertTrue ▁( ▁ok Button ▁. ▁isEnabled ▁( ▁) ▁) ▁; ▁runSwing ▁( ▁( ▁) ▁-> ▁ok Button ▁. ▁getAction Listeners ▁( ▁) ▁[ ▁0 ▁] ▁. ▁actionPerformed ▁( ▁null ▁) ▁) ▁; ▁program ▁. ▁flush Events ▁( ▁) ▁; ▁waitForSwing ▁( ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁model ▁. ▁getValue At ▁( ▁0 ▁, ▁Memory Map Model ▁. ▁START ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁model ▁. ▁getValue At ▁( ▁0 ▁, ▁Memory Map Model ▁. ▁END ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁model ▁. ▁getValue At ▁( ▁0 ▁, ▁Memory Map Model ▁. ▁LENGTH ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁model ▁. ▁getValue At ▁( ▁1 ▁, ▁Memory Map Model ▁. ▁NAME ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁model ▁. ▁getValue At ▁( ▁1 ▁, ▁Memory Map Model ▁. ▁START ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁model ▁. ▁getValue At ▁( ▁1 ▁, ▁Memory Map Model ▁. ▁END ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁model ▁. ▁getValue At ▁( ▁1 ▁, ▁Memory Map Model ▁. ▁LENGTH ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Split Block New Length ▁( ▁) ▁throws ▁Exception ▁{ ▁table ▁. ▁set Row Selection Interval ▁( ▁0 ▁, ▁0 ▁) ▁; ▁DockingActionIf ▁action ▁= ▁getAction ▁( ▁plugin ▁, ▁STR ▁) ▁; ▁performAction ▁( ▁action ▁, ▁false ▁) ▁; ▁Split Block Dialog ▁d ▁= ▁waitFor Dialog Component ▁( ▁Split Block Dialog ▁. ▁class ▁) ▁; ▁Address Input ▁block One End ▁= ▁( ▁Address Input ▁) ▁find Component ByName ▁( ▁d ▁. ▁getComponent ▁( ▁) ▁, ▁STR ▁) ▁;
▁public ▁class ▁Le v eld b Timeline StateStore ▁extends ▁Timeline StateStore ▁{ ▁public ▁static ▁final ▁Logger ▁LOG ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Le v eld b Timeline StateStore ▁. ▁class ▁) ▁; ▁private ▁static ▁final ▁String ▁DB _ NAME ▁= ▁STR ▁; ▁private ▁static ▁final ▁FsPermission ▁LE VEL DB _ DIR _ UM ASK ▁= ▁FsPermission ▁. ▁create Immutable ▁( ▁( ▁short ▁) ▁0 7 00 ▁) ▁; ▁private ▁static ▁final ▁byte ▁[ ▁] ▁TOKEN _ ENTRY _ PREFIX ▁= ▁bytes ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁byte ▁[ ▁] ▁TOKEN _ M ASTER _ KEY _ ENTRY _ PREFIX ▁= ▁bytes ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁byte ▁[ ▁] ▁L ATE ST _ SE QUENCE _ NUMBER _ KEY ▁= ▁bytes ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁Version ▁CURRENT _ VERSION _ INFO ▁= ▁Version ▁. ▁newInstance ▁( ▁1 ▁, ▁0 ▁) ▁; ▁private ▁static ▁final ▁byte ▁[ ▁] ▁TIME LINE _ STATE _ STORE _ VERSION _ KEY ▁= ▁bytes ▁( ▁STR ▁) ▁; ▁private ▁DB ▁db ▁; ▁public ▁Le v eld b Timeline StateStore ▁( ▁) ▁{ ▁super ▁( ▁Le v eld b Timeline StateStore ▁. ▁class ▁. ▁getName ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁init Storage ▁( ▁Configuration ▁conf ▁) ▁throws ▁IOException ▁{ ▁} ▁@ ▁Override ▁protected ▁void ▁start Storage ▁( ▁) ▁throws ▁IOException ▁{ ▁Options ▁options ▁= ▁new ▁Options ▁( ▁) ▁; ▁Path ▁db Path ▁= ▁new ▁Path ▁( ▁getConfig ▁( ▁) ▁. ▁get ▁( ▁Yarn Configuration ▁. ▁TIME LINE _ SERVICE _ LEVEL DB _ STATE _ STORE _ PATH ▁) ▁, ▁DB _ NAME ▁) ▁; ▁FileSystem ▁local FS ▁= ▁null ▁; ▁try ▁{ ▁local FS ▁= ▁FileSystem ▁. ▁getLocal ▁( ▁getConfig ▁( ▁) ▁) ▁; ▁if ▁( ▁! ▁local FS ▁. ▁exists ▁( ▁db Path ▁) ▁) ▁{ ▁if ▁( ▁! ▁local FS ▁. ▁mkdirs ▁( ▁db Path ▁) ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁STR ▁+ ▁STR ▁+ ▁db Path ▁) ▁; ▁} ▁local FS ▁. ▁set Permission ▁( ▁db Path ▁, ▁LE VEL DB _ DIR _ UM ASK ▁) ▁; ▁} ▁} ▁finally ▁{ ▁IOUtils ▁. ▁cleanup With Logger ▁( ▁LOG ▁, ▁local FS ▁) ▁; ▁} ▁J ni DB Factory ▁factory ▁= ▁new ▁J ni DB Factory ▁( ▁) ▁; ▁try ▁{ ▁options ▁. ▁create IfMissing ▁( ▁false ▁) ▁; ▁db ▁= ▁factory ▁. ▁open ▁( ▁new ▁File ▁( ▁db Path ▁. ▁toString ▁( ▁) ▁) ▁, ▁options ▁) ▁; ▁LOG ▁. ▁info ▁( ▁STR ▁+ ▁db Path ▁. ▁toString ▁( ▁) ▁) ▁; ▁check Version ▁( ▁) ▁; ▁} ▁catch ▁( ▁Native DB ▁. ▁DBException ▁e ▁) ▁{ ▁if ▁( ▁e ▁. ▁isNot Found ▁( ▁) ▁|| ▁e ▁. ▁getMessage ▁( ▁) ▁. ▁contains ▁( ▁STR ▁) ▁) ▁{ ▁try ▁{ ▁options ▁. ▁create IfMissing ▁( ▁true ▁) ▁; ▁db ▁= ▁factory ▁. ▁open ▁( ▁new ▁File ▁( ▁db Path ▁. ▁toString ▁( ▁) ▁) ▁, ▁options ▁) ▁; ▁LOG ▁. ▁info ▁( ▁STR ▁+ ▁db Path ▁. ▁toString ▁( ▁) ▁) ▁;
▁@ ▁NotNull ▁public ▁static ▁Json Writer ▁field ▁( ▁@ ▁NotNull ▁Json Writer ▁json ▁, ▁@ ▁NotNull ▁String ▁name ▁, ▁@ ▁Nullable ▁String ▁value ▁) ▁throws ▁IOException ▁{ ▁json ▁. ▁name ▁( ▁name ▁) ▁; ▁if ▁( ▁value ▁== ▁null ▁) ▁json ▁. ▁nullValue ▁( ▁) ▁; ▁else ▁json ▁. ▁value ▁( ▁value ▁) ▁; ▁return ▁json ▁; ▁} ▁@ ▁NotNull ▁public ▁static ▁Json Writer ▁field ▁( ▁@ ▁NotNull ▁Json Writer ▁json ▁, ▁@ ▁NotNull ▁String ▁name ▁, ▁@ ▁Nullable ▁Number ▁value ▁) ▁throws ▁IOException ▁{ ▁json ▁. ▁name ▁( ▁name ▁) ▁; ▁if ▁( ▁value ▁== ▁null ▁) ▁json ▁. ▁nullValue ▁( ▁) ▁; ▁else ▁json ▁. ▁value ▁( ▁value ▁) ▁; ▁return ▁json ▁; ▁} ▁@ ▁NotNull ▁public ▁static ▁Json Writer ▁field NE ▁( ▁@ ▁NotNull ▁Json Writer ▁json ▁, ▁@ ▁NotNull ▁String ▁name ▁, ▁@ ▁Nullable ▁String ▁value ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁CommonUtils ▁. ▁isEmpty ▁( ▁value ▁) ▁) ▁{ ▁return ▁json ▁; ▁} ▁json ▁. ▁name ▁( ▁name ▁) ▁; ▁json ▁. ▁value ▁( ▁value ▁) ▁; ▁return ▁json ▁; ▁} ▁@ ▁NotNull ▁public ▁static ▁Json Writer ▁field ▁( ▁@ ▁NotNull ▁Json Writer ▁json ▁, ▁@ ▁NotNull ▁String ▁name ▁, ▁long ▁value ▁) ▁throws ▁IOException ▁{ ▁json ▁. ▁name ▁( ▁name ▁) ▁; ▁json ▁. ▁value ▁( ▁value ▁) ▁; ▁return ▁json ▁; ▁} ▁@ ▁NotNull ▁public ▁static ▁Json Writer ▁field ▁( ▁@ ▁NotNull ▁Json Writer ▁json ▁, ▁@ ▁NotNull ▁String ▁name ▁, ▁double ▁value ▁) ▁throws ▁IOException ▁{ ▁json ▁. ▁name ▁( ▁name ▁) ▁; ▁json ▁. ▁value ▁( ▁value ▁) ▁; ▁return ▁json ▁; ▁} ▁@ ▁NotNull ▁public ▁static ▁Json Writer ▁field ▁( ▁@ ▁NotNull ▁Json Writer ▁json ▁, ▁@ ▁NotNull ▁String ▁name ▁, ▁boolean ▁value ▁) ▁throws ▁IOException ▁{ ▁json ▁. ▁name ▁( ▁name ▁) ▁; ▁json ▁. ▁value ▁( ▁value ▁) ▁; ▁return ▁json ▁; ▁} ▁public ▁static ▁void ▁serialize String List ▁( ▁@ ▁NotNull ▁Json Writer ▁json ▁, ▁@ ▁NotNull ▁String ▁tag Name ▁, ▁@ ▁Nullable ▁Collection ▁< ▁String ▁> ▁list ▁) ▁throws ▁IOException ▁{ ▁serialize String List ▁( ▁json ▁, ▁tag Name ▁, ▁list ▁, ▁false ▁) ▁; ▁} ▁public ▁static ▁void ▁serialize String List ▁( ▁@ ▁NotNull ▁Json Writer ▁json ▁, ▁@ ▁NotNull ▁String ▁tag Name ▁, ▁@ ▁Nullable ▁Collection ▁< ▁String ▁> ▁list ▁, ▁boolean ▁force ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁force ▁|| ▁! ▁CommonUtils ▁. ▁isEmpty ▁( ▁list ▁) ▁) ▁{ ▁json ▁. ▁name ▁( ▁tag Name ▁) ▁; ▁json ▁. ▁begin Array ▁( ▁) ▁; ▁for ▁( ▁String ▁include ▁: ▁CommonUtils ▁. ▁safe Collection ▁( ▁list ▁) ▁) ▁{ ▁json ▁. ▁value ▁( ▁include ▁) ▁; ▁} ▁json ▁. ▁endArray ▁( ▁) ▁; ▁} ▁} ▁public ▁static ▁void ▁serialize Object List ▁( ▁@ ▁NotNull ▁Json Writer ▁json ▁, ▁@ ▁NotNull ▁String ▁tag Name ▁, ▁@ ▁Nullable ▁Collection ▁< ▁? ▁> ▁list ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁! ▁CommonUtils ▁. ▁isEmpty ▁( ▁list ▁) ▁) ▁{ ▁json ▁. ▁name ▁( ▁tag Name ▁) ▁; ▁serialize Collection ▁( ▁json ▁, ▁list ▁) ▁; ▁} ▁}
▁public ▁class ▁Join Hash Supplier ▁implements ▁Lookup Source Supplier ▁{ ▁private ▁final ▁Session ▁session ▁; ▁private ▁final ▁Pages Hash ▁pages Hash ▁; ▁private ▁final ▁Adapt ive Long BigArray ▁addresses ▁; ▁private ▁final ▁List ▁< ▁Page ▁> ▁pages ▁; ▁private ▁final ▁Optional ▁< ▁Position Links ▁. ▁Factory ▁> ▁position Links ▁; ▁private ▁final ▁Optional ▁< ▁Join Filter Function Factory ▁> ▁filter Function Factory ▁; ▁private ▁final ▁List ▁< ▁Join Filter Function Factory ▁> ▁search Function Factories ▁; ▁public ▁Join Hash Supplier ▁( ▁Session ▁session ▁, ▁Pages Hash Strategy ▁pages Hash Strategy ▁, ▁Adapt ive Long BigArray ▁addresses ▁, ▁int ▁positionCount ▁, ▁List ▁< ▁List ▁< ▁Block ▁> ▁> ▁channels ▁, ▁Optional ▁< ▁Join Filter Function Factory ▁> ▁filter Function Factory ▁, ▁Optional ▁< ▁Integer ▁> ▁sort Channel ▁, ▁List ▁< ▁Join Filter Function Factory ▁> ▁search Function Factories ▁) ▁{ ▁this ▁. ▁session ▁= ▁requireNonNull ▁( ▁session ▁, ▁STR ▁) ▁; ▁this ▁. ▁addresses ▁= ▁requireNonNull ▁( ▁addresses ▁, ▁STR ▁) ▁; ▁this ▁. ▁filter Function Factory ▁= ▁requireNonNull ▁( ▁filter Function Factory ▁, ▁STR ▁) ▁; ▁this ▁. ▁search Function Factories ▁= ▁ImmutableList ▁. ▁copyOf ▁( ▁search Function Factories ▁) ▁; ▁requireNonNull ▁( ▁channels ▁, ▁STR ▁) ▁; ▁requireNonNull ▁( ▁pages Hash Strategy ▁, ▁STR ▁) ▁; ▁Position Links ▁. ▁Factory Builder ▁position Links FactoryBuilder ▁; ▁if ▁( ▁sort Channel ▁. ▁isPresent ▁( ▁) ▁&& ▁isF ast In equal ity Join ▁( ▁session ▁) ▁) ▁{ ▁checkArgument ▁( ▁filter Function Factory ▁. ▁isPresent ▁( ▁) ▁, ▁STR ▁) ▁; ▁position Links FactoryBuilder ▁= ▁Sorted Position Links ▁. ▁builder ▁( ▁positionCount ▁, ▁pages Hash Strategy ▁, ▁addresses ▁) ▁; ▁} ▁else ▁{ ▁position Links FactoryBuilder ▁= ▁Array Position Links ▁. ▁builder ▁( ▁positionCount ▁) ▁; ▁} ▁this ▁. ▁pages ▁= ▁channel sTo Pages ▁( ▁channels ▁) ▁; ▁this ▁. ▁pages Hash ▁= ▁new ▁Pages Hash ▁( ▁addresses ▁, ▁positionCount ▁, ▁pages Hash Strategy ▁, ▁position Links FactoryBuilder ▁) ▁; ▁this ▁. ▁position Links ▁= ▁position Links FactoryBuilder ▁. ▁isEmpty ▁( ▁) ▁? ▁Optional ▁. ▁empty ▁( ▁) ▁: ▁Optional ▁. ▁of ▁( ▁position Links FactoryBuilder ▁. ▁build ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁long ▁getHash Coll isions ▁( ▁) ▁{ ▁return ▁pages Hash ▁. ▁getHash Coll isions ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁double ▁getExpected Hash Coll isions ▁( ▁) ▁{ ▁return ▁pages Hash ▁. ▁getExpected Hash Coll isions ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁long ▁checksum ▁( ▁) ▁{ ▁return ▁position Links ▁. ▁map ▁( ▁Position Links ▁. ▁Factory ▁:: ▁checksum ▁) ▁. ▁orElse ▁( ▁0 L ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Join Hash ▁get ▁( ▁) ▁{ ▁Optional ▁< ▁Join Filter Function ▁> ▁filter Function ▁= ▁filter Function Factory ▁. ▁map ▁( ▁factory ▁-> ▁factory ▁. ▁create ▁( ▁session ▁. ▁getSql Function Properties ▁( ▁) ▁, ▁addresses ▁, ▁pages ▁) ▁) ▁;
▁) ▁static ▁class ▁J axb ObjectMapper Customizer ▁{ ▁@ ▁Autowired ▁void ▁add J axb Annotation Int ros pector ▁( ▁ObjectMapper ▁objectMapper ▁) ▁{ ▁J axb Annotation Int ros pector ▁j axb Annotation Int ros pector ▁= ▁new ▁J axb Annotation Int ros pector ▁( ▁objectMapper ▁. ▁getType Factory ▁( ▁) ▁) ▁; ▁objectMapper ▁. ▁set Annotation Int ros pect ors ▁( ▁create Pair ▁( ▁objectMapper ▁. ▁get Serialization Config ▁( ▁) ▁, ▁j axb Annotation Int ros pector ▁) ▁, ▁create Pair ▁( ▁objectMapper ▁. ▁get Deserialization Config ▁( ▁) ▁, ▁j axb Annotation Int ros pector ▁) ▁) ▁; ▁} ▁private ▁Annotation Int ros pector ▁create Pair ▁( ▁Mapper Config ▁< ▁? ▁> ▁config ▁, ▁J axb Annotation Int ros pector ▁j axb Annotation Int ros pector ▁) ▁{ ▁return ▁Annotation Int ros pector ▁. ▁pair ▁( ▁config ▁. ▁getAnnotation Int ros pector ▁( ▁) ▁, ▁j axb Annotation Int ros pector ▁) ▁; ▁} ▁} ▁private ▁static ▁final ▁class ▁ObjectMapper Context Resolver ▁implements ▁Context Resolver ▁< ▁ObjectMapper ▁> ▁{ ▁private ▁final ▁ObjectMapper ▁objectMapper ▁; ▁private ▁ObjectMapper Context Resolver ▁( ▁ObjectMapper ▁objectMapper ▁) ▁{ ▁this ▁. ▁objectMapper ▁= ▁objectMapper ▁; ▁} ▁@ ▁Override ▁public ▁ObjectMapper ▁getContext ▁( ▁Class ▁< ▁? ▁> ▁type ▁) ▁{ ▁return ▁this ▁. ▁objectMapper ▁; ▁} ▁} ▁} ▁}
▁public ▁Set ▁< ▁String ▁> ▁getEx clusion List ▁( ▁) ▁{ ▁return ▁ex clusion List ▁; ▁} ▁public ▁void ▁set Exclusion List ▁( ▁Set ▁< ▁String ▁> ▁excluded Nodes ▁) ▁{ ▁this ▁. ▁ex clusion List ▁. ▁addAll ▁( ▁excluded Nodes ▁) ▁; ▁} ▁public ▁float ▁get Threshold ▁( ▁) ▁{ ▁return ▁threshold ▁; ▁} ▁public ▁void ▁set Threshold ▁( ▁float ▁threshold Percent ▁) ▁{ ▁Preconditions ▁. ▁checkState ▁( ▁( ▁threshold Percent ▁>= ▁0.0 f ▁) ▁&& ▁( ▁threshold Percent ▁<= ▁100.0 f ▁) ▁, ▁STR ▁) ▁; ▁this ▁. ▁threshold ▁= ▁threshold Percent ▁; ▁} ▁public ▁Set ▁< ▁String ▁> ▁getIn clusion List ▁( ▁) ▁{ ▁return ▁in clusion List ▁; ▁} ▁public ▁void ▁setIn clusion List ▁( ▁Set ▁< ▁String ▁> ▁include Nodes ▁) ▁{ ▁this ▁. ▁in clusion List ▁. ▁addAll ▁( ▁include Nodes ▁) ▁; ▁} ▁public ▁String ▁toJson ▁( ▁) ▁throws ▁IOException ▁{ ▁return ▁Json Util ▁. ▁toJson String ▁( ▁this ▁) ▁; ▁} ▁@ ▁JsonIgnore ▁public ▁List ▁< ▁Disk Balancer DataNode ▁> ▁getNodes To Process ▁( ▁) ▁{ ▁return ▁node sTo Process ▁; ▁} ▁@ ▁JsonIgnore ▁public ▁void ▁set Nodes To Process ▁( ▁List ▁< ▁Disk Balancer DataNode ▁> ▁dn Nodes To Process ▁) ▁{ ▁this ▁. ▁node sTo Process ▁= ▁dn Nodes To Process ▁; ▁} ▁public ▁String ▁getOutput ▁( ▁) ▁{ ▁return ▁output path ▁; ▁} ▁public ▁void ▁setOutput ▁( ▁String ▁output ▁) ▁{ ▁this ▁. ▁output path ▁= ▁output ▁; ▁} ▁public ▁void ▁create Snapshot ▁( ▁String ▁snap Shot Name ▁) ▁throws ▁IOException ▁{ ▁String ▁json ▁= ▁this ▁. ▁toJson ▁( ▁) ▁; ▁File ▁out File ▁= ▁new ▁File ▁( ▁getOutput ▁( ▁) ▁+ ▁STR ▁+ ▁snap Shot Name ▁) ▁; ▁FileUtils ▁. ▁writeString ToFile ▁( ▁out File ▁, ▁json ▁, ▁Standard Charsets ▁. ▁UTF _8 ▁) ▁; ▁} ▁public ▁List ▁< ▁Node Plan ▁> ▁compute Plan ▁( ▁double ▁threshold Percent ▁) ▁{ ▁List ▁< ▁Node Plan ▁> ▁plan List ▁= ▁new ▁LinkedList ▁< ▁> ▁( ▁) ▁; ▁if ▁( ▁node sTo Process ▁== ▁null ▁) ▁{ ▁LOG ▁. ▁warn ▁( ▁STR ▁) ▁; ▁return ▁plan List ▁; ▁} ▁int ▁pool Size ▁= ▁compute PoolSize ▁( ▁node sTo Process ▁. ▁size ▁( ▁) ▁) ▁; ▁ExecutorService ▁executorService ▁= ▁Executors ▁. ▁newFixed ThreadPool ▁( ▁pool Size ▁) ▁; ▁List ▁< ▁Future ▁< ▁Node Plan ▁> ▁> ▁future List ▁= ▁new ▁LinkedList ▁< ▁> ▁( ▁) ▁; ▁for ▁( ▁int ▁x ▁= ▁0 ▁; ▁x ▁< ▁node sTo Process ▁. ▁size ▁( ▁) ▁; ▁x ▁++ ▁) ▁{ ▁final ▁Disk Balancer DataNode ▁node ▁= ▁node sTo Process ▁. ▁get ▁( ▁x ▁) ▁; ▁final ▁Planner ▁planner ▁= ▁Planner Factory ▁. ▁getP lanner ▁( ▁Planner Factory ▁. ▁GRE ED Y _ P L ANN ER ▁, ▁node ▁, ▁threshold Percent ▁) ▁; ▁future List ▁. ▁add ▁( ▁executorService ▁. ▁submit ▁( ▁new ▁Callable ▁< ▁Node Plan ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Node Plan ▁call ▁( ▁) ▁throws ▁Exception ▁{ ▁assert ▁planner ▁!= ▁null ▁; ▁return ▁planner ▁. ▁plan ▁( ▁node ▁) ▁; ▁} ▁} ▁) ▁) ▁; ▁}
▁final ▁LogicalType ▁[ ▁] ▁acc Types ▁= ▁Arrays ▁. ▁stream ▁( ▁agg InfoList ▁. ▁getA cc Types ▁( ▁) ▁) ▁. ▁map ▁( ▁LogicalType DataType Converter ▁:: ▁from DataType To Log icalType ▁) ▁. ▁toArray ▁( ▁LogicalType ▁[ ▁] ▁:: ▁new ▁) ▁; ▁final ▁int ▁input Count Index ▁= ▁agg InfoList ▁. ▁getIndex Of Count St ar ▁( ▁) ▁; ▁final ▁Group Table AggFunction ▁agg Function ▁= ▁new ▁Group Table AggFunction ▁( ▁aggs Handler ▁, ▁acc Types ▁, ▁input Count Index ▁, ▁generate Update Before ▁, ▁table Config ▁. ▁getId le State Retention ▁( ▁) ▁. ▁toMillis ▁( ▁) ▁) ▁; ▁final ▁OneInputStream Operator ▁< ▁RowData ▁, ▁RowData ▁> ▁operator ▁= ▁new ▁Keyed Process Operator ▁< ▁> ▁( ▁agg Function ▁) ▁; ▁final ▁One Input Transformation ▁< ▁RowData ▁, ▁RowData ▁> ▁transform ▁= ▁new ▁One Input Transformation ▁< ▁> ▁( ▁input Transform ▁, ▁STR ▁, ▁operator ▁, ▁Internal TypeInfo ▁. ▁of ▁( ▁getOutputType ▁( ▁) ▁) ▁, ▁input Transform ▁. ▁getParallelism ▁( ▁) ▁) ▁; ▁final ▁RowData KeySelector ▁selector ▁= ▁KeySelector Util ▁. ▁getRow Data Selector ▁( ▁grouping ▁, ▁Internal TypeInfo ▁. ▁of ▁( ▁input RowType ▁) ▁) ▁; ▁transform ▁. ▁setState KeySelector ▁( ▁selector ▁) ▁; ▁transform ▁. ▁setState Key Type ▁( ▁selector ▁. ▁getProduced Type ▁( ▁) ▁) ▁; ▁return ▁transform ▁; ▁} ▁}
▁writeString Field If NotNull ▁( ▁json ▁, ▁FILE ▁, ▁step ▁. ▁getFile ▁( ▁) ▁) ▁; ▁writeNumber Field If Defined ▁( ▁json ▁, ▁SI Z E ▁, ▁step ▁. ▁getSize ▁( ▁) ▁) ▁; ▁json ▁. ▁writeNumber Field ▁( ▁TOTAL ▁, ▁view ▁. ▁getTotal ▁( ▁phase ▁, ▁step ▁) ▁) ▁; ▁json ▁. ▁writeNumber Field ▁( ▁PER CENT _ COMP LETE ▁, ▁view ▁. ▁getPer cent Complete ▁( ▁phase ▁, ▁step ▁) ▁) ▁; ▁json ▁. ▁writeNumber Field ▁( ▁EL AP SED _ TIME ▁, ▁view ▁. ▁get ElapsedTime ▁( ▁phase ▁, ▁step ▁) ▁) ▁; ▁json ▁. ▁writeEndObject ▁( ▁) ▁; ▁} ▁json ▁. ▁writeEnd Array ▁( ▁) ▁; ▁json ▁. ▁writeEndObject ▁( ▁) ▁; ▁} ▁json ▁. ▁writeEnd Array ▁( ▁) ▁; ▁json ▁. ▁writeEndObject ▁( ▁) ▁; ▁} ▁finally ▁{ ▁IOUtils ▁. ▁cleanup With Logger ▁( ▁LOG ▁, ▁json ▁) ▁; ▁} ▁} ▁private ▁static ▁void ▁writeNumber Field If Defined ▁( ▁JsonGenerator ▁json ▁, ▁String ▁key ▁, ▁long ▁value ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁value ▁!= ▁Long ▁. ▁MIN _ VALUE ▁) ▁{ ▁json ▁. ▁writeNumber Field ▁( ▁key ▁, ▁value ▁) ▁; ▁} ▁} ▁private ▁static ▁void ▁writeString Field If NotNull ▁( ▁JsonGenerator ▁json ▁, ▁String ▁key ▁, ▁String ▁value ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁value ▁!= ▁null ▁) ▁{ ▁json ▁. ▁writeString Field ▁( ▁key ▁, ▁value ▁) ▁; ▁} ▁} ▁}
▁final ▁Byte Range ▁range ▁; ▁{ ▁final ▁long ▁start ▁= ▁randomLong Between ▁( ▁0 L ▁, ▁Math ▁. ▁max ▁( ▁0 L ▁, ▁file Contents ▁. ▁length ▁- ▁1 ▁) ▁) ▁; ▁range ▁= ▁Byte Range ▁. ▁of ▁( ▁start ▁, ▁randomLong Between ▁( ▁start ▁, ▁file Contents ▁. ▁length ▁) ▁) ▁; ▁} ▁final ▁Byte Range ▁sub Range ▁; ▁{ ▁if ▁( ▁range ▁. ▁length ▁( ▁) ▁> ▁1 L ▁) ▁{ ▁final ▁long ▁start ▁= ▁randomLong Between ▁( ▁range ▁. ▁start ▁( ▁) ▁, ▁range ▁. ▁end ▁( ▁) ▁- ▁1 L ▁) ▁; ▁sub Range ▁= ▁Byte Range ▁. ▁of ▁( ▁start ▁, ▁randomLong Between ▁( ▁start ▁+ ▁1 L ▁, ▁range ▁. ▁end ▁( ▁) ▁) ▁) ▁; ▁} ▁else ▁{ ▁sub Range ▁= ▁Byte Range ▁. ▁of ▁( ▁range ▁. ▁start ▁( ▁) ▁, ▁range ▁. ▁end ▁( ▁) ▁) ▁; ▁} ▁} ▁boolean ▁pending ▁= ▁false ▁; ▁for ▁( ▁long ▁i ▁= ▁sub Range ▁. ▁start ▁( ▁) ▁; ▁i ▁< ▁sub Range ▁. ▁end ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁file Contents ▁[ ▁toInt Bytes ▁( ▁i ▁) ▁] ▁== ▁UN AVAILABLE ▁) ▁{ ▁pending ▁= ▁true ▁; ▁} ▁} ▁if ▁( ▁pending ▁== ▁false ▁) ▁{ ▁final ▁AtomicBoolean ▁was Not ified ▁= ▁new ▁AtomicBoolean ▁( ▁) ▁; ▁final ▁ActionListener ▁< ▁Void ▁> ▁listener ▁= ▁ActionListener ▁. ▁wrap ▁( ▁ignored ▁-> ▁assertTrue ▁( ▁was Not ified ▁. ▁compareAndSet ▁( ▁false ▁, ▁true ▁) ▁) ▁, ▁e ▁-> ▁{ ▁throw ▁new ▁AssertionError ▁( ▁e ▁) ▁; ▁} ▁) ▁; ▁final ▁List ▁< ▁Sparse File Tracker ▁. ▁G ap ▁> ▁gap s ▁= ▁sp arse File Tracker ▁. ▁waitFor Range ▁( ▁range ▁, ▁sub Range ▁, ▁listener ▁) ▁; ▁assertTrue ▁( ▁STR ▁+ ▁sub Range ▁+ ▁STR ▁, ▁was Not ified ▁. ▁get ▁( ▁) ▁) ▁; ▁was Not ified ▁. ▁set ▁( ▁false ▁) ▁; ▁assertTrue ▁( ▁sp arse File Tracker ▁. ▁waitFor Range If Pending ▁( ▁sub Range ▁, ▁listener ▁) ▁) ▁; ▁assertTrue ▁( ▁was Not ified ▁. ▁get ▁( ▁) ▁) ▁; ▁for ▁( ▁final ▁Sparse File Tracker ▁. ▁G ap ▁gap ▁: ▁gap s ▁) ▁{ ▁assertThat ▁( ▁gap ▁. ▁start ▁( ▁) ▁, ▁greaterThan OrEqualTo ▁( ▁range ▁. ▁start ▁( ▁) ▁) ▁) ▁; ▁assertThat ▁( ▁gap ▁. ▁end ▁( ▁) ▁, ▁lessThan OrEqualTo ▁( ▁range ▁. ▁end ▁( ▁) ▁) ▁) ▁; ▁for ▁( ▁long ▁i ▁= ▁gap ▁. ▁start ▁( ▁) ▁; ▁i ▁< ▁gap ▁. ▁end ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁assertThat ▁( ▁file Contents ▁[ ▁toInt Bytes ▁( ▁i ▁) ▁] ▁, ▁equalTo ▁( ▁UN AVAILABLE ▁) ▁) ▁; ▁file Contents ▁[ ▁toInt Bytes ▁( ▁i ▁) ▁] ▁= ▁AV AILABLE ▁; ▁gap ▁. ▁on Progress ▁( ▁i ▁+ ▁1 L ▁) ▁; ▁} ▁gap ▁. ▁on Completion ▁( ▁) ▁; ▁} ▁} ▁else ▁{ ▁final ▁AtomicBoolean ▁wait If Pending Was Not ified ▁= ▁new ▁AtomicBoolean ▁( ▁) ▁;
▁if ▁( ▁! ▁old Space ▁. ▁is Loaded Memory Space ▁( ▁) ▁|| ▁old Space ▁. ▁getType ▁( ▁) ▁== ▁AddressSpace ▁. ▁TYPE _ CODE ▁) ▁{ ▁space It ▁. ▁remove ▁( ▁) ▁; ▁} ▁else ▁{ ▁AddressSpace ▁new Space ▁= ▁find Space Same Name ▁( ▁old Space ▁, ▁new Spaces ▁) ▁; ▁if ▁( ▁new Space ▁!= ▁null ▁) ▁{ ▁space Map ▁. ▁put ▁( ▁old Space ▁. ▁getName ▁( ▁) ▁, ▁new Space ▁) ▁; ▁new Spaces ▁. ▁remove ▁( ▁new Space ▁) ▁; ▁space It ▁. ▁remove ▁( ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁! ▁old Spaces ▁. ▁isEmpty ▁( ▁) ▁) ▁{ ▁throw ▁new ▁In compatible Language Exception ▁( ▁STR ▁+ ▁old Spaces ▁) ▁; ▁} ▁} ▁protected ▁static ▁AddressSpace ▁find Space Same Name ▁( ▁AddressSpace ▁old Space ▁, ▁ArrayList ▁< ▁AddressSpace ▁> ▁new Spaces ▁) ▁throws ▁In compatible Language Exception ▁{ ▁Iterator ▁< ▁AddressSpace ▁> ▁it ▁= ▁new Spaces ▁. ▁iterator ▁( ▁) ▁; ▁while ▁( ▁it ▁. ▁hasNext ▁( ▁) ▁) ▁{ ▁AddressSpace ▁space ▁= ▁it ▁. ▁next ▁( ▁) ▁; ▁if ▁( ▁space ▁. ▁getName ▁( ▁) ▁. ▁equals ▁( ▁old Space ▁. ▁getName ▁( ▁) ▁) ▁) ▁{ ▁if ▁( ▁old Space ▁. ▁getSize ▁( ▁) ▁> ▁space ▁. ▁getSize ▁( ▁) ▁) ▁{ ▁throw ▁new ▁In compatible Language Exception ▁( ▁STR ▁+ ▁old Space ▁. ▁getName ▁( ▁) ▁+ ▁STR ▁) ▁; ▁} ▁return ▁space ▁; ▁} ▁} ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁Language ▁getOld Language ▁( ▁) ▁{ ▁if ▁( ▁old Language ▁== ▁null ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁} ▁return ▁old Language ▁; ▁} ▁@ ▁Override ▁public ▁Language ID ▁getOld Language ID ▁( ▁) ▁{ ▁return ▁old Language ID ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getOld Version ▁( ▁) ▁{ ▁return ▁old Language Version ▁; ▁} ▁@ ▁Override ▁public ▁Language ▁getNew Language ▁( ▁) ▁{ ▁if ▁( ▁new Language ▁== ▁null ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁} ▁return ▁new Language ▁; ▁} ▁@ ▁Override ▁public ▁Language ID ▁getNew Language ID ▁( ▁) ▁{ ▁return ▁new Language ID ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getNew Version ▁( ▁) ▁{ ▁return ▁new Language Version ▁; ▁} ▁@ ▁Override ▁public ▁Register ▁getOld Register ▁( ▁Address ▁old Addr ▁, ▁int ▁size ▁) ▁{ ▁if ▁( ▁old Language ▁== ▁null ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁} ▁return ▁old Language ▁. ▁getRegister ▁( ▁old Addr ▁, ▁size ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Register ▁getOld Register Containing ▁( ▁Address ▁old Addr ▁) ▁{ ▁int ▁value ▁= ▁old Register Range Map ▁. ▁getValue ▁( ▁old Addr ▁. ▁getOffset ▁( ▁) ▁) ▁; ▁Register ▁old Reg ▁= ▁old Language ▁. ▁getRegister ▁( ▁old Addr ▁. ▁getNew Address ▁( ▁value ▁) ▁, ▁0 ▁) ▁; ▁if ▁( ▁value ▁== ▁0 ▁&& ▁old Reg ▁!= ▁null ▁) ▁{ ▁long ▁old Offset ▁= ▁old Addr ▁. ▁getOffset ▁( ▁) ▁;
▁Annotation Attributes ▁import Att rib s ▁= ▁Annotation Config Utils ▁. ▁attributes For ▁( ▁import Metadata ▁, ▁Import ▁. ▁class ▁) ▁; ▁Class ▁< ▁? ▁> ▁[ ▁] ▁imp orted Classes ▁= ▁import Att rib s ▁. ▁getClass Array ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁imp orted Classes ▁[ ▁0 ▁] ▁. ▁getName ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Imp orted Config Lite ▁. ▁class ▁. ▁getName ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁import Registrar ▁( ▁) ▁{ ▁Imp orted Registrar ▁. ▁called ▁= ▁false ▁; ▁Annotation Config Application Context ▁ctx ▁= ▁new ▁Annotation Config Application Context ▁( ▁) ▁; ▁ctx ▁. ▁register ▁( ▁Import ing Registrar Config ▁. ▁class ▁) ▁; ▁ctx ▁. ▁refresh ▁( ▁) ▁; ▁assertThat ▁( ▁ctx ▁. ▁getBean ▁( ▁STR ▁) ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁assertThat ▁( ▁ctx ▁. ▁getBean ▁( ▁STR ▁) ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁import Registrar With Import ▁( ▁) ▁{ ▁Imp orted Registrar ▁. ▁called ▁= ▁false ▁; ▁Annotation Config Application Context ▁ctx ▁= ▁new ▁Annotation Config Application Context ▁( ▁) ▁; ▁ctx ▁. ▁register ▁( ▁Import ing Registrar Config With Import ▁. ▁class ▁) ▁; ▁ctx ▁. ▁refresh ▁( ▁) ▁; ▁assertThat ▁( ▁ctx ▁. ▁getBean ▁( ▁STR ▁) ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁assertThat ▁( ▁ctx ▁. ▁getBean ▁( ▁STR ▁) ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁assertThat ▁( ▁ctx ▁. ▁getBean ▁( ▁STR ▁) ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁assertThat ▁( ▁ctx ▁. ▁getBean ▁( ▁Imp orted Config ▁. ▁class ▁) ▁) ▁. ▁isNotNull ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁metadata From Import s One Then Two ▁( ▁) ▁{ ▁Annotation Metadata ▁import Metadata ▁= ▁new ▁Annotation Config Application Context ▁( ▁Configuration One ▁. ▁class ▁, ▁Configuration Two ▁. ▁class ▁) ▁. ▁getBean ▁( ▁Metadata Holder ▁. ▁class ▁) ▁. ▁import Metadata ▁; ▁assertThat ▁( ▁( ▁( ▁Standard Annotation Metadata ▁) ▁import Metadata ▁) ▁. ▁getInt ros pected Class ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Configuration One ▁. ▁class ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁metadata From Import s Two Then One ▁( ▁) ▁{ ▁Annotation Metadata ▁import Metadata ▁= ▁new ▁Annotation Config Application Context ▁( ▁Configuration Two ▁. ▁class ▁, ▁Configuration One ▁. ▁class ▁) ▁. ▁getBean ▁( ▁Metadata Holder ▁. ▁class ▁) ▁. ▁import Metadata ▁; ▁assertThat ▁( ▁( ▁( ▁Standard Annotation Metadata ▁) ▁import Metadata ▁) ▁. ▁getInt ros pected Class ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Configuration One ▁. ▁class ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁metadata From Import s One Then Three ▁( ▁) ▁{ ▁Annotation Metadata ▁import Metadata ▁= ▁new ▁Annotation Config Application Context ▁( ▁Configuration One ▁. ▁class ▁, ▁Configuration Three ▁. ▁class ▁) ▁. ▁getBean ▁( ▁Metadata Holder ▁. ▁class ▁) ▁. ▁import Metadata ▁; ▁assertThat ▁( ▁( ▁( ▁Standard Annotation Metadata ▁) ▁import Metadata ▁) ▁. ▁getInt ros pected Class ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁Configuration One ▁. ▁class ▁) ▁; ▁}
▁public ▁class ▁Inv ocable HandlerMethod Instrumentation ▁extends ▁Abstract Spring 5 Reactive Instrumentation V 2 ▁{ ▁@ ▁Override ▁protected ▁ClassMatch ▁enhanceClass ▁( ▁) ▁{ ▁return ▁byName ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Constructor InterceptPoint ▁[ ▁] ▁getConstructors InterceptPoints ▁( ▁) ▁{ ▁return ▁new ▁Constructor InterceptPoint ▁[ ▁0 ▁] ▁; ▁} ▁@ ▁Override ▁public ▁InstanceMethods Intercept V 2 Point ▁[ ▁] ▁getInstance Methods Intercept V 2 Points ▁( ▁) ▁{ ▁return ▁new ▁InstanceMethods Intercept V 2 Point ▁[ ▁] ▁{ ▁new ▁InstanceMethods Intercept V 2 Point ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁ElementMatcher ▁< ▁Method Description ▁> ▁getMethods Matcher ▁( ▁) ▁{ ▁return ▁named ▁( ▁STR ▁) ▁. ▁and ▁( ▁takesArgument WithType ▁( ▁0 ▁, ▁STR ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getMethods Interceptor V 2 ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁isOverrideArgs ▁( ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁} ▁; ▁} ▁}
▁public ▁final ▁class ▁Enrich Policy ▁implements ▁Writeable ▁, ▁ToXContent Fragment ▁{ ▁public ▁static ▁final ▁String ▁EN RI CH _ INDEX _ NAME _ BASE ▁= ▁STR ▁; ▁public ▁static ▁final ▁String ▁EN RI CH _ INDEX _ PATTERN ▁= ▁EN RI CH _ INDEX _ NAME _ BASE ▁+ ▁STR ▁; ▁public ▁static ▁final ▁String ▁MATCH _ TYPE ▁= ▁STR ▁; ▁public ▁static ▁final ▁String ▁G EO _ MATCH _ TYPE ▁= ▁STR ▁; ▁public ▁static ▁final ▁String ▁[ ▁] ▁SUPPORTED _ POLICY _ TYPES ▁= ▁new ▁String ▁[ ▁] ▁{ ▁MATCH _ TYPE ▁, ▁G EO _ MATCH _ TYPE ▁} ▁; ▁private ▁static ▁final ▁ParseField ▁QUERY ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁ParseField ▁IN DICES ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁ParseField ▁MATCH _ FIELD ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁ParseField ▁EN RI CH _ FI ELDS ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁private ▁static ▁final ▁ParseField ▁E LAST IC SEARCH _ VERSION ▁= ▁new ▁ParseField ▁( ▁STR ▁) ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁private ▁static ▁final ▁Construct ingObjectParser ▁< ▁Enrich Policy ▁, ▁String ▁> ▁PARSER ▁= ▁new ▁Construct ingObjectParser ▁< ▁> ▁( ▁STR ▁, ▁false ▁, ▁( ▁args ▁, ▁policy Type ▁) ▁-> ▁new ▁Enrich Policy ▁( ▁policy Type ▁, ▁( ▁Query Source ▁) ▁args ▁[ ▁0 ▁] ▁, ▁( ▁List ▁< ▁String ▁> ▁) ▁args ▁[ ▁1 ▁] ▁, ▁( ▁String ▁) ▁args ▁[ ▁2 ▁] ▁, ▁( ▁List ▁< ▁String ▁> ▁) ▁args ▁[ ▁3 ▁] ▁, ▁( ▁Version ▁) ▁args ▁[ ▁4 ▁] ▁) ▁) ▁; ▁static ▁{ ▁declare Common Constructor Parsing Options ▁( ▁PARSER ▁) ▁; ▁} ▁private ▁static ▁< ▁T ▁> ▁void ▁declare Common Constructor Parsing Options ▁( ▁Construct ingObjectParser ▁< ▁T ▁, ▁? ▁> ▁parser ▁) ▁{ ▁parser ▁. ▁declareObject ▁( ▁Construct ingObjectParser ▁. ▁optional ConstructorArg ▁( ▁) ▁, ▁( ▁p ▁, ▁c ▁) ▁-> ▁{ ▁XContentBuilder ▁contentBuilder ▁= ▁XContentBuilder ▁. ▁builder ▁( ▁p ▁. ▁contentType ▁( ▁) ▁. ▁xContent ▁( ▁) ▁) ▁; ▁contentBuilder ▁. ▁generator ▁( ▁) ▁. ▁copy Current Structure ▁( ▁p ▁) ▁; ▁return ▁new ▁Query Source ▁( ▁BytesReference ▁. ▁bytes ▁( ▁contentBuilder ▁) ▁, ▁contentBuilder ▁. ▁contentType ▁( ▁) ▁) ▁; ▁} ▁, ▁QUERY ▁) ▁; ▁parser ▁. ▁declareString Array ▁( ▁Construct ingObjectParser ▁. ▁constructorArg ▁( ▁) ▁, ▁IN DICES ▁) ▁; ▁parser ▁. ▁declareString ▁( ▁Construct ingObjectParser ▁. ▁constructorArg ▁( ▁) ▁, ▁MATCH _ FIELD ▁) ▁; ▁parser ▁. ▁declareString Array ▁( ▁Construct ingObjectParser ▁. ▁constructorArg ▁( ▁) ▁, ▁EN RI CH _ FI ELDS ▁) ▁; ▁parser ▁. ▁declareField ▁( ▁Construct ingObjectParser ▁. ▁optional ConstructorArg ▁( ▁) ▁, ▁( ▁( ▁p ▁, ▁c ▁) ▁-> ▁Version ▁. ▁fromString ▁( ▁p ▁. ▁text ▁( ▁) ▁) ▁) ▁, ▁E LAST IC SEARCH _ VERSION ▁, ▁ValueType ▁. ▁STRING ▁) ▁; ▁} ▁public ▁static ▁Enrich Policy ▁fromXContent ▁( ▁XContentParser ▁parser ▁) ▁throws ▁IOException ▁{ ▁Token ▁token ▁= ▁parser ▁. ▁currentToken ▁( ▁) ▁;
▁@ ▁RunWith ▁( ▁Parameterized R obolectric TestRunner ▁. ▁class ▁) ▁public ▁final ▁class ▁Ac 4 Extractor Test ▁{ ▁@ ▁Parameters ▁( ▁name ▁= ▁STR ▁) ▁public ▁static ▁ImmutableList ▁< ▁Extractor Asserts ▁. ▁Sim ulation Config ▁> ▁params ▁( ▁) ▁{ ▁return ▁Extractor Asserts ▁. ▁configs ▁( ▁) ▁; ▁} ▁@ ▁Parameter ▁public ▁Extractor Asserts ▁. ▁Sim ulation Config ▁sim ulation Config ▁; ▁@ ▁Test ▁public ▁void ▁ac 4 Sample ▁( ▁) ▁throws ▁Exception ▁{ ▁Extractor Asserts ▁. ▁assert Behavior ▁( ▁Ac 4 Extractor ▁:: ▁new ▁, ▁STR ▁, ▁sim ulation Config ▁) ▁; ▁} ▁}
▁@ ▁Override ▁public ▁int ▁getMax Field Size ▁( ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setMax Field Size ▁( ▁int ▁max ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getMax Rows ▁( ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setMax Rows ▁( ▁int ▁max ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Escape Processing ▁( ▁boolean ▁enable ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getQuery Timeout ▁( ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setQuery Timeout ▁( ▁int ▁seconds ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁cancel ▁( ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁SQL Warning ▁get Warnings ▁( ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁clear Warnings ▁( ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Cursor Name ▁( ▁String ▁name ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁execute ▁( ▁String ▁sql ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁ResultSet ▁getResult Set ▁( ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getUpdate Count ▁( ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁getM ore Results ▁( ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Fetch Direction ▁( ▁int ▁direction ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getF etch Direction ▁( ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set Fetch Size ▁( ▁int ▁rows ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getF etch Size ▁( ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getResult Set Concurrency ▁( ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getResult Set Type ▁( ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁add Batch ▁( ▁String ▁sql ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁clear Batch ▁( ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁[ ▁] ▁execute Batch ▁( ▁) ▁throws ▁SQLException ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁}
▁public ▁class ▁F d InputStream ▁extends ▁InputStream ▁{ ▁private ▁static ▁final ▁PO SI X ▁LI B _ PO SI X ▁= ▁PO SI X Factory ▁. ▁getNative PO SI X ▁( ▁) ▁; ▁private ▁final ▁int ▁fd ▁; ▁private ▁boolean ▁closed ▁= ▁false ▁; ▁F d InputStream ▁( ▁int ▁fd ▁) ▁{ ▁this ▁. ▁fd ▁= ▁fd ▁; ▁} ▁@ ▁Override ▁public ▁synchronized ▁int ▁read ▁( ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁closed ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁STR ▁) ▁; ▁} ▁byte ▁[ ▁] ▁buf ▁= ▁new ▁byte ▁[ ▁1 ▁] ▁; ▁if ▁( ▁0 ▁== ▁read ▁( ▁buf ▁) ▁) ▁{ ▁return ▁- ▁1 ▁; ▁} ▁return ▁buf ▁[ ▁0 ▁] ▁& ▁0 x 0 FF ▁; ▁} ▁@ ▁Override ▁public ▁synchronized ▁int ▁read ▁( ▁byte ▁[ ▁] ▁b ▁) ▁throws ▁IOException ▁{ ▁return ▁read ▁( ▁b ▁, ▁0 ▁, ▁b ▁. ▁length ▁) ▁; ▁} ▁@ ▁Override ▁public ▁synchronized ▁int ▁read ▁( ▁byte ▁[ ▁] ▁b ▁, ▁int ▁off ▁, ▁int ▁len ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁closed ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁STR ▁) ▁; ▁} ▁ByteBuffer ▁buf ▁= ▁ByteBuffer ▁. ▁wrap ▁( ▁b ▁, ▁off ▁, ▁len ▁) ▁; ▁int ▁ret ▁= ▁LI B _ PO SI X ▁. ▁read ▁( ▁fd ▁, ▁buf ▁, ▁len ▁) ▁; ▁if ▁( ▁ret ▁< ▁0 ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁LI B _ PO SI X ▁. ▁str error ▁( ▁LI B _ PO SI X ▁. ▁err no ▁( ▁) ▁) ▁) ▁; ▁} ▁return ▁ret ▁; ▁} ▁@ ▁Override ▁public ▁synchronized ▁void ▁close ▁( ▁) ▁throws ▁IOException ▁{ ▁closed ▁= ▁true ▁; ▁} ▁}
▁@ ▁Beta ▁public ▁class ▁Client Reset Required Error ▁extends ▁App Exception ▁{ ▁private ▁final ▁long ▁app Native Pointer ▁; ▁private ▁final ▁Sync Configuration ▁original Configuration ▁; ▁private ▁final ▁Realm Configuration ▁backup Configuration ▁; ▁private ▁final ▁File ▁backup File ▁; ▁private ▁final ▁File ▁original File ▁; ▁Client Reset Required Error ▁( ▁long ▁app Native Pointer ▁, ▁ErrorCode ▁errorCode ▁, ▁String ▁errorMessage ▁, ▁Sync Configuration ▁original Configuration ▁, ▁Realm Configuration ▁backup Configuration ▁) ▁{ ▁super ▁( ▁errorCode ▁, ▁errorMessage ▁) ▁; ▁this ▁. ▁original Configuration ▁= ▁original Configuration ▁; ▁this ▁. ▁backup Configuration ▁= ▁backup Configuration ▁; ▁this ▁. ▁backup File ▁= ▁new ▁File ▁( ▁backup Configuration ▁. ▁getPath ▁( ▁) ▁) ▁; ▁this ▁. ▁original File ▁= ▁new ▁File ▁( ▁original Configuration ▁. ▁getPath ▁( ▁) ▁) ▁; ▁this ▁. ▁app Native Pointer ▁= ▁app Native Pointer ▁; ▁} ▁public ▁void ▁execute Client Reset ▁( ▁) ▁{ ▁synchronized ▁( ▁Realm ▁. ▁class ▁) ▁{ ▁if ▁( ▁Realm ▁. ▁getGlobal Instance Count ▁( ▁original Configuration ▁) ▁> ▁0 ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁+ ▁STR ▁) ▁; ▁} ▁native Execute Client Reset ▁( ▁app Native Pointer ▁, ▁original Configuration ▁. ▁getPath ▁( ▁) ▁) ▁; ▁} ▁} ▁public ▁File ▁get Backup File ▁( ▁) ▁{ ▁return ▁backup File ▁; ▁} ▁public ▁Realm Configuration ▁get Backup Realm Configuration ▁( ▁) ▁{ ▁return ▁backup Configuration ▁; ▁} ▁public ▁File ▁getOriginal File ▁( ▁) ▁{ ▁return ▁original File ▁; ▁} ▁private ▁native ▁void ▁native Execute Client Reset ▁( ▁long ▁app Native Pointer ▁, ▁String ▁original Path ▁) ▁; ▁}
▁@ ▁NodeInfo ▁( ▁allowed Usage Types ▁= ▁{ ▁InputType ▁. ▁Memory ▁} ▁, ▁name Template ▁= ▁STR ▁) ▁public ▁final ▁class ▁Memory Proxy Node ▁extends ▁Proxy Node ▁implements ▁Single Memory Kill ▁{ ▁public ▁static ▁final ▁NodeClass ▁< ▁Memory Proxy Node ▁> ▁TYPE ▁= ▁NodeClass ▁. ▁create ▁( ▁Memory Proxy Node ▁. ▁class ▁) ▁; ▁@ ▁Optional Input ▁( ▁InputType ▁. ▁Memory ▁) ▁Memory Kill ▁value ▁; ▁protected ▁final ▁Location Identity ▁location Identity ▁; ▁public ▁Memory Proxy Node ▁( ▁Memory Kill ▁value ▁, ▁Loop Exit Node ▁proxy Point ▁, ▁Location Identity ▁location Identity ▁) ▁{ ▁super ▁( ▁TYPE ▁, ▁StampFactory ▁. ▁for Void ▁( ▁) ▁, ▁proxy Point ▁) ▁; ▁this ▁. ▁value ▁= ▁value ▁; ▁this ▁. ▁location Identity ▁= ▁location Identity ▁; ▁} ▁public ▁void ▁setValue ▁( ▁Memory Kill ▁newValue ▁) ▁{ ▁this ▁. ▁update Usages ▁( ▁value ▁. ▁as Node ▁( ▁) ▁, ▁newValue ▁. ▁as Node ▁( ▁) ▁) ▁; ▁this ▁. ▁value ▁= ▁newValue ▁; ▁} ▁@ ▁Override ▁public ▁ValueNode ▁value ▁( ▁) ▁{ ▁return ▁( ▁value ▁== ▁null ▁? ▁null ▁: ▁value ▁. ▁as Node ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Ph i Node ▁create Ph i ▁( ▁Abstract Merge Node ▁merge ▁) ▁{ ▁return ▁graph ▁( ▁) ▁. ▁add Without Unique ▁( ▁new ▁Memory Ph i Node ▁( ▁merge ▁, ▁location Identity ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Location Identity ▁getK illed Location Identity ▁( ▁) ▁{ ▁return ▁location Identity ▁; ▁} ▁@ ▁Override ▁public ▁Proxy Node ▁duplicate On ▁( ▁Loop Exit Node ▁new Proxy Point ▁, ▁ValueNode ▁new Original Node ▁) ▁{ ▁assert ▁new Original Node ▁instanceof ▁Memory Kill ▁; ▁return ▁graph ▁( ▁) ▁. ▁add Without Unique With Inputs ▁( ▁new ▁Memory Proxy Node ▁( ▁( ▁Memory Kill ▁) ▁new Original Node ▁, ▁new Proxy Point ▁, ▁getK illed Location Identity ▁( ▁) ▁) ▁) ▁; ▁} ▁}
▁this ▁. ▁conf ▁. ▁set ▁( ▁Yarn Configuration ▁. ▁NM _ RE MOTE _ APP _ LOG _ DIR ▁, ▁this ▁. ▁remote Root LogDir ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁; ▁LogAggregation Service ▁log Aggregation Service ▁= ▁new ▁LogAggregation Service ▁( ▁dispatcher ▁, ▁this ▁. ▁context ▁, ▁this ▁. ▁del S r vc ▁, ▁super ▁. ▁dir s Handler ▁) ▁; ▁log Aggregation Service ▁. ▁init ▁( ▁this ▁. ▁conf ▁) ▁; ▁log Aggregation Service ▁. ▁start ▁( ▁) ▁; ▁ApplicationId ▁app ▁= ▁Builder Utils ▁. ▁new Application Id ▁( ▁1234 ▁, ▁1 ▁) ▁; ▁File ▁app LogDir ▁= ▁new ▁File ▁( ▁local LogDir ▁, ▁app ▁. ▁toString ▁( ▁) ▁) ▁; ▁app LogDir ▁. ▁mkdir ▁( ▁) ▁; ▁LogAggregation Context ▁context ▁= ▁LogAggregation Context ▁. ▁newInstance ▁( ▁STR ▁, ▁STR ▁) ▁; ▁log Aggregation Service ▁. ▁handle ▁( ▁new ▁Log Handler App Started Event ▁( ▁app ▁, ▁this ▁. ▁user ▁, ▁null ▁, ▁this ▁. ▁ac ls ▁, ▁context ▁) ▁) ▁; ▁Application AttemptId ▁app AttemptId ▁= ▁Builder Utils ▁. ▁new Application AttemptId ▁( ▁app ▁, ▁1 ▁) ▁; ▁ContainerId ▁cont ▁= ▁ContainerId ▁. ▁new Container Id ▁( ▁app AttemptId ▁, ▁1 ▁) ▁; ▁write Container Logs ▁( ▁app LogDir ▁, ▁cont ▁, ▁new ▁String ▁[ ▁] ▁{ ▁STR ▁, ▁STR ▁, ▁STR ▁} ▁, ▁EMPTY _ FILES ▁) ▁; ▁log Aggregation Service ▁. ▁handle ▁( ▁new ▁Log Handler Container Finished Event ▁( ▁cont ▁, ▁Container Type ▁. ▁APPLICATION _ M ASTER ▁, ▁0 ▁) ▁) ▁; ▁log Aggregation Service ▁. ▁handle ▁( ▁new ▁Log Handler App Finished Event ▁( ▁app ▁) ▁) ▁; ▁log Aggregation Service ▁. ▁stop ▁( ▁) ▁; ▁del S r vc ▁. ▁stop ▁( ▁) ▁; ▁File Deletion Task ▁delet ion Task ▁= ▁new ▁File Deletion Task ▁( ▁del S r vc ▁, ▁user ▁, ▁null ▁, ▁null ▁) ▁; ▁verify ▁( ▁del S r vc ▁, ▁times ▁( ▁0 ▁) ▁) ▁. ▁delete ▁( ▁delet ion Task ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testNo Container On Node ▁( ▁) ▁throws ▁Exception ▁{ ▁this ▁. ▁conf ▁. ▁set ▁( ▁Yarn Configuration ▁. ▁NM _ LOG _ DIR S ▁, ▁local LogDir ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁; ▁this ▁. ▁conf ▁. ▁set ▁( ▁Yarn Configuration ▁. ▁NM _ RE MOTE _ APP _ LOG _ DIR ▁, ▁this ▁. ▁remote Root LogDir ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁; ▁LogAggregation Service ▁log Aggregation Service ▁= ▁new ▁LogAggregation Service ▁( ▁dispatcher ▁, ▁this ▁. ▁context ▁, ▁this ▁. ▁del S r vc ▁, ▁super ▁. ▁dir s Handler ▁) ▁; ▁log Aggregation Service ▁. ▁init ▁( ▁this ▁. ▁conf ▁) ▁; ▁log Aggregation Service ▁. ▁start ▁( ▁) ▁; ▁ApplicationId ▁application 1 ▁= ▁Builder Utils ▁. ▁new Application Id ▁( ▁1234 ▁, ▁1 ▁) ▁; ▁File ▁app 1 LogDir ▁= ▁new ▁File ▁( ▁local LogDir ▁, ▁application 1 ▁. ▁toString ▁( ▁) ▁) ▁; ▁app 1 LogDir ▁. ▁mkdir ▁( ▁) ▁;
▁> ▁additional Inputs ▁, ▁Object ▁module Map ▁, ▁Object ▁additional Module Maps ▁, ▁Object ▁propagate Module Map To Compile Action ▁, ▁Object ▁do Not Generate Module Map ▁, ▁Object ▁code Coverage Enabled ▁, ▁Object ▁hdr s Checking Mode ▁, ▁Object ▁variables Extension ▁, ▁Object ▁language ▁, ▁Object ▁pur pose ▁, ▁Object ▁g rep Includes ▁, ▁StarlarkThread ▁thread ▁) ▁throws ▁EvalException ▁, ▁Interrupted Exception ▁; ▁@ ▁StarlarkMethod ▁( ▁name ▁= ▁STR ▁, ▁doc ▁= ▁STR ▁, ▁use Starlark Thread ▁= ▁true ▁, ▁parameters ▁= ▁{ ▁@ ▁Param ▁( ▁name ▁= ▁STR ▁, ▁positional ▁= ▁false ▁, ▁named ▁= ▁true ▁, ▁doc ▁= ▁STR ▁) ▁, ▁@ ▁Param ▁( ▁name ▁= ▁STR ▁, ▁doc ▁= ▁STR ▁, ▁positional ▁= ▁false ▁, ▁named ▁= ▁true ▁) ▁, ▁@ ▁Param ▁( ▁name ▁= ▁STR ▁, ▁doc ▁= ▁STR ▁, ▁positional ▁= ▁false ▁, ▁named ▁= ▁true ▁) ▁, ▁@ ▁Param ▁( ▁name ▁= ▁STR ▁, ▁doc ▁= ▁STR ▁, ▁positional ▁= ▁false ▁, ▁named ▁= ▁true ▁, ▁defaultValue ▁= ▁STR ▁, ▁allowed Types ▁= ▁{ ▁@ ▁ParamType ▁( ▁type ▁= ▁Cc Compilation Outputs Api ▁. ▁class ▁) ▁, ▁@ ▁ParamType ▁( ▁type ▁= ▁None Type ▁. ▁class ▁) ▁} ▁) ▁, ▁@ ▁Param ▁( ▁name ▁= ▁STR ▁, ▁doc ▁= ▁STR ▁, ▁positional ▁= ▁false ▁, ▁named ▁= ▁true ▁, ▁defaultValue ▁= ▁STR ▁) ▁, ▁@ ▁Param ▁( ▁name ▁= ▁STR ▁, ▁doc ▁= ▁STR ▁+ ▁STR ▁, ▁positional ▁= ▁false ▁, ▁named ▁= ▁true ▁, ▁defaultValue ▁= ▁STR ▁) ▁, ▁@ ▁Param ▁( ▁name ▁= ▁STR ▁, ▁doc ▁= ▁STR ▁+ ▁STR ▁, ▁positional ▁= ▁false ▁, ▁named ▁= ▁true ▁) ▁, ▁@ ▁Param ▁( ▁name ▁= ▁STR ▁, ▁doc ▁= ▁STR ▁, ▁positional ▁= ▁false ▁, ▁named ▁= ▁true ▁, ▁defaultValue ▁= ▁STR ▁) ▁, ▁@ ▁Param ▁( ▁name ▁= ▁STR ▁, ▁doc ▁= ▁STR ▁, ▁positional ▁= ▁false ▁, ▁named ▁= ▁true ▁, ▁defaultValue ▁= ▁STR ▁) ▁, ▁@ ▁Param ▁( ▁name ▁= ▁STR ▁, ▁doc ▁= ▁STR ▁, ▁positional ▁= ▁false ▁, ▁named ▁= ▁true ▁, ▁defaultValue ▁= ▁STR ▁) ▁, ▁@ ▁Param ▁( ▁name ▁= ▁STR ▁, ▁doc ▁= ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁+ ▁STR ▁, ▁positional ▁= ▁false ▁, ▁named ▁= ▁true ▁, ▁defaultValue ▁= ▁STR ▁) ▁, ▁@ ▁Param ▁( ▁name ▁= ▁STR ▁, ▁doc ▁= ▁STR ▁, ▁positional ▁= ▁false ▁, ▁named ▁= ▁true ▁, ▁defaultValue ▁= ▁STR ▁, ▁allowed Types ▁= ▁{ ▁@ ▁ParamType ▁( ▁type ▁= ▁Sequence ▁. ▁class ▁) ▁, ▁@ ▁ParamType ▁( ▁type ▁= ▁Depset ▁. ▁class ▁) ▁, ▁} ▁) ▁, ▁@ ▁Param ▁( ▁name ▁= ▁STR ▁, ▁positional ▁= ▁false ▁, ▁named ▁= ▁true ▁, ▁defaultValue ▁= ▁STR ▁, ▁allowed Types ▁= ▁{ ▁@ ▁ParamType ▁( ▁type ▁= ▁FileApi ▁. ▁class ▁) ▁, ▁@ ▁ParamType ▁( ▁type ▁= ▁None Type ▁. ▁class ▁) ▁, ▁} ▁) ▁, ▁@ ▁Param ▁( ▁name ▁= ▁STR ▁, ▁positional ▁= ▁false ▁, ▁named ▁= ▁true ▁, ▁documented ▁= ▁false ▁, ▁allowed Types ▁= ▁{ ▁@ ▁ParamType ▁( ▁type ▁= ▁String ▁. ▁class ▁) ▁}
▁public ▁class ▁Bug _ for _ Sp it Fire _4 ▁extends ▁TestCase ▁{ ▁public ▁void ▁test _ for _ Sp it Fire ▁( ▁) ▁{ ▁Generic ▁< ▁Payload ▁> ▁q ▁= ▁new ▁Generic ▁< ▁Payload ▁> ▁( ▁) ▁; ▁q ▁. ▁setHeader ▁( ▁new ▁Header ▁( ▁) ▁) ▁; ▁q ▁. ▁set Payload ▁( ▁new ▁Payload ▁( ▁) ▁) ▁; ▁String ▁text ▁= ▁JSON ▁. ▁toJSONString ▁( ▁q ▁, ▁Serializer Feature ▁. ▁WriteClassName ▁) ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁text ▁) ▁; ▁Generic ▁< ▁Payload ▁> ▁o ▁= ▁( ▁Generic ▁< ▁Payload ▁> ▁) ▁JSON ▁. ▁parseObject ▁( ▁text ▁, ▁q ▁. ▁getClass ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertNotNull ▁( ▁o ▁. ▁getPayload ▁( ▁) ▁) ▁; ▁} ▁public ▁static ▁abstract ▁class ▁Abstract DTO ▁{ ▁} ▁public ▁static ▁class ▁Header ▁{ ▁} ▁public ▁static ▁class ▁Payload ▁extends ▁Abstract DTO ▁{ ▁} ▁public ▁static ▁class ▁Generic ▁< ▁T ▁extends ▁Abstract DTO ▁> ▁extends ▁Abstract DTO ▁{ ▁Header ▁header ▁; ▁T ▁payload ▁; ▁public ▁Header ▁getHeader ▁( ▁) ▁{ ▁return ▁header ▁; ▁} ▁public ▁void ▁setHeader ▁( ▁Header ▁header ▁) ▁{ ▁this ▁. ▁header ▁= ▁header ▁; ▁} ▁public ▁T ▁getPayload ▁( ▁) ▁{ ▁return ▁payload ▁; ▁} ▁public ▁void ▁set Payload ▁( ▁T ▁payload ▁) ▁{ ▁this ▁. ▁payload ▁= ▁payload ▁; ▁} ▁} ▁}
▁static ▁final ▁Protocol Selection Listener Factory ▁NO _ FAIL _ SELECTION _ LIST ENER _ FACTORY ▁= ▁new ▁Protocol Selection Listener Factory ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Protocol Selection Listener ▁new Listener ▁( ▁SSLEngine ▁engine ▁, ▁List ▁< ▁String ▁> ▁supported Protocols ▁) ▁{ ▁return ▁new ▁No Fail Protocol Selection Listener ▁( ▁( ▁Jdk Ssl Engine ▁) ▁engine ▁, ▁supported Protocols ▁) ▁; ▁} ▁} ▁; ▁static ▁class ▁No Fail Protocol Selector ▁implements ▁Protocol Selector ▁{ ▁private ▁final ▁Jdk Ssl Engine ▁engine Wrapper ▁; ▁private ▁final ▁Set ▁< ▁String ▁> ▁supported Protocols ▁; ▁No Fail Protocol Selector ▁( ▁Jdk Ssl Engine ▁engine Wrapper ▁, ▁Set ▁< ▁String ▁> ▁supported Protocols ▁) ▁{ ▁this ▁. ▁engine Wrapper ▁= ▁engine Wrapper ▁; ▁this ▁. ▁supported Protocols ▁= ▁supported Protocols ▁; ▁} ▁@ ▁Override ▁public ▁void ▁unsupported ▁( ▁) ▁{ ▁engine Wrapper ▁. ▁set Negot iated Application Protocol ▁( ▁null ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁select ▁( ▁List ▁< ▁String ▁> ▁protocols ▁) ▁throws ▁Exception ▁{ ▁for ▁( ▁String ▁p ▁: ▁supported Protocols ▁) ▁{ ▁if ▁( ▁protocols ▁. ▁contains ▁( ▁p ▁) ▁) ▁{ ▁engine Wrapper ▁. ▁set Negot iated Application Protocol ▁( ▁p ▁) ▁; ▁return ▁p ▁; ▁} ▁} ▁return ▁no Select Match Found ▁( ▁) ▁; ▁} ▁public ▁String ▁no Select Match Found ▁( ▁) ▁throws ▁Exception ▁{ ▁engine Wrapper ▁. ▁set Negot iated Application Protocol ▁( ▁null ▁) ▁; ▁return ▁null ▁; ▁} ▁} ▁private ▁static ▁final ▁class ▁Fail Protocol Selector ▁extends ▁No Fail Protocol Selector ▁{ ▁Fail Protocol Selector ▁( ▁Jdk Ssl Engine ▁engine Wrapper ▁, ▁Set ▁< ▁String ▁> ▁supported Protocols ▁) ▁{ ▁super ▁( ▁engine Wrapper ▁, ▁supported Protocols ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁no Select Match Found ▁( ▁) ▁throws ▁Exception ▁{ ▁throw ▁new ▁SSL Handshake Exception ▁( ▁STR ▁) ▁; ▁} ▁} ▁private ▁static ▁class ▁No Fail Protocol Selection Listener ▁implements ▁Protocol Selection Listener ▁{ ▁private ▁final ▁Jdk Ssl Engine ▁engine Wrapper ▁; ▁private ▁final ▁List ▁< ▁String ▁> ▁supported Protocols ▁; ▁No Fail Protocol Selection Listener ▁( ▁Jdk Ssl Engine ▁engine Wrapper ▁, ▁List ▁< ▁String ▁> ▁supported Protocols ▁) ▁{ ▁this ▁. ▁engine Wrapper ▁= ▁engine Wrapper ▁; ▁this ▁. ▁supported Protocols ▁= ▁supported Protocols ▁; ▁} ▁@ ▁Override ▁public ▁void ▁unsupported ▁( ▁) ▁{ ▁engine Wrapper ▁. ▁set Negot iated Application Protocol ▁( ▁null ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁selected ▁( ▁String ▁protocol ▁) ▁throws ▁Exception ▁{ ▁if ▁( ▁supported Protocols ▁. ▁contains ▁( ▁protocol ▁) ▁) ▁{ ▁engine Wrapper ▁. ▁set Negot iated Application Protocol ▁( ▁protocol ▁) ▁; ▁} ▁else ▁{ ▁no Selected Match Found ▁( ▁protocol ▁) ▁; ▁} ▁} ▁protected ▁void ▁no Selected Match Found ▁( ▁String ▁protocol ▁) ▁throws ▁Exception ▁{ ▁} ▁} ▁private ▁static ▁final ▁class ▁Fail Protocol Selection Listener ▁extends ▁No Fail Protocol Selection Listener ▁{ ▁Fail Protocol Selection Listener ▁( ▁Jdk Ssl Engine ▁engine Wrapper ▁, ▁List ▁< ▁String ▁> ▁supported Protocols ▁) ▁{ ▁super ▁( ▁engine Wrapper ▁, ▁supported Protocols ▁) ▁; ▁}
▁@ ▁RunWith ▁( ▁AndroidJUnit 4 ▁. ▁class ▁) ▁public ▁final ▁class ▁T ee Audio Processor Test ▁{ ▁private ▁static ▁final ▁AudioFormat ▁AUDIO _ FORMAT ▁= ▁new ▁AudioFormat ▁( ▁44 100 ▁, ▁2 ▁, ▁C ▁. ▁ENCODING _ PC M _16 BIT ▁) ▁; ▁@ ▁Rule ▁public ▁final ▁Mockito Rule ▁mock ito ▁= ▁MockitoJUnit ▁. ▁rule ▁( ▁) ▁; ▁private ▁T ee Audio Processor ▁t ee Audio Processor ▁; ▁@ ▁Mock ▁private ▁Audio Buffer Sink ▁mock Audio Buffer Sink ▁; ▁@ ▁Before ▁public ▁void ▁setUp ▁( ▁) ▁{ ▁t ee Audio Processor ▁= ▁new ▁T ee Audio Processor ▁( ▁mock Audio Buffer Sink ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁initial Flush _ flush es Sink ▁( ▁) ▁throws ▁Exception ▁{ ▁t ee Audio Processor ▁. ▁configure ▁( ▁AUDIO _ FORMAT ▁) ▁; ▁t ee Audio Processor ▁. ▁flush ▁( ▁) ▁; ▁verify ▁( ▁mock Audio Buffer Sink ▁) ▁. ▁flush ▁( ▁AUDIO _ FORMAT ▁. ▁sampleRate ▁, ▁AUDIO _ FORMAT ▁. ▁channel Count ▁, ▁AUDIO _ FORMAT ▁. ▁encoding ▁) ▁; ▁} ▁}
▁public ▁abstract ▁class ▁ES Rest HighLevelClient TestCase ▁extends ▁ES RestTestCase ▁{ ▁protected ▁static ▁final ▁String ▁CONF LICT _ PI PE LINE _ ID ▁= ▁STR ▁; ▁private ▁static ▁Rest HighLevelClient ▁rest HighLevelClient ▁; ▁private ▁static ▁boolean ▁async ▁= ▁Boolean s ▁. ▁parseBoolean ▁( ▁System ▁. ▁getProperty ▁( ▁STR ▁, ▁STR ▁) ▁) ▁; ▁@ ▁Before ▁public ▁void ▁init HighLevelClient ▁( ▁) ▁throws ▁IOException ▁{ ▁super ▁. ▁init Client ▁( ▁) ▁; ▁if ▁( ▁rest HighLevelClient ▁== ▁null ▁) ▁{ ▁rest HighLevelClient ▁= ▁new ▁High Level Client ▁( ▁client ▁( ▁) ▁) ▁; ▁} ▁} ▁@ ▁AfterClass ▁public ▁static ▁void ▁cleanup Client ▁( ▁) ▁throws ▁IOException ▁{ ▁IOUtils ▁. ▁close ▁( ▁rest HighLevelClient ▁) ▁; ▁rest HighLevelClient ▁= ▁null ▁; ▁} ▁protected ▁static ▁Rest HighLevelClient ▁high Level Client ▁( ▁) ▁{ ▁return ▁rest HighLevelClient ▁; ▁} ▁protected ▁static ▁< ▁Req ▁, ▁Res p ▁> ▁Res p ▁execute ▁( ▁Req ▁request ▁, ▁Sync Method ▁< ▁Req ▁, ▁Res p ▁> ▁sync Method ▁, ▁Async Method ▁< ▁Req ▁, ▁Res p ▁> ▁async Method ▁) ▁throws ▁IOException ▁{ ▁return ▁execute ▁( ▁request ▁, ▁sync Method ▁, ▁async Method ▁, ▁RequestOptions ▁. ▁DEFAULT ▁) ▁; ▁} ▁protected ▁static ▁< ▁Req ▁, ▁Res p ▁> ▁Res p ▁execute ▁( ▁Req ▁request ▁, ▁Sync Method ▁< ▁Req ▁, ▁Res p ▁> ▁sync Method ▁, ▁Async Method ▁< ▁Req ▁, ▁Res p ▁> ▁async Method ▁, ▁RequestOptions ▁options ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁async ▁== ▁false ▁) ▁{ ▁return ▁sync Method ▁. ▁execute ▁( ▁request ▁, ▁options ▁) ▁; ▁} ▁else ▁{ ▁Plain ActionFuture ▁< ▁Res p ▁> ▁future ▁= ▁Plain ActionFuture ▁. ▁new Future ▁( ▁) ▁; ▁async Method ▁. ▁execute ▁( ▁request ▁, ▁options ▁, ▁future ▁) ▁; ▁return ▁future ▁. ▁actionGet ▁( ▁) ▁; ▁} ▁} ▁protected ▁static ▁< ▁Res p ▁> ▁Res p ▁execute ▁( ▁Sync Method No Request ▁< ▁Res p ▁> ▁sync Method No Request ▁, ▁Async Method No Request ▁< ▁Res p ▁> ▁async Method No Request ▁, ▁RequestOptions ▁request Options ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁async ▁== ▁false ▁) ▁{ ▁return ▁sync Method No Request ▁. ▁execute ▁( ▁request Options ▁) ▁; ▁} ▁else ▁{ ▁Plain ActionFuture ▁< ▁Res p ▁> ▁future ▁= ▁Plain ActionFuture ▁. ▁new Future ▁( ▁) ▁; ▁async Method No Request ▁. ▁execute ▁( ▁request Options ▁, ▁future ▁) ▁; ▁return ▁future ▁. ▁actionGet ▁( ▁) ▁; ▁} ▁} ▁@ ▁Functional Interface ▁protected ▁interface ▁Sync Method ▁< ▁Request ▁, ▁Response ▁> ▁{ ▁Response ▁execute ▁( ▁Request ▁request ▁, ▁RequestOptions ▁options ▁) ▁throws ▁IOException ▁; ▁} ▁@ ▁Functional Interface ▁protected ▁interface ▁Sync Method No Request ▁< ▁Response ▁> ▁{ ▁Response ▁execute ▁( ▁RequestOptions ▁options ▁) ▁throws ▁IOException ▁; ▁} ▁@ ▁Functional Interface ▁protected ▁interface ▁Async Method ▁< ▁Request ▁, ▁Response ▁> ▁{ ▁void ▁execute ▁( ▁Request ▁request ▁, ▁RequestOptions ▁options ▁, ▁ActionListener ▁< ▁Response ▁> ▁listener ▁) ▁; ▁} ▁@ ▁Functional Interface ▁protected ▁interface ▁Async Method No Request ▁< ▁Response ▁> ▁{ ▁void ▁execute ▁( ▁RequestOptions ▁options ▁, ▁ActionListener ▁< ▁Response ▁> ▁listener ▁) ▁; ▁}
▁@ ▁Specialization ▁( ▁limit ▁= ▁STR ▁) ▁@ ▁Ex plode Loop ▁protected ▁void ▁write Vector ▁( ▁LLVMManaged Pointer ▁address ▁, ▁LLVMI 16 Vector ▁value ▁, ▁@ ▁CachedLibrary ▁( ▁STR ▁) ▁LLVMManaged Write Library ▁native Write ▁) ▁{ ▁assert ▁value ▁. ▁getLength ▁( ▁) ▁== ▁get Vector Length ▁( ▁) ▁; ▁long ▁cur Offset ▁= ▁address ▁. ▁getOffset ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁get Vector Length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁native Write ▁. ▁write I 16 ▁( ▁address ▁. ▁getObject ▁( ▁) ▁, ▁cur Offset ▁, ▁value ▁. ▁getValue ▁( ▁i ▁) ▁) ▁; ▁cur Offset ▁+= ▁I 16_ SI Z E _ IN _ BYTES ▁; ▁} ▁} ▁@ ▁Specialization ▁( ▁limit ▁= ▁STR ▁) ▁@ ▁Ex plode Loop ▁protected ▁void ▁write Vector ▁( ▁LLVMManaged Pointer ▁address ▁, ▁LLVMI 32 Vector ▁value ▁, ▁@ ▁CachedLibrary ▁( ▁STR ▁) ▁LLVMManaged Write Library ▁native Write ▁) ▁{ ▁assert ▁value ▁. ▁getLength ▁( ▁) ▁== ▁get Vector Length ▁( ▁) ▁; ▁long ▁cur Offset ▁= ▁address ▁. ▁getOffset ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁get Vector Length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁native Write ▁. ▁write I 32 ▁( ▁address ▁. ▁getObject ▁( ▁) ▁, ▁cur Offset ▁, ▁value ▁. ▁getValue ▁( ▁i ▁) ▁) ▁; ▁cur Offset ▁+= ▁I 32_ SI Z E _ IN _ BYTES ▁; ▁} ▁} ▁@ ▁Specialization ▁( ▁limit ▁= ▁STR ▁) ▁@ ▁Ex plode Loop ▁protected ▁void ▁write Vector ▁( ▁LLVMManaged Pointer ▁address ▁, ▁LLVM Float Vector ▁value ▁, ▁@ ▁CachedLibrary ▁( ▁STR ▁) ▁LLVMManaged Write Library ▁native Write ▁) ▁{ ▁assert ▁value ▁. ▁getLength ▁( ▁) ▁== ▁get Vector Length ▁( ▁) ▁; ▁long ▁cur Offset ▁= ▁address ▁. ▁getOffset ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁get Vector Length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁native Write ▁. ▁write Float ▁( ▁address ▁. ▁getObject ▁( ▁) ▁, ▁cur Offset ▁, ▁value ▁. ▁getValue ▁( ▁i ▁) ▁) ▁; ▁cur Offset ▁+= ▁FLOAT _ SI Z E _ IN _ BYTES ▁; ▁} ▁} ▁@ ▁Specialization ▁( ▁limit ▁= ▁STR ▁) ▁@ ▁Ex plode Loop ▁protected ▁void ▁write Vector ▁( ▁LLVMManaged Pointer ▁address ▁, ▁LLVM Double Vector ▁value ▁, ▁@ ▁CachedLibrary ▁( ▁STR ▁) ▁LLVMManaged Write Library ▁native Write ▁) ▁{ ▁assert ▁value ▁. ▁getLength ▁( ▁) ▁== ▁get Vector Length ▁( ▁) ▁; ▁long ▁cur Offset ▁= ▁address ▁. ▁getOffset ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁get Vector Length ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁native Write ▁. ▁writeDouble ▁( ▁address ▁. ▁getObject ▁( ▁) ▁, ▁cur Offset ▁, ▁value ▁. ▁getValue ▁( ▁i ▁) ▁) ▁; ▁cur Offset ▁+= ▁DOUBLE _ SI Z E _ IN _ BYTES ▁; ▁} ▁}
▁final ▁Remoting Command ▁response ▁= ▁Remoting Command ▁. ▁create Response Command ▁( ▁Register Broker ResponseHeader ▁. ▁class ▁) ▁; ▁response ▁. ▁setCode ▁( ▁Response Code ▁. ▁SUCCESS ▁) ▁; ▁response ▁. ▁setRe mark ▁( ▁null ▁) ▁; ▁Topic Config Serialize Wrapper ▁topic Config Serialize Wrapper ▁= ▁new ▁Topic Config Serialize Wrapper ▁( ▁) ▁; ▁when ▁( ▁netty Remoting Client ▁. ▁getName ServerAddress List ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁Lists ▁. ▁asList ▁( ▁name server 1 ▁, ▁name server 2 ▁, ▁new ▁String ▁[ ▁] ▁{ ▁name server 3 ▁} ▁) ▁) ▁; ▁when ▁( ▁netty Remoting Client ▁. ▁invoke Sync ▁( ▁anyString ▁( ▁) ▁, ▁any ▁( ▁Remoting Command ▁. ▁class ▁) ▁, ▁any Long ▁( ▁) ▁) ▁) ▁. ▁then Answer ▁( ▁new ▁Answer ▁< ▁Remoting Command ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Remoting Command ▁answer ▁( ▁Invocation OnMock ▁invocation ▁) ▁throws ▁Throwable ▁{ ▁if ▁( ▁invocation ▁. ▁getArgument ▁( ▁0 ▁) ▁== ▁name server 1 ▁) ▁{ ▁return ▁response ▁; ▁} ▁else ▁if ▁( ▁invocation ▁. ▁getArgument ▁( ▁0 ▁) ▁== ▁name server 2 ▁) ▁{ ▁return ▁response ▁; ▁} ▁else ▁if ▁( ▁invocation ▁. ▁getArgument ▁( ▁0 ▁) ▁== ▁name server 3 ▁) ▁{ ▁TimeUnit ▁. ▁MILLISECONDS ▁. ▁sleep ▁( ▁time Out ▁+ ▁20 ▁) ▁; ▁return ▁response ▁; ▁} ▁return ▁response ▁; ▁} ▁} ▁) ▁; ▁List ▁< ▁Register Broker Result ▁> ▁register Broker Result List ▁= ▁broker Outer API ▁. ▁register Broker All ▁( ▁clusterName ▁, ▁broker Addr ▁, ▁broker Name ▁, ▁broker Id ▁, ▁STR ▁, ▁topic Config Serialize Wrapper ▁, ▁Lists ▁. ▁< ▁String ▁> ▁newArrayList ▁( ▁) ▁, ▁false ▁, ▁time Out ▁, ▁true ▁) ▁; ▁assertEquals ▁( ▁2 ▁, ▁register Broker Result List ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁private ▁Remoting Command ▁build Response ▁( ▁Boolean ▁changed ▁) ▁{ ▁final ▁Remoting Command ▁response ▁= ▁Remoting Command ▁. ▁create Response Command ▁( ▁Query Data Version ResponseHeader ▁. ▁class ▁) ▁; ▁final ▁Query Data Version ResponseHeader ▁response Header ▁= ▁( ▁Query Data Version ResponseHeader ▁) ▁response ▁. ▁read Custom Header ▁( ▁) ▁; ▁response ▁. ▁setCode ▁( ▁Response Code ▁. ▁SUCCESS ▁) ▁; ▁response ▁. ▁setRe mark ▁( ▁null ▁) ▁; ▁response Header ▁. ▁set Changed ▁( ▁changed ▁) ▁; ▁return ▁response ▁; ▁} ▁}
▁public ▁class ▁MySqlSelectTest _0 ▁extends ▁MysqlTest ▁{ ▁public ▁void ▁test _0 ▁( ▁) ▁throws ▁Exception ▁{ ▁String ▁sql ▁= ▁STR ▁; ▁MySql StatementParser ▁parser ▁= ▁new ▁MySql StatementParser ▁( ▁sql ▁) ▁; ▁List ▁< ▁SQLStatement ▁> ▁statementList ▁= ▁parser ▁. ▁parseStatement List ▁( ▁) ▁; ▁SQLStatement ▁statemen ▁= ▁statementList ▁. ▁get ▁( ▁0 ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁1 ▁, ▁statementList ▁. ▁size ▁( ▁) ▁) ▁; ▁MySqlSchema StatVisitor ▁visitor ▁= ▁new ▁MySqlSchema StatVisitor ▁( ▁) ▁; ▁statemen ▁. ▁accept ▁( ▁visitor ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁1 ▁, ▁visitor ▁. ▁getTables ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁2 ▁, ▁visitor ▁. ▁getColumns ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁0 ▁, ▁visitor ▁. ▁getConditions ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁visitor ▁. ▁getTables ▁( ▁) ▁. ▁containsKey ▁( ▁new ▁TableStat ▁. ▁Name ▁( ▁STR ▁) ▁) ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁visitor ▁. ▁getColumns ▁( ▁) ▁. ▁contains ▁( ▁new ▁Column ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁; ▁Assert ▁. ▁assertTrue ▁( ▁visitor ▁. ▁getColumns ▁( ▁) ▁. ▁contains ▁( ▁new ▁Column ▁( ▁STR ▁, ▁STR ▁) ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁E TC 1 Test ▁extends ▁GdxTest ▁{ ▁Orth ograph ic Camera ▁camera ▁; ▁Orth o C am Controller ▁controller ▁; ▁Texture ▁img 1 ▁; ▁Texture ▁img 2 ▁; ▁SpriteBatch ▁batch ▁; ▁BitmapFont ▁font ▁; ▁@ ▁Override ▁public ▁void ▁create ▁( ▁) ▁{ ▁font ▁= ▁new ▁BitmapFont ▁( ▁) ▁; ▁camera ▁= ▁new ▁Orth ograph ic Camera ▁( ▁Gdx ▁. ▁graphics ▁. ▁getWidth ▁( ▁) ▁, ▁Gdx ▁. ▁graphics ▁. ▁getHeight ▁( ▁) ▁) ▁; ▁controller ▁= ▁new ▁Orth o C am Controller ▁( ▁camera ▁) ▁; ▁Gdx ▁. ▁input ▁. ▁setInput Processor ▁( ▁controller ▁) ▁; ▁Pixmap ▁pixmap ▁= ▁new ▁Pixmap ▁( ▁32 ▁, ▁32 ▁, ▁Format ▁. ▁RGB 56 5 ▁) ▁; ▁pixmap ▁. ▁setColor ▁( ▁1 ▁, ▁0 ▁, ▁0 ▁, ▁1 ▁) ▁; ▁pixmap ▁. ▁fill ▁( ▁) ▁; ▁pixmap ▁. ▁setColor ▁( ▁0 ▁, ▁1 ▁, ▁0 ▁, ▁1 ▁) ▁; ▁pixmap ▁. ▁draw Line ▁( ▁0 ▁, ▁0 ▁, ▁32 ▁, ▁32 ▁) ▁; ▁pixmap ▁. ▁draw Line ▁( ▁0 ▁, ▁32 ▁, ▁32 ▁, ▁0 ▁) ▁; ▁E TC 1 Data ▁encoded Image ▁= ▁E TC 1 ▁. ▁encode Image PK M ▁( ▁pixmap ▁) ▁; ▁pixmap ▁. ▁dispose ▁( ▁) ▁; ▁pixmap ▁= ▁E TC 1 ▁. ▁decode Image ▁( ▁encoded Image ▁, ▁Format ▁. ▁RGB 56 5 ▁) ▁; ▁encoded Image ▁. ▁dispose ▁( ▁) ▁; ▁img 1 ▁= ▁new ▁Texture ▁( ▁pixmap ▁) ▁; ▁img 2 ▁= ▁new ▁Texture ▁( ▁STR ▁) ▁; ▁batch ▁= ▁new ▁SpriteBatch ▁( ▁) ▁; ▁pixmap ▁. ▁dispose ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁render ▁( ▁) ▁{ ▁Gdx ▁. ▁gl ▁. ▁glClear ▁( ▁GL 20 ▁. ▁GL _ COLOR _ BUFFER _ BIT ▁) ▁; ▁camera ▁. ▁update ▁( ▁) ▁; ▁batch ▁. ▁set Projection Matrix ▁( ▁camera ▁. ▁combined ▁) ▁; ▁batch ▁. ▁begin ▁( ▁) ▁; ▁batch ▁. ▁draw ▁( ▁img 2 ▁, ▁- ▁100 ▁, ▁0 ▁) ▁; ▁batch ▁. ▁draw ▁( ▁img 1 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁batch ▁. ▁end ▁( ▁) ▁; ▁batch ▁. ▁get Projection Matrix ▁( ▁) ▁. ▁setTo Or th o 2 D ▁( ▁0 ▁, ▁0 ▁, ▁Gdx ▁. ▁graphics ▁. ▁getWidth ▁( ▁) ▁, ▁Gdx ▁. ▁graphics ▁. ▁getHeight ▁( ▁) ▁) ▁; ▁batch ▁. ▁begin ▁( ▁) ▁; ▁font ▁. ▁draw ▁( ▁batch ▁, ▁STR ▁+ ▁Gdx ▁. ▁graphics ▁. ▁get Frames PerSecond ▁( ▁) ▁, ▁0 ▁, ▁30 ▁) ▁; ▁batch ▁. ▁end ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁dispose ▁( ▁) ▁{ ▁batch ▁. ▁dispose ▁( ▁) ▁; ▁font ▁. ▁dispose ▁( ▁) ▁; ▁img 1 ▁. ▁dispose ▁( ▁) ▁; ▁img 2 ▁. ▁dispose ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁Test Native A zure FileSystem Concurrency ▁extends ▁Abstract Was b TestBase ▁{ ▁private ▁InMemory Block BlobStore ▁backing Store ▁; ▁@ ▁Override ▁public ▁void ▁setUp ▁( ▁) ▁throws ▁Exception ▁{ ▁super ▁. ▁setUp ▁( ▁) ▁; ▁backing Store ▁= ▁getTest Account ▁( ▁) ▁. ▁getMock Storage ▁( ▁) ▁. ▁get Back ing Store ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁tearDown ▁( ▁) ▁throws ▁Exception ▁{ ▁super ▁. ▁tearDown ▁( ▁) ▁; ▁backing Store ▁= ▁null ▁; ▁} ▁@ ▁Override ▁protected ▁AzureBlob Storage Test Account ▁createTest Account ▁( ▁) ▁throws ▁Exception ▁{ ▁return ▁AzureBlob Storage Test Account ▁. ▁createMock ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Link Blob s ▁( ▁) ▁throws ▁Exception ▁{ ▁Path ▁filePath ▁= ▁new ▁Path ▁( ▁STR ▁) ▁; ▁FSData OutputStream ▁outputStream ▁= ▁fs ▁. ▁create ▁( ▁filePath ▁) ▁; ▁HashMap ▁< ▁String ▁, ▁String ▁> ▁metadata ▁= ▁backing Store ▁. ▁getMetadata ▁( ▁AzureBlob Storage Test Account ▁. ▁to Mock Uri ▁( ▁filePath ▁) ▁) ▁; ▁assertNotNull ▁( ▁metadata ▁) ▁; ▁String ▁link Value ▁= ▁metadata ▁. ▁get ▁( ▁Azure Native FileSystem Store ▁. ▁LIN K _ BACK _ TO _ UP LOAD _ IN _ PROGRESS _ METADATA _ KEY ▁) ▁; ▁link Value ▁= ▁URL Decoder ▁. ▁decode ▁( ▁link Value ▁, ▁STR ▁) ▁; ▁assertNotNull ▁( ▁link Value ▁) ▁; ▁assertTrue ▁( ▁backing Store ▁. ▁exists ▁( ▁AzureBlob Storage Test Account ▁. ▁to Mock Uri ▁( ▁link Value ▁) ▁) ▁) ▁; ▁assertTrue ▁( ▁fs ▁. ▁exists ▁( ▁filePath ▁) ▁) ▁; ▁outputStream ▁. ▁close ▁( ▁) ▁; ▁metadata ▁= ▁backing Store ▁. ▁getMetadata ▁( ▁AzureBlob Storage Test Account ▁. ▁to Mock Uri ▁( ▁filePath ▁) ▁) ▁; ▁assertNull ▁( ▁metadata ▁. ▁get ▁( ▁Azure Native FileSystem Store ▁. ▁LIN K _ BACK _ TO _ UP LOAD _ IN _ PROGRESS _ METADATA _ KEY ▁) ▁) ▁; ▁} ▁private ▁static ▁String ▁toString ▁( ▁FileStatus ▁[ ▁] ▁list ▁) ▁{ ▁String ▁[ ▁] ▁as Strings ▁= ▁new ▁String ▁[ ▁list ▁. ▁length ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁list ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁as Strings ▁[ ▁i ▁] ▁= ▁list ▁[ ▁i ▁] ▁. ▁getPath ▁( ▁) ▁. ▁toString ▁( ▁) ▁; ▁} ▁return ▁StringUtils ▁. ▁join ▁( ▁STR ▁, ▁as Strings ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testNo Temp Blob s Visible ▁( ▁) ▁throws ▁Exception ▁{ ▁Path ▁filePath ▁= ▁new ▁Path ▁( ▁STR ▁) ▁; ▁FSData OutputStream ▁outputStream ▁= ▁fs ▁. ▁create ▁( ▁filePath ▁) ▁; ▁FileStatus ▁[ ▁] ▁list Of Root ▁= ▁fs ▁. ▁listStatus ▁( ▁new ▁Path ▁( ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁+ ▁toString ▁( ▁list Of Root ▁) ▁, ▁1 ▁, ▁list Of Root ▁. ▁length ▁) ▁; ▁assertEquals ▁( ▁fs ▁. ▁make Qualified ▁( ▁filePath ▁) ▁, ▁list Of Root ▁[ ▁0 ▁] ▁. ▁getPath ▁( ▁) ▁) ▁; ▁outputStream ▁. ▁close ▁( ▁) ▁; ▁}
▁@ ▁RunWith ▁( ▁Robolectric TestRunner ▁. ▁class ▁) ▁@ ▁Config ▁( ▁sdk ▁= ▁18 ▁) ▁public ▁class ▁String Loader Test ▁{ ▁private ▁static ▁final ▁int ▁IMAGE _ S IDE ▁= ▁100 ▁; ▁@ ▁Mock ▁private ▁ModelLoader ▁< ▁Uri ▁, ▁Object ▁> ▁uri Loader ▁; ▁@ ▁Mock ▁private ▁Data Fetcher ▁< ▁Object ▁> ▁fetcher ▁; ▁@ ▁Mock ▁private ▁Key ▁key ▁; ▁private ▁String Loader ▁< ▁Object ▁> ▁loader ▁; ▁private ▁Options ▁options ▁; ▁@ ▁Before ▁public ▁void ▁setUp ▁( ▁) ▁{ ▁Mockito Annotations ▁. ▁initMocks ▁( ▁this ▁) ▁; ▁options ▁= ▁new ▁Options ▁( ▁) ▁; ▁when ▁( ▁uri Loader ▁. ▁handles ▁( ▁any ▁( ▁Uri ▁. ▁class ▁) ▁) ▁) ▁. ▁thenReturn ▁( ▁true ▁) ▁; ▁loader ▁= ▁new ▁String Loader ▁< ▁> ▁( ▁uri Loader ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Handles Paths ▁( ▁) ▁{ ▁assumeTrue ▁( ▁STR ▁, ▁! ▁Util ▁. ▁isWindows ▁( ▁) ▁) ▁; ▁File ▁f ▁= ▁Application Provider ▁. ▁getApplication Context ▁( ▁) ▁. ▁getCache Dir ▁( ▁) ▁; ▁Uri ▁expected ▁= ▁Uri ▁. ▁from File ▁( ▁f ▁) ▁; ▁when ▁( ▁uri Loader ▁. ▁build LoadData ▁( ▁eq ▁( ▁expected ▁) ▁, ▁eq ▁( ▁IMAGE _ S IDE ▁) ▁, ▁eq ▁( ▁IMAGE _ S IDE ▁) ▁, ▁eq ▁( ▁options ▁) ▁) ▁) ▁. ▁thenReturn ▁( ▁new ▁ModelLoader ▁. ▁Load Data ▁< ▁> ▁( ▁key ▁, ▁fetcher ▁) ▁) ▁; ▁assertTrue ▁( ▁loader ▁. ▁handles ▁( ▁f ▁. ▁getAbsolutePath ▁( ▁) ▁) ▁) ▁; ▁assertEquals ▁( ▁fetcher ▁, ▁Preconditions ▁. ▁checkNotNull ▁( ▁loader ▁. ▁build LoadData ▁( ▁f ▁. ▁getAbsolutePath ▁( ▁) ▁, ▁IMAGE _ S IDE ▁, ▁IMAGE _ S IDE ▁, ▁options ▁) ▁) ▁. ▁fetcher ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Can Handle Complex File Paths ▁( ▁) ▁{ ▁String ▁test Path ▁= ▁STR ▁+ ▁STR ▁; ▁Uri ▁expected ▁= ▁Uri ▁. ▁from File ▁( ▁new ▁File ▁( ▁test Path ▁) ▁) ▁; ▁when ▁( ▁uri Loader ▁. ▁build LoadData ▁( ▁eq ▁( ▁expected ▁) ▁, ▁eq ▁( ▁IMAGE _ S IDE ▁) ▁, ▁eq ▁( ▁IMAGE _ S IDE ▁) ▁, ▁eq ▁( ▁options ▁) ▁) ▁) ▁. ▁thenReturn ▁( ▁new ▁ModelLoader ▁. ▁Load Data ▁< ▁> ▁( ▁key ▁, ▁fetcher ▁) ▁) ▁; ▁assertTrue ▁( ▁loader ▁. ▁handles ▁( ▁test Path ▁) ▁) ▁; ▁assertEquals ▁( ▁fetcher ▁, ▁Preconditions ▁. ▁checkNotNull ▁( ▁loader ▁. ▁build LoadData ▁( ▁test Path ▁, ▁IMAGE _ S IDE ▁, ▁IMAGE _ S IDE ▁, ▁options ▁) ▁) ▁. ▁fetcher ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Handles File Uris ▁( ▁) ▁{ ▁File ▁f ▁= ▁Application Provider ▁. ▁getApplication Context ▁( ▁) ▁. ▁getCache Dir ▁( ▁) ▁; ▁Uri ▁expected ▁= ▁Uri ▁. ▁from File ▁( ▁f ▁) ▁; ▁when ▁( ▁uri Loader ▁. ▁build LoadData ▁( ▁eq ▁( ▁expected ▁) ▁, ▁eq ▁( ▁IMAGE _ S IDE ▁) ▁, ▁eq ▁( ▁IMAGE _ S IDE ▁) ▁, ▁eq ▁( ▁options ▁) ▁) ▁) ▁. ▁thenReturn ▁( ▁new ▁ModelLoader ▁. ▁Load Data ▁< ▁> ▁( ▁key ▁, ▁fetcher ▁) ▁) ▁;
▁Hdfs Environment ▁test Hdfs Environment ▁= ▁createTest Hdfs Environment ▁( ▁hive ClientConfig ▁, ▁met astore ClientConfig ▁) ▁; ▁return ▁ImmutableSet ▁. ▁< ▁Hive Batch PageSource Factory ▁> ▁builder ▁( ▁) ▁. ▁add ▁( ▁new ▁R c File PageSource Factory ▁( ▁FUNCTION _ AND _ TYPE _ MANAGER ▁, ▁test Hdfs Environment ▁, ▁stats ▁) ▁) ▁. ▁add ▁( ▁new ▁Orc Batch PageSource Factory ▁( ▁FUNCTION _ AND _ TYPE _ MANAGER ▁, ▁FUNCTION _ RESOL UTION ▁, ▁hive ClientConfig ▁, ▁test Hdfs Environment ▁, ▁stats ▁, ▁new ▁Storage Orc File Tail Source ▁( ▁) ▁, ▁new ▁Storage Stripe Metadata Source ▁( ▁) ▁) ▁) ▁. ▁add ▁( ▁new ▁Dwrf Batch PageSource Factory ▁( ▁FUNCTION _ AND _ TYPE _ MANAGER ▁, ▁FUNCTION _ RESOL UTION ▁, ▁hive ClientConfig ▁, ▁test Hdfs Environment ▁, ▁stats ▁, ▁new ▁Storage Orc File Tail Source ▁( ▁) ▁, ▁new ▁Storage Stripe Metadata Source ▁( ▁) ▁, ▁NO _ EN CRY PTION ▁) ▁) ▁. ▁add ▁( ▁new ▁Parquet PageSource Factory ▁( ▁FUNCTION _ AND _ TYPE _ MANAGER ▁, ▁FUNCTION _ RESOL UTION ▁, ▁test Hdfs Environment ▁, ▁stats ▁, ▁new ▁Metadata Reader ▁( ▁) ▁) ▁) ▁. ▁add ▁( ▁new ▁Page File PageSource Factory ▁( ▁test Hdfs Environment ▁, ▁new ▁Block Encoding Manager ▁( ▁) ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁public ▁static ▁Set ▁< ▁Hive Selective PageSource Factory ▁> ▁getDefault Hive Selective PageSource Factories ▁( ▁Hive ClientConfig ▁hive ClientConfig ▁, ▁Met astore ClientConfig ▁met astore ClientConfig ▁) ▁{ ▁File Format DataSource Stats ▁stats ▁= ▁new ▁File Format DataSource Stats ▁( ▁) ▁; ▁Hdfs Environment ▁test Hdfs Environment ▁= ▁createTest Hdfs Environment ▁( ▁hive ClientConfig ▁, ▁met astore ClientConfig ▁) ▁; ▁return ▁ImmutableSet ▁. ▁< ▁Hive Selective PageSource Factory ▁> ▁builder ▁( ▁) ▁. ▁add ▁( ▁new ▁Orc Selective PageSource Factory ▁( ▁FUNCTION _ AND _ TYPE _ MANAGER ▁, ▁FUNCTION _ RESOL UTION ▁, ▁ROW _ EX PRE SSION _ SERVICE ▁, ▁hive ClientConfig ▁, ▁test Hdfs Environment ▁, ▁stats ▁, ▁new ▁Storage Orc File Tail Source ▁( ▁) ▁, ▁new ▁Storage Stripe Metadata Source ▁( ▁) ▁, ▁new ▁TupleDomain Filter Cache ▁( ▁) ▁) ▁) ▁. ▁add ▁( ▁new ▁Dwrf Selective PageSource Factory ▁( ▁FUNCTION _ AND _ TYPE _ MANAGER ▁, ▁FUNCTION _ RESOL UTION ▁, ▁ROW _ EX PRE SSION _ SERVICE ▁, ▁hive ClientConfig ▁, ▁test Hdfs Environment ▁, ▁stats ▁, ▁new ▁Storage Orc File Tail Source ▁( ▁) ▁, ▁new ▁Storage Stripe Metadata Source ▁( ▁) ▁, ▁new ▁TupleDomain Filter Cache ▁( ▁) ▁, ▁NO _ EN CRY PTION ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁} ▁public ▁static ▁Set ▁< ▁Hive Record Cursor Provider ▁> ▁getDefault Hive Record Cursor Provider ▁( ▁Hive ClientConfig ▁hive ClientConfig ▁, ▁Met astore ClientConfig ▁met astore ClientConfig ▁) ▁{ ▁Hdfs Environment ▁test Hdfs Environment ▁= ▁createTest Hdfs Environment ▁( ▁hive ClientConfig ▁, ▁met astore ClientConfig ▁) ▁; ▁return ▁ImmutableSet ▁. ▁< ▁Hive Record Cursor Provider ▁> ▁builder ▁( ▁) ▁. ▁add ▁( ▁new ▁Generic Hive Record Cursor Provider ▁( ▁test Hdfs Environment ▁) ▁) ▁. ▁build ▁( ▁) ▁;
▁@ ▁Test Method Order ▁( ▁Method Order er ▁. ▁Order Annotation ▁. ▁class ▁) ▁public ▁class ▁Session Holder Test ▁{ ▁private ▁String ▁path name ▁; ▁@ ▁BeforeEach ▁public ▁void ▁before ▁( ▁) ▁{ ▁String ▁session Store Path ▁= ▁Session Holder ▁. ▁CONFIG ▁. ▁getConfig ▁( ▁Configuration Keys ▁. ▁STO RE _ FILE _ DIR ▁) ▁; ▁path name ▁= ▁session Store Path ▁+ ▁File ▁. ▁separator ▁+ ▁ROOT _ SESSION _ MANAGER _ NAME ▁; ▁Session Holder ▁. ▁init ▁( ▁Store Mode ▁. ▁RED IS ▁. ▁getName ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁@ ▁Order ▁( ▁1 ▁) ▁public ▁void ▁test Init ▁( ▁) ▁throws ▁IOException ▁{ ▁File ▁root Session File ▁= ▁new ▁File ▁( ▁path name ▁) ▁; ▁if ▁( ▁root Session File ▁. ▁exists ▁( ▁) ▁) ▁{ ▁root Session File ▁. ▁delete ▁( ▁) ▁; ▁} ▁final ▁String ▁mode ▁= ▁Store Mode ▁. ▁FILE ▁. ▁getName ▁( ▁) ▁; ▁Session Holder ▁. ▁init ▁( ▁mode ▁) ▁; ▁try ▁{ ▁final ▁File ▁actual ▁= ▁new ▁File ▁( ▁path name ▁) ▁; ▁Assertions ▁. ▁assertTrue ▁( ▁actual ▁. ▁exists ▁( ▁) ▁) ▁; ▁Assertions ▁. ▁assertTrue ▁( ▁actual ▁. ▁isFile ▁( ▁) ▁) ▁; ▁} ▁finally ▁{ ▁Session Holder ▁. ▁destroy ▁( ▁) ▁; ▁} ▁} ▁@ ▁AfterEach ▁public ▁void ▁after ▁( ▁) ▁{ ▁final ▁File ▁actual ▁= ▁new ▁File ▁( ▁path name ▁) ▁; ▁if ▁( ▁actual ▁. ▁exists ▁( ▁) ▁) ▁{ ▁actual ▁. ▁delete ▁( ▁) ▁; ▁} ▁} ▁@ ▁Order ▁( ▁2 ▁) ▁public ▁void ▁test _ ret ry Rollback ing Lock ▁( ▁) ▁{ ▁Assertions ▁. ▁assertEquals ▁( ▁true ▁, ▁Session Holder ▁. ▁acquire Distributed Lock ▁( ▁RETRY _ ROLL BACK ING ▁) ▁) ▁; ▁} ▁@ ▁Order ▁( ▁3 ▁) ▁public ▁void ▁test _ un Retry Rollback ing Lock ▁( ▁) ▁{ ▁Assertions ▁. ▁assertEquals ▁( ▁true ▁, ▁Session Holder ▁. ▁release Distributed Lock ▁( ▁RETRY _ ROLL BACK ING ▁) ▁) ▁; ▁} ▁@ ▁Order ▁( ▁4 ▁) ▁public ▁void ▁test _ ret ry Commit ting Lock ▁( ▁) ▁{ ▁Assertions ▁. ▁assertEquals ▁( ▁true ▁, ▁Session Holder ▁. ▁acquire Distributed Lock ▁( ▁RETRY _ COMMIT TING ▁) ▁) ▁; ▁} ▁@ ▁Order ▁( ▁5 ▁) ▁public ▁void ▁test _ un Retry Commit ting Lock ▁( ▁) ▁{ ▁Assertions ▁. ▁assertEquals ▁( ▁true ▁, ▁Session Holder ▁. ▁release Distributed Lock ▁( ▁RETRY _ COMMIT TING ▁) ▁) ▁; ▁} ▁@ ▁Order ▁( ▁6 ▁) ▁public ▁void ▁test _ as ync Commit ting Lock ▁( ▁) ▁{ ▁Assertions ▁. ▁assertEquals ▁( ▁true ▁, ▁Session Holder ▁. ▁acquire Distributed Lock ▁( ▁ASYNC _ COMMIT TING ▁) ▁) ▁; ▁} ▁@ ▁Order ▁( ▁7 ▁) ▁public ▁void ▁test _ un Async Commit ting Lock ▁( ▁) ▁{ ▁Assertions ▁. ▁assertEquals ▁( ▁true ▁, ▁Session Holder ▁. ▁release Distributed Lock ▁( ▁ASYNC _ COMMIT TING ▁) ▁) ▁; ▁}
▁@ ▁Override ▁public ▁InputType ▁getOutputType ▁( ▁int ▁layer Index ▁, ▁InputType ▁... ▁vertex Inputs ▁) ▁throws ▁Invalid Input TypeException ▁{ ▁if ▁( ▁vertex Inputs ▁. ▁length ▁== ▁1 ▁) ▁return ▁vertex Inputs ▁[ ▁0 ▁] ▁; ▁InputType Util ▁. ▁convert Multiple Types ▁( ▁vertex Inputs ▁) ▁; ▁InputType ▁first ▁= ▁vertex Inputs ▁[ ▁0 ▁] ▁; ▁if ▁( ▁first ▁. ▁getType ▁( ▁) ▁!= ▁InputType ▁. ▁Type ▁. ▁CNN ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁vertex Inputs ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁vertex Inputs ▁[ ▁i ▁] ▁. ▁getType ▁( ▁) ▁!= ▁first ▁. ▁getType ▁( ▁) ▁) ▁{ ▁throw ▁new ▁Invalid Input TypeException ▁( ▁STR ▁+ ▁STR ▁+ ▁first ▁. ▁getType ▁( ▁) ▁+ ▁STR ▁+ ▁( ▁i ▁+ ▁1 ▁) ▁+ ▁STR ▁+ ▁vertex Inputs ▁[ ▁i ▁] ▁. ▁getType ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁else ▁{ ▁InputType ▁. ▁InputType Convolution al ▁first Conv ▁= ▁( ▁InputType ▁. ▁InputType Convolution al ▁) ▁first ▁; ▁val ▁fd ▁= ▁first Conv ▁. ▁get Channels ▁( ▁) ▁; ▁val ▁fw ▁= ▁first Conv ▁. ▁getWidth ▁( ▁) ▁; ▁val ▁f h ▁= ▁first Conv ▁. ▁getHeight ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁1 ▁; ▁i ▁< ▁vertex Inputs ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁vertex Inputs ▁[ ▁i ▁] ▁. ▁getType ▁( ▁) ▁!= ▁InputType ▁. ▁Type ▁. ▁CNN ▁) ▁{ ▁throw ▁new ▁Invalid Input TypeException ▁( ▁STR ▁+ ▁STR ▁+ ▁InputType ▁. ▁Type ▁. ▁CNN ▁+ ▁STR ▁+ ▁( ▁i ▁+ ▁1 ▁) ▁+ ▁STR ▁+ ▁vertex Inputs ▁[ ▁i ▁] ▁. ▁getType ▁( ▁) ▁) ▁; ▁} ▁InputType ▁. ▁InputType Convolution al ▁other Conv ▁= ▁( ▁InputType ▁. ▁InputType Convolution al ▁) ▁vertex Inputs ▁[ ▁i ▁] ▁; ▁val ▁o d ▁= ▁other Conv ▁. ▁get Channels ▁( ▁) ▁; ▁val ▁ow ▁= ▁other Conv ▁. ▁getWidth ▁( ▁) ▁; ▁val ▁o h ▁= ▁other Conv ▁. ▁getHeight ▁( ▁) ▁; ▁if ▁( ▁fd ▁!= ▁o d ▁|| ▁fw ▁!= ▁ow ▁|| ▁f h ▁!= ▁o h ▁) ▁{ ▁throw ▁new ▁Invalid Input TypeException ▁( ▁STR ▁+ ▁STR ▁+ ▁fd ▁+ ▁STR ▁+ ▁fw ▁+ ▁STR ▁+ ▁f h ▁+ ▁STR ▁+ ▁i ▁+ ▁STR ▁+ ▁o d ▁+ ▁STR ▁+ ▁ow ▁+ ▁STR ▁+ ▁o h ▁+ ▁STR ▁) ▁; ▁} ▁} ▁} ▁if ▁( ▁vertex Inputs ▁. ▁length ▁< ▁2 ▁) ▁return ▁vertex Inputs ▁[ ▁0 ▁] ▁; ▁if ▁( ▁first ▁. ▁getType ▁( ▁) ▁== ▁InputType ▁. ▁Type ▁. ▁F F ▁) ▁{ ▁InputType ▁. ▁InputType Feed Forward ▁max Input Type ▁= ▁null ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁vertex Inputs ▁. ▁length ▁; ▁i ▁++ ▁) ▁{ ▁InputType ▁. ▁InputType Feed Forward ▁feed Forward ▁= ▁( ▁InputType ▁. ▁InputType Feed Forward ▁) ▁vertex Inputs ▁[ ▁i ▁] ▁; ▁if ▁( ▁max Input Type ▁== ▁null ▁) ▁max Input Type ▁= ▁feed Forward ▁;
▁public ▁class ▁Author ▁extends ▁Person ▁{ ▁private ▁List ▁< ▁Item ▁> ▁items ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁public ▁Author ▁( ▁String ▁firstName ▁, ▁String ▁lastName ▁) ▁{ ▁super ▁( ▁firstName ▁, ▁lastName ▁) ▁; ▁} ▁@ ▁Json Managed Reference ▁public ▁List ▁< ▁Item ▁> ▁getItems ▁( ▁) ▁{ ▁return ▁items ▁; ▁} ▁public ▁void ▁set Items ▁( ▁List ▁< ▁Item ▁> ▁items ▁) ▁{ ▁this ▁. ▁items ▁= ▁items ▁; ▁} ▁}
▁public ▁class ▁KeyValue Pair StateSerializer ▁implements ▁Accumulator StateSerializer ▁< ▁KeyValue Pairs State ▁> ▁{ ▁private ▁final ▁Map Type ▁mapType ▁; ▁public ▁KeyValue Pair StateSerializer ▁( ▁Map Type ▁mapType ▁) ▁{ ▁this ▁. ▁mapType ▁= ▁mapType ▁; ▁} ▁@ ▁Override ▁public ▁Type ▁getSerialized Type ▁( ▁) ▁{ ▁return ▁mapType ▁; ▁} ▁@ ▁Override ▁public ▁void ▁serialize ▁( ▁KeyValue Pairs State ▁state ▁, ▁BlockBuilder ▁out ▁) ▁{ ▁if ▁( ▁state ▁. ▁get ▁( ▁) ▁== ▁null ▁) ▁{ ▁out ▁. ▁appendNull ▁( ▁) ▁; ▁} ▁else ▁{ ▁state ▁. ▁get ▁( ▁) ▁. ▁serialize ▁( ▁out ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁deserialize ▁( ▁Block ▁block ▁, ▁int ▁index ▁, ▁KeyValue Pairs State ▁state ▁) ▁{ ▁state ▁. ▁set ▁( ▁new ▁KeyValue Pairs ▁( ▁mapType ▁. ▁getObject ▁( ▁block ▁, ▁index ▁) ▁, ▁state ▁. ▁getKey Type ▁( ▁) ▁, ▁state ▁. ▁getValue Type ▁( ▁) ▁) ▁) ▁; ▁} ▁}
▁output Future ▁. ▁addListener ▁( ▁listener ▁, ▁direct Executor ▁( ▁) ▁) ▁; ▁task Future ▁. ▁addListener ▁( ▁listener ▁, ▁direct Executor ▁( ▁) ▁) ▁; ▁return ▁output Future ▁; ▁} ▁enum ▁Runn ing State ▁{ ▁NOT _ RUN ▁, ▁CANCELLED ▁, ▁STARTED ▁, ▁} ▁private ▁static ▁final ▁class ▁Task Non Re entrant Executor ▁extends ▁AtomicReference ▁< ▁Runn ing State ▁> ▁implements ▁Executor ▁, ▁Runnable ▁{ ▁@ ▁CheckForNull ▁Execution Se quencer ▁se quencer ▁; ▁@ ▁CheckForNull ▁Executor ▁delegate ▁; ▁@ ▁CheckForNull ▁Runnable ▁task ▁; ▁@ ▁CheckForNull ▁Thread ▁submit ting ▁; ▁private ▁Task Non Re entrant Executor ▁( ▁Executor ▁delegate ▁, ▁Execution Se quencer ▁se quencer ▁) ▁{ ▁super ▁( ▁NOT _ RUN ▁) ▁; ▁this ▁. ▁delegate ▁= ▁delegate ▁; ▁this ▁. ▁se quencer ▁= ▁se quencer ▁; ▁} ▁@ ▁Override ▁public ▁void ▁execute ▁( ▁Runnable ▁task ▁) ▁{ ▁if ▁( ▁get ▁( ▁) ▁== ▁Runn ing State ▁. ▁CANCELLED ▁) ▁{ ▁delegate ▁= ▁null ▁; ▁se quencer ▁= ▁null ▁; ▁return ▁; ▁} ▁submit ting ▁= ▁Thread ▁. ▁currentThread ▁( ▁) ▁; ▁try ▁{ ▁Thread Conf ined Task Queue ▁submit ting Task Queue ▁= ▁requireNonNull ▁( ▁se quencer ▁) ▁. ▁latest Task Queue ▁; ▁if ▁( ▁submit ting Task Queue ▁. ▁thread ▁== ▁submit ting ▁) ▁{ ▁se quencer ▁= ▁null ▁; ▁checkState ▁( ▁submit ting Task Queue ▁. ▁next Task ▁== ▁null ▁) ▁; ▁submit ting Task Queue ▁. ▁next Task ▁= ▁task ▁; ▁submit ting Task Queue ▁. ▁next Executor ▁= ▁requireNonNull ▁( ▁delegate ▁) ▁; ▁delegate ▁= ▁null ▁; ▁} ▁else ▁{ ▁Executor ▁local Delegate ▁= ▁requireNonNull ▁( ▁delegate ▁) ▁; ▁delegate ▁= ▁null ▁; ▁this ▁. ▁task ▁= ▁task ▁; ▁local Delegate ▁. ▁execute ▁( ▁this ▁) ▁; ▁} ▁} ▁finally ▁{ ▁submit ting ▁= ▁null ▁; ▁} ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁@ ▁Override ▁public ▁void ▁run ▁( ▁) ▁{ ▁Thread ▁currentThread ▁= ▁Thread ▁. ▁currentThread ▁( ▁) ▁; ▁if ▁( ▁currentThread ▁!= ▁submit ting ▁) ▁{ ▁Runnable ▁local Task ▁= ▁requireNonNull ▁( ▁task ▁) ▁; ▁task ▁= ▁null ▁; ▁local Task ▁. ▁run ▁( ▁) ▁; ▁return ▁; ▁} ▁Thread Conf ined Task Queue ▁execut ing Task Queue ▁= ▁new ▁Thread Conf ined Task Queue ▁( ▁) ▁; ▁execut ing Task Queue ▁. ▁thread ▁= ▁currentThread ▁; ▁requireNonNull ▁( ▁se quencer ▁) ▁. ▁latest Task Queue ▁= ▁execut ing Task Queue ▁; ▁se quencer ▁= ▁null ▁; ▁try ▁{ ▁Runnable ▁local Task ▁= ▁requireNonNull ▁( ▁task ▁) ▁; ▁task ▁= ▁null ▁; ▁local Task ▁. ▁run ▁( ▁) ▁; ▁Runnable ▁queue d Task ▁; ▁Executor ▁queue d Executor ▁; ▁while ▁( ▁( ▁queue d Task ▁= ▁execut ing Task Queue ▁. ▁next Task ▁) ▁!= ▁null ▁& ▁( ▁queue d Executor ▁= ▁execut ing Task Queue ▁. ▁next Executor ▁) ▁!= ▁null ▁) ▁{ ▁execut ing Task Queue ▁. ▁next Task ▁= ▁null ▁; ▁execut ing Task Queue ▁. ▁next Executor ▁= ▁null ▁; ▁queue d Executor ▁. ▁execute ▁( ▁queue d Task ▁) ▁; ▁} ▁} ▁finally ▁{ ▁execut ing Task Queue ▁. ▁thread ▁= ▁null ▁; ▁} ▁}
▁public ▁class ▁Ph i List Attr ▁implements ▁I Attribute ▁{ ▁private ▁final ▁List ▁< ▁Ph i Insn ▁> ▁list ▁= ▁new ▁LinkedList ▁< ▁> ▁( ▁) ▁; ▁@ ▁Override ▁public ▁AType ▁< ▁Ph i List Attr ▁> ▁getType ▁( ▁) ▁{ ▁return ▁AType ▁. ▁P H I _ LIST ▁; ▁} ▁public ▁List ▁< ▁Ph i Insn ▁> ▁getList ▁( ▁) ▁{ ▁return ▁list ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁StringBuilder ▁sb ▁= ▁new ▁StringBuilder ▁( ▁) ▁; ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁for ▁( ▁Ph i Insn ▁phi Insn ▁: ▁list ▁) ▁{ ▁sb ▁. ▁append ▁( ▁CHAR ▁) ▁. ▁append ▁( ▁phi Insn ▁. ▁getResult ▁( ▁) ▁. ▁getReg Num ▁( ▁) ▁) ▁. ▁append ▁( ▁CHAR ▁) ▁; ▁} ▁for ▁( ▁Ph i Insn ▁phi Insn ▁: ▁list ▁) ▁{ ▁sb ▁. ▁append ▁( ▁ICode Writer ▁. ▁N L ▁) ▁. ▁append ▁( ▁STR ▁) ▁. ▁append ▁( ▁phi Insn ▁) ▁. ▁append ▁( ▁CHAR ▁) ▁. ▁append ▁( ▁phi Insn ▁. ▁getAttributes String ▁( ▁) ▁) ▁; ▁} ▁return ▁sb ▁. ▁toString ▁( ▁) ▁; ▁} ▁}
▁public ▁class ▁Reflection TestUtils UnitTest ▁{ ▁@ ▁Test ▁public ▁void ▁when Non Public Field _ then Reflection TestUtils Set Field ▁( ▁) ▁{ ▁Employee ▁employee ▁= ▁new ▁Employee ▁( ▁) ▁; ▁Reflection TestUtils ▁. ▁setField ▁( ▁employee ▁, ▁STR ▁, ▁1 ▁) ▁; ▁assertTrue ▁( ▁employee ▁. ▁getId ▁( ▁) ▁. ▁equals ▁( ▁1 ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁when Non Public Method _ then Reflection TestUtils Invoke Method ▁( ▁) ▁{ ▁Employee ▁employee ▁= ▁new ▁Employee ▁( ▁) ▁; ▁Reflection TestUtils ▁. ▁setField ▁( ▁employee ▁, ▁STR ▁, ▁1 ▁) ▁; ▁employee ▁. ▁setName ▁( ▁STR ▁) ▁; ▁assertTrue ▁( ▁Reflection TestUtils ▁. ▁invoke Method ▁( ▁employee ▁, ▁STR ▁) ▁. ▁equals ▁( ▁STR ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁when Inject ing Mock Of Dependency _ then Reflection TestUtils Set Field ▁( ▁) ▁{ ▁Employee ▁employee ▁= ▁new ▁Employee ▁( ▁) ▁; ▁Reflection TestUtils ▁. ▁setField ▁( ▁employee ▁, ▁STR ▁, ▁1 ▁) ▁; ▁employee ▁. ▁setName ▁( ▁STR ▁) ▁; ▁H R Service ▁h r Service ▁= ▁mock ▁( ▁H R Service ▁. ▁class ▁) ▁; ▁when ▁( ▁h r Service ▁. ▁getE mployee Status ▁( ▁employee ▁. ▁getId ▁( ▁) ▁) ▁) ▁. ▁thenReturn ▁( ▁STR ▁) ▁; ▁Employee Service ▁employee Service ▁= ▁new ▁Employee Service ▁( ▁) ▁; ▁Reflection TestUtils ▁. ▁setField ▁( ▁employee Service ▁, ▁STR ▁, ▁h r Service ▁) ▁; ▁assertEquals ▁( ▁STR ▁+ ▁employee ▁. ▁getId ▁( ▁) ▁+ ▁STR ▁, ▁employee Service ▁. ▁find Employee Status ▁( ▁employee ▁. ▁getId ▁( ▁) ▁) ▁) ▁; ▁} ▁}
▁public ▁class ▁Test Queue Placement Policy ▁{ ▁private ▁final ▁static ▁F airScheduler Configuration ▁CONF ▁= ▁new ▁F airScheduler Configuration ▁( ▁) ▁; ▁private ▁Placement Manager ▁place ment Manager ▁; ▁private ▁F airScheduler ▁scheduler ▁; ▁private ▁Queue Manager ▁queue Manager ▁; ▁private ▁Application Submission Context ▁asc ▁; ▁private ▁Application Placement Context ▁context ▁; ▁@ ▁BeforeClass ▁public ▁static ▁void ▁setup ▁( ▁) ▁{ ▁CONF ▁. ▁setClass ▁( ▁Common Configuration Keys ▁. ▁HADOOP _ SECURITY _ GROUP _ MAPPING ▁, ▁Simple Groups Mapping ▁. ▁class ▁, ▁Group Mapping ServiceProvider ▁. ▁class ▁) ▁; ▁} ▁@ ▁Before ▁public ▁void ▁init Test ▁( ▁) ▁{ ▁SystemClock ▁clock ▁= ▁SystemClock ▁. ▁getInstance ▁( ▁) ▁; ▁RM Context ▁rm Context ▁= ▁mock ▁( ▁RM Context ▁. ▁class ▁) ▁; ▁place ment Manager ▁= ▁new ▁Placement Manager ▁( ▁) ▁; ▁scheduler ▁= ▁mock ▁( ▁F airScheduler ▁. ▁class ▁) ▁; ▁when ▁( ▁scheduler ▁. ▁getC lock ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁clock ▁) ▁; ▁when ▁( ▁scheduler ▁. ▁getRM Context ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁rm Context ▁) ▁; ▁when ▁( ▁scheduler ▁. ▁getConfig ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁CONF ▁) ▁; ▁when ▁( ▁scheduler ▁. ▁getConf ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁CONF ▁) ▁; ▁when ▁( ▁rm Context ▁. ▁getQueue Placement Manager ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁place ment Manager ▁) ▁; ▁Allocation Configuration ▁alloc Conf ▁= ▁new ▁Allocation Configuration ▁( ▁scheduler ▁) ▁; ▁when ▁( ▁scheduler ▁. ▁get Allocation Configuration ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁alloc Conf ▁) ▁; ▁queue Manager ▁= ▁new ▁Queue Manager ▁( ▁scheduler ▁) ▁; ▁queue Manager ▁. ▁initialize ▁( ▁) ▁; ▁when ▁( ▁scheduler ▁. ▁getQueue Manager ▁( ▁) ▁) ▁. ▁thenReturn ▁( ▁queue Manager ▁) ▁; ▁} ▁@ ▁After ▁public ▁void ▁clean Test ▁( ▁) ▁{ ▁place ment Manager ▁= ▁null ▁; ▁queue Manager ▁= ▁null ▁; ▁scheduler ▁= ▁null ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Specified User Policy ▁( ▁) ▁throws ▁Exception ▁{ ▁StringBuffer ▁sb ▁= ▁new ▁StringBuffer ▁( ▁) ▁; ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁create Policy ▁( ▁sb ▁. ▁toString ▁( ▁) ▁) ▁; ▁asc ▁= ▁new App Submission Context ▁( ▁STR ▁) ▁; ▁context ▁= ▁place ment Manager ▁. ▁place Application ▁( ▁asc ▁, ▁STR ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁context ▁. ▁getQueue ▁( ▁) ▁) ▁; ▁asc ▁= ▁new App Submission Context ▁( ▁STR ▁) ▁; ▁context ▁= ▁place ment Manager ▁. ▁place Application ▁( ▁asc ▁, ▁STR ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁context ▁. ▁getQueue ▁( ▁) ▁) ▁; ▁context ▁= ▁place ment Manager ▁. ▁place Application ▁( ▁asc ▁, ▁STR ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁context ▁. ▁getQueue ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testNo Create ▁( ▁) ▁throws ▁Exception ▁{ ▁StringBuffer ▁sb ▁= ▁new ▁StringBuffer ▁( ▁) ▁; ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁sb ▁. ▁append ▁( ▁STR ▁) ▁; ▁sb ▁. ▁append ▁( ▁STR ▁) ▁;
▁Variable X Ref FieldLocation ▁var X Ref Loc ▁= ▁( ▁Variable X Ref FieldLocation ▁) ▁loc ▁; ▁if ▁( ▁var X Ref Loc ▁. ▁is Location For ▁( ▁sv ▁) ▁) ▁{ ▁return ▁create FieldLocation ▁( ▁var X Ref Loc ▁. ▁getChar Offset ▁( ▁) ▁, ▁var X Ref Loc ▁. ▁getIndex ▁( ▁) ▁, ▁( ▁Listing TextField ▁) ▁bf ▁, ▁index ▁, ▁field Num ▁) ▁; ▁} ▁} ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁ProgramLocation ▁getProgram Location ▁( ▁int ▁row ▁, ▁int ▁col ▁, ▁Listing Field ▁bf ▁) ▁{ ▁Object ▁obj ▁= ▁bf ▁. ▁getProxy ▁( ▁) ▁. ▁getObject ▁( ▁) ▁; ▁if ▁( ▁! ▁( ▁obj ▁instanceof ▁Variable ▁) ▁) ▁{ ▁return ▁null ▁; ▁} ▁Listing TextField ▁field ▁= ▁( ▁Listing TextField ▁) ▁getField ▁( ▁bf ▁. ▁getProxy ▁( ▁) ▁, ▁0 ▁) ▁; ▁if ▁( ▁field ▁!= ▁null ▁) ▁{ ▁Row Col Location ▁loc ▁= ▁field ▁. ▁screen To Data Location ▁( ▁row ▁, ▁col ▁) ▁; ▁int ▁index ▁= ▁loc ▁. ▁row ▁( ▁) ▁; ▁Variable ▁var ▁= ▁( ▁Variable ▁) ▁obj ▁; ▁List ▁< ▁Reference ▁> ▁x re fs ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁List ▁< ▁Reference ▁> ▁off cut s ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁X Reference Util ▁. ▁getVariable Refs ▁( ▁var ▁, ▁x re fs ▁, ▁off cut s ▁) ▁; ▁Reference ▁ref ▁= ▁null ▁; ▁if ▁( ▁index ▁< ▁x re fs ▁. ▁size ▁( ▁) ▁) ▁{ ▁ref ▁= ▁x re fs ▁. ▁get ▁( ▁index ▁) ▁; ▁} ▁else ▁if ▁( ▁index ▁< ▁x re fs ▁. ▁size ▁( ▁) ▁+ ▁off cut s ▁. ▁size ▁( ▁) ▁) ▁{ ▁ref ▁= ▁off cut s ▁. ▁get ▁( ▁index ▁- ▁x re fs ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁if ▁( ▁ref ▁!= ▁null ▁) ▁{ ▁Address ▁ref Addr ▁= ▁ref ▁. ▁getFrom Address ▁( ▁) ▁; ▁return ▁new ▁Variable X Ref FieldLocation ▁( ▁var ▁. ▁getProgram ▁( ▁) ▁, ▁var ▁, ▁ref Addr ▁, ▁index ▁, ▁loc ▁. ▁col ▁( ▁) ▁) ▁; ▁} ▁} ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁accepts Type ▁( ▁int ▁category ▁, ▁Class ▁< ▁? ▁> ▁proxy Object Class ▁) ▁{ ▁if ▁( ▁! ▁Variable ▁. ▁class ▁. ▁isAssignable From ▁( ▁proxy Object Class ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁return ▁( ▁category ▁== ▁Field Format Model ▁. ▁FUNCTION _ VAR S ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Field Factory ▁newInstance ▁( ▁Field Format Model ▁format Model ▁, ▁Highlight Provider ▁provider ▁, ▁ToolOptions ▁display Options ▁, ▁ToolOptions ▁field Options ▁) ▁{ ▁return ▁new ▁Variable X Ref FieldFactory ▁( ▁format Model ▁, ▁provider ▁, ▁display Options ▁, ▁field Options ▁) ▁; ▁} ▁}
▁public ▁class ▁Memory Poll uter ▁{ ▁private ▁static ▁final ▁int ▁ME G ABYTE _ IN _ BYTES ▁= ▁1024 ▁ * ▁1024 ▁; ▁private ▁static ▁final ▁int ▁ITER ATION _ COUNT ▁= ▁1024 ▁ * ▁10 ▁; ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ITER ATION _ COUNT ▁; ▁i ▁++ ▁) ▁{ ▁byte ▁[ ▁] ▁array ▁= ▁new ▁byte ▁[ ▁ME G ABYTE _ IN _ BYTES ▁] ▁; ▁} ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁) ▁; ▁} ▁}
▁public ▁class ▁Sparse File Tracker Tests ▁extends ▁ESTestCase ▁{ ▁private ▁static ▁final ▁byte ▁UN AVAILABLE ▁= ▁( ▁byte ▁) ▁0 x 00 ▁; ▁private ▁static ▁final ▁byte ▁AV AILABLE ▁= ▁( ▁byte ▁) ▁0 xff ▁; ▁public ▁void ▁testInvalid Length ▁( ▁) ▁{ ▁IllegalArgument Exception ▁e ▁= ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁new ▁Sparse File Tracker ▁( ▁STR ▁, ▁- ▁1 L ▁) ▁) ▁; ▁assertThat ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁} ▁public ▁void ▁testInvalid Range ▁( ▁) ▁{ ▁final ▁byte ▁[ ▁] ▁file Contents ▁= ▁new ▁byte ▁[ ▁between ▁( ▁0 ▁, ▁1000 ▁) ▁] ▁; ▁final ▁long ▁length ▁= ▁file Contents ▁. ▁length ▁; ▁final ▁Sparse File Tracker ▁sp arse File Tracker ▁= ▁new ▁Sparse File Tracker ▁( ▁STR ▁, ▁length ▁) ▁; ▁final ▁AtomicBoolean ▁invok ed ▁= ▁new ▁AtomicBoolean ▁( ▁false ▁) ▁; ▁final ▁ActionListener ▁< ▁Void ▁> ▁listener ▁= ▁ActionListener ▁. ▁wrap ▁( ▁( ▁) ▁-> ▁invok ed ▁. ▁set ▁( ▁true ▁) ▁) ▁; ▁assertThat ▁( ▁invok ed ▁. ▁get ▁( ▁) ▁, ▁is ▁( ▁false ▁) ▁) ▁; ▁IllegalArgument Exception ▁e ▁= ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁sp arse File Tracker ▁. ▁waitFor Range ▁( ▁Byte Range ▁. ▁of ▁( ▁randomLong Between ▁( ▁0 L ▁, ▁Math ▁. ▁max ▁( ▁0 L ▁, ▁length ▁- ▁1 L ▁) ▁) ▁, ▁length ▁+ ▁1 L ▁) ▁, ▁null ▁, ▁listener ▁) ▁) ▁; ▁assertThat ▁( ▁STR ▁, ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁invok ed ▁. ▁get ▁( ▁) ▁, ▁is ▁( ▁false ▁) ▁) ▁; ▁if ▁( ▁length ▁> ▁1 L ▁) ▁{ ▁e ▁= ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁{ ▁long ▁start ▁= ▁randomLong Between ▁( ▁1 L ▁, ▁Math ▁. ▁max ▁( ▁1 L ▁, ▁length ▁- ▁1 L ▁) ▁) ▁; ▁long ▁end ▁= ▁randomLong Between ▁( ▁length ▁+ ▁1 ▁, ▁length ▁+ ▁1000 L ▁) ▁; ▁sp arse File Tracker ▁. ▁waitFor Range ▁( ▁Byte Range ▁. ▁of ▁( ▁start ▁, ▁end ▁) ▁, ▁null ▁, ▁listener ▁) ▁; ▁} ▁) ▁; ▁assertThat ▁( ▁STR ▁, ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁invok ed ▁. ▁get ▁( ▁) ▁, ▁is ▁( ▁false ▁) ▁) ▁; ▁final ▁long ▁start ▁= ▁randomLong Between ▁( ▁0 L ▁, ▁length ▁- ▁1 L ▁) ▁; ▁final ▁long ▁end ▁= ▁randomLong Between ▁( ▁start ▁+ ▁1 L ▁, ▁length ▁) ▁; ▁if ▁( ▁start ▁> ▁0 L ▁) ▁{ ▁e ▁= ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁sp arse File Tracker ▁. ▁waitFor Range ▁( ▁Byte Range ▁. ▁of ▁( ▁start ▁, ▁end ▁) ▁, ▁Byte Range ▁. ▁of ▁( ▁start ▁- ▁1 L ▁, ▁end ▁) ▁, ▁listener ▁) ▁) ▁; ▁assertThat ▁( ▁STR ▁, ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁;
▁public ▁final ▁class ▁RowExpression Formatter ▁{ ▁private ▁final ▁Function MetadataManager ▁function MetadataManager ▁; ▁private ▁final ▁Standard Function Resolution ▁standard Function Resolution ▁; ▁public ▁RowExpression Formatter ▁( ▁Function AndTypeManager ▁function AndTypeManager ▁) ▁{ ▁this ▁. ▁function MetadataManager ▁= ▁requireNonNull ▁( ▁function AndTypeManager ▁, ▁STR ▁) ▁; ▁this ▁. ▁standard Function Resolution ▁= ▁new ▁Function Resolution ▁( ▁function AndTypeManager ▁) ▁; ▁} ▁public ▁String ▁format Row Expression ▁( ▁Connector Session ▁session ▁, ▁RowExpression ▁expression ▁) ▁{ ▁return ▁expression ▁. ▁accept ▁( ▁new ▁Formatter ▁( ▁) ▁, ▁requireNonNull ▁( ▁session ▁, ▁STR ▁) ▁) ▁; ▁} ▁private ▁List ▁< ▁String ▁> ▁format Row Expressions ▁( ▁Connector Session ▁session ▁, ▁List ▁< ▁RowExpression ▁> ▁row Expressions ▁) ▁{ ▁return ▁row Expressions ▁. ▁stream ▁( ▁) ▁. ▁map ▁( ▁row Expression ▁-> ▁format Row Expression ▁( ▁session ▁, ▁row Expression ▁) ▁) ▁. ▁collect ▁( ▁toList ▁( ▁) ▁) ▁; ▁} ▁public ▁class ▁Formatter ▁implements ▁RowExpression Visitor ▁< ▁String ▁, ▁Connector Session ▁> ▁{ ▁@ ▁Override ▁public ▁String ▁visit Call ▁( ▁CallExpression ▁node ▁, ▁Connector Session ▁session ▁) ▁{ ▁if ▁( ▁standard Function Resolution ▁. ▁isA rithmetic Function ▁( ▁node ▁. ▁getFunction Handle ▁( ▁) ▁) ▁|| ▁standard Function Resolution ▁. ▁is Comparison Function ▁( ▁node ▁. ▁getFunction Handle ▁( ▁) ▁) ▁) ▁{ ▁String ▁operation ▁= ▁function MetadataManager ▁. ▁getFunction Metadata ▁( ▁node ▁. ▁getFunction Handle ▁( ▁) ▁) ▁. ▁getOperator Type ▁( ▁) ▁. ▁get ▁( ▁) ▁. ▁getOperator ▁( ▁) ▁; ▁return ▁String ▁. ▁join ▁( ▁STR ▁+ ▁operation ▁+ ▁STR ▁, ▁format Row Expressions ▁( ▁session ▁, ▁node ▁. ▁getArguments ▁( ▁) ▁) ▁. ▁stream ▁( ▁) ▁. ▁map ▁( ▁e ▁-> ▁STR ▁+ ▁e ▁+ ▁STR ▁) ▁. ▁collect ▁( ▁toImmutableList ▁( ▁) ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁standard Function Resolution ▁. ▁isC ast Function ▁( ▁node ▁. ▁getFunction Handle ▁( ▁) ▁) ▁) ▁{ ▁return ▁String ▁. ▁format ▁( ▁STR ▁, ▁format Row Expression ▁( ▁session ▁, ▁node ▁. ▁getArguments ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁) ▁, ▁node ▁. ▁getType ▁( ▁) ▁. ▁getDisplayName ▁( ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁standard Function Resolution ▁. ▁is Neg ate Function ▁( ▁node ▁. ▁getFunction Handle ▁( ▁) ▁) ▁) ▁{ ▁return ▁STR ▁+ ▁format Row Expression ▁( ▁session ▁, ▁node ▁. ▁getArguments ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁) ▁+ ▁STR ▁; ▁} ▁else ▁if ▁( ▁standard Function Resolution ▁. ▁is Sub s cript Function ▁( ▁node ▁. ▁getFunction Handle ▁( ▁) ▁) ▁) ▁{ ▁return ▁format Row Expression ▁( ▁session ▁, ▁node ▁. ▁getArguments ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁) ▁+ ▁STR ▁+ ▁format Row Expression ▁( ▁session ▁, ▁node ▁. ▁getArguments ▁( ▁) ▁. ▁get ▁( ▁1 ▁) ▁) ▁+ ▁STR ▁; ▁} ▁else ▁if ▁( ▁standard Function Resolution ▁. ▁is Between Function ▁( ▁node ▁. ▁getFunction Handle ▁( ▁) ▁) ▁) ▁{ ▁List ▁< ▁String ▁> ▁formatted Expressions ▁= ▁format Row Expressions ▁( ▁session ▁, ▁node ▁. ▁getArguments ▁( ▁) ▁) ▁;
▁private ▁Abstract BeanDefinition ▁parse Advice ▁( ▁String ▁aspect Name ▁, ▁int ▁order ▁, ▁Element ▁aspect Element ▁, ▁Element ▁advice Element ▁, ▁ParserContext ▁parserContext ▁, ▁List ▁< ▁BeanDefinition ▁> ▁bean Definitions ▁, ▁List ▁< ▁Bean Reference ▁> ▁bean References ▁) ▁{ ▁try ▁{ ▁this ▁. ▁parse State ▁. ▁push ▁( ▁new ▁Advice Entry ▁( ▁parserContext ▁. ▁getDelegate ▁( ▁) ▁. ▁getLocal Name ▁( ▁advice Element ▁) ▁) ▁) ▁; ▁Root BeanDefinition ▁method Definition ▁= ▁new ▁Root BeanDefinition ▁( ▁Method Loc ating FactoryBean ▁. ▁class ▁) ▁; ▁method Definition ▁. ▁getProperty Values ▁( ▁) ▁. ▁add ▁( ▁STR ▁, ▁aspect Name ▁) ▁; ▁method Definition ▁. ▁getProperty Values ▁( ▁) ▁. ▁add ▁( ▁STR ▁, ▁advice Element ▁. ▁getAttribute ▁( ▁STR ▁) ▁) ▁; ▁method Definition ▁. ▁setS yn thetic ▁( ▁true ▁) ▁; ▁Root BeanDefinition ▁aspect Factory Def ▁= ▁new ▁Root BeanDefinition ▁( ▁Simple BeanFactory Aware Aspect Instance Factory ▁. ▁class ▁) ▁; ▁aspect Factory Def ▁. ▁getProperty Values ▁( ▁) ▁. ▁add ▁( ▁STR ▁, ▁aspect Name ▁) ▁; ▁aspect Factory Def ▁. ▁setS yn thetic ▁( ▁true ▁) ▁; ▁Abstract BeanDefinition ▁advice Def ▁= ▁create Advice Definition ▁( ▁advice Element ▁, ▁parserContext ▁, ▁aspect Name ▁, ▁order ▁, ▁method Definition ▁, ▁aspect Factory Def ▁, ▁bean Definitions ▁, ▁bean References ▁) ▁; ▁Root BeanDefinition ▁advisor Definition ▁= ▁new ▁Root BeanDefinition ▁( ▁AspectJ Pointcut Advisor ▁. ▁class ▁) ▁; ▁advisor Definition ▁. ▁setSource ▁( ▁parserContext ▁. ▁extract Source ▁( ▁advice Element ▁) ▁) ▁; ▁advisor Definition ▁. ▁getConstructor Argument Values ▁( ▁) ▁. ▁add Generic Argument Value ▁( ▁advice Def ▁) ▁; ▁if ▁( ▁aspect Element ▁. ▁has Attribute ▁( ▁ORDER _ PROPERTY ▁) ▁) ▁{ ▁advisor Definition ▁. ▁getProperty Values ▁( ▁) ▁. ▁add ▁( ▁ORDER _ PROPERTY ▁, ▁aspect Element ▁. ▁getAttribute ▁( ▁ORDER _ PROPERTY ▁) ▁) ▁; ▁} ▁parserContext ▁. ▁get ReaderContext ▁( ▁) ▁. ▁register With Generated Name ▁( ▁advisor Definition ▁) ▁; ▁return ▁advisor Definition ▁; ▁} ▁finally ▁{ ▁this ▁. ▁parse State ▁. ▁pop ▁( ▁) ▁; ▁} ▁} ▁private ▁Abstract BeanDefinition ▁create Advice Definition ▁( ▁Element ▁advice Element ▁, ▁ParserContext ▁parserContext ▁, ▁String ▁aspect Name ▁, ▁int ▁order ▁, ▁Root BeanDefinition ▁method Def ▁, ▁Root BeanDefinition ▁aspect Factory Def ▁, ▁List ▁< ▁BeanDefinition ▁> ▁bean Definitions ▁, ▁List ▁< ▁Bean Reference ▁> ▁bean References ▁) ▁{ ▁Root BeanDefinition ▁advice Definition ▁= ▁new ▁Root BeanDefinition ▁( ▁get Advice Class ▁( ▁advice Element ▁, ▁parserContext ▁) ▁) ▁; ▁advice Definition ▁. ▁setSource ▁( ▁parserContext ▁. ▁extract Source ▁( ▁advice Element ▁) ▁) ▁; ▁advice Definition ▁. ▁getProperty Values ▁( ▁) ▁. ▁add ▁( ▁A SPE CT _ NAME _ PROPERTY ▁, ▁aspect Name ▁) ▁; ▁advice Definition ▁. ▁getProperty Values ▁( ▁) ▁. ▁add ▁( ▁DE CL AR ATION _ ORDER _ PROPERTY ▁, ▁order ▁) ▁; ▁if ▁( ▁advice Element ▁. ▁has Attribute ▁( ▁RETURN ING ▁) ▁) ▁{ ▁advice Definition ▁. ▁getProperty Values ▁( ▁) ▁. ▁add ▁( ▁RETURN ING _ PROPERTY ▁, ▁advice Element ▁. ▁getAttribute ▁( ▁RETURN ING ▁) ▁) ▁; ▁}
▁public ▁class ▁Http sTest ▁{ ▁@ ▁Test ▁@ ▁Ignore ▁public ▁void ▁getTest ▁( ▁) ▁{ ▁final ▁AtomicInteger ▁count ▁= ▁new ▁AtomicInteger ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁100 ▁; ▁i ▁++ ▁) ▁{ ▁Thread Util ▁. ▁execute ▁( ▁( ▁) ▁-> ▁{ ▁final ▁String ▁s ▁= ▁Http Util ▁. ▁get ▁( ▁STR ▁) ▁; ▁Console ▁. ▁log ▁( ▁count ▁. ▁incrementAndGet ▁( ▁) ▁) ▁; ▁} ▁) ▁; ▁} ▁Thread Util ▁. ▁sync ▁( ▁this ▁) ▁; ▁} ▁}
▁@ ▁RunWith ▁( ▁MockitoJUnit Runner ▁. ▁class ▁) ▁public ▁class ▁Kubernetes Discovery Service Test ▁{ ▁private ▁String ▁config Service Config Name ▁= ▁STR ▁; ▁private ▁String ▁admin Service Config Name ▁= ▁STR ▁; ▁@ ▁Mock ▁private ▁B iz Config ▁b iz Config ▁; ▁private ▁Kubernetes Discovery Service ▁k ubernetes Discovery Service ▁; ▁@ ▁Before ▁public ▁void ▁setUp ▁( ▁) ▁throws ▁Exception ▁{ ▁k ubernetes Discovery Service ▁= ▁new ▁Kubernetes Discovery Service ▁( ▁b iz Config ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testGet ServiceInstance sWith Invalid ServiceId ▁( ▁) ▁{ ▁String ▁some Invalid ServiceId ▁= ▁STR ▁; ▁assertTrue ▁( ▁k ubernetes Discovery Service ▁. ▁getService Instances ▁( ▁some Invalid ServiceId ▁) ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testGet ServiceInstance sWith Null Config ▁( ▁) ▁{ ▁when ▁( ▁b iz Config ▁. ▁getValue ▁( ▁config Service Config Name ▁) ▁) ▁. ▁thenReturn ▁( ▁null ▁) ▁; ▁assertTrue ▁( ▁k ubernetes Discovery Service ▁. ▁getService Instances ▁( ▁Service Name Consts ▁. ▁A POL LO _ CONFIG SERVICE ▁) ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁verify ▁( ▁b iz Config ▁, ▁times ▁( ▁1 ▁) ▁) ▁. ▁getValue ▁( ▁config Service Config Name ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testGet Config Service Instances ▁( ▁) ▁{ ▁String ▁some Url ▁= ▁STR ▁; ▁when ▁( ▁b iz Config ▁. ▁getValue ▁( ▁config Service Config Name ▁) ▁) ▁. ▁thenReturn ▁( ▁some Url ▁) ▁; ▁List ▁< ▁Service DTO ▁> ▁service DTO List ▁= ▁k ubernetes Discovery Service ▁. ▁getService Instances ▁( ▁Service Name Consts ▁. ▁A POL LO _ CONFIG SERVICE ▁) ▁; ▁assertEquals ▁( ▁1 ▁, ▁service DTO List ▁. ▁size ▁( ▁) ▁) ▁; ▁Service DTO ▁service DTO ▁= ▁service DTO List ▁. ▁get ▁( ▁0 ▁) ▁; ▁assertEquals ▁( ▁Service Name Consts ▁. ▁A POL LO _ CONFIG SERVICE ▁, ▁service DTO ▁. ▁getApp Name ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁String ▁. ▁format ▁( ▁STR ▁, ▁Service Name Consts ▁. ▁A POL LO _ CONFIG SERVICE ▁, ▁some Url ▁) ▁, ▁service DTO ▁. ▁getInstance Id ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁some Url ▁, ▁service DTO ▁. ▁getH om ep age Url ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testGet Admin Service Instances ▁( ▁) ▁{ ▁String ▁some Url ▁= ▁STR ▁; ▁String ▁another Url ▁= ▁STR ▁; ▁when ▁( ▁b iz Config ▁. ▁getValue ▁( ▁admin Service Config Name ▁) ▁) ▁. ▁thenReturn ▁( ▁String ▁. ▁format ▁( ▁STR ▁, ▁some Url ▁, ▁another Url ▁) ▁) ▁; ▁List ▁< ▁Service DTO ▁> ▁service DTO List ▁= ▁k ubernetes Discovery Service ▁. ▁getService Instances ▁( ▁Service Name Consts ▁. ▁A POL LO _ AD MIN SERVICE ▁) ▁; ▁assertEquals ▁( ▁2 ▁, ▁service DTO List ▁. ▁size ▁( ▁) ▁) ▁; ▁Service DTO ▁service DTO ▁= ▁service DTO List ▁. ▁get ▁( ▁0 ▁) ▁; ▁assertEquals ▁( ▁Service Name Consts ▁. ▁A POL LO _ AD MIN SERVICE ▁, ▁service DTO ▁. ▁getApp Name ▁( ▁) ▁) ▁;
▁assertThat ▁( ▁restart ing ▁. ▁getJob Status ▁( ▁) ▁, ▁is ▁( ▁JobStatus ▁. ▁RE STAR TING ▁) ▁) ▁; ▁assertThat ▁( ▁restart ing ▁. ▁getJob ▁( ▁) ▁. ▁getState ▁( ▁) ▁, ▁is ▁( ▁JobStatus ▁. ▁RE STAR TING ▁) ▁) ▁; ▁assertThat ▁( ▁restart ing ▁. ▁getJob ▁( ▁) ▁. ▁getStatus Timestamp ▁( ▁JobStatus ▁. ▁CANCE LED ▁) ▁, ▁is ▁( ▁0 L ▁) ▁) ▁; ▁} ▁} ▁public ▁Restart ing ▁create Restart ing State ▁( ▁Mock Restart ing Context ▁ctx ▁, ▁ExecutionGraph ▁executionGraph ▁) ▁{ ▁final ▁ExecutionGraph Handler ▁executionGraph Handler ▁= ▁new ▁ExecutionGraph Handler ▁( ▁executionGraph ▁, ▁log ▁, ▁ctx ▁. ▁getMain ThreadExecutor ▁( ▁) ▁, ▁ctx ▁. ▁getMain ThreadExecutor ▁( ▁) ▁) ▁; ▁final ▁Operator Coordinator Handler ▁operator Coordinator Handler ▁= ▁new ▁Testing Operator Coordinator Handler ▁( ▁) ▁; ▁executionGraph ▁. ▁transitionTo Running ▁( ▁) ▁; ▁return ▁new ▁Restart ing ▁( ▁ctx ▁, ▁executionGraph ▁, ▁executionGraph Handler ▁, ▁operator Coordinator Handler ▁, ▁log ▁, ▁Duration ▁. ▁ Z ERO ▁) ▁; ▁} ▁public ▁Restart ing ▁create Restart ing State ▁( ▁Mock Restart ing Context ▁ctx ▁) ▁throws ▁Job Exception ▁, ▁Job Execution Exception ▁{ ▁return ▁create Restart ing State ▁( ▁ctx ▁, ▁new ▁State Tracking Mock ExecutionGraph ▁( ▁) ▁) ▁; ▁} ▁private ▁static ▁class ▁Mock Restart ing Context ▁extends ▁Mock State With ExecutionGraph Context ▁implements ▁Restart ing ▁. ▁Context ▁{ ▁private ▁final ▁State Validator ▁< ▁ Execut ing Test ▁. ▁Cancel ling Arguments ▁> ▁cancel ling State Validator ▁= ▁new ▁State Validator ▁< ▁> ▁( ▁STR ▁) ▁; ▁private ▁final ▁State Validator ▁< ▁Void ▁> ▁waiting For Resources State Validator ▁= ▁new ▁State Validator ▁< ▁> ▁( ▁STR ▁) ▁; ▁public ▁void ▁set Expect Cancel ling ▁( ▁Consumer ▁< ▁ Execut ing Test ▁. ▁Cancel ling Arguments ▁> ▁assert er ▁) ▁{ ▁cancel ling State Validator ▁. ▁expect Input ▁( ▁assert er ▁) ▁; ▁} ▁public ▁void ▁set Expect Waiting For Resources ▁( ▁) ▁{ ▁waiting For Resources State Validator ▁. ▁expect Input ▁( ▁( ▁none ▁) ▁-> ▁{ ▁} ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁goTo Cancel ing ▁( ▁ExecutionGraph ▁executionGraph ▁, ▁ExecutionGraph Handler ▁executionGraph Handler ▁, ▁Operator Coordinator Handler ▁operator Coordinator Handler ▁) ▁{ ▁cancel ling State Validator ▁. ▁validate Input ▁( ▁new ▁ Execut ing Test ▁. ▁Cancel ling Arguments ▁( ▁executionGraph ▁, ▁executionGraph Handler ▁, ▁operator Coordinator Handler ▁) ▁) ▁; ▁h ad State Transition ▁= ▁true ▁; ▁} ▁@ ▁Override ▁public ▁void ▁goTo Waiting For Resources ▁( ▁) ▁{ ▁waiting For Resources State Validator ▁. ▁validate Input ▁( ▁null ▁) ▁; ▁h ad State Transition ▁= ▁true ▁; ▁} ▁@ ▁Override ▁public ▁ScheduledFuture ▁< ▁? ▁> ▁run If State ▁( ▁State ▁expected State ▁, ▁Runnable ▁action ▁, ▁Duration ▁delay ▁) ▁{ ▁if ▁( ▁! ▁h ad State Transition ▁) ▁{ ▁action ▁. ▁run ▁( ▁) ▁; ▁} ▁return ▁Completed Scheduled Future ▁. ▁create ▁( ▁null ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁close ▁( ▁) ▁throws ▁Exception ▁{ ▁super ▁. ▁close ▁( ▁) ▁; ▁cancel ling State Validator ▁. ▁close ▁( ▁) ▁;
▁public ▁abstract ▁class ▁Native Context Extension ▁implements ▁Context Extension ▁{ ▁public ▁static ▁class ▁Unsupported Native TypeException ▁extends ▁Exception ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁private ▁final ▁Type ▁type ▁; ▁public ▁Unsupported Native TypeException ▁( ▁Type ▁type ▁) ▁{ ▁super ▁( ▁STR ▁+ ▁type ▁+ ▁STR ▁) ▁; ▁this ▁. ▁type ▁= ▁type ▁; ▁} ▁public ▁Type ▁getType ▁( ▁) ▁{ ▁return ▁type ▁; ▁} ▁} ▁public ▁static ▁final ▁class ▁Native Lookup Result ▁{ ▁private ▁final ▁Object ▁object ▁; ▁public ▁Native Lookup Result ▁( ▁Object ▁object ▁) ▁{ ▁this ▁. ▁object ▁= ▁object ▁; ▁} ▁public ▁Object ▁getObject ▁( ▁) ▁{ ▁return ▁object ▁; ▁} ▁} ▁public ▁static ▁final ▁class ▁Native Pointer Into Library ▁{ ▁private ▁final ▁long ▁address ▁; ▁public ▁Native Pointer Into Library ▁( ▁long ▁address ▁) ▁{ ▁this ▁. ▁address ▁= ▁address ▁; ▁} ▁public ▁long ▁getAddress ▁( ▁) ▁{ ▁return ▁address ▁; ▁} ▁} ▁public ▁abstract ▁Native Pointer Into Library ▁getNative Handle ▁( ▁String ▁name ▁) ▁; ▁public ▁abstract ▁CallTarget ▁create Native Wrapper Factory ▁( ▁LLVM Function Code ▁code ▁) ▁; ▁public ▁abstract ▁void ▁add Library Handles ▁( ▁Object ▁library ▁) ▁; ▁public ▁abstract ▁CallTarget ▁parse Native Library ▁( ▁String ▁path ▁, ▁LLVMContext ▁context ▁) ▁throws ▁Uns atisfied Link Error ▁; ▁public ▁abstract ▁Native Lookup Result ▁getNative Function OrNull ▁( ▁String ▁name ▁) ▁; ▁public ▁abstract ▁static ▁class ▁W ell Known Native Function Node ▁extends ▁LLVM Node ▁{ ▁public ▁final ▁Object ▁execute ▁( ▁Object ▁... ▁args ▁) ▁throws ▁A rity Exception ▁, ▁Unsupported MessageException ▁, ▁Unsupported TypeException ▁{ ▁return ▁execute Impl ▁( ▁args ▁) ▁; ▁} ▁protected ▁abstract ▁Object ▁execute Impl ▁( ▁Object ▁[ ▁] ▁args ▁) ▁throws ▁A rity Exception ▁, ▁Unsupported MessageException ▁, ▁Unsupported TypeException ▁; ▁} ▁public ▁abstract ▁W ell Known Native Function Node ▁getW ell Known Native Function ▁( ▁String ▁name ▁, ▁String ▁signature ▁) ▁; ▁public ▁abstract ▁Object ▁getNative Function ▁( ▁String ▁name ▁, ▁String ▁signature ▁) ▁; ▁public ▁abstract ▁Source ▁getNative Signature Source Skip Stack Arg ▁( ▁Function Type ▁type ▁) ▁throws ▁Unsupported Native TypeException ▁; ▁public ▁abstract ▁Object ▁bind Signature ▁( ▁LLVM Function Code ▁function ▁, ▁Source ▁signature Source ▁) ▁; ▁public ▁abstract ▁Object ▁bind Signature ▁( ▁long ▁fn Ptr ▁, ▁Source ▁signature Source ▁) ▁; ▁protected ▁Truffle File ▁locate Internal Library ▁( ▁LLVMContext ▁context ▁, ▁String ▁lib ▁, ▁Object ▁reason ▁) ▁{ ▁return ▁LLVMContext ▁. ▁Internal Library Locator ▁. ▁INSTANCE ▁. ▁locate Library ▁( ▁context ▁, ▁lib ▁, ▁reason ▁) ▁; ▁} ▁public ▁static ▁String ▁getNative Library ▁( ▁String ▁lib name ▁) ▁{ ▁return ▁getNative Library Prefix ▁( ▁) ▁+ ▁lib name ▁+ ▁CHAR ▁+ ▁getNative Library Suffix ▁( ▁) ▁; ▁} ▁public ▁static ▁String ▁getNative Library Versioned ▁( ▁String ▁lib name ▁, ▁int ▁version ▁) ▁{ ▁return ▁getNative Library Prefix ▁( ▁) ▁+ ▁lib name ▁+ ▁CHAR ▁+ ▁getNative Library Suffix Versioned ▁( ▁version ▁) ▁; ▁} ▁public ▁static ▁String ▁getNative Library Prefix ▁( ▁) ▁{ ▁if ▁( ▁System ▁. ▁getProperty ▁( ▁STR ▁) ▁. ▁toLowerCase ▁( ▁) ▁. ▁contains ▁( ▁STR ▁) ▁) ▁{ ▁return ▁STR ▁; ▁}
▁Map ▁< ▁String ▁, ▁String ▁> ▁result ▁= ▁template ▁. ▁match ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁result ▁) ▁. ▁as ▁( ▁STR ▁) ▁. ▁isEqualTo ▁( ▁expected ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁match Custom Regex With Nested Cur ly B race s ▁( ▁) ▁throws ▁Exception ▁{ ▁Uri Template ▁template ▁= ▁new ▁Uri Template ▁( ▁STR ▁) ▁; ▁Map ▁< ▁String ▁, ▁String ▁> ▁result ▁= ▁template ▁. ▁match ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁result ▁) ▁. ▁as ▁( ▁STR ▁) ▁. ▁isEqualTo ▁( ▁Collections ▁. ▁singletonMap ▁( ▁STR ▁, ▁STR ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁match Duplicate ▁( ▁) ▁throws ▁Exception ▁{ ▁Uri Template ▁template ▁= ▁new ▁Uri Template ▁( ▁STR ▁) ▁; ▁Map ▁< ▁String ▁, ▁String ▁> ▁result ▁= ▁template ▁. ▁match ▁( ▁STR ▁) ▁; ▁Map ▁< ▁String ▁, ▁String ▁> ▁expected ▁= ▁Collections ▁. ▁singletonMap ▁( ▁STR ▁, ▁STR ▁) ▁; ▁assertThat ▁( ▁result ▁) ▁. ▁as ▁( ▁STR ▁) ▁. ▁isEqualTo ▁( ▁expected ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁match Multiple In One Segment ▁( ▁) ▁throws ▁Exception ▁{ ▁Uri Template ▁template ▁= ▁new ▁Uri Template ▁( ▁STR ▁) ▁; ▁Map ▁< ▁String ▁, ▁String ▁> ▁result ▁= ▁template ▁. ▁match ▁( ▁STR ▁) ▁; ▁Map ▁< ▁String ▁, ▁String ▁> ▁expected ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁2 ▁) ▁; ▁expected ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁; ▁expected ▁. ▁put ▁( ▁STR ▁, ▁STR ▁) ▁; ▁assertThat ▁( ▁result ▁) ▁. ▁as ▁( ▁STR ▁) ▁. ▁isEqualTo ▁( ▁expected ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁match With Multiple Segments At The End ▁( ▁) ▁throws ▁Exception ▁{ ▁Uri Template ▁template ▁= ▁new ▁Uri Template ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁template ▁. ▁matches ▁( ▁STR ▁) ▁) ▁. ▁isFalse ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁query Variables ▁( ▁) ▁throws ▁Exception ▁{ ▁Uri Template ▁template ▁= ▁new ▁Uri Template ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁template ▁. ▁matches ▁( ▁STR ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁fragment s ▁( ▁) ▁throws ▁Exception ▁{ ▁Uri Template ▁template ▁= ▁new ▁Uri Template ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁template ▁. ▁matches ▁( ▁STR ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁template ▁= ▁new ▁Uri Template ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁template ▁. ▁matches ▁( ▁STR ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁matches With Slash At The End ▁( ▁) ▁throws ▁Exception ▁{ ▁assertThat ▁( ▁new ▁Uri Template ▁( ▁STR ▁) ▁. ▁matches ▁( ▁STR ▁) ▁) ▁. ▁isTrue ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁expand With D oll ar ▁( ▁) ▁throws ▁Exception ▁{ ▁Uri Template ▁template ▁= ▁new ▁Uri Template ▁( ▁STR ▁) ▁; ▁URI ▁uri ▁= ▁template ▁. ▁expand ▁( ▁STR ▁) ▁; ▁assertThat ▁( ▁uri ▁. ▁toString ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁expand With At Sign ▁( ▁) ▁throws ▁Exception ▁{ ▁Uri Template ▁template ▁= ▁new ▁Uri Template ▁( ▁STR ▁) ▁;
▁public ▁class ▁Serial Iterator ▁implements ▁Iterator ▁< ▁Scheduling Request ▁> ▁{ ▁private ▁final ▁List ▁< ▁Scheduling Request ▁> ▁s cheduling Request List ▁; ▁private ▁int ▁cursor ▁; ▁public ▁Serial Iterator ▁( ▁Collection ▁< ▁Scheduling Request ▁> ▁s cheduling Requests ▁) ▁{ ▁this ▁. ▁s cheduling Request List ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁s cheduling Requests ▁) ▁; ▁this ▁. ▁cursor ▁= ▁0 ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁hasNext ▁( ▁) ▁{ ▁return ▁( ▁cursor ▁< ▁s cheduling Request List ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Scheduling Request ▁next ▁( ▁) ▁{ ▁if ▁( ▁hasNext ▁( ▁) ▁) ▁{ ▁return ▁s cheduling Request List ▁. ▁get ▁( ▁cursor ▁++ ▁) ▁; ▁} ▁throw ▁new ▁NoSuch ElementException ▁( ▁) ▁; ▁} ▁}
▁public ▁final ▁class ▁M ari a DB Database SQL Initialization ▁extends ▁Default Database SQL Initialization ▁implements ▁Database SQL Initialization ▁{ ▁@ ▁Override ▁public ▁void ▁execute Init SQL s ▁( ▁final ▁String ▁sc enario ▁, ▁final ▁DatabaseType ▁databaseType ▁, ▁final ▁Map ▁< ▁String ▁, ▁DataSource ▁> ▁dataSourceMap ▁) ▁throws ▁IOException ▁, ▁SQLException ▁{ ▁super ▁. ▁execute Init SQL s ▁( ▁sc enario ▁, ▁databaseType ▁, ▁dataSourceMap ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getType ▁( ▁) ▁{ ▁return ▁new ▁M ari a DB DatabaseType ▁( ▁) ▁. ▁getName ▁( ▁) ▁; ▁} ▁}
▁else ▁{ ▁register Handler ▁( ▁route ▁. ▁getMethod ▁( ▁) ▁, ▁route ▁. ▁getPath ▁( ▁) ▁, ▁route ▁. ▁getRest ApiVersion ▁( ▁) ▁, ▁handler ▁) ▁; ▁} ▁} ▁public ▁void ▁register Handler ▁( ▁final ▁Rest Handler ▁handler ▁) ▁{ ▁handler ▁. ▁routes ▁( ▁) ▁. ▁forEach ▁( ▁route ▁-> ▁register Handler ▁( ▁route ▁, ▁handler ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁dispatch Request ▁( ▁RestRequest ▁request ▁, ▁RestChannel ▁channel ▁, ▁ThreadContext ▁threadContext ▁) ▁{ ▁threadContext ▁. ▁add ResponseHeader ▁( ▁E LAST IC _ PRO DU CT _ HTTP _ HEADER ▁, ▁E LAST IC _ PRO DU CT _ HTTP _ HEADER _ VALUE ▁) ▁; ▁try ▁{ ▁try All Handlers ▁( ▁request ▁, ▁channel ▁, ▁threadContext ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁try ▁{ ▁channel ▁. ▁send Response ▁( ▁new ▁Bytes RestResponse ▁( ▁channel ▁, ▁e ▁) ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁inner ▁) ▁{ ▁inner ▁. ▁add Suppressed ▁( ▁e ▁) ▁; ▁logger ▁. ▁error ▁( ▁( ▁) ▁-> ▁new ▁Parameterized Message ▁( ▁STR ▁, ▁request ▁. ▁uri ▁( ▁) ▁) ▁, ▁inner ▁) ▁; ▁} ▁} ▁} ▁@ ▁Override ▁public ▁void ▁dispatch Bad Request ▁( ▁final ▁RestChannel ▁channel ▁, ▁final ▁ThreadContext ▁threadContext ▁, ▁final ▁Throwable ▁cause ▁) ▁{ ▁threadContext ▁. ▁add ResponseHeader ▁( ▁E LAST IC _ PRO DU CT _ HTTP _ HEADER ▁, ▁E LAST IC _ PRO DU CT _ HTTP _ HEADER _ VALUE ▁) ▁; ▁try ▁{ ▁final ▁Exception ▁e ▁; ▁if ▁( ▁cause ▁== ▁null ▁) ▁{ ▁e ▁= ▁new ▁Elasticsearch Exception ▁( ▁STR ▁) ▁; ▁} ▁else ▁if ▁( ▁cause ▁instanceof ▁Exception ▁) ▁{ ▁e ▁= ▁( ▁Exception ▁) ▁cause ▁; ▁} ▁else ▁{ ▁e ▁= ▁new ▁Elasticsearch Exception ▁( ▁cause ▁) ▁; ▁} ▁channel ▁. ▁send Response ▁( ▁new ▁Bytes RestResponse ▁( ▁channel ▁, ▁BAD _ REQUEST ▁, ▁e ▁) ▁) ▁; ▁} ▁catch ▁( ▁final ▁IOException ▁e ▁) ▁{ ▁if ▁( ▁cause ▁!= ▁null ▁) ▁{ ▁e ▁. ▁add Suppressed ▁( ▁cause ▁) ▁; ▁} ▁logger ▁. ▁warn ▁( ▁STR ▁, ▁e ▁) ▁; ▁channel ▁. ▁send Response ▁( ▁new ▁Bytes RestResponse ▁( ▁INTERNAL _ SERVER _ ERROR ▁, ▁Bytes RestResponse ▁. ▁TEXT _ CONTENT _ TYPE ▁, ▁BytesArray ▁. ▁EMPTY ▁) ▁) ▁; ▁} ▁} ▁private ▁void ▁dispatch Request ▁( ▁RestRequest ▁request ▁, ▁RestChannel ▁channel ▁, ▁Rest Handler ▁handler ▁, ▁ThreadContext ▁threadContext ▁) ▁throws ▁Exception ▁{ ▁final ▁int ▁contentLength ▁= ▁request ▁. ▁contentLength ▁( ▁) ▁; ▁if ▁( ▁contentLength ▁> ▁0 ▁) ▁{ ▁final ▁XContentType ▁xContentType ▁= ▁request ▁. ▁get XContent Type ▁( ▁) ▁; ▁if ▁( ▁xContentType ▁== ▁null ▁) ▁{ ▁send ContentType ErrorMessage ▁( ▁request ▁. ▁getAll Header Values ▁( ▁STR ▁) ▁, ▁channel ▁) ▁; ▁return ▁; ▁}
▁current C ue Info Builder ▁= ▁cue Info Builders ▁[ ▁0 ▁] ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁void ▁flush ▁( ▁) ▁{ ▁super ▁. ▁flush ▁( ▁) ▁; ▁cue s ▁= ▁null ▁; ▁last C ue s ▁= ▁null ▁; ▁current Window ▁= ▁0 ▁; ▁current C ue Info Builder ▁= ▁cue Info Builders ▁[ ▁current Window ▁] ▁; ▁reset C ue Builders ▁( ▁) ▁; ▁current Dt v Cc Packet ▁= ▁null ▁; ▁} ▁@ ▁Override ▁protected ▁boolean ▁is New Sub title Data Available ▁( ▁) ▁{ ▁return ▁cue s ▁!= ▁last C ue s ▁; ▁} ▁@ ▁Override ▁protected ▁Subtitle ▁create Sub title ▁( ▁) ▁{ ▁last C ue s ▁= ▁cue s ▁; ▁return ▁new ▁C e a Sub title ▁( ▁Assertions ▁. ▁checkNotNull ▁( ▁cue s ▁) ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁decode ▁( ▁Subtitle InputBuffer ▁input Buffer ▁) ▁{ ▁ByteBuffer ▁sub title Data ▁= ▁Assertions ▁. ▁checkNotNull ▁( ▁input Buffer ▁. ▁data ▁) ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁byte ▁[ ▁] ▁input Buffer Data ▁= ▁sub title Data ▁. ▁array ▁( ▁) ▁; ▁cc Data ▁. ▁reset ▁( ▁input Buffer Data ▁, ▁sub title Data ▁. ▁limit ▁( ▁) ▁) ▁; ▁while ▁( ▁cc Data ▁. ▁bytes Left ▁( ▁) ▁>= ▁3 ▁) ▁{ ▁int ▁cc Type And Valid ▁= ▁( ▁cc Data ▁. ▁readUnsigned Byte ▁( ▁) ▁& ▁0 x 07 ▁) ▁; ▁int ▁cc Type ▁= ▁cc Type And Valid ▁& ▁( ▁D T V CC _ P ACKET _ DATA ▁| ▁D T V CC _ P ACKET _ START ▁) ▁; ▁boolean ▁cc Valid ▁= ▁( ▁cc Type And Valid ▁& ▁C C _ VALID _ FLAG ▁) ▁== ▁C C _ VALID _ FLAG ▁; ▁byte ▁cc Data 1 ▁= ▁( ▁byte ▁) ▁cc Data ▁. ▁readUnsigned Byte ▁( ▁) ▁; ▁byte ▁cc Data 2 ▁= ▁( ▁byte ▁) ▁cc Data ▁. ▁readUnsigned Byte ▁( ▁) ▁; ▁if ▁( ▁cc Type ▁!= ▁D T V CC _ P ACKET _ DATA ▁&& ▁cc Type ▁!= ▁D T V CC _ P ACKET _ START ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁! ▁cc Valid ▁) ▁{ ▁continue ▁; ▁} ▁if ▁( ▁cc Type ▁== ▁D T V CC _ P ACKET _ START ▁) ▁{ ▁finalize Current Packet ▁( ▁) ▁; ▁int ▁sequenceNumber ▁= ▁( ▁cc Data 1 ▁& ▁0 x C 0 ▁) ▁>> ▁6 ▁; ▁if ▁( ▁previous SequenceNumber ▁!= ▁C ▁. ▁INDEX _ UNSET ▁&& ▁sequenceNumber ▁!= ▁( ▁previous SequenceNumber ▁+ ▁1 ▁) ▁ % ▁4 ▁) ▁{ ▁reset C ue Builders ▁( ▁) ▁; ▁Log ▁. ▁w ▁( ▁TAG ▁, ▁STR ▁+ ▁previous SequenceNumber ▁+ ▁STR ▁+ ▁sequenceNumber ▁) ▁; ▁} ▁previous SequenceNumber ▁= ▁sequenceNumber ▁; ▁int ▁packet Size ▁= ▁cc Data 1 ▁& ▁0 x 3 F ▁; ▁if ▁( ▁packet Size ▁== ▁0 ▁) ▁{ ▁packet Size ▁= ▁64 ▁; ▁}
▁@ ▁Tool Event Name ▁( ▁Dual Program Location PluginEvent ▁. ▁NAME ▁) ▁public ▁final ▁class ▁Dual Program Location PluginEvent ▁extends ▁Plugin Event ▁{ ▁public ▁static ▁final ▁String ▁NAME ▁= ▁STR ▁; ▁private ▁ProgramLocation ▁loc ▁; ▁private ▁String ▁program Name ▁; ▁public ▁Dual Program Location PluginEvent ▁( ▁String ▁src ▁, ▁ProgramLocation ▁loc ▁, ▁String ▁program Name ▁) ▁{ ▁super ▁( ▁src ▁, ▁NAME ▁) ▁; ▁this ▁. ▁loc ▁= ▁loc ▁; ▁this ▁. ▁program Name ▁= ▁program Name ▁; ▁} ▁public ▁Dual Program Location PluginEvent ▁( ▁String ▁src ▁, ▁ProgramLocation ▁loc ▁, ▁Program ▁program ▁) ▁{ ▁super ▁( ▁src ▁, ▁NAME ▁) ▁; ▁this ▁. ▁loc ▁= ▁loc ▁; ▁this ▁. ▁program Name ▁= ▁program ▁. ▁getName ▁( ▁) ▁; ▁} ▁public ▁ProgramLocation ▁getLocation ▁( ▁) ▁{ ▁return ▁loc ▁; ▁} ▁public ▁String ▁getProgram Name ▁( ▁) ▁{ ▁return ▁program Name ▁; ▁} ▁}
▁private ▁static ▁class ▁Pro c Time Ded uplicate Operator Translator ▁extends ▁D ed uplicate Operator Translator ▁{ ▁private ▁final ▁Generated Record Equal iser ▁generated Equal iser ▁; ▁protected ▁Pro c Time Ded uplicate Operator Translator ▁( ▁Table Config ▁table Config ▁, ▁Internal TypeInfo ▁< ▁RowData ▁> ▁row TypeInfo ▁, ▁TypeSerializer ▁< ▁RowData ▁> ▁type Serializer ▁, ▁RowType ▁input RowType ▁, ▁boolean ▁keep Last Row ▁, ▁boolean ▁generate Update Before ▁) ▁{ ▁super ▁( ▁table Config ▁, ▁row TypeInfo ▁, ▁type Serializer ▁, ▁keep Last Row ▁, ▁generate Update Before ▁) ▁; ▁generated Equal iser ▁= ▁new ▁E qual iser Code Generator ▁( ▁input RowType ▁) ▁. ▁generate Record Equal iser ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁OneInputStream Operator ▁< ▁RowData ▁, ▁RowData ▁> ▁create Ded uplicate Operator ▁( ▁) ▁{ ▁if ▁( ▁is Mini Batch Enabled ▁( ▁) ▁) ▁{ ▁Count Bundle Trigger ▁< ▁RowData ▁> ▁trigger ▁= ▁new ▁Count Bundle Trigger ▁< ▁> ▁( ▁getMin i BatchSize ▁( ▁) ▁) ▁; ▁if ▁( ▁keep Last Row ▁) ▁{ ▁Pro c Time Mini Batch Ded uplicate Keep Last Row Function ▁process Function ▁= ▁new ▁Pro c Time Mini Batch Ded uplicate Keep Last Row Function ▁( ▁row TypeInfo ▁, ▁type Serializer ▁, ▁getMin Retention Time ▁( ▁) ▁, ▁generate Update Before ▁, ▁generate Insert ▁( ▁) ▁, ▁true ▁, ▁generated Equal iser ▁) ▁; ▁return ▁new ▁Keyed Map Bundle Operator ▁< ▁> ▁( ▁process Function ▁, ▁trigger ▁) ▁; ▁} ▁else ▁{ ▁Pro c Time Mini Batch Ded uplicate Keep First Row Function ▁process Function ▁= ▁new ▁Pro c Time Mini Batch Ded uplicate Keep First Row Function ▁( ▁type Serializer ▁, ▁getMin Retention Time ▁( ▁) ▁) ▁; ▁return ▁new ▁Keyed Map Bundle Operator ▁< ▁> ▁( ▁process Function ▁, ▁trigger ▁) ▁; ▁} ▁} ▁else ▁{ ▁if ▁( ▁keep Last Row ▁) ▁{ ▁Pro c Time Ded uplicate Keep Last Row Function ▁process Function ▁= ▁new ▁Pro c Time Ded uplicate Keep Last Row Function ▁( ▁row TypeInfo ▁, ▁getMin Retention Time ▁( ▁) ▁, ▁generate Update Before ▁, ▁generate Insert ▁( ▁) ▁, ▁true ▁, ▁generated Equal iser ▁) ▁; ▁return ▁new ▁Keyed Process Operator ▁< ▁> ▁( ▁process Function ▁) ▁; ▁} ▁else ▁{ ▁Pro c Time Ded uplicate Keep First Row Function ▁process Function ▁= ▁new ▁Pro c Time Ded uplicate Keep First Row Function ▁( ▁getMin Retention Time ▁( ▁) ▁) ▁; ▁return ▁new ▁Keyed Process Operator ▁< ▁> ▁( ▁process Function ▁) ▁; ▁} ▁} ▁} ▁} ▁}
▁@ ▁Override ▁public ▁Pinpoint Netty Server Builder ▁max Inbound Message Size ▁( ▁int ▁bytes ▁) ▁{ ▁checkArgument ▁( ▁bytes ▁>= ▁0 ▁, ▁STR ▁, ▁bytes ▁) ▁; ▁this ▁. ▁max Message Size ▁= ▁bytes ▁; ▁return ▁this ▁; ▁} ▁@ ▁Deprecated ▁public ▁Pinpoint Netty Server Builder ▁max Header ListSize ▁( ▁int ▁max Header ListSize ▁) ▁{ ▁return ▁max Inbound Metadata Size ▁( ▁max Header ListSize ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Pinpoint Netty Server Builder ▁max Inbound Metadata Size ▁( ▁int ▁bytes ▁) ▁{ ▁checkArgument ▁( ▁bytes ▁> ▁0 ▁, ▁STR ▁, ▁bytes ▁) ▁; ▁this ▁. ▁max Header ListSize ▁= ▁bytes ▁; ▁return ▁this ▁; ▁} ▁public ▁Pinpoint Netty Server Builder ▁keepAlive Time ▁( ▁long ▁keepAlive Time ▁, ▁TimeUnit ▁timeUnit ▁) ▁{ ▁checkArgument ▁( ▁keepAlive Time ▁> ▁0 L ▁, ▁STR ▁, ▁keepAlive Time ▁) ▁; ▁keepAlive Time In Nanos ▁= ▁timeUnit ▁. ▁toNanos ▁( ▁keepAlive Time ▁) ▁; ▁keepAlive Time In Nanos ▁= ▁Keep Alive Manager ▁. ▁cl amp Keep Alive Time In Nanos ▁( ▁keepAlive Time In Nanos ▁) ▁; ▁if ▁( ▁keepAlive Time In Nanos ▁>= ▁AS _ L ARGE _ AS _ INFIN ITE ▁) ▁{ ▁keepAlive Time In Nanos ▁= ▁SERVER _ K EEP AL IVE _ TIME _ N AN OS _ DIS ABLED ▁; ▁} ▁if ▁( ▁keepAlive Time In Nanos ▁< ▁MIN _ K EEP AL IVE _ TIME _ N ANO ▁) ▁{ ▁keepAlive Time In Nanos ▁= ▁MIN _ K EEP AL IVE _ TIME _ N ANO ▁; ▁} ▁return ▁this ▁; ▁} ▁public ▁Pinpoint Netty Server Builder ▁keepAlive Timeout ▁( ▁long ▁keepAlive Timeout ▁, ▁TimeUnit ▁timeUnit ▁) ▁{ ▁checkArgument ▁( ▁keepAlive Timeout ▁> ▁0 L ▁, ▁STR ▁, ▁keepAlive Timeout ▁) ▁; ▁keepAlive Timeout In Nanos ▁= ▁timeUnit ▁. ▁toNanos ▁( ▁keepAlive Timeout ▁) ▁; ▁keepAlive Timeout In Nanos ▁= ▁Keep Alive Manager ▁. ▁cl amp Keep Alive Timeout In Nanos ▁( ▁keepAlive Timeout In Nanos ▁) ▁; ▁if ▁( ▁keepAlive Timeout In Nanos ▁< ▁MIN _ K EEP AL IVE _ TIMEOUT _ N ANO ▁) ▁{ ▁keepAlive Timeout In Nanos ▁= ▁MIN _ K EEP AL IVE _ TIMEOUT _ N ANO ▁; ▁} ▁return ▁this ▁; ▁} ▁public ▁Pinpoint Netty Server Builder ▁max Connection Idle ▁( ▁long ▁max Connection Idle ▁, ▁TimeUnit ▁timeUnit ▁) ▁{ ▁checkArgument ▁( ▁max Connection Idle ▁> ▁0 L ▁, ▁STR ▁, ▁max Connection Idle ▁) ▁; ▁max Connection Idle In Nanos ▁= ▁timeUnit ▁. ▁toNanos ▁( ▁max Connection Idle ▁) ▁; ▁if ▁( ▁max Connection Idle In Nanos ▁>= ▁AS _ L ARGE _ AS _ INFIN ITE ▁) ▁{ ▁max Connection Idle In Nanos ▁= ▁MAX _ CONNECTION _ ID LE _ N AN OS _ DIS ABLED ▁; ▁} ▁if ▁( ▁max Connection Idle In Nanos ▁< ▁MIN _ MAX _ CONNECTION _ ID LE _ N ANO ▁) ▁{ ▁max Connection Idle In Nanos ▁= ▁MIN _ MAX _ CONNECTION _ ID LE _ N ANO ▁; ▁} ▁return ▁this ▁; ▁}
▁public ▁class ▁Rest Update Filter Action ▁extends ▁BaseRestHandler ▁{ ▁@ ▁Override ▁public ▁List ▁< ▁Route ▁> ▁routes ▁( ▁) ▁{ ▁return ▁List ▁. ▁of ▁( ▁new ▁Route ▁( ▁POST ▁, ▁BASE _ PATH ▁+ ▁STR ▁+ ▁MlFilter ▁. ▁ID ▁+ ▁STR ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getName ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁protected ▁RestChannel Consumer ▁prepareRequest ▁( ▁RestRequest ▁restRequest ▁, ▁NodeClient ▁client ▁) ▁throws ▁IOException ▁{ ▁String ▁filter Id ▁= ▁restRequest ▁. ▁param ▁( ▁MlFilter ▁. ▁ID ▁. ▁getPreferred Name ▁( ▁) ▁) ▁; ▁XContentParser ▁parser ▁= ▁restRequest ▁. ▁content Or Source Param Parser ▁( ▁) ▁; ▁Update Filter Action ▁. ▁Request ▁put Filter Request ▁= ▁Update Filter Action ▁. ▁Request ▁. ▁parse Request ▁( ▁filter Id ▁, ▁parser ▁) ▁; ▁return ▁channel ▁-> ▁client ▁. ▁execute ▁( ▁Update Filter Action ▁. ▁INSTANCE ▁, ▁put Filter Request ▁, ▁new ▁RestToXContent Listener ▁< ▁> ▁( ▁channel ▁) ▁) ▁; ▁} ▁}
▁@ ▁RunWith ▁( ▁JUnit 4 ▁. ▁class ▁) ▁public ▁class ▁Sky frame Aware Action Test ▁extends ▁Timestamp Builder TestCase ▁{ ▁private ▁Builder ▁builder ▁; ▁private ▁Executor ▁executor ▁; ▁private ▁Track ing Evaluation Progress Receiver ▁progress Receiver ▁; ▁@ ▁Before ▁public ▁final ▁void ▁create Builder ▁( ▁) ▁throws ▁Exception ▁{ ▁progress Receiver ▁= ▁new ▁Track ing Evaluation Progress Receiver ▁( ▁) ▁; ▁builder ▁= ▁create Builder ▁( ▁inMemory Cache ▁, ▁1 ▁, ▁false ▁, ▁progress Receiver ▁, ▁Graph In con sistency Receiver ▁. ▁TH ROW ING ▁) ▁; ▁} ▁@ ▁Before ▁public ▁final ▁void ▁create Executor ▁( ▁) ▁throws ▁Exception ▁{ ▁executor ▁= ▁new ▁Dummy Executor ▁( ▁fileSystem ▁, ▁root Directory ▁) ▁; ▁} ▁private ▁static ▁final ▁class ▁Track ing Evaluation Progress Receiver ▁implements ▁Evaluation Progress Receiver ▁{ ▁public ▁static ▁final ▁class ▁Invalid ated Key ▁{ ▁public ▁final ▁SkyKey ▁skyKey ▁; ▁public ▁final ▁Invalid ation State ▁state ▁; ▁Invalid ated Key ▁( ▁SkyKey ▁skyKey ▁, ▁Invalid ation State ▁state ▁) ▁{ ▁this ▁. ▁skyKey ▁= ▁skyKey ▁; ▁this ▁. ▁state ▁= ▁state ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁obj ▁) ▁{ ▁return ▁obj ▁instanceof ▁Invalid ated Key ▁&& ▁this ▁. ▁skyKey ▁. ▁equals ▁( ▁( ▁( ▁Invalid ated Key ▁) ▁obj ▁) ▁. ▁skyKey ▁) ▁&& ▁this ▁. ▁state ▁. ▁equals ▁( ▁( ▁( ▁Invalid ated Key ▁) ▁obj ▁) ▁. ▁state ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁Objects ▁. ▁hashCode ▁( ▁skyKey ▁, ▁state ▁) ▁; ▁} ▁} ▁private ▁static ▁final ▁class ▁Evalu ated Entry ▁{ ▁public ▁final ▁SkyKey ▁skyKey ▁; ▁final ▁Evaluation Success State ▁success State ▁; ▁public ▁final ▁Evaluation State ▁state ▁; ▁Evalu ated Entry ▁( ▁SkyKey ▁skyKey ▁, ▁Evaluation Success State ▁success State ▁, ▁Evaluation State ▁state ▁) ▁{ ▁this ▁. ▁skyKey ▁= ▁skyKey ▁; ▁this ▁. ▁success State ▁= ▁success State ▁; ▁this ▁. ▁state ▁= ▁state ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁obj ▁) ▁{ ▁return ▁obj ▁instanceof ▁Evalu ated Entry ▁&& ▁this ▁. ▁skyKey ▁. ▁equals ▁( ▁( ▁( ▁Evalu ated Entry ▁) ▁obj ▁) ▁. ▁skyKey ▁) ▁&& ▁this ▁. ▁success State ▁. ▁equals ▁( ▁( ▁( ▁Evalu ated Entry ▁) ▁obj ▁) ▁. ▁success State ▁) ▁&& ▁this ▁. ▁state ▁. ▁equals ▁( ▁( ▁( ▁Evalu ated Entry ▁) ▁obj ▁) ▁. ▁state ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁Objects ▁. ▁hashCode ▁( ▁skyKey ▁, ▁success State ▁, ▁state ▁) ▁; ▁} ▁} ▁public ▁final ▁Set ▁< ▁Invalid ated Key ▁> ▁invalid ated ▁= ▁Sets ▁. ▁new Concurrent HashSet ▁( ▁) ▁; ▁public ▁final ▁Set ▁< ▁SkyKey ▁> ▁enqueue d ▁= ▁Sets ▁. ▁new Concurrent HashSet ▁( ▁) ▁; ▁public ▁final ▁Set ▁< ▁Evalu ated Entry ▁> ▁evalu ated ▁= ▁Sets ▁. ▁new Concurrent HashSet ▁( ▁) ▁; ▁public ▁void ▁reset ▁( ▁) ▁{ ▁invalid ated ▁. ▁clear ▁( ▁) ▁; ▁enqueue d ▁. ▁clear ▁( ▁) ▁; ▁evalu ated ▁. ▁clear ▁( ▁) ▁; ▁}
▁@ ▁SpringBoot Application ▁public ▁class ▁Dynamic Validation App ▁{ ▁@ ▁Role s Allowed ▁( ▁STR ▁) ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Spring Application ▁. ▁run ▁( ▁Dynamic Validation App ▁. ▁class ▁, ▁args ▁) ▁; ▁} ▁}
▁public ▁class ▁Ad der After Return Aspect ▁{ ▁private ▁final ▁Logger ▁logger ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁this ▁. ▁getClass ▁( ▁) ▁) ▁; ▁public ▁void ▁after Return ▁( ▁final ▁Object ▁returnValue ▁) ▁throws ▁Throwable ▁{ ▁logger ▁. ▁info ▁( ▁STR ▁, ▁returnValue ▁) ▁; ▁} ▁}
▁@ ▁SpringBoot Application ▁( ▁exclude ▁= ▁{ ▁Security Auto Configuration ▁. ▁class ▁, ▁Management Web Security Auto Configuration ▁. ▁class ▁} ▁, ▁scan Base Packages ▁= ▁STR ▁) ▁public ▁class ▁Endpoint En a bl ing Application ▁{ ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁{ ▁Spring Application ▁. ▁run ▁( ▁Endpoint En a bl ing Application ▁. ▁class ▁, ▁args ▁) ▁; ▁} ▁}
▁public ▁abstract ▁class ▁Abstract Disk Http Data ▁extends ▁Abstract Http Data ▁{ ▁private ▁static ▁final ▁InternalLogger ▁logger ▁= ▁InternalLogger Factory ▁. ▁getInstance ▁( ▁Abstract Disk Http Data ▁. ▁class ▁) ▁; ▁private ▁File ▁file ▁; ▁private ▁boolean ▁is Ren amed ▁; ▁private ▁FileChannel ▁file Channel ▁; ▁protected ▁Abstract Disk Http Data ▁( ▁String ▁name ▁, ▁Charset ▁charset ▁, ▁long ▁size ▁) ▁{ ▁super ▁( ▁name ▁, ▁charset ▁, ▁size ▁) ▁; ▁} ▁protected ▁abstract ▁String ▁get Disk Filename ▁( ▁) ▁; ▁protected ▁abstract ▁String ▁getPrefix ▁( ▁) ▁; ▁protected ▁abstract ▁String ▁getBase Directory ▁( ▁) ▁; ▁protected ▁abstract ▁String ▁getPost fix ▁( ▁) ▁; ▁protected ▁abstract ▁boolean ▁deleteOnExit ▁( ▁) ▁; ▁private ▁File ▁tempFile ▁( ▁) ▁throws ▁IOException ▁{ ▁String ▁new p ost fix ▁; ▁String ▁disk Filename ▁= ▁get Disk Filename ▁( ▁) ▁; ▁if ▁( ▁disk Filename ▁!= ▁null ▁) ▁{ ▁new p ost fix ▁= ▁CHAR ▁+ ▁disk Filename ▁; ▁} ▁else ▁{ ▁new p ost fix ▁= ▁getPost fix ▁( ▁) ▁; ▁} ▁File ▁tmpFile ▁; ▁if ▁( ▁getBase Directory ▁( ▁) ▁== ▁null ▁) ▁{ ▁tmpFile ▁= ▁Platform Dependent ▁. ▁createTempFile ▁( ▁getPrefix ▁( ▁) ▁, ▁new p ost fix ▁, ▁null ▁) ▁; ▁} ▁else ▁{ ▁tmpFile ▁= ▁Platform Dependent ▁. ▁createTempFile ▁( ▁getPrefix ▁( ▁) ▁, ▁new p ost fix ▁, ▁new ▁File ▁( ▁getBase Directory ▁( ▁) ▁) ▁) ▁; ▁} ▁if ▁( ▁deleteOnExit ▁( ▁) ▁) ▁{ ▁Delete File OnExit Hook ▁. ▁add ▁( ▁tmpFile ▁. ▁getPath ▁( ▁) ▁) ▁; ▁} ▁return ▁tmpFile ▁; ▁} ▁@ ▁Override ▁public ▁void ▁setContent ▁( ▁ByteBuf ▁buffer ▁) ▁throws ▁IOException ▁{ ▁ObjectUtil ▁. ▁checkNotNull ▁( ▁buffer ▁, ▁STR ▁) ▁; ▁try ▁{ ▁size ▁= ▁buffer ▁. ▁readableBytes ▁( ▁) ▁; ▁check Size ▁( ▁size ▁) ▁; ▁if ▁( ▁defined Size ▁> ▁0 ▁&& ▁defined Size ▁< ▁size ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁STR ▁+ ▁size ▁+ ▁STR ▁+ ▁defined Size ▁) ▁; ▁} ▁if ▁( ▁file ▁== ▁null ▁) ▁{ ▁file ▁= ▁tempFile ▁( ▁) ▁; ▁} ▁if ▁( ▁buffer ▁. ▁readableBytes ▁( ▁) ▁== ▁0 ▁) ▁{ ▁if ▁( ▁! ▁file ▁. ▁createNewFile ▁( ▁) ▁) ▁{ ▁if ▁( ▁file ▁. ▁length ▁( ▁) ▁== ▁0 ▁) ▁{ ▁return ▁; ▁} ▁else ▁{ ▁if ▁( ▁! ▁file ▁. ▁delete ▁( ▁) ▁|| ▁! ▁file ▁. ▁createNewFile ▁( ▁) ▁) ▁{ ▁throw ▁new ▁IOException ▁( ▁STR ▁+ ▁file ▁) ▁; ▁} ▁} ▁} ▁return ▁; ▁} ▁Random AccessFile ▁access File ▁= ▁new ▁Random AccessFile ▁( ▁file ▁, ▁STR ▁) ▁; ▁try ▁{ ▁access File ▁. ▁setLength ▁( ▁0 ▁) ▁; ▁FileChannel ▁local file Channel ▁= ▁access File ▁. ▁getChannel ▁( ▁) ▁; ▁ByteBuffer ▁byteBuffer ▁= ▁buffer ▁. ▁nio Buffer ▁( ▁) ▁; ▁int ▁written ▁= ▁0 ▁; ▁while ▁( ▁written ▁< ▁size ▁) ▁{ ▁written ▁+= ▁local file Channel ▁. ▁write ▁( ▁byteBuffer ▁) ▁; ▁} ▁buffer ▁. ▁readerIndex ▁( ▁buffer ▁. ▁readerIndex ▁( ▁) ▁+ ▁written ▁) ▁; ▁local file Channel ▁. ▁force ▁( ▁false ▁) ▁; ▁} ▁finally ▁{ ▁access File ▁. ▁close ▁( ▁) ▁; ▁}
▁public ▁class ▁E p ub View Page ▁implements ▁Serializable ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁- ▁2 19 8 40 78 38 110 78 6 60 6 L ▁; ▁private ▁String ▁src ▁; ▁private ▁String ▁image Url ▁; ▁private ▁String ▁page Num ▁; ▁private ▁List ▁< ▁E p ub View Hot Point ▁> ▁h ot Points ▁; ▁public ▁String ▁getImage Url ▁( ▁) ▁{ ▁return ▁image Url ▁; ▁} ▁public ▁void ▁setImage Url ▁( ▁String ▁image Url ▁) ▁{ ▁this ▁. ▁image Url ▁= ▁image Url ▁; ▁} ▁public ▁String ▁getPage Num ▁( ▁) ▁{ ▁return ▁page Num ▁; ▁} ▁public ▁void ▁setPage Num ▁( ▁String ▁page Num ▁) ▁{ ▁this ▁. ▁page Num ▁= ▁page Num ▁; ▁} ▁public ▁List ▁< ▁E p ub View Hot Point ▁> ▁getH ot Points ▁( ▁) ▁{ ▁return ▁h ot Points ▁; ▁} ▁public ▁void ▁set Hot Points ▁( ▁List ▁< ▁E p ub View Hot Point ▁> ▁h ot Points ▁) ▁{ ▁this ▁. ▁h ot Points ▁= ▁h ot Points ▁; ▁} ▁public ▁static ▁long ▁get Serial version uid ▁( ▁) ▁{ ▁return ▁serial VersionUID ▁; ▁} ▁public ▁String ▁getS rc ▁( ▁) ▁{ ▁return ▁src ▁; ▁} ▁public ▁void ▁setS rc ▁( ▁String ▁src ▁) ▁{ ▁this ▁. ▁src ▁= ▁src ▁; ▁} ▁}
▁public ▁class ▁Volume Impl ▁implements ▁Volume ▁{ ▁private ▁static ▁final ▁Logger ▁LOG ▁= ▁LoggerFactory ▁. ▁getLogger ▁( ▁Volume Impl ▁. ▁class ▁) ▁; ▁private ▁final ▁Lock ▁readLock ▁; ▁private ▁final ▁Lock ▁writeLock ▁; ▁private ▁final ▁StateMachine ▁< ▁Volume State ▁, ▁Volume EventType ▁, ▁Volume Event ▁> ▁stateMachine ▁; ▁private ▁final ▁Volume Id ▁volume Id ▁; ▁private ▁final ▁Volume MetaData ▁volume Meta ▁; ▁private ▁Csi Adaptor Protocol ▁ad aptor Client ▁; ▁public ▁Volume Impl ▁( ▁Volume MetaData ▁volume Meta ▁) ▁{ ▁Read WriteLock ▁lock ▁= ▁new ▁Reentrant ReadWriteLock ▁( ▁) ▁; ▁this ▁. ▁writeLock ▁= ▁lock ▁. ▁writeLock ▁( ▁) ▁; ▁this ▁. ▁readLock ▁= ▁lock ▁. ▁readLock ▁( ▁) ▁; ▁this ▁. ▁volume Id ▁= ▁volume Meta ▁. ▁getVolume Id ▁( ▁) ▁; ▁this ▁. ▁volume Meta ▁= ▁volume Meta ▁; ▁this ▁. ▁stateMachine ▁= ▁create Volume StateFactory ▁( ▁) ▁. ▁make ▁( ▁this ▁) ▁; ▁} ▁@ ▁Visible ForTesting ▁public ▁void ▁setClient ▁( ▁Csi Adaptor Protocol ▁cs i Adaptor Client ▁) ▁{ ▁this ▁. ▁ad aptor Client ▁= ▁cs i Adaptor Client ▁; ▁} ▁@ ▁Override ▁public ▁Csi Adaptor Protocol ▁getClient ▁( ▁) ▁{ ▁return ▁this ▁. ▁ad aptor Client ▁; ▁} ▁@ ▁Override ▁public ▁Volume MetaData ▁getVolume Meta ▁( ▁) ▁{ ▁return ▁this ▁. ▁volume Meta ▁; ▁}
▁this ▁. ▁sy mlink Behavior ▁= ▁sy mlink Behavior ▁== ▁null ▁? ▁DEFAULT _ SY ML INK _ BE HA VI OR ▁: ▁sy mlink Behavior ▁; ▁this ▁. ▁strip Prefix ▁= ▁strip Prefix ▁== ▁null ▁? ▁DEFAULT _ STR IP _ PREFIX ▁: ▁strip Prefix ▁; ▁} ▁public ▁Label ▁getS rc Label ▁( ▁) ▁{ ▁return ▁src Label ▁; ▁} ▁public ▁PathFragment ▁getDest Dir ▁( ▁) ▁{ ▁return ▁dest Dir ▁; ▁} ▁public ▁S y mlink Behavior ▁getS y mlink Behavior ▁( ▁) ▁{ ▁return ▁sy mlink Behavior ▁; ▁} ▁@ ▁Nullable ▁public ▁ImmutableSet ▁< ▁String ▁> ▁get Exclude s ▁( ▁) ▁{ ▁return ▁excludes ▁; ▁} ▁@ ▁Nullable ▁public ▁ImmutableList ▁< ▁Label ▁> ▁getFiles ▁( ▁) ▁{ ▁return ▁files ▁; ▁} ▁public ▁boolean ▁is SourceFile set ▁( ▁) ▁{ ▁return ▁STR ▁. ▁equals ▁( ▁src Label ▁. ▁getName ▁( ▁) ▁) ▁; ▁} ▁public ▁Collection ▁< ▁Label ▁> ▁getLabels ▁( ▁) ▁{ ▁Set ▁< ▁Label ▁> ▁labels ▁= ▁new ▁LinkedHashSet ▁< ▁> ▁( ▁) ▁; ▁if ▁( ▁files ▁!= ▁null ▁) ▁{ ▁labels ▁. ▁addAll ▁( ▁files ▁) ▁; ▁} ▁else ▁{ ▁labels ▁. ▁add ▁( ▁src Label ▁) ▁; ▁} ▁return ▁labels ▁; ▁} ▁public ▁String ▁getSt rip Prefix ▁( ▁) ▁{ ▁return ▁strip Prefix ▁; ▁} ▁@ ▁Nullable ▁public ▁String ▁validate ▁( ▁) ▁{ ▁if ▁( ▁excludes ▁!= ▁null ▁&& ▁files ▁!= ▁null ▁) ▁{ ▁return ▁STR ▁; ▁} ▁else ▁if ▁( ▁files ▁!= ▁null ▁&& ▁! ▁is SourceFile set ▁( ▁) ▁) ▁{ ▁return ▁STR ▁+ ▁src Label ▁+ ▁STR ▁; ▁} ▁else ▁if ▁( ▁dest Dir ▁. ▁isA bsolute ▁( ▁) ▁) ▁{ ▁return ▁STR ▁+ ▁dest Dir ▁+ ▁STR ▁; ▁} ▁else ▁if ▁( ▁! ▁strip Prefix ▁. ▁equals ▁( ▁DEFAULT _ STR IP _ PREFIX ▁) ▁&& ▁files ▁== ▁null ▁) ▁{ ▁return ▁STR ▁+ ▁DEFAULT _ STR IP _ PREFIX ▁+ ▁STR ▁; ▁} ▁else ▁if ▁( ▁strip Prefix ▁. ▁startsWith ▁( ▁STR ▁) ▁) ▁{ ▁return ▁STR ▁+ ▁STR IP _ PREFIX _ WORK SPACE ▁+ ▁STR ▁; ▁} ▁else ▁if ▁( ▁PathFragment ▁. ▁create ▁( ▁strip Prefix ▁) ▁. ▁contains Up level References ▁( ▁) ▁) ▁{ ▁return ▁STR ▁; ▁} ▁else ▁if ▁( ▁strip Prefix ▁. ▁startsWith ▁( ▁STR ▁) ▁&& ▁! ▁strip Prefix ▁. ▁startsWith ▁( ▁STR IP _ PREFIX _ WORK SPACE ▁) ▁) ▁{ ▁return ▁STR ▁+ ▁STR IP _ PREFIX _ WORK SPACE ▁+ ▁STR ▁; ▁} ▁else ▁{ ▁return ▁null ▁; ▁} ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁String ▁. ▁format ▁( ▁STR ▁+ ▁STR ▁, ▁src Label ▁, ▁dest Dir ▁, ▁strip Prefix ▁, ▁sy mlink Behavior ▁, ▁files ▁!= ▁null ▁? ▁files ▁. ▁size ▁( ▁) ▁: ▁0 ▁, ▁excludes ▁!= ▁null ▁? ▁excludes ▁. ▁size ▁( ▁) ▁: ▁0 ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁Objects ▁. ▁hashCode ▁( ▁src Label ▁, ▁files ▁, ▁excludes ▁, ▁dest Dir ▁, ▁sy mlink Behavior ▁, ▁strip Prefix ▁) ▁; ▁}
▁@ ▁Data ▁@ ▁Entity ▁@ ▁Table ▁( ▁name ▁= ▁STR ▁, ▁indexes ▁= ▁{ ▁@ ▁Index ▁( ▁name ▁= ▁STR ▁, ▁column List ▁= ▁STR ▁) ▁, ▁@ ▁Index ▁( ▁name ▁= ▁STR ▁, ▁column List ▁= ▁STR ▁) ▁} ▁) ▁@ ▁ToString ▁( ▁callSuper ▁= ▁true ▁) ▁@ ▁Equals AndHashCode ▁( ▁callSuper ▁= ▁true ▁) ▁public ▁class ▁Theme Setting ▁extends ▁Base Entity ▁{ ▁@ ▁Id ▁@ ▁GeneratedValue ▁( ▁strategy ▁= ▁GenerationType ▁. ▁IDENTITY ▁, ▁generator ▁= ▁STR ▁) ▁@ ▁Generic Generator ▁( ▁name ▁= ▁STR ▁, ▁strategy ▁= ▁STR ▁) ▁private ▁Integer ▁id ▁; ▁@ ▁Column ▁( ▁name ▁= ▁STR ▁, ▁nullable ▁= ▁false ▁) ▁private ▁String ▁key ▁; ▁@ ▁Column ▁( ▁name ▁= ▁STR ▁, ▁nullable ▁= ▁false ▁) ▁@ ▁L ob ▁private ▁String ▁value ▁; ▁@ ▁Column ▁( ▁name ▁= ▁STR ▁, ▁nullable ▁= ▁false ▁) ▁private ▁String ▁theme Id ▁; ▁}
▁@ ▁Data ▁@ ▁ToString ▁( ▁callSuper ▁= ▁true ▁) ▁@ ▁Equals AndHashCode ▁( ▁callSuper ▁= ▁true ▁) ▁public ▁class ▁ServiceInstance Topology Matcher ▁extends ▁Abstract Matcher ▁< ▁ServiceInstance Topology ▁> ▁{ ▁private ▁List ▁< ▁ServiceInstance Node Matcher ▁> ▁nodes ▁; ▁private ▁List ▁< ▁Call Matcher ▁> ▁calls ▁; ▁@ ▁Override ▁public ▁void ▁verify ▁( ▁ServiceInstance Topology ▁to po Data ▁) ▁{ ▁if ▁( ▁nonNull ▁( ▁getNodes ▁( ▁) ▁) ▁) ▁{ ▁verify Nodes ▁( ▁to po Data ▁) ▁; ▁} ▁if ▁( ▁nonNull ▁( ▁get Calls ▁( ▁) ▁) ▁) ▁{ ▁convert NodeId ▁( ▁get Calls ▁( ▁) ▁, ▁to po Data ▁. ▁getNodes ▁( ▁) ▁) ▁; ▁verify Calls ▁( ▁to po Data ▁) ▁; ▁} ▁} ▁private ▁void ▁verify Nodes ▁( ▁ServiceInstance Topology ▁to po Data ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁getNodes ▁( ▁) ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁boolean ▁matched ▁= ▁false ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁to po Data ▁. ▁getNodes ▁( ▁) ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁try ▁{ ▁getNodes ▁( ▁) ▁. ▁get ▁( ▁i ▁) ▁. ▁verify ▁( ▁to po Data ▁. ▁getNodes ▁( ▁) ▁. ▁get ▁( ▁j ▁) ▁) ▁; ▁matched ▁= ▁true ▁; ▁} ▁catch ▁( ▁Throwable ▁ignored ▁) ▁{ ▁} ▁} ▁if ▁( ▁! ▁matched ▁) ▁{ ▁fail ▁( ▁STR ▁, ▁getNodes ▁( ▁) ▁, ▁to po Data ▁. ▁getNodes ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁private ▁void ▁verify Calls ▁( ▁ServiceInstance Topology ▁to po Data ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁get Calls ▁( ▁) ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁boolean ▁matched ▁= ▁false ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁to po Data ▁. ▁get Calls ▁( ▁) ▁. ▁size ▁( ▁) ▁; ▁j ▁++ ▁) ▁{ ▁try ▁{ ▁get Calls ▁( ▁) ▁. ▁get ▁( ▁i ▁) ▁. ▁verify ▁( ▁to po Data ▁. ▁get Calls ▁( ▁) ▁. ▁get ▁( ▁j ▁) ▁) ▁; ▁matched ▁= ▁true ▁; ▁} ▁catch ▁( ▁Throwable ▁ignored ▁) ▁{ ▁} ▁} ▁if ▁( ▁! ▁matched ▁) ▁{ ▁fail ▁( ▁STR ▁, ▁get Calls ▁( ▁) ▁, ▁to po Data ▁. ▁get Calls ▁( ▁) ▁) ▁; ▁} ▁} ▁} ▁private ▁static ▁void ▁convert NodeId ▁( ▁List ▁< ▁Call Matcher ▁> ▁call Matchers ▁, ▁List ▁< ▁ServiceInstance Node ▁> ▁nodes ▁) ▁{ ▁for ▁( ▁Call Matcher ▁call Matcher ▁: ▁call Matchers ▁) ▁{ ▁ServiceInstance Node ▁source Node ▁= ▁Variable Ex press Parser ▁. ▁parse ▁( ▁call Matcher ▁. ▁getSource ▁( ▁) ▁, ▁nodes ▁, ▁ServiceInstance Node ▁:: ▁getName ▁) ▁; ▁ServiceInstance Node ▁target Node ▁= ▁Variable Ex press Parser ▁. ▁parse ▁( ▁call Matcher ▁. ▁getTarget ▁( ▁) ▁, ▁nodes ▁, ▁ServiceInstance Node ▁:: ▁getName ▁) ▁; ▁boolean ▁convert ▁= ▁false ▁; ▁if ▁( ▁nonNull ▁( ▁source Node ▁) ▁) ▁{ ▁call Matcher ▁. ▁setSource ▁( ▁source Node ▁. ▁getId ▁( ▁) ▁) ▁; ▁convert ▁= ▁true ▁; ▁}
▁@ ▁Cluster Scope ▁( ▁scope ▁= ▁Scope ▁. ▁SU ITE ▁, ▁supports Ded icated M asters ▁= ▁false ▁, ▁numDataNodes ▁= ▁2 ▁) ▁public ▁class ▁Fetch Sub Phase Plugin IT ▁extends ▁ESIntegTestCase ▁{ ▁@ ▁Override ▁protected ▁Collection ▁< ▁Class ▁< ▁? ▁extends ▁Plugin ▁> ▁> ▁node Plugins ▁( ▁) ▁{ ▁return ▁Collections ▁. ▁singletonList ▁( ▁Fetch Term Vectors Plugin ▁. ▁class ▁) ▁; ▁} ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁public ▁void ▁test Plugin ▁( ▁) ▁throws ▁Exception ▁{ ▁client ▁( ▁) ▁. ▁admin ▁( ▁) ▁. ▁indices ▁( ▁) ▁. ▁prepareCreate ▁( ▁STR ▁) ▁. ▁set Mapping ▁( ▁jsonBuilder ▁( ▁) ▁. ▁startObject ▁( ▁) ▁. ▁startObject ▁( ▁STR ▁) ▁. ▁startObject ▁( ▁STR ▁) ▁. ▁startObject ▁( ▁STR ▁) ▁. ▁field ▁( ▁STR ▁, ▁STR ▁) ▁. ▁field ▁( ▁STR ▁, ▁STR ▁) ▁. ▁endObject ▁( ▁) ▁. ▁endObject ▁( ▁) ▁. ▁endObject ▁( ▁) ▁. ▁endObject ▁( ▁) ▁) ▁. ▁get ▁( ▁) ▁; ▁client ▁( ▁) ▁. ▁index ▁( ▁index Request ▁( ▁STR ▁) ▁. ▁id ▁( ▁STR ▁) ▁. ▁source ▁( ▁jsonBuilder ▁( ▁) ▁. ▁startObject ▁( ▁) ▁. ▁field ▁( ▁STR ▁, ▁STR ▁) ▁. ▁endObject ▁( ▁) ▁) ▁) ▁. ▁actionGet ▁( ▁) ▁; ▁client ▁( ▁) ▁. ▁admin ▁( ▁) ▁. ▁indices ▁( ▁) ▁. ▁prepare Refresh ▁( ▁) ▁. ▁get ▁( ▁) ▁; ▁SearchResponse ▁response ▁= ▁client ▁( ▁) ▁. ▁prepareSearch ▁( ▁) ▁. ▁setSource ▁( ▁new ▁Search SourceBuilder ▁( ▁) ▁. ▁ext ▁( ▁Collections ▁. ▁singletonList ▁( ▁new ▁Term Vectors Fetch Builder ▁( ▁STR ▁) ▁) ▁) ▁) ▁. ▁get ▁( ▁) ▁; ▁assert SearchResponse ▁( ▁response ▁) ▁; ▁assertThat ▁( ▁( ▁( ▁Map ▁< ▁String ▁, ▁Integer ▁> ▁) ▁response ▁. ▁getHits ▁( ▁) ▁. ▁get At ▁( ▁0 ▁) ▁. ▁field ▁( ▁STR ▁) ▁. ▁getValues ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁) ▁. ▁get ▁( ▁STR ▁) ▁, ▁equalTo ▁( ▁2 ▁) ▁) ▁; ▁assertThat ▁( ▁( ▁( ▁Map ▁< ▁String ▁, ▁Integer ▁> ▁) ▁response ▁. ▁getHits ▁( ▁) ▁. ▁get At ▁( ▁0 ▁) ▁. ▁field ▁( ▁STR ▁) ▁. ▁getValues ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁) ▁. ▁get ▁( ▁STR ▁) ▁, ▁equalTo ▁( ▁2 ▁) ▁) ▁; ▁assertThat ▁( ▁( ▁( ▁Map ▁< ▁String ▁, ▁Integer ▁> ▁) ▁response ▁. ▁getHits ▁( ▁) ▁. ▁get At ▁( ▁0 ▁) ▁. ▁field ▁( ▁STR ▁) ▁. ▁getValues ▁( ▁) ▁. ▁get ▁( ▁0 ▁) ▁) ▁. ▁get ▁( ▁STR ▁) ▁, ▁equalTo ▁( ▁1 ▁) ▁) ▁; ▁} ▁public ▁static ▁class ▁Fetch Term Vectors Plugin ▁extends ▁Plugin ▁implements ▁Search Plugin ▁{ ▁@ ▁Override ▁public ▁List ▁< ▁Fetch Sub Phase ▁> ▁getF etch Sub Phase s ▁( ▁Fetch Phase Construction Context ▁context ▁) ▁{ ▁return ▁singletonList ▁( ▁new ▁Term Vectors Fetch Sub Phase ▁( ▁) ▁) ▁; ▁}
▁} ▁} ▁) ▁; ▁Recording Subscriber ▁< ▁String ▁> ▁subscriber ▁= ▁subscriber Rule ▁. ▁create ▁( ▁) ▁; ▁final ▁AtomicReference ▁< ▁Throwable ▁> ▁error Ref ▁= ▁new ▁AtomicReference ▁< ▁> ▁( ▁) ▁; ▁final ▁Runtime Exception ▁e ▁= ▁new ▁Runtime Exception ▁( ▁) ▁; ▁service ▁. ▁body ▁( ▁) ▁. ▁subscribe ▁( ▁new ▁Forwarding Subscriber ▁< ▁String ▁> ▁( ▁subscriber ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁onError ▁( ▁Throwable ▁throwable ▁) ▁{ ▁if ▁( ▁! ▁error Ref ▁. ▁compareAndSet ▁( ▁null ▁, ▁throwable ▁) ▁) ▁{ ▁throw ▁Exceptions ▁. ▁propagate ▁( ▁throwable ▁) ▁; ▁} ▁throw ▁e ▁; ▁} ▁} ▁) ▁; ▁Composite Exception ▁composite ▁= ▁( ▁Composite Exception ▁) ▁throwable Ref ▁. ▁get ▁( ▁) ▁; ▁assertThat ▁( ▁composite ▁. ▁get Exceptions ▁( ▁) ▁) ▁. ▁containsExactly ▁( ▁error Ref ▁. ▁get ▁( ▁) ▁, ▁e ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁response Throwing In OnNext Del iver ed To Error ▁( ▁) ▁{ ▁server ▁. ▁enqueue ▁( ▁new ▁MockResponse ▁( ▁) ▁) ▁; ▁Recording Subscriber ▁< ▁Response ▁< ▁String ▁> ▁> ▁subscriber ▁= ▁subscriber Rule ▁. ▁create ▁( ▁) ▁; ▁final ▁Runtime Exception ▁e ▁= ▁new ▁Runtime Exception ▁( ▁) ▁; ▁service ▁. ▁response ▁( ▁) ▁. ▁safe Subscribe ▁( ▁new ▁Forwarding Subscriber ▁< ▁Response ▁< ▁String ▁> ▁> ▁( ▁subscriber ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁onNext ▁( ▁Response ▁< ▁String ▁> ▁value ▁) ▁{ ▁throw ▁e ▁; ▁} ▁} ▁) ▁; ▁subscriber ▁. ▁assertError ▁( ▁e ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁response Throwing In On Complete Del iver ed To Plugin ▁( ▁) ▁{ ▁server ▁. ▁enqueue ▁( ▁new ▁MockResponse ▁( ▁) ▁) ▁; ▁final ▁AtomicReference ▁< ▁Throwable ▁> ▁throwable Ref ▁= ▁new ▁AtomicReference ▁< ▁> ▁( ▁) ▁; ▁RxJavaPlugins ▁. ▁set ErrorHandler ▁( ▁throwable ▁-> ▁{ ▁if ▁( ▁! ▁throwable Ref ▁. ▁compareAndSet ▁( ▁null ▁, ▁throwable ▁) ▁) ▁{ ▁throw ▁Exceptions ▁. ▁propagate ▁( ▁throwable ▁) ▁; ▁} ▁} ▁) ▁; ▁Recording Subscriber ▁< ▁Response ▁< ▁String ▁> ▁> ▁subscriber ▁= ▁subscriber Rule ▁. ▁create ▁( ▁) ▁; ▁final ▁Runtime Exception ▁e ▁= ▁new ▁Runtime Exception ▁( ▁) ▁; ▁service ▁. ▁response ▁( ▁) ▁. ▁subscribe ▁( ▁new ▁Forwarding Subscriber ▁< ▁Response ▁< ▁String ▁> ▁> ▁( ▁subscriber ▁) ▁{ ▁@ ▁Override ▁public ▁void ▁onComplete ▁( ▁) ▁{ ▁throw ▁e ▁; ▁} ▁} ▁) ▁; ▁subscriber ▁. ▁assert Any Value ▁( ▁) ▁; ▁assertThat ▁( ▁throwable Ref ▁. ▁get ▁( ▁) ▁. ▁getCause ▁( ▁) ▁) ▁. ▁isSameAs ▁( ▁e ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁response Throwing In OnError Del iver ed To Plugin ▁( ▁) ▁{ ▁server ▁. ▁enqueue ▁( ▁new ▁MockResponse ▁( ▁) ▁. ▁set Socket Policy ▁( ▁DIS CONNECT _ AFTER _ REQUEST ▁) ▁) ▁; ▁final ▁AtomicReference ▁< ▁Throwable ▁> ▁throwable Ref ▁= ▁new ▁AtomicReference ▁< ▁> ▁( ▁) ▁; ▁RxJavaPlugins ▁. ▁set ErrorHandler ▁( ▁throwable ▁-> ▁{ ▁if ▁( ▁! ▁throwable Ref ▁. ▁compareAndSet ▁( ▁null ▁, ▁throwable ▁) ▁) ▁{ ▁throw ▁Exceptions ▁. ▁propagate ▁( ▁throwable ▁) ▁; ▁} ▁} ▁) ▁;
▁public ▁class ▁Job s Overview Handler ▁extends ▁Abstract RestHandler ▁< ▁RestfulGateway ▁, ▁Empty RequestBody ▁, ▁Multiple Jobs Details ▁, ▁Empty Message Parameters ▁> ▁implements ▁On ly ExecutionGraph Json Arch iv ist ▁{ ▁public ▁Job s Overview Handler ▁( ▁Gateway Retriever ▁< ▁? ▁extends ▁RestfulGateway ▁> ▁leader Retriever ▁, ▁Time ▁timeout ▁, ▁Map ▁< ▁String ▁, ▁String ▁> ▁responseHeaders ▁, ▁MessageHeaders ▁< ▁Empty RequestBody ▁, ▁Multiple Jobs Details ▁, ▁Empty Message Parameters ▁> ▁message Headers ▁) ▁{ ▁super ▁( ▁leader Retriever ▁, ▁timeout ▁, ▁responseHeaders ▁, ▁message Headers ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁Completable Future ▁< ▁Multiple Jobs Details ▁> ▁handleRequest ▁( ▁@ ▁Nonnull ▁HandlerRequest ▁< ▁Empty RequestBody ▁, ▁Empty Message Parameters ▁> ▁request ▁, ▁@ ▁Nonnull ▁RestfulGateway ▁gateway ▁) ▁throws ▁Rest HandlerException ▁{ ▁return ▁gateway ▁. ▁request Multiple Job Details ▁( ▁timeout ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Collection ▁< ▁Archived Json ▁> ▁archive Json WithPath ▁( ▁Access ExecutionGraph ▁graph ▁) ▁throws ▁IOException ▁{ ▁ResponseBody ▁json ▁= ▁new ▁Multiple Jobs Details ▁( ▁Collections ▁. ▁singleton ▁( ▁Job Details ▁. ▁create Details For Job ▁( ▁graph ▁) ▁) ▁) ▁; ▁String ▁path ▁= ▁getMessage Headers ▁( ▁) ▁. ▁getTarget Rest Endpoint URL ▁( ▁) ▁. ▁replace ▁( ▁CHAR ▁+ ▁JobID PathParameter ▁. ▁KEY ▁, ▁graph ▁. ▁getJobID ▁( ▁) ▁. ▁toString ▁( ▁) ▁) ▁; ▁return ▁Collections ▁. ▁singletonList ▁( ▁new ▁Archived Json ▁( ▁path ▁, ▁json ▁) ▁) ▁; ▁} ▁}
▁@ ▁RunWith ▁( ▁JUnit 4 ▁. ▁class ▁) ▁public ▁class ▁Scan UtilTest ▁{ ▁@ ▁Test ▁public ▁void ▁test Scan To ▁( ▁) ▁{ ▁assertThrows ▁( ▁NullPointer Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁assert Location ▁( ▁null ▁, ▁new ▁byte ▁[ ▁] ▁{ ▁} ▁, ▁- ▁1 ▁) ▁) ▁; ▁assertThrows ▁( ▁NullPointer Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁assert Location ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁} ▁, ▁null ▁, ▁- ▁1 ▁) ▁) ▁; ▁assert Location ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁} ▁, ▁new ▁byte ▁[ ▁] ▁{ ▁} ▁, ▁- ▁1 ▁) ▁; ▁assert Location ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁} ▁, ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁} ▁, ▁0 ▁) ▁; ▁assert Location ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁} ▁, ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁0 ▁) ▁; ▁assert Location ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁} ▁, ▁new ▁byte ▁[ ▁] ▁{ ▁} ▁, ▁- ▁1 ▁) ▁; ▁assert Location ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁} ▁, ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁} ▁, ▁0 ▁) ▁; ▁assert Location ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁} ▁, ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁0 ▁) ▁; ▁assert Location ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁} ▁, ▁new ▁byte ▁[ ▁] ▁{ ▁5 ▁, ▁4 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁2 ▁) ▁; ▁assert Location ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁} ▁, ▁new ▁byte ▁[ ▁] ▁{ ▁4 ▁, ▁2 ▁, ▁3 ▁, ▁1 ▁} ▁, ▁3 ▁) ▁; ▁assert Location ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁new ▁byte ▁[ ▁] ▁{ ▁} ▁, ▁- ▁1 ▁) ▁; ▁assert Location ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁} ▁, ▁- ▁1 ▁) ▁; ▁assert Location ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁0 ▁) ▁; ▁assert Location ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁0 ▁) ▁; ▁assert Location ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁new ▁byte ▁[ ▁] ▁{ ▁5 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁1 ▁) ▁; ▁assert Location ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁} ▁, ▁new ▁byte ▁[ ▁] ▁{ ▁5 ▁, ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁, ▁5 ▁} ▁, ▁1 ▁) ▁; ▁assert Location ▁( ▁new ▁byte ▁[ ▁] ▁{ ▁1 ▁, ▁2 ▁, ▁3 ▁, ▁4 ▁}
▁@ ▁RunWith ▁( ▁JUnit 4 ▁. ▁class ▁) ▁public ▁final ▁class ▁Starlark Repository Context Test ▁{ ▁private ▁Sc ratch ▁scratch ▁; ▁private ▁Path ▁output Directory ▁; ▁private ▁Root ▁root ▁; ▁private ▁Path ▁workspace File ▁; ▁private ▁Starlark Repository Context ▁context ▁; ▁private ▁static ▁final ▁StarlarkThread ▁thread ▁= ▁new ▁StarlarkThread ▁( ▁M ut ability ▁. ▁create ▁( ▁STR ▁) ▁, ▁Starlark Semantics ▁. ▁DEFAULT ▁) ▁; ▁private ▁static ▁String ▁ONE _ LINE _ PAT CH ▁= ▁STR ▁; ▁@ ▁Before ▁public ▁void ▁setUp ▁( ▁) ▁throws ▁Exception ▁{ ▁scratch ▁= ▁new ▁Sc ratch ▁( ▁STR ▁) ▁; ▁output Directory ▁= ▁scratch ▁. ▁dir ▁( ▁STR ▁) ▁; ▁root ▁= ▁Root ▁. ▁from Path ▁( ▁scratch ▁. ▁dir ▁( ▁STR ▁) ▁) ▁; ▁workspace File ▁= ▁scratch ▁. ▁file ▁( ▁STR ▁) ▁; ▁} ▁protected ▁static ▁RuleClass ▁build Rule Class ▁( ▁Attribute ▁... ▁attributes ▁) ▁{ ▁RuleClass ▁. ▁Builder ▁rule Class Builder ▁= ▁new ▁RuleClass ▁. ▁Builder ▁( ▁STR ▁, ▁RuleClass Type ▁. ▁W OR K SPACE ▁, ▁true ▁) ▁; ▁for ▁( ▁Attribute ▁attr ▁: ▁attributes ▁) ▁{ ▁rule Class Builder ▁. ▁addAttribute ▁( ▁attr ▁) ▁; ▁} ▁rule Class Builder ▁. ▁set Workspace Only ▁( ▁) ▁; ▁rule Class Builder ▁. ▁set ConfiguredTarget Function ▁( ▁( ▁Starlark Function ▁) ▁exec ▁( ▁STR ▁, ▁STR ▁) ▁) ▁; ▁return ▁rule Class Builder ▁. ▁build ▁( ▁) ▁; ▁} ▁private ▁static ▁Object ▁exec ▁( ▁String ▁... ▁lines ▁) ▁{ ▁try ▁{ ▁return ▁Starlark ▁. ▁exec File ▁( ▁Parser Input ▁. ▁from Lines ▁( ▁lines ▁) ▁, ▁File Options ▁. ▁DEFAULT ▁, ▁Module ▁. ▁create ▁( ▁) ▁, ▁thread ▁) ▁; ▁} ▁catch ▁( ▁Exception ▁ex ▁) ▁{ ▁throw ▁new ▁AssertionError ▁( ▁STR ▁, ▁ex ▁) ▁; ▁} ▁} ▁private ▁static ▁final ▁ImmutableList ▁< ▁StarlarkThread ▁. ▁Call Stack Entry ▁> ▁DUMMY _ STACK ▁= ▁ImmutableList ▁. ▁of ▁( ▁new ▁StarlarkThread ▁. ▁Call Stack Entry ▁( ▁STR ▁, ▁Location ▁. ▁from File Line Column ▁( ▁STR ▁, ▁10 ▁, ▁1 ▁) ▁) ▁, ▁new ▁StarlarkThread ▁. ▁Call Stack Entry ▁( ▁STR ▁, ▁Location ▁. ▁from File Line Column ▁( ▁STR ▁, ▁42 ▁, ▁1 ▁) ▁) ▁, ▁new ▁StarlarkThread ▁. ▁Call Stack Entry ▁( ▁STR ▁, ▁Location ▁. ▁from File Line Column ▁( ▁STR ▁, ▁30 ▁, ▁6 ▁) ▁) ▁) ▁; ▁protected ▁void ▁setUp Context For Rule ▁( ▁Map ▁< ▁String ▁, ▁Object ▁> ▁k w args ▁, ▁ImmutableSet ▁< ▁PathFragment ▁> ▁ignored Path Fragments ▁, ▁Starlark Semantics ▁starlark Semantics ▁, ▁@ ▁Nullable ▁Repository Remote Executor ▁repo Remote Executor ▁, ▁Attribute ▁... ▁attributes ▁) ▁throws ▁Exception ▁{ ▁Package ▁. ▁Builder ▁package Builder ▁= ▁Package ▁. ▁new External Package Builder ▁( ▁Default Package Settings ▁. ▁INSTANCE ▁, ▁RootedPath ▁. ▁to R ootedPath ▁( ▁root ▁, ▁workspace File ▁) ▁, ▁STR ▁, ▁starlark Semantics ▁) ▁; ▁Extended EventHandler ▁listener ▁= ▁Mockito ▁. ▁mock ▁( ▁Extended EventHandler ▁. ▁class ▁) ▁; ▁Rule ▁rule ▁= ▁Workspace Factory Helper ▁. ▁createAnd Add Repository Rule ▁( ▁build Rule Class ▁( ▁attributes ▁) ▁, ▁null ▁, ▁k w args ▁, ▁starlark Semantics ▁, ▁DUMMY _ STACK ▁) ▁;
▁public ▁class ▁Asci id o ctor Demo IntegrationTest ▁{ ▁@ ▁Test ▁public ▁void ▁givenString _ when Conver ting _ then Result ing HTML Code ▁( ▁) ▁{ ▁final ▁Asci id o ctor Demo ▁as ci id o ctor Demo ▁= ▁new ▁Asci id o ctor Demo ▁( ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁as ci id o ctor Demo ▁. ▁generate HTML FromString ▁( ▁STR ▁) ▁, ▁STR ▁) ▁; ▁} ▁}
▁public ▁class ▁Normal Msg Dynamic Balance IT ▁extends ▁Base Conf ▁{ ▁private ▁static ▁Logger ▁logger ▁= ▁Logger ▁. ▁getLogger ▁( ▁Normal Msg Static Balance IT ▁. ▁class ▁) ▁; ▁private ▁RMQNormal Producer ▁producer ▁= ▁null ▁; ▁private ▁String ▁topic ▁= ▁null ▁; ▁@ ▁Before ▁public ▁void ▁setUp ▁( ▁) ▁{ ▁topic ▁= ▁init Topic ▁( ▁) ▁; ▁logger ▁. ▁info ▁( ▁String ▁. ▁format ▁( ▁STR ▁, ▁topic ▁) ▁) ▁; ▁producer ▁= ▁getProducer ▁( ▁nsAddr ▁, ▁topic ▁) ▁; ▁} ▁@ ▁After ▁public ▁void ▁tearDown ▁( ▁) ▁{ ▁super ▁. ▁shutdown ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Two Consumer And Crash One ▁( ▁) ▁{ ▁int ▁msgSize ▁= ▁400 ▁; ▁RMQNormal Consumer ▁consumer 1 ▁= ▁getConsumer ▁( ▁nsAddr ▁, ▁topic ▁, ▁STR ▁, ▁new ▁RMQNormal Listener ▁( ▁) ▁) ▁; ▁RMQNormal Consumer ▁consumer 2 ▁= ▁getConsumer ▁( ▁nsAddr ▁, ▁consumer 1 ▁. ▁getConsumer Group ▁( ▁) ▁, ▁topic ▁, ▁STR ▁, ▁new ▁RMQNormal Listener ▁( ▁) ▁) ▁; ▁TestUtils ▁. ▁waitFor Seconds ▁( ▁waitTime ▁) ▁; ▁producer ▁. ▁send ▁( ▁msgSize ▁) ▁; ▁MQ Wait ▁. ▁wait Consume All ▁( ▁consume Time ▁, ▁producer ▁. ▁getAllMsgBody ▁( ▁) ▁, ▁consumer 1 ▁. ▁getListener ▁( ▁) ▁, ▁consumer 2 ▁. ▁getListener ▁( ▁) ▁) ▁; ▁consumer 2 ▁. ▁shutdown ▁( ▁) ▁; ▁producer ▁. ▁send ▁( ▁msgSize ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁msgSize ▁ * ▁2 ▁, ▁producer ▁. ▁getAll Un d up MsgBody ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁boolean ▁recv All ▁= ▁MQ Wait ▁. ▁wait Consume All ▁( ▁consume Time ▁, ▁producer ▁. ▁getAllMsgBody ▁( ▁) ▁, ▁consumer 1 ▁. ▁getListener ▁( ▁) ▁, ▁consumer 2 ▁. ▁getListener ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁recv All ▁) ▁. ▁isEqualTo ▁( ▁true ▁) ▁; ▁boolean ▁balance ▁= ▁Verify Utils ▁. ▁verify Balance ▁( ▁msgSize ▁, ▁Verify Utils ▁. ▁getFilter d Message ▁( ▁producer ▁. ▁getAllMsgBody ▁( ▁) ▁, ▁consumer 1 ▁. ▁getListener ▁( ▁) ▁. ▁getAll Un d up MsgBody ▁( ▁) ▁) ▁. ▁size ▁( ▁) ▁- ▁msgSize ▁, ▁Verify Utils ▁. ▁getFilter d Message ▁( ▁producer ▁. ▁getAllMsgBody ▁( ▁) ▁, ▁consumer 2 ▁. ▁getListener ▁( ▁) ▁. ▁getAll Un d up MsgBody ▁( ▁) ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁balance ▁) ▁. ▁isEqualTo ▁( ▁true ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test 3 Consumer And Crash One ▁( ▁) ▁{ ▁int ▁msgSize ▁= ▁400 ▁; ▁RMQNormal Consumer ▁consumer 1 ▁= ▁getConsumer ▁( ▁nsAddr ▁, ▁topic ▁, ▁STR ▁, ▁new ▁RMQNormal Listener ▁( ▁) ▁) ▁; ▁RMQNormal Consumer ▁consumer 2 ▁= ▁getConsumer ▁( ▁nsAddr ▁, ▁consumer 1 ▁. ▁getConsumer Group ▁( ▁) ▁, ▁topic ▁, ▁STR ▁, ▁new ▁RMQNormal Listener ▁( ▁) ▁) ▁; ▁RMQNormal Consumer ▁consumer 3 ▁= ▁getConsumer ▁( ▁nsAddr ▁, ▁consumer 1 ▁. ▁getConsumer Group ▁( ▁) ▁, ▁topic ▁, ▁STR ▁, ▁new ▁RMQNormal Listener ▁( ▁) ▁) ▁; ▁TestUtils ▁. ▁waitFor Seconds ▁( ▁waitTime ▁) ▁; ▁producer ▁. ▁send ▁( ▁msgSize ▁) ▁;
▁public ▁class ▁Test Weight No ise ▁extends ▁BaseDL 4 JTest ▁{ ▁@ ▁Test ▁public ▁void ▁test Weight No ise Config Json ▁( ▁) ▁{ ▁I Weight No ise ▁[ ▁] ▁weight No ise s ▁= ▁new ▁I Weight No ise ▁[ ▁] ▁{ ▁new ▁Drop Connect ▁( ▁0.5 ▁) ▁, ▁new ▁Drop Connect ▁( ▁new ▁S ig m oid Schedule ▁( ▁Schedule Type ▁. ▁ITER ATION ▁, ▁0.5 ▁, ▁0.5 ▁, ▁100 ▁) ▁) ▁, ▁new ▁Weight No ise ▁( ▁new ▁Normal Distribution ▁( ▁0 ▁, ▁0.1 ▁) ▁) ▁} ▁; ▁for ▁( ▁I Weight No ise ▁w n ▁: ▁weight No ise s ▁) ▁{ ▁MultiLayer Configuration ▁conf ▁= ▁new ▁NeuralNet Configuration ▁. ▁Builder ▁( ▁) ▁. ▁weight No ise ▁( ▁w n ▁) ▁. ▁list ▁( ▁) ▁. ▁layer ▁( ▁new ▁Dense Layer ▁. ▁Builder ▁( ▁) ▁. ▁nIn ▁( ▁10 ▁) ▁. ▁nOut ▁( ▁10 ▁) ▁. ▁build ▁( ▁) ▁) ▁. ▁layer ▁( ▁new ▁Dense Layer ▁. ▁Builder ▁( ▁) ▁. ▁nIn ▁( ▁10 ▁) ▁. ▁nOut ▁( ▁10 ▁) ▁. ▁weight No ise ▁( ▁new ▁Drop Connect ▁( ▁0.25 ▁) ▁) ▁. ▁build ▁( ▁) ▁) ▁. ▁layer ▁( ▁new ▁Output Layer ▁. ▁Builder ▁( ▁) ▁. ▁nIn ▁( ▁10 ▁) ▁. ▁nOut ▁( ▁10 ▁) ▁. ▁activation ▁( ▁Activation ▁. ▁S OFT MAX ▁) ▁. ▁build ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁; ▁MultiLayer Network ▁net ▁= ▁new ▁MultiLayer Network ▁( ▁conf ▁) ▁; ▁net ▁. ▁init ▁( ▁) ▁; ▁assertEquals ▁( ▁w n ▁, ▁( ▁( ▁Base Layer ▁) ▁net ▁. ▁getLayer ▁( ▁0 ▁) ▁. ▁conf ▁( ▁) ▁. ▁getLayer ▁( ▁) ▁) ▁. ▁getWeight No ise ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁new ▁Drop Connect ▁( ▁0.25 ▁) ▁, ▁( ▁( ▁Base Layer ▁) ▁net ▁. ▁getLayer ▁( ▁1 ▁) ▁. ▁conf ▁( ▁) ▁. ▁getLayer ▁( ▁) ▁) ▁. ▁getWeight No ise ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁w n ▁, ▁( ▁( ▁Base Layer ▁) ▁net ▁. ▁getLayer ▁( ▁2 ▁) ▁. ▁conf ▁( ▁) ▁. ▁getLayer ▁( ▁) ▁) ▁. ▁getWeight No ise ▁( ▁) ▁) ▁; ▁TestUtils ▁. ▁test Model Serialization ▁( ▁net ▁) ▁; ▁Comp utationGraph Configuration ▁conf 2 ▁= ▁new ▁NeuralNet Configuration ▁. ▁Builder ▁( ▁) ▁. ▁weight No ise ▁( ▁w n ▁) ▁. ▁graph Builder ▁( ▁) ▁. ▁add Inputs ▁( ▁STR ▁) ▁. ▁layer ▁( ▁STR ▁, ▁new ▁Dense Layer ▁. ▁Builder ▁( ▁) ▁. ▁nIn ▁( ▁10 ▁) ▁. ▁nOut ▁( ▁10 ▁) ▁. ▁build ▁( ▁) ▁, ▁STR ▁) ▁. ▁layer ▁( ▁STR ▁, ▁new ▁Dense Layer ▁. ▁Builder ▁( ▁) ▁. ▁nIn ▁( ▁10 ▁) ▁. ▁nOut ▁( ▁10 ▁) ▁. ▁weight No ise ▁( ▁new ▁Drop Connect ▁( ▁0.25 ▁) ▁) ▁. ▁build ▁( ▁) ▁, ▁STR ▁) ▁. ▁layer ▁( ▁STR ▁, ▁new ▁Output Layer ▁. ▁Builder ▁( ▁) ▁. ▁nIn ▁( ▁10 ▁) ▁. ▁nOut ▁( ▁10 ▁) ▁. ▁activation ▁( ▁Activation ▁. ▁S OFT MAX ▁) ▁. ▁build ▁( ▁) ▁, ▁STR ▁) ▁. ▁setOutput s ▁( ▁STR ▁) ▁. ▁build ▁( ▁) ▁;
▁} ▁} ▁try ▁{ ▁return ▁client ▁. ▁store File ▁( ▁fileName ▁, ▁file Stream ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁throw ▁new ▁IO RuntimeException ▁( ▁e ▁) ▁; ▁} ▁finally ▁{ ▁if ▁( ▁this ▁. ▁back To P wd ▁) ▁{ ▁cd ▁( ▁pw d ▁) ▁; ▁} ▁} ▁} ▁@ ▁Override ▁public ▁void ▁download ▁( ▁String ▁path ▁, ▁File ▁out File ▁) ▁{ ▁final ▁String ▁fileName ▁= ▁FileUtil ▁. ▁getName ▁( ▁path ▁) ▁; ▁final ▁String ▁dir ▁= ▁StrUtil ▁. ▁remove Suffix ▁( ▁path ▁, ▁fileName ▁) ▁; ▁download ▁( ▁dir ▁, ▁fileName ▁, ▁out File ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁recursive Download Folder ▁( ▁String ▁source Path ▁, ▁File ▁dest Dir ▁) ▁{ ▁String ▁fileName ▁; ▁String ▁src File ▁; ▁File ▁dest File ▁; ▁for ▁( ▁F T P File ▁f tp File ▁: ▁ls Files ▁( ▁source Path ▁, ▁null ▁) ▁) ▁{ ▁fileName ▁= ▁f tp File ▁. ▁getName ▁( ▁) ▁; ▁src File ▁= ▁StrUtil ▁. ▁format ▁( ▁STR ▁, ▁source Path ▁, ▁fileName ▁) ▁; ▁dest File ▁= ▁FileUtil ▁. ▁file ▁( ▁dest Dir ▁, ▁fileName ▁) ▁; ▁if ▁( ▁false ▁== ▁f tp File ▁. ▁isDirectory ▁( ▁) ▁) ▁{ ▁if ▁( ▁false ▁== ▁FileUtil ▁. ▁exist ▁( ▁dest File ▁) ▁|| ▁( ▁f tp File ▁. ▁getTimestamp ▁( ▁) ▁. ▁getTime InMillis ▁( ▁) ▁> ▁dest File ▁. ▁lastModified ▁( ▁) ▁) ▁) ▁{ ▁download ▁( ▁src File ▁, ▁dest File ▁) ▁; ▁} ▁} ▁else ▁{ ▁FileUtil ▁. ▁mkdir ▁( ▁dest File ▁) ▁; ▁recursive Download Folder ▁( ▁src File ▁, ▁dest File ▁) ▁; ▁} ▁} ▁} ▁public ▁void ▁download ▁( ▁String ▁path ▁, ▁String ▁fileName ▁, ▁File ▁out File ▁) ▁throws ▁IO RuntimeException ▁{ ▁if ▁( ▁out File ▁. ▁isDirectory ▁( ▁) ▁) ▁{ ▁out File ▁= ▁new ▁File ▁( ▁out File ▁, ▁fileName ▁) ▁; ▁} ▁if ▁( ▁false ▁== ▁out File ▁. ▁exists ▁( ▁) ▁) ▁{ ▁FileUtil ▁. ▁touch ▁( ▁out File ▁) ▁; ▁} ▁try ▁( ▁OutputStream ▁out ▁= ▁FileUtil ▁. ▁getOutputStream ▁( ▁out File ▁) ▁) ▁{ ▁download ▁( ▁path ▁, ▁fileName ▁, ▁out ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁throw ▁new ▁IO RuntimeException ▁( ▁e ▁) ▁; ▁} ▁} ▁public ▁void ▁download ▁( ▁String ▁path ▁, ▁String ▁fileName ▁, ▁OutputStream ▁out ▁) ▁{ ▁download ▁( ▁path ▁, ▁fileName ▁, ▁out ▁, ▁null ▁) ▁; ▁} ▁public ▁void ▁download ▁( ▁String ▁path ▁, ▁String ▁fileName ▁, ▁OutputStream ▁out ▁, ▁Charset ▁fileName Charset ▁) ▁throws ▁IO RuntimeException ▁{ ▁String ▁pw d ▁= ▁null ▁; ▁if ▁( ▁this ▁. ▁back To P wd ▁) ▁{ ▁pw d ▁= ▁pw d ▁( ▁) ▁; ▁} ▁if ▁( ▁false ▁== ▁is Dir ▁( ▁path ▁) ▁) ▁{ ▁throw ▁new ▁F tp Exception ▁( ▁STR ▁, ▁path ▁) ▁; ▁} ▁if ▁( ▁null ▁!= ▁fileName Charset ▁) ▁{ ▁fileName ▁= ▁new ▁String ▁( ▁fileName ▁. ▁getBytes ▁( ▁fileName Charset ▁) ▁, ▁Standard Charsets ▁. ▁ISO _88 59 _1 ▁) ▁; ▁}
▁@ ▁Override ▁public ▁void ▁release Period ▁( ▁Media Period ▁media Period ▁) ▁{ ▁( ▁( ▁Progress ive Media Period ▁) ▁media Period ▁) ▁. ▁release ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁release Source Internal ▁( ▁) ▁{ ▁d rm SessionManager ▁. ▁release ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁on Source Info Refresh ed ▁( ▁long ▁duration Us ▁, ▁boolean ▁is Seek able ▁, ▁boolean ▁is Live ▁) ▁{ ▁duration Us ▁= ▁duration Us ▁== ▁C ▁. ▁TIME _ UNSET ▁? ▁timeline Duration Us ▁: ▁duration Us ▁; ▁if ▁( ▁timeline Duration Us ▁== ▁duration Us ▁&& ▁timeline Is Seek able ▁== ▁is Seek able ▁&& ▁timeline Is Live ▁== ▁is Live ▁) ▁{ ▁return ▁; ▁} ▁notify Source Info Refresh ed ▁( ▁duration Us ▁, ▁is Seek able ▁, ▁is Live ▁) ▁; ▁} ▁private ▁void ▁notify Source Info Refresh ed ▁( ▁long ▁duration Us ▁, ▁boolean ▁is Seek able ▁, ▁boolean ▁is Live ▁) ▁{ ▁timeline Duration Us ▁= ▁duration Us ▁; ▁timeline Is Seek able ▁= ▁is Seek able ▁; ▁timeline Is Live ▁= ▁is Live ▁; ▁refresh Source Info ▁( ▁new ▁Single Period Timeline ▁( ▁timeline Duration Us ▁, ▁timeline Is Seek able ▁, ▁false ▁, ▁timeline Is Live ▁, ▁null ▁, ▁tag ▁) ▁) ▁; ▁} ▁}
▁try ▁{ ▁return ▁Sql Helper ▁. ▁ret Bool ▁( ▁sqlSession ▁. ▁update ▁( ▁sqlStatement ▁( ▁Sql Method ▁. ▁UPDATE ▁) ▁, ▁map ▁) ▁) ▁; ▁} ▁finally ▁{ ▁close Sql Session ▁( ▁sqlSession ▁) ▁; ▁} ▁} ▁public ▁List ▁< ▁T ▁> ▁selectAll ▁( ▁) ▁{ ▁SqlSession ▁sqlSession ▁= ▁sqlSession ▁( ▁) ▁; ▁try ▁{ ▁return ▁sqlSession ▁. ▁select List ▁( ▁sqlStatement ▁( ▁Sql Method ▁. ▁SELECT _ LIST ▁) ▁) ▁; ▁} ▁finally ▁{ ▁close Sql Session ▁( ▁sqlSession ▁) ▁; ▁} ▁} ▁public ▁T ▁select ById ▁( ▁Serializable ▁id ▁) ▁{ ▁SqlSession ▁sqlSession ▁= ▁sqlSession ▁( ▁) ▁; ▁try ▁{ ▁return ▁sqlSession ▁. ▁select One ▁( ▁sqlStatement ▁( ▁Sql Method ▁. ▁SELECT _ BY _ ID ▁) ▁, ▁id ▁) ▁; ▁} ▁finally ▁{ ▁close Sql Session ▁( ▁sqlSession ▁) ▁; ▁} ▁} ▁public ▁T ▁select ById ▁( ▁) ▁{ ▁Assert ▁. ▁isFalse ▁( ▁StringUtils ▁. ▁check Val Null ▁( ▁pk Val ▁( ▁) ▁) ▁, ▁STR ▁) ▁; ▁return ▁select ById ▁( ▁pk Val ▁( ▁) ▁) ▁; ▁} ▁public ▁List ▁< ▁T ▁> ▁select List ▁( ▁Wrapper ▁< ▁T ▁> ▁query Wrapper ▁) ▁{ ▁Map ▁< ▁String ▁, ▁Object ▁> ▁map ▁= ▁CollectionUtils ▁. ▁newHashMap With Expected Size ▁( ▁1 ▁) ▁; ▁map ▁. ▁put ▁( ▁Constants ▁. ▁WR APPER ▁, ▁query Wrapper ▁) ▁; ▁SqlSession ▁sqlSession ▁= ▁sqlSession ▁( ▁) ▁; ▁try ▁{ ▁return ▁sqlSession ▁. ▁select List ▁( ▁sqlStatement ▁( ▁Sql Method ▁. ▁SELECT _ LIST ▁) ▁, ▁map ▁) ▁; ▁} ▁finally ▁{ ▁close Sql Session ▁( ▁sqlSession ▁) ▁; ▁} ▁} ▁public ▁T ▁select One ▁( ▁Wrapper ▁< ▁T ▁> ▁query Wrapper ▁) ▁{ ▁return ▁Sql Helper ▁. ▁getObject ▁( ▁( ▁) ▁-> ▁LogFactory ▁. ▁getLog ▁( ▁this ▁. ▁entity Class ▁) ▁, ▁select List ▁( ▁query Wrapper ▁) ▁) ▁; ▁} ▁public ▁< ▁E ▁extends ▁I Page ▁< ▁T ▁> ▁> ▁E ▁select Page ▁( ▁E ▁page ▁, ▁Wrapper ▁< ▁T ▁> ▁query Wrapper ▁) ▁{ ▁Map ▁< ▁String ▁, ▁Object ▁> ▁map ▁= ▁CollectionUtils ▁. ▁newHashMap With Expected Size ▁( ▁2 ▁) ▁; ▁map ▁. ▁put ▁( ▁Constants ▁. ▁WR APPER ▁, ▁query Wrapper ▁) ▁; ▁map ▁. ▁put ▁( ▁STR ▁, ▁page ▁) ▁; ▁SqlSession ▁sqlSession ▁= ▁sqlSession ▁( ▁) ▁; ▁try ▁{ ▁page ▁. ▁set Records ▁( ▁sqlSession ▁. ▁select List ▁( ▁sqlStatement ▁( ▁Sql Method ▁. ▁SELECT _ PAGE ▁) ▁, ▁map ▁) ▁) ▁; ▁} ▁finally ▁{ ▁close Sql Session ▁( ▁sqlSession ▁) ▁; ▁} ▁return ▁page ▁; ▁} ▁public ▁Integer ▁select Count ▁( ▁Wrapper ▁< ▁T ▁> ▁query Wrapper ▁) ▁{ ▁Map ▁< ▁String ▁, ▁Object ▁> ▁map ▁= ▁CollectionUtils ▁. ▁newHashMap With Expected Size ▁( ▁1 ▁) ▁; ▁map ▁. ▁put ▁( ▁Constants ▁. ▁WR APPER ▁, ▁query Wrapper ▁) ▁; ▁SqlSession ▁sqlSession ▁= ▁sqlSession ▁( ▁) ▁; ▁try ▁{ ▁return ▁Sql Helper ▁. ▁ret Count ▁( ▁sqlSession ▁. ▁< ▁Integer ▁> ▁select One ▁( ▁sqlStatement ▁( ▁Sql Method ▁. ▁SELECT _ COUNT ▁) ▁, ▁map ▁) ▁) ▁; ▁} ▁finally ▁{ ▁close Sql Session ▁( ▁sqlSession ▁) ▁; ▁} ▁}
▁return ▁pi ▁== ▁null ▁? ▁null ▁: ▁pi ▁. ▁application Info ▁. ▁load Icon ▁( ▁pm ▁) ▁; ▁} ▁catch ▁( ▁Package Manager ▁. ▁Name Not FoundException ▁e ▁) ▁{ ▁e ▁. ▁printStackTrace ▁( ▁) ▁; ▁return ▁null ▁; ▁} ▁} ▁public ▁static ▁int ▁getApp Icon Id ▁( ▁) ▁{ ▁return ▁getApp Icon Id ▁( ▁Utils ▁. ▁getApp ▁( ▁) ▁. ▁getPackageName ▁( ▁) ▁) ▁; ▁} ▁public ▁static ▁int ▁getApp Icon Id ▁( ▁final ▁String ▁packageName ▁) ▁{ ▁if ▁( ▁Utils Bridge ▁. ▁is Space ▁( ▁packageName ▁) ▁) ▁return ▁0 ▁; ▁try ▁{ ▁Package Manager ▁pm ▁= ▁Utils ▁. ▁getApp ▁( ▁) ▁. ▁getPackage Manager ▁( ▁) ▁; ▁Package Info ▁pi ▁= ▁pm ▁. ▁getPackage Info ▁( ▁packageName ▁, ▁0 ▁) ▁; ▁return ▁pi ▁== ▁null ▁? ▁0 ▁: ▁pi ▁. ▁application Info ▁. ▁icon ▁; ▁} ▁catch ▁( ▁Package Manager ▁. ▁Name Not FoundException ▁e ▁) ▁{ ▁e ▁. ▁printStackTrace ▁( ▁) ▁; ▁return ▁0 ▁; ▁} ▁} ▁@ ▁NonNull ▁public ▁static ▁String ▁getApp Package Name ▁( ▁) ▁{ ▁return ▁Utils ▁. ▁getApp ▁( ▁) ▁. ▁getPackageName ▁( ▁) ▁; ▁} ▁@ ▁NonNull ▁public ▁static ▁String ▁getApp Name ▁( ▁) ▁{ ▁return ▁getApp Name ▁( ▁Utils ▁. ▁getApp ▁( ▁) ▁. ▁getPackageName ▁( ▁) ▁) ▁; ▁} ▁@ ▁NonNull ▁public ▁static ▁String ▁getApp Name ▁( ▁final ▁String ▁packageName ▁) ▁{ ▁if ▁( ▁Utils Bridge ▁. ▁is Space ▁( ▁packageName ▁) ▁) ▁return ▁STR ▁; ▁try ▁{ ▁Package Manager ▁pm ▁= ▁Utils ▁. ▁getApp ▁( ▁) ▁. ▁getPackage Manager ▁( ▁) ▁; ▁Package Info ▁pi ▁= ▁pm ▁. ▁getPackage Info ▁( ▁packageName ▁, ▁0 ▁) ▁; ▁return ▁pi ▁== ▁null ▁? ▁STR ▁: ▁pi ▁. ▁application Info ▁. ▁load Label ▁( ▁pm ▁) ▁. ▁toString ▁( ▁) ▁; ▁} ▁catch ▁( ▁Package Manager ▁. ▁Name Not FoundException ▁e ▁) ▁{ ▁e ▁. ▁printStackTrace ▁( ▁) ▁; ▁return ▁STR ▁; ▁} ▁} ▁@ ▁NonNull ▁public ▁static ▁String ▁getApp Path ▁( ▁) ▁{ ▁return ▁getApp Path ▁( ▁Utils ▁. ▁getApp ▁( ▁) ▁. ▁getPackageName ▁( ▁) ▁) ▁; ▁} ▁@ ▁NonNull ▁public ▁static ▁String ▁getApp Path ▁( ▁final ▁String ▁packageName ▁) ▁{ ▁if ▁( ▁Utils Bridge ▁. ▁is Space ▁( ▁packageName ▁) ▁) ▁return ▁STR ▁; ▁try ▁{ ▁Package Manager ▁pm ▁= ▁Utils ▁. ▁getApp ▁( ▁) ▁. ▁getPackage Manager ▁( ▁) ▁; ▁Package Info ▁pi ▁= ▁pm ▁. ▁getPackage Info ▁( ▁packageName ▁, ▁0 ▁) ▁; ▁return ▁pi ▁== ▁null ▁? ▁STR ▁: ▁pi ▁. ▁application Info ▁. ▁source Dir ▁; ▁} ▁catch ▁( ▁Package Manager ▁. ▁Name Not FoundException ▁e ▁) ▁{ ▁e ▁. ▁printStackTrace ▁( ▁) ▁; ▁return ▁STR ▁; ▁} ▁} ▁@ ▁NonNull ▁public ▁static ▁String ▁getApp Version Name ▁( ▁) ▁{ ▁return ▁getApp Version Name ▁( ▁Utils ▁. ▁getApp ▁( ▁) ▁. ▁getPackageName ▁( ▁) ▁) ▁; ▁} ▁@ ▁NonNull ▁public ▁static ▁String ▁getApp Version Name ▁( ▁final ▁String ▁packageName ▁) ▁{ ▁if ▁( ▁Utils Bridge ▁. ▁is Space ▁( ▁packageName ▁) ▁) ▁return ▁STR ▁; ▁try ▁{ ▁Package Manager ▁pm ▁= ▁Utils ▁. ▁getApp ▁( ▁) ▁. ▁getPackage Manager ▁( ▁) ▁;
▁@ ▁Internal ▁public ▁class ▁Stats Summary Snapshot ▁implements ▁Serializable ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁1 L ▁; ▁private ▁final ▁long ▁min ▁; ▁private ▁final ▁long ▁max ▁; ▁private ▁final ▁long ▁sum ▁; ▁private ▁final ▁long ▁count ▁; ▁@ ▁Nullable ▁private ▁final ▁Histogram Statistics ▁histogram ▁; ▁public ▁Stats Summary Snapshot ▁( ▁long ▁min ▁, ▁long ▁max ▁, ▁long ▁sum ▁, ▁long ▁count ▁, ▁@ ▁Nullable ▁Histogram Statistics ▁histogram ▁) ▁{ ▁this ▁. ▁min ▁= ▁min ▁; ▁this ▁. ▁max ▁= ▁max ▁; ▁this ▁. ▁sum ▁= ▁sum ▁; ▁this ▁. ▁count ▁= ▁count ▁; ▁this ▁. ▁histogram ▁= ▁histogram ▁; ▁} ▁public ▁static ▁Stats Summary Snapshot ▁empty ▁( ▁) ▁{ ▁return ▁new ▁Stats Summary Snapshot ▁( ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁, ▁null ▁) ▁; ▁} ▁public ▁long ▁getMinimum ▁( ▁) ▁{ ▁return ▁min ▁; ▁} ▁public ▁long ▁getMaximum ▁( ▁) ▁{ ▁return ▁max ▁; ▁} ▁public ▁long ▁getSum ▁( ▁) ▁{ ▁return ▁sum ▁; ▁} ▁public ▁long ▁getCount ▁( ▁) ▁{ ▁return ▁count ▁; ▁} ▁public ▁long ▁getA verage ▁( ▁) ▁{ ▁if ▁( ▁count ▁== ▁0 ▁) ▁{ ▁return ▁0 ▁; ▁} ▁else ▁{ ▁return ▁sum ▁ / ▁count ▁; ▁} ▁} ▁public ▁double ▁getQu antile ▁( ▁double ▁qu antile ▁) ▁{ ▁return ▁histogram ▁== ▁null ▁? ▁Double ▁. ▁NaN ▁: ▁histogram ▁. ▁getQu antile ▁( ▁qu antile ▁) ▁; ▁} ▁}
▁@ ▁Configuration ▁( ▁proxyBean Methods ▁= ▁false ▁) ▁@ ▁Import ▁( ▁{ ▁ExampleService Caller ▁. ▁class ▁, ▁Simple Example Service ▁. ▁class ▁} ▁) ▁public ▁class ▁Spy Bean On Test Field For Existing Bean Config ▁{ ▁}
▁class ▁Set CR S Action ▁extends ▁Action ▁{ ▁private ▁final ▁I Geometry Value Editor ▁value Editor ▁; ▁private ▁final ▁int ▁s rid ▁; ▁public ▁Set CR S Action ▁( ▁I Geometry Value Editor ▁value Editor ▁, ▁int ▁s rid ▁) ▁{ ▁super ▁( ▁s rid ▁== ▁G is Constants ▁. ▁SR ID _ SI MPLE ▁? ▁G IS Messages ▁. ▁panel _ set _ cr s _ action _ text _ s imple ▁: ▁STR ▁+ ▁s rid ▁, ▁AS _ CHECK _ BOX ▁) ▁; ▁this ▁. ▁value Editor ▁= ▁value Editor ▁; ▁this ▁. ▁s rid ▁= ▁s rid ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁isChecked ▁( ▁) ▁{ ▁return ▁s rid ▁== ▁value Editor ▁. ▁getValue SR ID ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁run ▁( ▁) ▁{ ▁value Editor ▁. ▁setValue SR ID ▁( ▁s rid ▁) ▁; ▁} ▁}
▁public ▁final ▁class ▁AppInfo Json Verification s ▁{ ▁private ▁AppInfo Json Verification s ▁( ▁) ▁{ ▁} ▁public ▁static ▁void ▁verify ▁( ▁JSONObject ▁info ▁, ▁RMApp ▁app ▁) ▁throws ▁JSONException ▁{ ▁check String Match ▁( ▁STR ▁, ▁app ▁. ▁getApplication Id ▁( ▁) ▁. ▁toString ▁( ▁) ▁, ▁info ▁. ▁getString ▁( ▁STR ▁) ▁) ▁; ▁check String Match ▁( ▁STR ▁, ▁app ▁. ▁getUser ▁( ▁) ▁, ▁info ▁. ▁getString ▁( ▁STR ▁) ▁) ▁; ▁check String Match ▁( ▁STR ▁, ▁app ▁. ▁getName ▁( ▁) ▁, ▁info ▁. ▁getString ▁( ▁STR ▁) ▁) ▁; ▁check String Match ▁( ▁STR ▁, ▁app ▁. ▁getApplication Type ▁( ▁) ▁, ▁info ▁. ▁getString ▁( ▁STR ▁) ▁) ▁; ▁check String Match ▁( ▁STR ▁, ▁app ▁. ▁getQueue ▁( ▁) ▁, ▁info ▁. ▁getString ▁( ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁0 ▁, ▁info ▁. ▁getInt ▁( ▁STR ▁) ▁) ▁; ▁check String Match ▁( ▁STR ▁, ▁app ▁. ▁getState ▁( ▁) ▁. ▁toString ▁( ▁) ▁, ▁info ▁. ▁getString ▁( ▁STR ▁) ▁) ▁; ▁check String Match ▁( ▁STR ▁, ▁app ▁. ▁getF inal Application Status ▁( ▁) ▁. ▁toString ▁( ▁) ▁, ▁info ▁. ▁getString ▁( ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁0 ▁, ▁( ▁float ▁) ▁info ▁. ▁getDouble ▁( ▁STR ▁) ▁, ▁0.0 ▁) ▁; ▁if ▁( ▁STR ▁. ▁equals ▁( ▁info ▁. ▁getString ▁( ▁STR ▁) ▁) ▁) ▁{ ▁check String Match ▁( ▁STR ▁, ▁STR ▁, ▁info ▁. ▁getString ▁( ▁STR ▁) ▁) ▁; ▁} ▁check String Equal ▁( ▁STR ▁, ▁app ▁. ▁getD iagnostics ▁( ▁) ▁. ▁toString ▁( ▁) ▁, ▁info ▁. ▁getString ▁( ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁ResourceManager ▁. ▁getCluster Time Stamp ▁( ▁) ▁, ▁info ▁. ▁getLong ▁( ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁app ▁. ▁getStartTime ▁( ▁) ▁, ▁info ▁. ▁getLong ▁( ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁app ▁. ▁getF inish Time ▁( ▁) ▁, ▁info ▁. ▁getLong ▁( ▁STR ▁) ▁) ▁; ▁assertTrue ▁( ▁STR ▁, ▁info ▁. ▁getLong ▁( ▁STR ▁) ▁> ▁0 ▁) ▁; ▁check String Match ▁( ▁STR ▁, ▁app ▁. ▁getCurrent App Attempt ▁( ▁) ▁. ▁getMaster Container ▁( ▁) ▁. ▁getNode Http Address ▁( ▁) ▁, ▁info ▁. ▁getString ▁( ▁STR ▁) ▁) ▁; ▁assertTrue ▁( ▁STR ▁, ▁info ▁. ▁getString ▁( ▁STR ▁) ▁. ▁startsWith ▁( ▁STR ▁) ▁) ▁; ▁assertTrue ▁( ▁STR ▁, ▁info ▁. ▁getString ▁( ▁STR ▁) ▁. ▁endsWith ▁( ▁STR ▁+ ▁app ▁. ▁getUser ▁( ▁) ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁1024 ▁, ▁info ▁. ▁getInt ▁( ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁1 ▁, ▁info ▁. ▁getInt ▁( ▁STR ▁) ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁50 .0 f ▁, ▁( ▁float ▁) ▁info ▁. ▁getDouble ▁( ▁STR ▁) ▁, ▁0.01 f ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁50 .0 f ▁, ▁( ▁float ▁) ▁info ▁. ▁getDouble ▁( ▁STR ▁) ▁, ▁0.01 f ▁) ▁; ▁assertEquals ▁( ▁STR ▁, ▁1 ▁, ▁info ▁. ▁getInt ▁( ▁STR ▁) ▁) ▁;
▁public ▁class ▁M nist Label File ▁extends ▁M nist Db File ▁{ ▁public ▁M nist Label File ▁( ▁String ▁name ▁, ▁String ▁mode ▁) ▁throws ▁IOException ▁{ ▁super ▁( ▁name ▁, ▁mode ▁) ▁; ▁} ▁public ▁int ▁read Label ▁( ▁) ▁throws ▁IOException ▁{ ▁return ▁readUnsigned Byte ▁( ▁) ▁; ▁} ▁public ▁int ▁[ ▁] ▁read Labels ▁( ▁int ▁num ▁) ▁throws ▁IOException ▁{ ▁int ▁[ ▁] ▁out ▁= ▁new ▁int ▁[ ▁num ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁num ▁; ▁i ▁++ ▁) ▁out ▁[ ▁i ▁] ▁= ▁read Label ▁( ▁) ▁; ▁return ▁out ▁; ▁} ▁@ ▁Override ▁protected ▁int ▁getM agic Number ▁( ▁) ▁{ ▁return ▁20 4 9 ▁; ▁} ▁}
▁public ▁class ▁AspectJ We aver MessageHandler ▁implements ▁I MessageHandler ▁{ ▁private ▁static ▁final ▁String ▁A J _ ID ▁= ▁STR ▁; ▁private ▁static ▁final ▁Log ▁logger ▁= ▁LogFactory ▁. ▁getLog ▁( ▁STR ▁) ▁; ▁@ ▁Override ▁public ▁boolean ▁handle Message ▁( ▁I Message ▁message ▁) ▁throws ▁Ab ort Exception ▁{ ▁Kind ▁message Kind ▁= ▁message ▁. ▁getKind ▁( ▁) ▁; ▁if ▁( ▁message Kind ▁== ▁I Message ▁. ▁DEBUG ▁) ▁{ ▁if ▁( ▁logger ▁. ▁isDebugEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁debug ▁( ▁make Message For ▁( ▁message ▁) ▁) ▁; ▁return ▁true ▁; ▁} ▁} ▁else ▁if ▁( ▁message Kind ▁== ▁I Message ▁. ▁INFO ▁|| ▁message Kind ▁== ▁I Message ▁. ▁WE A VE INFO ▁) ▁{ ▁if ▁( ▁logger ▁. ▁isInfoEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁info ▁( ▁make Message For ▁( ▁message ▁) ▁) ▁; ▁return ▁true ▁; ▁} ▁} ▁else ▁if ▁( ▁message Kind ▁== ▁I Message ▁. ▁WARNING ▁) ▁{ ▁if ▁( ▁logger ▁. ▁isWarnEnabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁warn ▁( ▁make Message For ▁( ▁message ▁) ▁) ▁; ▁return ▁true ▁; ▁} ▁} ▁else ▁if ▁( ▁message Kind ▁== ▁I Message ▁. ▁ERROR ▁) ▁{ ▁if ▁( ▁logger ▁. ▁isError Enabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁error ▁( ▁make Message For ▁( ▁message ▁) ▁) ▁; ▁return ▁true ▁; ▁} ▁} ▁else ▁if ▁( ▁message Kind ▁== ▁I Message ▁. ▁AB ORT ▁) ▁{ ▁if ▁( ▁logger ▁. ▁is Fatal Enabled ▁( ▁) ▁) ▁{ ▁logger ▁. ▁fatal ▁( ▁make Message For ▁( ▁message ▁) ▁) ▁; ▁return ▁true ▁; ▁} ▁} ▁return ▁false ▁; ▁} ▁private ▁String ▁make Message For ▁( ▁I Message ▁a Message ▁) ▁{ ▁return ▁A J _ ID ▁+ ▁a Message ▁. ▁getMessage ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁is Ignoring ▁( ▁Kind ▁message Kind ▁) ▁{ ▁return ▁false ▁; ▁} ▁@ ▁Override ▁public ▁void ▁d ont Ignore ▁( ▁Kind ▁message Kind ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁void ▁ignore ▁( ▁Kind ▁kind ▁) ▁{ ▁} ▁}
▁i ▁< ▁count ▁; ▁i ▁++ ▁) ▁{ ▁Plain ActionFuture ▁< ▁Authentication Result ▁> ▁future ▁= ▁new ▁Plain ActionFuture ▁< ▁> ▁( ▁) ▁; ▁realm ▁. ▁authenticate ▁( ▁new ▁Username Password Token ▁( ▁STR ▁, ▁new ▁SecureString ▁( ▁PASSWORD ▁) ▁) ▁, ▁future ▁) ▁; ▁future ▁. ▁actionGet ▁( ▁) ▁; ▁} ▁verify ▁( ▁sessionFactory ▁, ▁times ▁( ▁count ▁) ▁) ▁. ▁session ▁( ▁eq ▁( ▁STR ▁) ▁, ▁any ▁( ▁SecureString ▁. ▁class ▁) ▁, ▁any ActionListener ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁test Authenticate Caching Clear s Cache On Role Mapper Refresh ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁Realm Config ▁. ▁Realm Identifier ▁realm Identifier ▁= ▁realm Id ▁( ▁STR ▁) ▁; ▁Settings ▁settings ▁= ▁settings ▁( ▁realm Identifier ▁) ▁; ▁Realm Config ▁config ▁= ▁setup Realm ▁( ▁realm Identifier ▁, ▁settings ▁) ▁; ▁Active Directory SessionFactory ▁sessionFactory ▁= ▁spy ▁( ▁new ▁Active Directory SessionFactory ▁( ▁config ▁, ▁ssl Service ▁, ▁threadPool ▁) ▁) ▁; ▁D n Role Mapper ▁role Mapper ▁= ▁new ▁D n Role Mapper ▁( ▁config ▁, ▁resource Watcher Service ▁) ▁; ▁Ldap Realm ▁realm ▁= ▁new ▁Ldap Realm ▁( ▁config ▁, ▁sessionFactory ▁, ▁role Mapper ▁, ▁threadPool ▁) ▁; ▁realm ▁. ▁initialize ▁( ▁Collections ▁. ▁singleton ▁( ▁realm ▁) ▁, ▁licenseState ▁) ▁; ▁int ▁count ▁= ▁randomInt Between ▁( ▁2 ▁, ▁10 ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁count ▁; ▁i ▁++ ▁) ▁{ ▁Plain ActionFuture ▁< ▁Authentication Result ▁> ▁future ▁= ▁new ▁Plain ActionFuture ▁< ▁> ▁( ▁) ▁; ▁realm ▁. ▁authenticate ▁( ▁new ▁Username Password Token ▁( ▁STR ▁, ▁new ▁SecureString ▁( ▁PASSWORD ▁) ▁) ▁, ▁future ▁) ▁; ▁future ▁. ▁actionGet ▁( ▁) ▁; ▁} ▁verify ▁( ▁sessionFactory ▁, ▁times ▁( ▁1 ▁) ▁) ▁. ▁session ▁( ▁eq ▁( ▁STR ▁) ▁, ▁any ▁( ▁SecureString ▁. ▁class ▁) ▁, ▁any ActionListener ▁( ▁) ▁) ▁; ▁role Mapper ▁. ▁notify Refresh ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁count ▁; ▁i ▁++ ▁) ▁{ ▁Plain ActionFuture ▁< ▁Authentication Result ▁> ▁future ▁= ▁new ▁Plain ActionFuture ▁< ▁> ▁( ▁) ▁; ▁realm ▁. ▁authenticate ▁( ▁new ▁Username Password Token ▁( ▁STR ▁, ▁new ▁SecureString ▁( ▁PASSWORD ▁) ▁) ▁, ▁future ▁) ▁; ▁future ▁. ▁actionGet ▁( ▁) ▁; ▁} ▁verify ▁( ▁sessionFactory ▁, ▁times ▁( ▁2 ▁) ▁) ▁. ▁session ▁( ▁eq ▁( ▁STR ▁) ▁, ▁any ▁( ▁SecureString ▁. ▁class ▁) ▁, ▁any ActionListener ▁( ▁) ▁) ▁; ▁} ▁public ▁void ▁testUn auth enticated Lookup With Connection Pool ▁( ▁) ▁throws ▁Exception ▁{ ▁do Un auth enticated Lookup ▁( ▁true ▁) ▁; ▁} ▁public ▁void ▁testUn auth enticated Lookup Without Connection Pool ▁( ▁) ▁throws ▁Exception ▁{ ▁do Un auth enticated Lookup ▁( ▁false ▁) ▁; ▁} ▁private ▁void ▁do Un auth enticated Lookup ▁( ▁boolean ▁p ooled ▁) ▁throws ▁Exception ▁{ ▁final ▁Realm Config ▁. ▁Realm Identifier ▁realm Identifier ▁= ▁realm Id ▁( ▁STR ▁) ▁;
▁public ▁class ▁Exp and able Transformation Activity ▁extends ▁BaseTest Activity ▁{ ▁@ ▁Visible ForTesting ▁public ▁Float ingAction Button ▁fab ▁; ▁@ ▁Visible ForTesting ▁public ▁View ▁sheet ▁; ▁@ ▁Visible ForTesting ▁public ▁View ▁s cri m ▁; ▁@ ▁Override ▁protected ▁int ▁getContent View Layout ResId ▁( ▁) ▁{ ▁return ▁R ▁. ▁layout ▁. ▁des ign _ exp and able _ trans formation ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁on Content View Set ▁( ▁) ▁{ ▁fab ▁= ▁findViewById ▁( ▁R ▁. ▁id ▁. ▁fab ▁) ▁; ▁sheet ▁= ▁findViewById ▁( ▁R ▁. ▁id ▁. ▁sheet ▁) ▁; ▁s cri m ▁= ▁findViewById ▁( ▁R ▁. ▁id ▁. ▁s cri m ▁) ▁; ▁} ▁}
▁for ▁( ▁Map ▁. ▁Entry ▁< ▁K ▁, ▁Collection ▁< ▁V ▁> ▁> ▁entry ▁: ▁multimap ▁. ▁asMap ▁( ▁) ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁stream ▁. ▁writeObject ▁( ▁entry ▁. ▁getKey ▁( ▁) ▁) ▁; ▁stream ▁. ▁writeInt ▁( ▁entry ▁. ▁getValue ▁( ▁) ▁. ▁size ▁( ▁) ▁) ▁; ▁for ▁( ▁V ▁value ▁: ▁entry ▁. ▁getValue ▁( ▁) ▁) ▁{ ▁stream ▁. ▁writeObject ▁( ▁value ▁) ▁; ▁} ▁} ▁} ▁static ▁< ▁K ▁, ▁V ▁> ▁void ▁populate Multimap ▁( ▁Multimap ▁< ▁K ▁, ▁V ▁> ▁multimap ▁, ▁Object InputStream ▁stream ▁) ▁throws ▁IOException ▁, ▁ClassNot FoundException ▁{ ▁int ▁distinct Keys ▁= ▁stream ▁. ▁readInt ▁( ▁) ▁; ▁populate Multimap ▁( ▁multimap ▁, ▁stream ▁, ▁distinct Keys ▁) ▁; ▁} ▁static ▁< ▁K ▁, ▁V ▁> ▁void ▁populate Multimap ▁( ▁Multimap ▁< ▁K ▁, ▁V ▁> ▁multimap ▁, ▁Object InputStream ▁stream ▁, ▁int ▁distinct Keys ▁) ▁throws ▁IOException ▁, ▁ClassNot FoundException ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁distinct Keys ▁; ▁i ▁++ ▁) ▁{ ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁K ▁key ▁= ▁( ▁K ▁) ▁stream ▁. ▁readObject ▁( ▁) ▁; ▁Collection ▁< ▁V ▁> ▁values ▁= ▁multimap ▁. ▁get ▁( ▁key ▁) ▁; ▁int ▁value Count ▁= ▁stream ▁. ▁readInt ▁( ▁) ▁; ▁for ▁( ▁int ▁j ▁= ▁0 ▁; ▁j ▁< ▁value Count ▁; ▁j ▁++ ▁) ▁{ ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁V ▁value ▁= ▁( ▁V ▁) ▁stream ▁. ▁readObject ▁( ▁) ▁; ▁values ▁. ▁add ▁( ▁value ▁) ▁; ▁} ▁} ▁} ▁static ▁< ▁T ▁> ▁Field Setter ▁< ▁T ▁> ▁getField Setter ▁( ▁final ▁Class ▁< ▁T ▁> ▁clazz ▁, ▁String ▁fieldName ▁) ▁{ ▁try ▁{ ▁Field ▁field ▁= ▁clazz ▁. ▁getDeclared Field ▁( ▁fieldName ▁) ▁; ▁return ▁new ▁Field Setter ▁< ▁T ▁> ▁( ▁field ▁) ▁; ▁} ▁catch ▁( ▁NoSuch FieldException ▁e ▁) ▁{ ▁throw ▁new ▁AssertionError ▁( ▁e ▁) ▁; ▁} ▁} ▁static ▁final ▁class ▁Field Setter ▁< ▁T ▁> ▁{ ▁private ▁final ▁Field ▁field ▁; ▁private ▁Field Setter ▁( ▁Field ▁field ▁) ▁{ ▁this ▁. ▁field ▁= ▁field ▁; ▁field ▁. ▁setAccessible ▁( ▁true ▁) ▁; ▁} ▁void ▁set ▁( ▁T ▁instance ▁, ▁Object ▁value ▁) ▁{ ▁try ▁{ ▁field ▁. ▁set ▁( ▁instance ▁, ▁value ▁) ▁; ▁} ▁catch ▁( ▁Illegal AccessException ▁imp ossible ▁) ▁{ ▁throw ▁new ▁AssertionError ▁( ▁imp ossible ▁) ▁; ▁} ▁} ▁void ▁set ▁( ▁T ▁instance ▁, ▁int ▁value ▁) ▁{ ▁try ▁{ ▁field ▁. ▁set ▁( ▁instance ▁, ▁value ▁) ▁; ▁} ▁catch ▁( ▁Illegal AccessException ▁imp ossible ▁) ▁{ ▁throw ▁new ▁AssertionError ▁( ▁imp ossible ▁) ▁; ▁} ▁} ▁} ▁}
▁Employee ▁employee ▁= ▁Stream ▁. ▁of ▁( ▁emp Ids ▁) ▁. ▁map ▁( ▁employee Repository ▁:: ▁findById ▁) ▁. ▁filter ▁( ▁e ▁-> ▁e ▁!= ▁null ▁) ▁. ▁filter ▁( ▁e ▁-> ▁e ▁. ▁getS alary ▁( ▁) ▁> ▁100000 ▁) ▁. ▁findFirst ▁( ▁) ▁. ▁orElse ▁( ▁null ▁) ▁; ▁assertEquals ▁( ▁employee ▁. ▁getS alary ▁( ▁) ▁, ▁new ▁Double ▁( ▁200 000 ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁when Collect Stream ToList _ thenGet List ▁( ▁) ▁{ ▁List ▁< ▁Employee ▁> ▁employees ▁= ▁emp List ▁. ▁stream ▁( ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toList ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁emp List ▁, ▁employees ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁when Stream ToArray _ thenGet Array ▁( ▁) ▁{ ▁Employee ▁[ ▁] ▁employees ▁= ▁emp List ▁. ▁stream ▁( ▁) ▁. ▁toArray ▁( ▁Employee ▁[ ▁] ▁:: ▁new ▁) ▁; ▁assertThat ▁( ▁emp List ▁. ▁toArray ▁( ▁) ▁, ▁equalTo ▁( ▁employees ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁when Stream Count _ thenGet Element Count ▁( ▁) ▁{ ▁Long ▁emp Count ▁= ▁emp List ▁. ▁stream ▁( ▁) ▁. ▁filter ▁( ▁e ▁-> ▁e ▁. ▁getS alary ▁( ▁) ▁> ▁200 000 ▁) ▁. ▁count ▁( ▁) ▁; ▁assertEquals ▁( ▁emp Count ▁, ▁new ▁Long ▁( ▁1 ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁when Limit Infinite Stream _ thenGet F inite Elements ▁( ▁) ▁{ ▁Stream ▁< ▁Integer ▁> ▁inf inite Stream ▁= ▁Stream ▁. ▁iterate ▁( ▁2 ▁, ▁i ▁-> ▁i ▁ * ▁2 ▁) ▁; ▁List ▁< ▁Integer ▁> ▁collect ▁= ▁inf inite Stream ▁. ▁skip ▁( ▁3 ▁) ▁. ▁limit ▁( ▁5 ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toList ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁collect ▁, ▁Arrays ▁. ▁asList ▁( ▁16 ▁, ▁32 ▁, ▁64 ▁, ▁128 ▁, ▁256 ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁when Sort Stream _ thenGet Sorted Stream ▁( ▁) ▁{ ▁List ▁< ▁Employee ▁> ▁employees ▁= ▁emp List ▁. ▁stream ▁( ▁) ▁. ▁sorted ▁( ▁( ▁e 1 ▁, ▁e 2 ▁) ▁-> ▁e 1 ▁. ▁getName ▁( ▁) ▁. ▁compareTo ▁( ▁e 2 ▁. ▁getName ▁( ▁) ▁) ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toList ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁employees ▁. ▁get ▁( ▁0 ▁) ▁. ▁getName ▁( ▁) ▁, ▁STR ▁) ▁; ▁assertEquals ▁( ▁employees ▁. ▁get ▁( ▁1 ▁) ▁. ▁getName ▁( ▁) ▁, ▁STR ▁) ▁; ▁assertEquals ▁( ▁employees ▁. ▁get ▁( ▁2 ▁) ▁. ▁getName ▁( ▁) ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁when Find Min _ thenGet Min Element From Stream ▁( ▁) ▁{ ▁Employee ▁first E mp ▁= ▁emp List ▁. ▁stream ▁( ▁) ▁. ▁min ▁( ▁( ▁e 1 ▁, ▁e 2 ▁) ▁-> ▁e 1 ▁. ▁getId ▁( ▁) ▁- ▁e 2 ▁. ▁getId ▁( ▁) ▁) ▁. ▁orElseThrow ▁( ▁NoSuch ElementException ▁:: ▁new ▁) ▁; ▁assertEquals ▁( ▁first E mp ▁. ▁getId ▁( ▁) ▁, ▁new ▁Integer ▁( ▁1 ▁) ▁) ▁; ▁}
▁try ▁{ ▁msg ▁= ▁Message ▁. ▁obtain ▁( ▁inline Fence ▁, ▁ACTION _ ON _ TERMIN ATE ▁) ▁; ▁inline Fence ▁. ▁handle Message ▁( ▁msg ▁) ▁; ▁} ▁finally ▁{ ▁msg ▁. ▁recycle ▁( ▁) ▁; ▁} ▁} ▁static ▁ClassLoader ▁call Get ClassLoader ▁( ▁Handler ▁inline Fence ▁, ▁ClassLoader ▁cl ▁) ▁{ ▁Message ▁msg ▁= ▁null ▁; ▁try ▁{ ▁msg ▁= ▁Message ▁. ▁obtain ▁( ▁inline Fence ▁, ▁ACTION _ GET _ CLASS LOADER ▁, ▁cl ▁) ▁; ▁inline Fence ▁. ▁handle Message ▁( ▁msg ▁) ▁; ▁return ▁( ▁ClassLoader ▁) ▁msg ▁. ▁obj ▁; ▁} ▁finally ▁{ ▁msg ▁. ▁recycle ▁( ▁) ▁; ▁} ▁} ▁static ▁Context ▁call Get Base Context ▁( ▁Handler ▁inline Fence ▁, ▁Context ▁base ▁) ▁{ ▁Message ▁msg ▁= ▁null ▁; ▁try ▁{ ▁msg ▁= ▁Message ▁. ▁obtain ▁( ▁inline Fence ▁, ▁ACTION _ GET _ BASE _ CONTEXT ▁, ▁base ▁) ▁; ▁inline Fence ▁. ▁handle Message ▁( ▁msg ▁) ▁; ▁return ▁( ▁Context ▁) ▁msg ▁. ▁obj ▁; ▁} ▁finally ▁{ ▁msg ▁. ▁recycle ▁( ▁) ▁; ▁} ▁} ▁static ▁AssetManager ▁call Get Assets ▁( ▁Handler ▁inline Fence ▁, ▁AssetManager ▁ass ets ▁) ▁{ ▁Message ▁msg ▁= ▁null ▁; ▁try ▁{ ▁msg ▁= ▁Message ▁. ▁obtain ▁( ▁inline Fence ▁, ▁ACTION _ GET _ AS SET S ▁, ▁ass ets ▁) ▁; ▁inline Fence ▁. ▁handle Message ▁( ▁msg ▁) ▁; ▁return ▁( ▁AssetManager ▁) ▁msg ▁. ▁obj ▁; ▁} ▁finally ▁{ ▁msg ▁. ▁recycle ▁( ▁) ▁; ▁} ▁} ▁static ▁Resources ▁call Get Resources ▁( ▁Handler ▁inline Fence ▁, ▁Resources ▁res ▁) ▁{ ▁Message ▁msg ▁= ▁null ▁; ▁try ▁{ ▁msg ▁= ▁Message ▁. ▁obtain ▁( ▁inline Fence ▁, ▁ACTION _ GET _ RESOURCE S ▁, ▁res ▁) ▁; ▁inline Fence ▁. ▁handle Message ▁( ▁msg ▁) ▁; ▁return ▁( ▁Resources ▁) ▁msg ▁. ▁obj ▁; ▁} ▁finally ▁{ ▁msg ▁. ▁recycle ▁( ▁) ▁; ▁} ▁} ▁static ▁Object ▁call Get System Service ▁( ▁Handler ▁inline Fence ▁, ▁String ▁name ▁, ▁Object ▁service ▁) ▁{ ▁Message ▁msg ▁= ▁null ▁; ▁try ▁{ ▁msg ▁= ▁Message ▁. ▁obtain ▁( ▁inline Fence ▁, ▁ACTION _ GET _ SYSTEM _ SERVICE ▁, ▁new ▁Object ▁[ ▁] ▁{ ▁name ▁, ▁service ▁} ▁) ▁; ▁inline Fence ▁. ▁handle Message ▁( ▁msg ▁) ▁; ▁return ▁msg ▁. ▁obj ▁; ▁} ▁finally ▁{ ▁msg ▁. ▁recycle ▁( ▁) ▁; ▁} ▁} ▁static ▁int ▁call M Z N ight Mode Use Of ▁( ▁Handler ▁inline Fence ▁) ▁{ ▁Message ▁msg ▁= ▁null ▁; ▁try ▁{ ▁msg ▁= ▁Message ▁. ▁obtain ▁( ▁inline Fence ▁, ▁ACTION _ M Z _ N IGHT MODE _ USE _ OF ▁) ▁; ▁inline Fence ▁. ▁handle Message ▁( ▁msg ▁) ▁; ▁return ▁( ▁int ▁) ▁msg ▁. ▁obj ▁; ▁} ▁finally ▁{ ▁msg ▁. ▁recycle ▁( ▁) ▁; ▁} ▁} ▁}
▁@ ▁RunWith ▁( ▁JUnit 4 ▁. ▁class ▁) ▁public ▁class ▁Persistent String Indexer Test ▁{ ▁private ▁static ▁class ▁Manual Clock ▁implements ▁Clock ▁{ ▁private ▁long ▁currentTime ▁= ▁0 L ▁; ▁Manual Clock ▁( ▁) ▁{ ▁} ▁@ ▁Override ▁public ▁long ▁current TimeMillis ▁( ▁) ▁{ ▁throw ▁new ▁AssertionError ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Override ▁public ▁long ▁nanoTime ▁( ▁) ▁{ ▁return ▁currentTime ▁; ▁} ▁void ▁advance ▁( ▁long ▁time ▁) ▁{ ▁currentTime ▁+= ▁time ▁; ▁} ▁} ▁private ▁Persistent String Indexer ▁ps i ▁; ▁private ▁Map ▁< ▁Integer ▁, ▁String ▁> ▁mappings ▁= ▁new ▁Concurrent HashMap ▁< ▁> ▁( ▁) ▁; ▁private ▁Sc ratch ▁scratch ▁= ▁new ▁Sc ratch ▁( ▁) ▁; ▁private ▁Manual Clock ▁clock ▁= ▁new ▁Manual Clock ▁( ▁) ▁; ▁private ▁Path ▁data Path ▁; ▁private ▁Path ▁journal Path ▁; ▁@ ▁Before ▁public ▁final ▁void ▁create Indexer ▁( ▁) ▁throws ▁Exception ▁{ ▁data Path ▁= ▁scratch ▁. ▁resolve ▁( ▁STR ▁) ▁; ▁journal Path ▁= ▁scratch ▁. ▁resolve ▁( ▁STR ▁) ▁; ▁ps i ▁= ▁Persistent String Indexer ▁. ▁new Persistent String Indexer ▁( ▁data Path ▁, ▁clock ▁) ▁; ▁} ▁private ▁void ▁assert Size ▁( ▁int ▁expected ▁) ▁{ ▁assertThat ▁( ▁ps i ▁. ▁size ▁( ▁) ▁) ▁. ▁isEqualTo ▁( ▁expected ▁) ▁; ▁} ▁private ▁void ▁assert Index ▁( ▁int ▁expected ▁, ▁String ▁s ▁) ▁{ ▁int ▁index ▁= ▁ps i ▁. ▁getOrCreate Index ▁( ▁s ▁) ▁; ▁assertThat ▁( ▁index ▁) ▁. ▁isEqualTo ▁( ▁expected ▁) ▁; ▁mappings ▁. ▁put ▁( ▁expected ▁, ▁s ▁) ▁; ▁} ▁private ▁void ▁assert Content ▁( ▁) ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁ps i ▁. ▁size ▁( ▁) ▁; ▁i ▁++ ▁) ▁{ ▁if ▁( ▁mappings ▁. ▁get ▁( ▁i ▁) ▁!= ▁null ▁) ▁{ ▁assertThat ▁( ▁mappings ▁) ▁. ▁containsEntry ▁( ▁i ▁, ▁ps i ▁. ▁getString For Index ▁( ▁i ▁) ▁) ▁; ▁} ▁} ▁} ▁private ▁void ▁setup Test Content ▁( ▁) ▁{ ▁assert Size ▁( ▁0 ▁) ▁; ▁assert Index ▁( ▁0 ▁, ▁STR ▁) ▁; ▁assert Index ▁( ▁1 ▁, ▁STR ▁) ▁; ▁assert Index ▁( ▁2 ▁, ▁STR ▁) ▁; ▁assert Index ▁( ▁3 ▁, ▁STR ▁) ▁; ▁assert Index ▁( ▁3 ▁, ▁STR ▁) ▁; ▁assert Index ▁( ▁4 ▁, ▁STR ▁) ▁; ▁assert Index ▁( ▁5 ▁, ▁STR ▁) ▁; ▁assert Size ▁( ▁6 ▁) ▁; ▁assert Index ▁( ▁6 ▁, ▁STR ▁) ▁; ▁assert Index ▁( ▁7 ▁, ▁STR ▁) ▁; ▁assert Index ▁( ▁8 ▁, ▁STR ▁) ▁; ▁assert Size ▁( ▁9 ▁) ▁; ▁assert Content ▁( ▁) ▁; ▁} ▁private ▁void ▁write L ot sOf Entries Concurrent ly ▁( ▁final ▁int ▁num To Write ▁) ▁throws ▁Interrupted Exception ▁{ ▁final ▁int ▁NUM _ THREADS ▁= ▁10 ▁; ▁final ▁CountDownLatch ▁s ynchron izer Latch ▁= ▁new ▁CountDownLatch ▁( ▁NUM _ THREADS ▁) ▁; ▁Test Runnable ▁index Adder ▁= ▁( ▁) ▁-> ▁{ ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁num To Write ▁; ▁i ▁++ ▁) ▁{ ▁s ynchron izer Latch ▁. ▁countDown ▁( ▁) ▁;
▁public ▁final ▁class ▁Player Holder ▁{ ▁private ▁Player Holder ▁( ▁) ▁{ ▁} ▁private ▁static ▁Player Holder ▁instance ▁; ▁public ▁static ▁synchronized ▁Player Holder ▁getInstance ▁( ▁) ▁{ ▁if ▁( ▁Player Holder ▁. ▁instance ▁== ▁null ▁) ▁{ ▁Player Holder ▁. ▁instance ▁= ▁new ▁Player Holder ▁( ▁) ▁; ▁} ▁return ▁Player Holder ▁. ▁instance ▁; ▁} ▁private ▁final ▁boolean ▁DEBUG ▁= ▁Main Activity ▁. ▁DEBUG ▁; ▁private ▁final ▁String ▁TAG ▁= ▁Player Holder ▁. ▁class ▁. ▁getSimpleName ▁( ▁) ▁; ▁private ▁Player Service Extended EventListener ▁listener ▁; ▁private ▁final ▁Player Service Connection ▁service Connection ▁= ▁new ▁Player Service Connection ▁( ▁) ▁; ▁public ▁boolean ▁bound ▁; ▁private ▁Main Player ▁player Service ▁; ▁private ▁Player ▁player ▁; ▁@ ▁Nullable ▁public ▁Main Player ▁. ▁Player Type ▁getType ▁( ▁) ▁{ ▁if ▁( ▁player ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁return ▁player ▁. ▁getP layer Type ▁( ▁) ▁; ▁} ▁public ▁boolean ▁isP lay ing ▁( ▁) ▁{ ▁if ▁( ▁player ▁== ▁null ▁) ▁{ ▁return ▁false ▁; ▁} ▁return ▁player ▁. ▁isP lay ing ▁( ▁) ▁; ▁} ▁public ▁boolean ▁isP layer Open ▁( ▁) ▁{ ▁return ▁player ▁!= ▁null ▁; ▁} ▁public ▁void ▁set Listener ▁( ▁@ ▁Nullable ▁final ▁Player Service Extended EventListener ▁new Listener ▁) ▁{ ▁listener ▁= ▁new Listener ▁; ▁if ▁( ▁listener ▁== ▁null ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁player ▁!= ▁null ▁) ▁{ ▁listener ▁. ▁on Service Connected ▁( ▁player ▁, ▁player Service ▁, ▁false ▁) ▁; ▁start Player Listener ▁( ▁) ▁; ▁} ▁} ▁private ▁Context ▁get Common Context ▁( ▁) ▁{ ▁return ▁App ▁. ▁getApp ▁( ▁) ▁; ▁} ▁public ▁void ▁start Service ▁( ▁final ▁boolean ▁play After Connect ▁, ▁final ▁Player Service Extended EventListener ▁new Listener ▁) ▁{ ▁final ▁Context ▁context ▁= ▁get Common Context ▁( ▁) ▁; ▁set Listener ▁( ▁new Listener ▁) ▁; ▁if ▁( ▁bound ▁) ▁{ ▁return ▁; ▁} ▁unbind ▁( ▁context ▁) ▁; ▁Context Compat ▁. ▁start Foreground Service ▁( ▁context ▁, ▁new ▁Intent ▁( ▁context ▁, ▁Main Player ▁. ▁class ▁) ▁) ▁; ▁service Connection ▁. ▁do Play After Connect ▁( ▁play After Connect ▁) ▁; ▁bind ▁( ▁context ▁) ▁; ▁} ▁public ▁void ▁stop Service ▁( ▁) ▁{ ▁final ▁Context ▁context ▁= ▁get Common Context ▁( ▁) ▁; ▁unbind ▁( ▁context ▁) ▁; ▁context ▁. ▁stop Service ▁( ▁new ▁Intent ▁( ▁context ▁, ▁Main Player ▁. ▁class ▁) ▁) ▁; ▁} ▁class ▁Player Service Connection ▁implements ▁Service Connection ▁{ ▁private ▁boolean ▁play After Connect ▁= ▁false ▁; ▁public ▁void ▁do Play After Connect ▁( ▁final ▁boolean ▁play After Connection ▁) ▁{ ▁this ▁. ▁play After Connect ▁= ▁play After Connection ▁; ▁} ▁@ ▁Override ▁public ▁void ▁on Service Disconnect ed ▁( ▁final ▁Component Name ▁comp Name ▁) ▁{ ▁if ▁( ▁DEBUG ▁) ▁{ ▁Log ▁. ▁d ▁( ▁TAG ▁, ▁STR ▁) ▁; ▁} ▁final ▁Context ▁context ▁= ▁get Common Context ▁( ▁) ▁; ▁unbind ▁( ▁context ▁) ▁; ▁}
▁@ ▁RunWith ▁( ▁JUnit 4 ▁. ▁class ▁) ▁public ▁class ▁Stream Multiplexer Test ▁{ ▁private ▁ByteArray OutputStream ▁multiple xed ▁; ▁private ▁OutputStream ▁out ▁; ▁private ▁OutputStream ▁err ▁; ▁private ▁OutputStream ▁ctl ▁; ▁@ ▁Before ▁public ▁final ▁void ▁create OutputStream s ▁( ▁) ▁throws ▁Exception ▁{ ▁multiple xed ▁= ▁new ▁ByteArray OutputStream ▁( ▁) ▁; ▁Stream Multiplexer ▁multiple xer ▁= ▁new ▁Stream Multiplexer ▁( ▁multiple xed ▁) ▁; ▁out ▁= ▁multiple xer ▁. ▁create St dout ▁( ▁) ▁; ▁err ▁= ▁multiple xer ▁. ▁create St derr ▁( ▁) ▁; ▁ctl ▁= ▁multiple xer ▁. ▁createControl ▁( ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁testEmpty Wire ▁( ▁) ▁throws ▁IOException ▁{ ▁out ▁. ▁flush ▁( ▁) ▁; ▁err ▁. ▁flush ▁( ▁) ▁; ▁ctl ▁. ▁flush ▁( ▁) ▁; ▁assertThat ▁( ▁multiple xed ▁. ▁toByteArray ▁( ▁) ▁) ▁. ▁isEmpty ▁( ▁) ▁; ▁} ▁private ▁static ▁byte ▁[ ▁] ▁getL at in ▁( ▁String ▁string ▁) ▁throws ▁Unsupported Encoding Exception ▁{ ▁return ▁string ▁. ▁getBytes ▁( ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Hello World On Std Out ▁( ▁) ▁throws ▁Exception ▁{ ▁out ▁. ▁write ▁( ▁getL at in ▁( ▁STR ▁) ▁) ▁; ▁out ▁. ▁flush ▁( ▁) ▁; ▁assert Message ▁( ▁multiple xed ▁. ▁toByteArray ▁( ▁) ▁, ▁0 ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Inter le aved St dout St derr Control ▁( ▁) ▁throws ▁Exception ▁{ ▁int ▁start ▁= ▁0 ▁; ▁out ▁. ▁write ▁( ▁getL at in ▁( ▁STR ▁) ▁) ▁; ▁out ▁. ▁flush ▁( ▁) ▁; ▁assert Message ▁( ▁multiple xed ▁. ▁toByteArray ▁( ▁) ▁, ▁start ▁, ▁STR ▁) ▁; ▁start ▁= ▁multiple xed ▁. ▁toByteArray ▁( ▁) ▁. ▁length ▁; ▁err ▁. ▁write ▁( ▁getL at in ▁( ▁STR ▁) ▁) ▁; ▁err ▁. ▁flush ▁( ▁) ▁; ▁assert Message ▁( ▁multiple xed ▁. ▁toByteArray ▁( ▁) ▁, ▁start ▁, ▁STR ▁) ▁; ▁start ▁= ▁multiple xed ▁. ▁toByteArray ▁( ▁) ▁. ▁length ▁; ▁ctl ▁. ▁write ▁( ▁getL at in ▁( ▁STR ▁) ▁) ▁; ▁ctl ▁. ▁flush ▁( ▁) ▁; ▁assert Message ▁( ▁multiple xed ▁. ▁toByteArray ▁( ▁) ▁, ▁start ▁, ▁STR ▁) ▁; ▁start ▁= ▁multiple xed ▁. ▁toByteArray ▁( ▁) ▁. ▁length ▁; ▁out ▁. ▁write ▁( ▁getL at in ▁( ▁STR ▁) ▁) ▁; ▁out ▁. ▁flush ▁( ▁) ▁; ▁assert Message ▁( ▁multiple xed ▁. ▁toByteArray ▁( ▁) ▁, ▁start ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test Will Not Commit To Under lying Stream Un less Flush Or New line ▁( ▁) ▁throws ▁Exception ▁{ ▁out ▁. ▁write ▁( ▁getL at in ▁( ▁STR ▁+ ▁STR ▁) ▁) ▁; ▁assertThat ▁( ▁new ▁byte ▁[ ▁0 ▁] ▁) ▁. ▁isEqualTo ▁( ▁multiple xed ▁. ▁toByteArray ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁test New line Tri gg ers Flush ▁( ▁) ▁throws ▁Exception ▁{ ▁out ▁. ▁write ▁( ▁getL at in ▁( ▁STR ▁) ▁) ▁;
▁public ▁class ▁Shard E ject or ▁{ ▁private ▁static ▁final ▁Logger ▁log ▁= ▁Logger ▁. ▁get ▁( ▁Shard E ject or ▁. ▁class ▁) ▁; ▁private ▁final ▁String ▁current Node ▁; ▁private ▁final ▁Node Supplier ▁node Supplier ▁; ▁private ▁final ▁Shard Manager ▁shard Manager ▁; ▁private ▁final ▁Storage Service ▁storage Service ▁; ▁private ▁final ▁Duration ▁interval ▁; ▁private ▁final ▁Optional ▁< ▁Backup Store ▁> ▁backup Store ▁; ▁private ▁final ▁Scheduled ExecutorService ▁executor ▁; ▁private ▁final ▁Optional ▁< ▁Raw Local FileSystem ▁> ▁local FileSystem ▁; ▁private ▁final ▁AtomicBoolean ▁started ▁= ▁new ▁AtomicBoolean ▁( ▁) ▁; ▁private ▁final ▁Counter Stat ▁shards E jected ▁= ▁new ▁Counter Stat ▁( ▁) ▁; ▁private ▁final ▁Counter Stat ▁job Errors ▁= ▁new ▁Counter Stat ▁( ▁) ▁; ▁@ ▁Inject ▁public ▁Shard E ject or ▁( ▁Node Manager ▁nodeManager ▁, ▁Node Supplier ▁node Supplier ▁, ▁Shard Manager ▁shard Manager ▁, ▁Storage Service ▁storage Service ▁, ▁Storage Manager Config ▁config ▁, ▁Optional ▁< ▁Backup Store ▁> ▁backup Store ▁, ▁Orc Data Environment ▁environment ▁, ▁Raptor Connector Id ▁connectorId ▁) ▁{ ▁this ▁( ▁nodeManager ▁. ▁getCurrent Node ▁( ▁) ▁. ▁getNode Identifier ▁( ▁) ▁, ▁node Supplier ▁, ▁shard Manager ▁, ▁storage Service ▁, ▁config ▁. ▁getShard E ject or Interval ▁( ▁) ▁, ▁backup Store ▁, ▁environment ▁, ▁connectorId ▁. ▁toString ▁( ▁) ▁) ▁; ▁} ▁public ▁Shard E ject or ▁( ▁String ▁current Node ▁, ▁Node Supplier ▁node Supplier ▁, ▁Shard Manager ▁shard Manager ▁, ▁Storage Service ▁storage Service ▁, ▁Duration ▁interval ▁, ▁Optional ▁< ▁Backup Store ▁> ▁backup Store ▁, ▁Orc Data Environment ▁environment ▁, ▁String ▁connectorId ▁) ▁{ ▁this ▁. ▁current Node ▁= ▁requireNonNull ▁( ▁current Node ▁, ▁STR ▁) ▁; ▁this ▁. ▁node Supplier ▁= ▁requireNonNull ▁( ▁node Supplier ▁, ▁STR ▁) ▁; ▁this ▁. ▁shard Manager ▁= ▁requireNonNull ▁( ▁shard Manager ▁, ▁STR ▁) ▁; ▁this ▁. ▁storage Service ▁= ▁requireNonNull ▁( ▁storage Service ▁, ▁STR ▁) ▁; ▁this ▁. ▁interval ▁= ▁requireNonNull ▁( ▁interval ▁, ▁STR ▁) ▁; ▁this ▁. ▁backup Store ▁= ▁requireNonNull ▁( ▁backup Store ▁, ▁STR ▁) ▁; ▁this ▁. ▁executor ▁= ▁new Scheduled ThreadPool ▁( ▁1 ▁, ▁daemon Threads Named ▁( ▁STR ▁+ ▁connectorId ▁) ▁) ▁; ▁this ▁. ▁local FileSystem ▁= ▁try Get Local FileSystem ▁( ▁requireNonNull ▁( ▁environment ▁, ▁STR ▁) ▁) ▁; ▁checkState ▁( ▁( ▁! ▁backup Store ▁. ▁isPresent ▁( ▁) ▁|| ▁local FileSystem ▁. ▁isPresent ▁( ▁) ▁) ▁, ▁STR ▁) ▁; ▁} ▁@ ▁PostConstruct ▁public ▁void ▁start ▁( ▁) ▁{ ▁if ▁( ▁! ▁backup Store ▁. ▁isPresent ▁( ▁) ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁! ▁started ▁. ▁getAndSet ▁( ▁true ▁) ▁) ▁{ ▁start Job ▁( ▁) ▁; ▁} ▁} ▁@ ▁Pre Destroy ▁public ▁void ▁shutdown ▁( ▁) ▁{ ▁executor ▁. ▁shutdownNow ▁( ▁) ▁; ▁} ▁@ ▁Managed ▁@ ▁Nested ▁public ▁Counter Stat ▁get Shards E jected ▁( ▁) ▁{ ▁return ▁shards E jected ▁; ▁} ▁@ ▁Managed ▁@ ▁Nested ▁public ▁Counter Stat ▁getJob Errors ▁( ▁) ▁{ ▁return ▁job Errors ▁; ▁}
▁public ▁class ▁Extra Script Utils ▁extends ▁Flat Program API ▁{ ▁Program ▁program ▁; ▁TaskMonitor ▁task Monitor ▁; ▁int ▁default Pointer Size ▁; ▁Extra Script Utils ▁( ▁Program ▁program ▁, ▁TaskMonitor ▁task Monitor ▁) ▁{ ▁this ▁. ▁program ▁= ▁program ▁; ▁this ▁. ▁task Monitor ▁= ▁task Monitor ▁; ▁currentProgram ▁= ▁program ▁; ▁monitor ▁= ▁task Monitor ▁; ▁default Pointer Size ▁= ▁program ▁. ▁getDefault Pointer Size ▁( ▁) ▁; ▁} ▁public ▁boolean ▁isArray Or Structure Of All Pointer s ▁( ▁Data ▁data ▁) ▁throws ▁Cancelled Exception ▁{ ▁if ▁( ▁data ▁== ▁null ▁) ▁{ ▁return ▁false ▁; ▁} ▁if ▁( ▁! ▁data ▁. ▁isArray ▁( ▁) ▁&& ▁! ▁data ▁. ▁is Structure ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁int ▁num Components ▁= ▁data ▁. ▁getNum Components ▁( ▁) ▁; ▁for ▁( ▁int ▁ii ▁= ▁0 ▁; ▁ii ▁< ▁num Components ▁; ▁++ ▁ii ▁) ▁{ ▁task Monitor ▁. ▁checkCanceled ▁( ▁) ▁; ▁Data ▁component ▁= ▁data ▁. ▁getComponent ▁( ▁ii ▁) ▁; ▁if ▁( ▁! ▁component ▁. ▁is Pointer ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁true ▁; ▁} ▁public ▁Address ▁getPointer ▁( ▁Address ▁address ▁) ▁{ ▁try ▁{ ▁long ▁offset ▁= ▁0 ▁; ▁if ▁( ▁default Pointer Size ▁== ▁4 ▁) ▁{ ▁offset ▁= ▁getInt ▁( ▁address ▁) ▁; ▁} ▁if ▁( ▁default Pointer Size ▁== ▁8 ▁) ▁{ ▁offset ▁= ▁getLong ▁( ▁address ▁) ▁; ▁} ▁if ▁( ▁offset ▁== ▁0 ▁) ▁{ ▁return ▁null ▁; ▁} ▁Address ▁possible Function Pointer ▁= ▁address ▁. ▁getNew Address ▁( ▁offset ▁) ▁; ▁return ▁possible Function Pointer ▁; ▁} ▁catch ▁( ▁Memory AccessException ▁e ▁) ▁{ ▁return ▁null ▁; ▁} ▁catch ▁( ▁Address OutOfBounds Exception ▁e ▁) ▁{ ▁return ▁null ▁; ▁} ▁} ▁public ▁boolean ▁is Function Pointer ▁( ▁Address ▁address ▁, ▁boolean ▁allow Null Function Pointer ▁) ▁throws ▁Cancelled Exception ▁{ ▁if ▁( ▁isNull Pointer ▁( ▁address ▁) ▁&& ▁allow Null Function Pointer ▁) ▁{ ▁return ▁true ▁; ▁} ▁Data ▁data ▁= ▁program ▁. ▁getListing ▁( ▁) ▁. ▁get Defined Data At ▁( ▁address ▁) ▁; ▁if ▁( ▁data ▁!= ▁null ▁) ▁{ ▁if ▁( ▁data ▁. ▁is Pointer ▁( ▁) ▁&& ▁getP ointed To Function ▁( ▁address ▁) ▁!= ▁null ▁) ▁{ ▁return ▁true ▁; ▁} ▁} ▁else ▁{ ▁Pointer DataType ▁pointer DataType ▁= ▁new ▁Pointer DataType ▁( ▁) ▁; ▁try ▁{ ▁data ▁= ▁createData ▁( ▁address ▁, ▁pointer DataType ▁) ▁; ▁if ▁( ▁getP ointed To Function ▁( ▁address ▁) ▁!= ▁null ▁) ▁{ ▁return ▁true ▁; ▁} ▁clear Listing ▁( ▁address ▁) ▁; ▁return ▁false ▁; ▁} ▁catch ▁( ▁Exception ▁e ▁) ▁{ ▁return ▁false ▁; ▁} ▁} ▁return ▁false ▁; ▁} ▁public ▁boolean ▁isNull Pointer ▁( ▁Address ▁address ▁) ▁throws ▁Cancelled Exception ▁{ ▁if ▁( ▁! ▁has Num Z eros ▁( ▁address ▁, ▁default Pointer Size ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁DataType ▁null Pointer ▁= ▁program ▁. ▁getDataType Manager ▁( ▁) ▁. ▁getPointer ▁( ▁null ▁) ▁; ▁Listing ▁listing ▁= ▁program ▁. ▁getListing ▁( ▁) ▁; ▁Data ▁d ▁= ▁listing ▁. ▁get Defined Data At ▁( ▁address ▁) ▁;
▁public ▁class ▁BiFunction Adapter ▁< ▁A ▁, ▁B ▁, ▁R ▁> ▁implements ▁Function 2 ▁< ▁A ▁, ▁B ▁, ▁R ▁> ▁{ ▁private ▁final ▁BiFunction ▁< ▁A ▁, ▁B ▁, ▁R ▁> ▁fn ▁; ▁public ▁BiFunction Adapter ▁( ▁BiFunction ▁< ▁A ▁, ▁B ▁, ▁R ▁> ▁fn ▁) ▁{ ▁this ▁. ▁fn ▁= ▁fn ▁; ▁} ▁@ ▁Override ▁public ▁R ▁call ▁( ▁A ▁v 1 ▁, ▁B ▁v 2 ▁) ▁throws ▁Exception ▁{ ▁return ▁fn ▁. ▁apply ▁( ▁v 1 ▁, ▁v 2 ▁) ▁; ▁} ▁}
▁class ▁Window Root View Compact V 16 Impl ▁extends ▁Window Root View Compat ▁{ ▁private ▁Context ▁m Context ▁; ▁Window Root View Compact V 16 Impl ▁( ▁Context ▁context ▁) ▁{ ▁this ▁. ▁m Context ▁= ▁context ▁; ▁} ▁@ ▁NonNull ▁@ ▁Override ▁public ▁List ▁< ▁View ▁> ▁getRoot Views ▁( ▁) ▁{ ▁Window Manager ▁window Manager ▁= ▁( ▁Window Manager ▁) ▁m Context ▁. ▁getSystem Service ▁( ▁Context ▁. ▁WINDO W _ SERVICE ▁) ▁; ▁Object ▁w m ▁= ▁get Outer ▁( ▁window Manager ▁) ▁; ▁return ▁getWindow Views ▁( ▁w m ▁) ▁; ▁} ▁private ▁static ▁Object ▁get Outer ▁( ▁Object ▁inner W M ▁) ▁{ ▁try ▁{ ▁Field ▁parent Field ▁= ▁inner W M ▁. ▁getClass ▁( ▁) ▁. ▁getDeclared Field ▁( ▁STR ▁) ▁; ▁parent Field ▁. ▁setAccessible ▁( ▁true ▁) ▁; ▁Object ▁outer W M ▁= ▁parent Field ▁. ▁get ▁( ▁inner W M ▁) ▁; ▁parent Field ▁. ▁setAccessible ▁( ▁false ▁) ▁; ▁return ▁outer W M ▁; ▁} ▁catch ▁( ▁NoSuch FieldException ▁e ▁) ▁{ ▁throw ▁new ▁Runtime Exception ▁( ▁e ▁) ▁; ▁} ▁catch ▁( ▁Illegal AccessException ▁e ▁) ▁{ ▁throw ▁new ▁Runtime Exception ▁( ▁e ▁) ▁; ▁} ▁} ▁private ▁static ▁List ▁< ▁View ▁> ▁getWindow Views ▁( ▁final ▁Object ▁window Manager ▁) ▁{ ▁try ▁{ ▁Class ▁cl z ▁= ▁window Manager ▁. ▁getClass ▁( ▁) ▁; ▁Field ▁field ▁= ▁cl z ▁. ▁getDeclared Field ▁( ▁STR ▁) ▁; ▁field ▁. ▁setAccessible ▁( ▁true ▁) ▁; ▁return ▁Collections ▁. ▁unmodifiable List ▁( ▁Arrays ▁. ▁asList ▁( ▁( ▁View ▁[ ▁] ▁) ▁field ▁. ▁get ▁( ▁window Manager ▁) ▁) ▁) ▁; ▁} ▁catch ▁( ▁NoSuch FieldException ▁e ▁) ▁{ ▁throw ▁new ▁Runtime Exception ▁( ▁e ▁) ▁; ▁} ▁catch ▁( ▁Illegal AccessException ▁e ▁) ▁{ ▁throw ▁new ▁Runtime Exception ▁( ▁e ▁) ▁; ▁} ▁} ▁}
▁catch ▁( ▁Authentication Exception ▁x ▁) ▁{ ▁throw ▁org ▁. ▁a ce g ise c urity ▁. ▁Authentication Exception ▁. ▁from Spring ▁( ▁x ▁) ▁; ▁} ▁} ▁public ▁HttpResponse ▁comm ence Sign up ▁( ▁Fed er ated Identity ▁identity ▁) ▁{ ▁throw ▁new ▁Unsupported Operation Exception ▁( ▁) ▁; ▁} ▁public ▁final ▁void ▁do Capt cha ▁( ▁StaplerRequest ▁req ▁, ▁Stapler Response ▁rsp ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁c apt cha Support ▁!= ▁null ▁) ▁{ ▁String ▁id ▁= ▁req ▁. ▁getSession ▁( ▁) ▁. ▁getId ▁( ▁) ▁; ▁rsp ▁. ▁setContentType ▁( ▁STR ▁) ▁; ▁rsp ▁. ▁setHeader ▁( ▁STR ▁, ▁STR ▁) ▁; ▁rsp ▁. ▁setHeader ▁( ▁STR ▁, ▁STR ▁) ▁; ▁rsp ▁. ▁setHeader ▁( ▁STR ▁, ▁STR ▁) ▁; ▁c apt cha Support ▁. ▁generate Image ▁( ▁id ▁, ▁rsp ▁. ▁getOutputStream ▁( ▁) ▁) ▁; ▁} ▁} ▁protected ▁final ▁boolean ▁validate Capt cha ▁( ▁String ▁text ▁) ▁{ ▁if ▁( ▁c apt cha Support ▁!= ▁null ▁) ▁{ ▁String ▁id ▁= ▁Stapler ▁. ▁getCurrent Request ▁( ▁) ▁. ▁getSession ▁( ▁) ▁. ▁getId ▁( ▁) ▁; ▁return ▁c apt cha Support ▁. ▁validate Capt cha ▁( ▁id ▁, ▁text ▁) ▁; ▁} ▁return ▁true ▁; ▁} ▁private ▁transient ▁Security Components ▁security Components ▁; ▁public ▁synchronized ▁Security Components ▁getSecurity Components ▁( ▁) ▁{ ▁if ▁( ▁this ▁. ▁security Components ▁== ▁null ▁) ▁{ ▁this ▁. ▁security Components ▁= ▁this ▁. ▁create Security Components ▁( ▁) ▁; ▁} ▁return ▁this ▁. ▁security Components ▁; ▁} ▁public ▁Filter ▁create Filter ▁( ▁Filter Config ▁filterConfig ▁) ▁{ ▁LOGGER ▁. ▁enter ing ▁( ▁Security Realm ▁. ▁class ▁. ▁getName ▁( ▁) ▁, ▁STR ▁) ▁; ▁Security Components ▁sc ▁= ▁getSecurity Components ▁( ▁) ▁; ▁List ▁< ▁Filter ▁> ▁filters ▁= ▁new ▁ArrayList ▁< ▁> ▁( ▁) ▁; ▁{ ▁HttpSession Security Context Repository ▁http Session Security Context Repository ▁= ▁new ▁HttpSession Security Context Repository ▁( ▁) ▁; ▁http Session Security Context Repository ▁. ▁setAllow Session Creation ▁( ▁false ▁) ▁; ▁filters ▁. ▁add ▁( ▁new ▁HttpSession Context Integration Filter 2 ▁( ▁http Session Security Context Repository ▁) ▁) ▁; ▁} ▁{ ▁Basic Header Processor ▁b hp ▁= ▁new ▁Basic Header Processor ▁( ▁) ▁; ▁Basic Authentication EntryPoint ▁basic Authentication EntryPoint ▁= ▁new ▁Basic Authentication EntryPoint ▁( ▁) ▁; ▁basic Authentication EntryPoint ▁. ▁set Realm Name ▁( ▁STR ▁) ▁; ▁b hp ▁. ▁set Authentication EntryPoint ▁( ▁basic Authentication EntryPoint ▁) ▁; ▁b hp ▁. ▁setRe member Me Services ▁( ▁sc ▁. ▁re member Me 2 ▁) ▁; ▁filters ▁. ▁add ▁( ▁b hp ▁) ▁; ▁} ▁{ ▁Authentication Processing Filter 2 ▁ap f ▁= ▁new ▁Authentication Processing Filter 2 ▁( ▁get Authentication Gateway Url ▁( ▁) ▁) ▁; ▁ap f ▁. ▁set Authentication Manager ▁( ▁sc ▁. ▁manager 2 ▁) ▁; ▁if ▁( ▁System Properties ▁. ▁getInteger ▁( ▁Security Realm ▁. ▁class ▁. ▁getName ▁( ▁) ▁+ ▁STR ▁, ▁1 ▁) ▁== ▁1 ▁) ▁{ ▁ap f ▁. ▁set Session Authentication Strategy ▁( ▁new ▁Session Fix ation Prote ction Strategy ▁( ▁) ▁) ▁; ▁}
▁public ▁static ▁void ▁close Channel ▁( ▁Channel ▁channel ▁) ▁{ ▁for ▁( ▁Map ▁. ▁Entry ▁< ▁Long ▁, ▁Channel ▁> ▁entry ▁: ▁CHANNEL S ▁. ▁entrySet ▁( ▁) ▁) ▁{ ▁if ▁( ▁channel ▁. ▁equals ▁( ▁entry ▁. ▁getValue ▁( ▁) ▁) ▁) ▁{ ▁Default Future ▁future ▁= ▁get Future ▁( ▁entry ▁. ▁getKey ▁( ▁) ▁) ▁; ▁if ▁( ▁future ▁!= ▁null ▁&& ▁! ▁future ▁. ▁isDone ▁( ▁) ▁) ▁{ ▁Response ▁disconnect Response ▁= ▁new ▁Response ▁( ▁future ▁. ▁getId ▁( ▁) ▁) ▁; ▁disconnect Response ▁. ▁setStatus ▁( ▁Response ▁. ▁CHANNEL _ IN ACTIVE ▁) ▁; ▁disconnect Response ▁. ▁set ErrorMessage ▁( ▁STR ▁+ ▁channel ▁+ ▁STR ▁+ ▁future ▁. ▁getRequest ▁( ▁) ▁) ▁; ▁Default Future ▁. ▁received ▁( ▁channel ▁, ▁disconnect Response ▁) ▁; ▁} ▁} ▁} ▁} ▁public ▁static ▁void ▁received ▁( ▁Channel ▁channel ▁, ▁Response ▁response ▁) ▁{ ▁received ▁( ▁channel ▁, ▁response ▁, ▁false ▁) ▁; ▁} ▁public ▁static ▁void ▁received ▁( ▁Channel ▁channel ▁, ▁Response ▁response ▁, ▁boolean ▁timeout ▁) ▁{ ▁try ▁{ ▁Default Future ▁future ▁= ▁F UT URE S ▁. ▁remove ▁( ▁response ▁. ▁getId ▁( ▁) ▁) ▁; ▁if ▁( ▁future ▁!= ▁null ▁) ▁{ ▁Timeout ▁t ▁= ▁future ▁. ▁timeout Check Task ▁; ▁if ▁( ▁! ▁timeout ▁) ▁{ ▁t ▁. ▁cancel ▁( ▁) ▁; ▁} ▁future ▁. ▁do Received ▁( ▁response ▁) ▁; ▁} ▁else ▁{ ▁logger ▁. ▁warn ▁( ▁STR ▁+ ▁( ▁new ▁Simple DateFormat ▁( ▁STR ▁) ▁. ▁format ▁( ▁new ▁Date ▁( ▁) ▁) ▁) ▁+ ▁STR ▁+ ▁response ▁. ▁getStatus ▁( ▁) ▁+ ▁( ▁channel ▁== ▁null ▁? ▁STR ▁: ▁STR ▁+ ▁channel ▁. ▁getLocal Address ▁( ▁) ▁+ ▁STR ▁+ ▁channel ▁. ▁getRemote Address ▁( ▁) ▁) ▁+ ▁STR ▁) ▁; ▁} ▁} ▁finally ▁{ ▁CHANNEL S ▁. ▁remove ▁( ▁response ▁. ▁getId ▁( ▁) ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁boolean ▁cancel ▁( ▁boolean ▁may Interrupt If Running ▁) ▁{ ▁Response ▁error Result ▁= ▁new ▁Response ▁( ▁id ▁) ▁; ▁error Result ▁. ▁setStatus ▁( ▁Response ▁. ▁CLIENT _ ERROR ▁) ▁; ▁error Result ▁. ▁set ErrorMessage ▁( ▁STR ▁) ▁; ▁this ▁. ▁do Received ▁( ▁error Result ▁) ▁; ▁F UT URE S ▁. ▁remove ▁( ▁id ▁) ▁; ▁CHANNEL S ▁. ▁remove ▁( ▁id ▁) ▁; ▁return ▁true ▁; ▁} ▁public ▁void ▁cancel ▁( ▁) ▁{ ▁this ▁. ▁cancel ▁( ▁true ▁) ▁; ▁} ▁private ▁void ▁do Received ▁( ▁Response ▁res ▁) ▁{ ▁if ▁( ▁res ▁== ▁null ▁) ▁{ ▁throw ▁new ▁Illegal StateException ▁( ▁STR ▁) ▁; ▁} ▁if ▁( ▁res ▁. ▁getStatus ▁( ▁) ▁== ▁Response ▁. ▁OK ▁) ▁{ ▁this ▁. ▁complete ▁( ▁res ▁. ▁getResult ▁( ▁) ▁) ▁; ▁} ▁else ▁if ▁( ▁res ▁. ▁getStatus ▁( ▁) ▁== ▁Response ▁. ▁CLIENT _ TIMEOUT ▁|| ▁res ▁. ▁getStatus ▁( ▁) ▁== ▁Response ▁. ▁SERVER _ TIMEOUT ▁) ▁{ ▁this ▁. ▁complete Exceptionally ▁( ▁new ▁Timeout Exception ▁( ▁res ▁. ▁getStatus ▁( ▁) ▁== ▁Response ▁. ▁SERVER _ TIMEOUT ▁, ▁channel ▁, ▁res ▁. ▁getError Message ▁( ▁) ▁) ▁) ▁; ▁}
▁public ▁class ▁Debug Settings Fragment ▁extends ▁Base Preference Fragment ▁{ ▁@ ▁Override ▁public ▁void ▁onCreate Preferences ▁( ▁final ▁Bundle ▁saved InstanceState ▁, ▁final ▁String ▁root Key ▁) ▁{ ▁add Preferences From Resource ▁( ▁R ▁. ▁xml ▁. ▁debug _ settings ▁) ▁; ▁final ▁Preference ▁show Memory Leak s Preference ▁= ▁find Preference ▁( ▁getString ▁( ▁R ▁. ▁string ▁. ▁show _ memory _ le ak s _ key ▁) ▁) ▁; ▁final ▁Preference ▁crash The App Preference ▁= ▁find Preference ▁( ▁getString ▁( ▁R ▁. ▁string ▁. ▁crash _ th e _ app _ key ▁) ▁) ▁; ▁assert ▁show Memory Leak s Preference ▁!= ▁null ▁; ▁assert ▁crash The App Preference ▁!= ▁null ▁; ▁show Memory Leak s Preference ▁. ▁setOn Preference ClickListener ▁( ▁preference ▁-> ▁{ ▁startActivity ▁( ▁Le ak Can ary ▁. ▁INSTANCE ▁. ▁new Leak Display Activity Intent ▁( ▁) ▁) ▁; ▁return ▁true ▁; ▁} ▁) ▁; ▁crash The App Preference ▁. ▁setOn Preference ClickListener ▁( ▁preference ▁-> ▁{ ▁throw ▁new ▁Runtime Exception ▁( ▁) ▁; ▁} ▁) ▁; ▁} ▁}
▁public ▁class ▁Completable Subscribe On Test ▁extends ▁RxJavaTest ▁{ ▁@ ▁Test ▁public ▁void ▁normal ▁( ▁) ▁{ ▁List ▁< ▁Throwable ▁> ▁list ▁= ▁TestHelper ▁. ▁track Plugin Errors ▁( ▁) ▁; ▁try ▁{ ▁TestScheduler ▁scheduler ▁= ▁new ▁TestScheduler ▁( ▁) ▁; ▁TestObserver ▁< ▁Void ▁> ▁to ▁= ▁Completable ▁. ▁complete ▁( ▁) ▁. ▁subscribeOn ▁( ▁scheduler ▁) ▁. ▁test ▁( ▁) ▁; ▁scheduler ▁. ▁advanceTime By ▁( ▁1 ▁, ▁TimeUnit ▁. ▁SECONDS ▁) ▁; ▁to ▁. ▁assertResult ▁( ▁) ▁; ▁assertTrue ▁( ▁list ▁. ▁toString ▁( ▁) ▁, ▁list ▁. ▁isEmpty ▁( ▁) ▁) ▁; ▁} ▁finally ▁{ ▁RxJavaPlugins ▁. ▁reset ▁( ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁dispose ▁( ▁) ▁{ ▁TestHelper ▁. ▁checkDisposed ▁( ▁PublishSubject ▁. ▁create ▁( ▁) ▁. ▁ignore Elements ▁( ▁) ▁. ▁subscribeOn ▁( ▁new ▁TestScheduler ▁( ▁) ▁) ▁) ▁; ▁} ▁@ ▁Test ▁public ▁void ▁double OnSubscribe ▁( ▁) ▁{ ▁TestHelper ▁. ▁check Double OnSubscribe Completable ▁( ▁new ▁Function ▁< ▁Completable ▁, ▁Completable Source ▁> ▁( ▁) ▁{ ▁@ ▁Override ▁public ▁Completable Source ▁apply ▁( ▁Completable ▁c ▁) ▁throws ▁Exception ▁{ ▁return ▁c ▁. ▁subscribeOn ▁( ▁Schedulers ▁. ▁single ▁( ▁) ▁) ▁; ▁} ▁} ▁) ▁; ▁} ▁}
▁public ▁class ▁Test View FileSystem Over load Scheme With Hdfs Scheme ▁{ ▁private ▁static ▁final ▁String ▁TEST _ STRING ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁FS _ IMP L _ PATTERN _ KEY ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁H DFS _ SCHEME ▁= ▁STR ▁; ▁private ▁Configuration ▁conf ▁= ▁null ▁; ▁private ▁static ▁MiniDFSCluster ▁cluster ▁= ▁null ▁; ▁private ▁URI ▁default FS URI ▁; ▁private ▁File ▁local Target Dir ▁; ▁private ▁static ▁final ▁String ▁TEST _ ROOT _ DIR ▁= ▁PathUtils ▁. ▁getTest Dir Name ▁( ▁Test View FileSystem Over load Scheme With Hdfs Scheme ▁. ▁class ▁) ▁; ▁private ▁static ▁final ▁String ▁H DFS _ USER _ FOLDER ▁= ▁STR ▁; ▁private ▁static ▁final ▁String ▁LOCAL _ FOLDER ▁= ▁STR ▁; ▁@ ▁BeforeClass ▁public ▁static ▁void ▁init ▁( ▁) ▁throws ▁IOException ▁{ ▁cluster ▁= ▁new ▁MiniDFSCluster ▁. ▁Builder ▁( ▁new ▁Configuration ▁( ▁) ▁) ▁. ▁numDataNodes ▁( ▁2 ▁) ▁. ▁build ▁( ▁) ▁; ▁cluster ▁. ▁wait Cluster Up ▁( ▁) ▁; ▁} ▁@ ▁Before ▁public ▁void ▁setUp ▁( ▁) ▁throws ▁IOException ▁{ ▁Configuration ▁config ▁= ▁getNew Conf ▁( ▁) ▁; ▁config ▁. ▁setInt ▁( ▁Common Configuration Keys Public ▁. ▁I PC _ CLIENT _ CONNECT _ MAX _ RE TRIES _ KEY ▁, ▁1 ▁) ▁; ▁config ▁. ▁set ▁( ▁String ▁. ▁format ▁( ▁FS _ IMP L _ PATTERN _ KEY ▁, ▁H DFS _ SCHEME ▁) ▁, ▁View FileSystem Over load Scheme ▁. ▁class ▁. ▁getName ▁( ▁) ▁) ▁; ▁config ▁. ▁setBoolean ▁( ▁CONFIG _ VIEW FS _ IG NORE _ PORT _ IN _ M OUNT _ TABLE _ NAME ▁, ▁CONFIG _ VIEW FS _ IG NORE _ PORT _ IN _ M OUNT _ TABLE _ NAME _ DEFAULT ▁) ▁; ▁setConf ▁( ▁config ▁) ▁; ▁default FS URI ▁= ▁URI ▁. ▁create ▁( ▁config ▁. ▁get ▁( ▁Common Configuration Keys ▁. ▁FS _ DEFAULT _ NAME _ KEY ▁) ▁) ▁; ▁local Target Dir ▁= ▁new ▁File ▁( ▁TEST _ ROOT _ DIR ▁, ▁STR ▁) ▁; ▁local Target Dir ▁. ▁mkdirs ▁( ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁H DFS _ SCHEME ▁, ▁default FS URI ▁. ▁getScheme ▁( ▁) ▁) ▁; ▁} ▁@ ▁After ▁public ▁void ▁cleanUp ▁( ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁cluster ▁!= ▁null ▁) ▁{ ▁FileSystem ▁fs ▁= ▁new ▁Distributed FileSystem ▁( ▁) ▁; ▁fs ▁. ▁initialize ▁( ▁default FS URI ▁, ▁conf ▁) ▁; ▁try ▁{ ▁FileStatus ▁[ ▁] ▁stat uses ▁= ▁fs ▁. ▁listStatus ▁( ▁new ▁Path ▁( ▁STR ▁) ▁) ▁; ▁for ▁( ▁FileStatus ▁st ▁: ▁stat uses ▁) ▁{ ▁Assert ▁. ▁assertTrue ▁( ▁fs ▁. ▁delete ▁( ▁st ▁. ▁getPath ▁( ▁) ▁, ▁true ▁) ▁) ▁; ▁} ▁} ▁finally ▁{ ▁fs ▁. ▁close ▁( ▁) ▁; ▁} ▁FileSystem ▁. ▁close All ▁( ▁) ▁; ▁} ▁} ▁@ ▁AfterClass ▁public ▁static ▁void ▁tearDown ▁( ▁) ▁throws ▁IOException ▁{ ▁if ▁( ▁cluster ▁!= ▁null ▁) ▁{ ▁FileSystem ▁. ▁close All ▁( ▁) ▁; ▁cluster ▁. ▁shutdown ▁( ▁) ▁; ▁} ▁}
▁class ▁Postgre DataSource Info ▁extends ▁JDBC DataSource Info ▁{ ▁private ▁final ▁Postgre DataSource ▁dataSource ▁; ▁public ▁Postgre DataSource Info ▁( ▁Postgre DataSource ▁dataSource ▁, ▁JDBC Database MetaData ▁metaData ▁) ▁{ ▁super ▁( ▁metaData ▁) ▁; ▁this ▁. ▁dataSource ▁= ▁dataSource ▁; ▁} ▁@ ▁Override ▁public ▁String ▁getDatabase Product Version ▁( ▁) ▁{ ▁String ▁server Version ▁= ▁dataSource ▁. ▁getServer Version ▁( ▁) ▁; ▁return ▁CommonUtils ▁. ▁isEmpty ▁( ▁server Version ▁) ▁? ▁super ▁. ▁getDatabase Product Version ▁( ▁) ▁: ▁super ▁. ▁getDatabase Product Version ▁( ▁) ▁+ ▁STR ▁+ ▁server Version ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁supports Multiple Results ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁needs Table Meta For Column Resolution ▁( ▁) ▁{ ▁return ▁dataSource ▁. ▁getServer Type ▁( ▁) ▁. ▁supports Entity Metadata In Results ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁supports ResultSet Limit ▁( ▁) ▁{ ▁return ▁dataSource ▁. ▁getServer Type ▁( ▁) ▁. ▁supports ResultSet Limits ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁supports Transaction s ▁( ▁) ▁{ ▁return ▁dataSource ▁. ▁getServer Type ▁( ▁) ▁. ▁supports Transaction s ▁( ▁) ▁; ▁} ▁@ ▁Override ▁protected ▁boolean ▁is Ignore ReadOnly Flag ▁( ▁) ▁{ ▁return ▁true ▁; ▁} ▁}
▁protected ▁ScriptTemplate ▁as Script From ▁( ▁ScriptTemplate ▁first Script ▁, ▁ScriptTemplate ▁second Script ▁, ▁ScriptTemplate ▁third Script ▁) ▁{ ▁return ▁new ▁ScriptTemplate ▁( ▁format Template ▁( ▁STR ▁+ ▁script MethodName ▁( ▁) ▁+ ▁STR ▁+ ▁first Script ▁. ▁template ▁( ▁) ▁+ ▁STR ▁+ ▁second Script ▁. ▁template ▁( ▁) ▁+ ▁STR ▁+ ▁third Script ▁. ▁template ▁( ▁) ▁+ ▁STR ▁) ▁, ▁params Builder ▁( ▁) ▁. ▁script ▁( ▁first Script ▁. ▁params ▁( ▁) ▁) ▁. ▁script ▁( ▁second Script ▁. ▁params ▁( ▁) ▁) ▁. ▁script ▁( ▁third Script ▁. ▁params ▁( ▁) ▁) ▁. ▁variable ▁( ▁zoneId ▁. ▁getId ▁( ▁) ▁) ▁. ▁build ▁( ▁) ▁, ▁dataType ▁( ▁) ▁) ▁; ▁} ▁protected ▁String ▁script MethodName ▁( ▁) ▁{ ▁return ▁getClass ▁( ▁) ▁. ▁getSimpleName ▁( ▁) ▁. ▁toLowerCase ▁( ▁Locale ▁. ▁ROOT ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁Objects ▁. ▁hash ▁( ▁super ▁. ▁hashCode ▁( ▁) ▁, ▁zoneId ▁) ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁o ▁) ▁{ ▁if ▁( ▁this ▁== ▁o ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁o ▁== ▁null ▁|| ▁getClass ▁( ▁) ▁!= ▁o ▁. ▁getClass ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁if ▁( ▁super ▁. ▁equals ▁( ▁o ▁) ▁== ▁false ▁) ▁{ ▁return ▁false ▁; ▁} ▁Th ree Args DateTime Function ▁that ▁= ▁( ▁Th ree Args DateTime Function ▁) ▁o ▁; ▁return ▁zoneId ▁. ▁equals ▁( ▁that ▁. ▁zoneId ▁) ▁; ▁} ▁}
▁public ▁class ▁Oracle Server Execute Plan ▁implements ▁DBP Object With Description ▁{ ▁private ▁String ▁plan ▁; ▁public ▁Oracle Server Execute Plan ▁( ▁ResultSet ▁dbResult ▁) ▁{ ▁this ▁. ▁plan ▁= ▁JDBCUtils ▁. ▁safeGetString ▁( ▁dbResult ▁, ▁STR ▁) ▁; ▁} ▁@ ▁Property ▁( ▁viewable ▁= ▁true ▁, ▁order ▁= ▁1 ▁) ▁public ▁String ▁getP lan ▁( ▁) ▁{ ▁return ▁plan ▁; ▁} ▁@ ▁Nullable ▁@ ▁Override ▁public ▁String ▁getDescription ▁( ▁) ▁{ ▁return ▁plan ▁; ▁} ▁}
▁public ▁final ▁class ▁Single Using ▁< ▁T ▁, ▁U ▁> ▁extends ▁Single ▁< ▁T ▁> ▁{ ▁final ▁Supplier ▁< ▁U ▁> ▁resource Supplier ▁; ▁final ▁Function ▁< ▁? ▁super ▁U ▁, ▁? ▁extends ▁SingleSource ▁< ▁? ▁extends ▁T ▁> ▁> ▁single Function ▁; ▁final ▁Consumer ▁< ▁? ▁super ▁U ▁> ▁dis po ser ▁; ▁final ▁boolean ▁e ager ▁; ▁public ▁Single Using ▁( ▁Supplier ▁< ▁U ▁> ▁resource Supplier ▁, ▁Function ▁< ▁? ▁super ▁U ▁, ▁? ▁extends ▁SingleSource ▁< ▁? ▁extends ▁T ▁> ▁> ▁single Function ▁, ▁Consumer ▁< ▁? ▁super ▁U ▁> ▁dis po ser ▁, ▁boolean ▁e ager ▁) ▁{ ▁this ▁. ▁resource Supplier ▁= ▁resource Supplier ▁; ▁this ▁. ▁single Function ▁= ▁single Function ▁; ▁this ▁. ▁dis po ser ▁= ▁dis po ser ▁; ▁this ▁. ▁e ager ▁= ▁e ager ▁; ▁} ▁@ ▁Override ▁protected ▁void ▁subscribeActual ▁( ▁final ▁SingleObserver ▁< ▁? ▁super ▁T ▁> ▁observer ▁) ▁{ ▁final ▁U ▁resource ▁; ▁try ▁{ ▁resource ▁= ▁resource Supplier ▁. ▁get ▁( ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁ex ▁) ▁{ ▁Exceptions ▁. ▁throwIfFatal ▁( ▁ex ▁) ▁; ▁Empty Disposable ▁. ▁error ▁( ▁ex ▁, ▁observer ▁) ▁; ▁return ▁; ▁} ▁SingleSource ▁< ▁? ▁extends ▁T ▁> ▁source ▁; ▁try ▁{ ▁source ▁= ▁Objects ▁. ▁requireNonNull ▁( ▁single Function ▁. ▁apply ▁( ▁resource ▁) ▁, ▁STR ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁ex ▁) ▁{ ▁Exceptions ▁. ▁throwIfFatal ▁( ▁ex ▁) ▁; ▁if ▁( ▁e ager ▁) ▁{ ▁try ▁{ ▁dis po ser ▁. ▁accept ▁( ▁resource ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁exc ▁) ▁{ ▁Exceptions ▁. ▁throwIfFatal ▁( ▁exc ▁) ▁; ▁ex ▁= ▁new ▁Composite Exception ▁( ▁ex ▁, ▁exc ▁) ▁; ▁} ▁} ▁Empty Disposable ▁. ▁error ▁( ▁ex ▁, ▁observer ▁) ▁; ▁if ▁( ▁! ▁e ager ▁) ▁{ ▁try ▁{ ▁dis po ser ▁. ▁accept ▁( ▁resource ▁) ▁; ▁} ▁catch ▁( ▁Throwable ▁exc ▁) ▁{ ▁Exceptions ▁. ▁throwIfFatal ▁( ▁exc ▁) ▁; ▁RxJavaPlugins ▁. ▁onError ▁( ▁exc ▁) ▁; ▁} ▁} ▁return ▁; ▁} ▁source ▁. ▁subscribe ▁( ▁new ▁U sing SingleObserver ▁< ▁T ▁, ▁U ▁> ▁( ▁observer ▁, ▁resource ▁, ▁e ager ▁, ▁dis po ser ▁) ▁) ▁; ▁} ▁static ▁final ▁class ▁U sing SingleObserver ▁< ▁T ▁, ▁U ▁> ▁extends ▁AtomicReference ▁< ▁Object ▁> ▁implements ▁SingleObserver ▁< ▁T ▁> ▁, ▁Disposable ▁{ ▁private ▁static ▁final ▁long ▁serial VersionUID ▁= ▁- ▁5 33 15 24 05 70 5 40 83 9 35 L ▁; ▁final ▁SingleObserver ▁< ▁? ▁super ▁T ▁> ▁downstream ▁; ▁final ▁Consumer ▁< ▁? ▁super ▁U ▁> ▁dis po ser ▁; ▁final ▁boolean ▁e ager ▁; ▁Disposable ▁upstream ▁; ▁U sing SingleObserver ▁( ▁SingleObserver ▁< ▁? ▁super ▁T ▁> ▁actual ▁, ▁U ▁resource ▁, ▁boolean ▁e ager ▁, ▁Consumer ▁< ▁? ▁super ▁U ▁> ▁dis po ser ▁) ▁{ ▁super ▁( ▁resource ▁) ▁; ▁this ▁. ▁downstream ▁= ▁actual ▁; ▁this ▁. ▁e ager ▁= ▁e ager ▁; ▁this ▁. ▁dis po ser ▁= ▁dis po ser ▁; ▁}
▁public ▁class ▁Multi SearchAction ▁extends ▁ActionType ▁< ▁Multi SearchResponse ▁> ▁{ ▁public ▁static ▁final ▁Multi SearchAction ▁INSTANCE ▁= ▁new ▁Multi SearchAction ▁( ▁) ▁; ▁public ▁static ▁final ▁String ▁NAME ▁= ▁STR ▁; ▁private ▁Multi SearchAction ▁( ▁) ▁{ ▁super ▁( ▁NAME ▁, ▁Multi SearchResponse ▁:: ▁new ▁) ▁; ▁} ▁}
▁if ▁( ▁st ay Closed ▁&& ▁closed ▁) ▁{ ▁channel ▁. ▁close ▁( ▁) ▁; ▁} ▁return ▁added ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁remove ▁( ▁Object ▁o ▁) ▁{ ▁Channel ▁c ▁= ▁null ▁; ▁if ▁( ▁o ▁instanceof ▁Channel Id ▁) ▁{ ▁c ▁= ▁non Server Channels ▁. ▁remove ▁( ▁o ▁) ▁; ▁if ▁( ▁c ▁== ▁null ▁) ▁{ ▁c ▁= ▁server Channels ▁. ▁remove ▁( ▁o ▁) ▁; ▁} ▁} ▁else ▁if ▁( ▁o ▁instanceof ▁Channel ▁) ▁{ ▁c ▁= ▁( ▁Channel ▁) ▁o ▁; ▁if ▁( ▁c ▁instanceof ▁Server Channel ▁) ▁{ ▁c ▁= ▁server Channels ▁. ▁remove ▁( ▁c ▁. ▁id ▁( ▁) ▁) ▁; ▁} ▁else ▁{ ▁c ▁= ▁non Server Channels ▁. ▁remove ▁( ▁c ▁. ▁id ▁( ▁) ▁) ▁; ▁} ▁} ▁if ▁( ▁c ▁== ▁null ▁) ▁{ ▁return ▁false ▁; ▁} ▁c ▁. ▁close Future ▁( ▁) ▁. ▁removeListener ▁( ▁remo ver ▁) ▁; ▁return ▁true ▁; ▁} ▁@ ▁Override ▁public ▁void ▁clear ▁( ▁) ▁{ ▁non Server Channels ▁. ▁clear ▁( ▁) ▁; ▁server Channels ▁. ▁clear ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Iterator ▁< ▁Channel ▁> ▁iterator ▁( ▁) ▁{ ▁return ▁new ▁Combined Iterator ▁< ▁Channel ▁> ▁( ▁server Channels ▁. ▁values ▁( ▁) ▁. ▁iterator ▁( ▁) ▁, ▁non Server Channels ▁. ▁values ▁( ▁) ▁. ▁iterator ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁[ ▁] ▁toArray ▁( ▁) ▁{ ▁Collection ▁< ▁Channel ▁> ▁channels ▁= ▁new ▁ArrayList ▁< ▁Channel ▁> ▁( ▁size ▁( ▁) ▁) ▁; ▁channels ▁. ▁addAll ▁( ▁server Channels ▁. ▁values ▁( ▁) ▁) ▁; ▁channels ▁. ▁addAll ▁( ▁non Server Channels ▁. ▁values ▁( ▁) ▁) ▁; ▁return ▁channels ▁. ▁toArray ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁< ▁T ▁> ▁T ▁[ ▁] ▁toArray ▁( ▁T ▁[ ▁] ▁a ▁) ▁{ ▁Collection ▁< ▁Channel ▁> ▁channels ▁= ▁new ▁ArrayList ▁< ▁Channel ▁> ▁( ▁size ▁( ▁) ▁) ▁; ▁channels ▁. ▁addAll ▁( ▁server Channels ▁. ▁values ▁( ▁) ▁) ▁; ▁channels ▁. ▁addAll ▁( ▁non Server Channels ▁. ▁values ▁( ▁) ▁) ▁; ▁return ▁channels ▁. ▁toArray ▁( ▁a ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Channel Group Future ▁close ▁( ▁) ▁{ ▁return ▁close ▁( ▁Channel Matchers ▁. ▁all ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Channel Group Future ▁disconnect ▁( ▁) ▁{ ▁return ▁disconnect ▁( ▁Channel Matchers ▁. ▁all ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Channel Group Future ▁d eregister ▁( ▁) ▁{ ▁return ▁d eregister ▁( ▁Channel Matchers ▁. ▁all ▁( ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Channel Group Future ▁write ▁( ▁Object ▁message ▁) ▁{ ▁return ▁write ▁( ▁message ▁, ▁Channel Matchers ▁. ▁all ▁( ▁) ▁) ▁; ▁} ▁private ▁static ▁Object ▁safe Duplicate ▁( ▁Object ▁message ▁) ▁{ ▁if ▁( ▁message ▁instanceof ▁ByteBuf ▁) ▁{ ▁return ▁( ▁( ▁ByteBuf ▁) ▁message ▁) ▁. ▁retained Duplicate ▁( ▁) ▁; ▁} ▁else ▁if ▁( ▁message ▁instanceof ▁ByteBuf Holder ▁) ▁{ ▁return ▁( ▁( ▁ByteBuf Holder ▁) ▁message ▁) ▁. ▁retained Duplicate ▁( ▁) ▁; ▁}
▁public ▁class ▁Pre vent Routing Test ▁extends ▁Stapler Abstract Test ▁{ ▁@ ▁TestExtension ▁public ▁static ▁class ▁Target Null ▁extends ▁Abstract Un prote cted Root Action ▁implements ▁Stapler Proxy ▁{ ▁@ ▁Override ▁public ▁@ ▁CheckForNull ▁String ▁getUrl Name ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁getTarget ▁( ▁) ▁{ ▁return ▁null ▁; ▁} ▁public ▁Renderable ▁getL eg it Rout able ▁( ▁) ▁{ ▁return ▁new ▁Renderable ▁( ▁) ▁; ▁} ▁} ▁@ ▁Test ▁@ ▁Ignore ▁( ▁STR ▁) ▁public ▁void ▁getTarget Null _ is Not Rout able ▁( ▁) ▁throws ▁Exception ▁{ ▁assertNot Reach able ▁( ▁STR ▁) ▁; ▁} ▁@ ▁TestExtension ▁public ▁static ▁class ▁Target New Object ▁extends ▁Abstract Un prote cted Root Action ▁implements ▁Stapler Proxy ▁{ ▁@ ▁Override ▁public ▁@ ▁CheckForNull ▁String ▁getUrl Name ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁@ ▁Override ▁public ▁Object ▁getTarget ▁( ▁) ▁{ ▁return ▁new ▁Object ▁( ▁) ▁; ▁} ▁public ▁Renderable ▁getL eg it Rout able ▁( ▁) ▁{ ▁return ▁new ▁Renderable ▁( ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁getTarget New Object _ is Not Rout able ▁( ▁) ▁throws ▁Exception ▁{ ▁assertNot Reach able ▁( ▁STR ▁) ▁; ▁} ▁@ ▁TestExtension ▁public ▁static ▁class ▁Not AR e quest ▁extends ▁Abstract Un prote cted Root Action ▁{ ▁@ ▁Override ▁public ▁@ ▁CheckForNull ▁String ▁getUrl Name ▁( ▁) ▁{ ▁return ▁STR ▁; ▁} ▁public ▁Renderable ▁getL eg it Rout able ▁( ▁) ▁{ ▁not St apler Getter ▁( ▁this ▁) ▁; ▁return ▁new ▁Renderable ▁( ▁) ▁; ▁} ▁public ▁Renderable ▁getL eg it Rout able 2 ▁( ▁) ▁{ ▁return ▁new ▁Renderable ▁( ▁) ▁; ▁} ▁} ▁private ▁static ▁void ▁not St apler Getter ▁( ▁@ ▁NonNull ▁Object ▁o ▁) ▁{ ▁StaplerRequest ▁req ▁= ▁Stapler ▁. ▁getCurrent Request ▁( ▁) ▁; ▁if ▁( ▁req ▁!= ▁null ▁) ▁{ ▁List ▁< ▁An ce stor ▁> ▁ancestors ▁= ▁req ▁. ▁get Ance stors ▁( ▁) ▁; ▁if ▁( ▁! ▁ancestors ▁. ▁isEmpty ▁( ▁) ▁&& ▁ancestors ▁. ▁get ▁( ▁ancestors ▁. ▁size ▁( ▁) ▁- ▁1 ▁) ▁. ▁getObject ▁( ▁) ▁== ▁o ▁) ▁{ ▁throw ▁HttpResponse s ▁. ▁not Found ▁( ▁) ▁; ▁} ▁} ▁} ▁@ ▁Test ▁public ▁void ▁regular Getter _ not AR e quest ▁( ▁) ▁throws ▁Exception ▁{ ▁assert Reach able ▁( ▁STR ▁) ▁; ▁assertNot Reach able ▁( ▁STR ▁) ▁; ▁} ▁}
▁public ▁class ▁Queue sTest ▁extends ▁TestCase ▁{ ▁public ▁static ▁List ▁< ▁BlockingQueue ▁< ▁Object ▁> ▁> ▁blocking Queues ▁( ▁) ▁{ ▁return ▁ImmutableList ▁. ▁< ▁BlockingQueue ▁< ▁Object ▁> ▁> ▁of ▁( ▁new ▁Linked BlockingQueue ▁< ▁Object ▁> ▁( ▁) ▁, ▁new ▁Linked BlockingQueue ▁< ▁Object ▁> ▁( ▁10 ▁) ▁, ▁new ▁S ynchronous Queue ▁< ▁Object ▁> ▁( ▁) ▁, ▁new ▁Array BlockingQueue ▁< ▁Object ▁> ▁( ▁10 ▁) ▁, ▁new ▁Linked Blocking Deque ▁< ▁Object ▁> ▁( ▁) ▁, ▁new ▁Linked Blocking Deque ▁< ▁Object ▁> ▁( ▁10 ▁) ▁, ▁new ▁Priority BlockingQueue ▁< ▁Object ▁> ▁( ▁10 ▁, ▁Ordering ▁. ▁ar b itr ary ▁( ▁) ▁) ▁) ▁; ▁} ▁private ▁ExecutorService ▁threadPool ▁; ▁@ ▁Override ▁public ▁void ▁setUp ▁( ▁) ▁{ ▁threadPool ▁= ▁newCached ThreadPool ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁tearDown ▁( ▁) ▁throws ▁Interrupted Exception ▁{ ▁threadPool ▁. ▁shutdown ▁( ▁) ▁; ▁assertTrue ▁( ▁STR ▁, ▁threadPool ▁. ▁await Termination ▁( ▁10 ▁, ▁SECONDS ▁) ▁) ▁; ▁} ▁private ▁static ▁< ▁T ▁> ▁int ▁drain ▁( ▁BlockingQueue ▁< ▁T ▁> ▁q ▁, ▁Collection ▁< ▁? ▁super ▁T ▁> ▁buffer ▁, ▁int ▁max Elements ▁, ▁long ▁timeout ▁, ▁TimeUnit ▁unit ▁, ▁boolean ▁interrupt ibly ▁) ▁throws ▁Interrupted Exception ▁{ ▁return ▁interrupt ibly ▁? ▁Queue s ▁. ▁drain ▁( ▁q ▁, ▁buffer ▁, ▁max Elements ▁, ▁timeout ▁, ▁unit ▁) ▁: ▁Queue s ▁. ▁drain Uninterruptibly ▁( ▁q ▁, ▁buffer ▁, ▁max Elements ▁, ▁timeout ▁, ▁unit ▁) ▁; ▁} ▁public ▁void ▁test Multiple Pro ducers ▁( ▁) ▁throws ▁Exception ▁{ ▁for ▁( ▁BlockingQueue ▁< ▁Object ▁> ▁q ▁: ▁blocking Queues ▁( ▁) ▁) ▁{ ▁test Multiple Pro ducers ▁( ▁q ▁) ▁; ▁} ▁} ▁private ▁void ▁test Multiple Pro ducers ▁( ▁BlockingQueue ▁< ▁Object ▁> ▁q ▁) ▁throws ▁Interrupted Exception ▁{ ▁for ▁( ▁boolean ▁interrupt ibly ▁: ▁new ▁boolean ▁[ ▁] ▁{ ▁true ▁, ▁false ▁} ▁) ▁{ ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁Future ▁< ▁? ▁> ▁p o ssi bly Ignored Error ▁= ▁threadPool ▁. ▁submit ▁( ▁new ▁Producer ▁( ▁q ▁, ▁20 ▁) ▁) ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁Future ▁< ▁? ▁> ▁p o ssi bly Ignored Error 1 ▁= ▁threadPool ▁. ▁submit ▁( ▁new ▁Producer ▁( ▁q ▁, ▁20 ▁) ▁) ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁Future ▁< ▁? ▁> ▁p o ssi bly Ignored Error 2 ▁= ▁threadPool ▁. ▁submit ▁( ▁new ▁Producer ▁( ▁q ▁, ▁20 ▁) ▁) ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁Future ▁< ▁? ▁> ▁p o ssi bly Ignored Error 3 ▁= ▁threadPool ▁. ▁submit ▁( ▁new ▁Producer ▁( ▁q ▁, ▁20 ▁) ▁) ▁; ▁@ ▁Suppress Warnings ▁( ▁STR ▁) ▁Future ▁< ▁? ▁> ▁p o ssi bly Ignored Error 4 ▁= ▁threadPool ▁. ▁submit ▁( ▁new ▁Producer ▁( ▁q ▁, ▁20 ▁) ▁) ▁; ▁List ▁< ▁Object ▁> ▁buf ▁= ▁newArrayList ▁( ▁) ▁; ▁int ▁elements ▁= ▁drain ▁( ▁q ▁, ▁buf ▁, ▁100 ▁, ▁MAX _ VALUE ▁, ▁NANOSECONDS ▁, ▁interrupt ibly ▁) ▁; ▁assertEquals ▁( ▁100 ▁, ▁elements ▁) ▁;
▁plugins ▁. ▁add ▁( ▁new ▁PluginInfo ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁Version ▁. ▁CURRENT ▁, ▁STR ▁, ▁STR ▁, ▁Collections ▁. ▁emptyList ▁( ▁) ▁, ▁randomBoolean ▁( ▁) ▁, ▁Plugin Type ▁. ▁IS OL ATED ▁, ▁STR ▁, ▁randomBoolean ▁( ▁) ▁) ▁) ▁; ▁plugins ▁. ▁add ▁( ▁new ▁PluginInfo ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁Version ▁. ▁CURRENT ▁, ▁STR ▁, ▁STR ▁, ▁Collections ▁. ▁emptyList ▁( ▁) ▁, ▁randomBoolean ▁( ▁) ▁, ▁Plugin Type ▁. ▁BO OTSTRAP ▁, ▁STR ▁, ▁randomBoolean ▁( ▁) ▁) ▁) ▁; ▁plugins ▁. ▁add ▁( ▁new ▁PluginInfo ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁Version ▁. ▁CURRENT ▁, ▁STR ▁, ▁STR ▁, ▁Collections ▁. ▁emptyList ▁( ▁) ▁, ▁randomBoolean ▁( ▁) ▁, ▁Plugin Type ▁. ▁IS OL ATED ▁, ▁STR ▁, ▁randomBoolean ▁( ▁) ▁) ▁) ▁; ▁P lugins And Modules ▁plugins Info ▁= ▁new ▁P lugins And Modules ▁( ▁plugins ▁, ▁Collections ▁. ▁emptyList ▁( ▁) ▁) ▁; ▁final ▁List ▁< ▁PluginInfo ▁> ▁infos ▁= ▁plugins Info ▁. ▁getPlugin Infos ▁( ▁) ▁; ▁List ▁< ▁String ▁> ▁names ▁= ▁infos ▁. ▁stream ▁( ▁) ▁. ▁map ▁( ▁PluginInfo ▁:: ▁getName ▁) ▁. ▁collect ▁( ▁Collectors ▁. ▁toList ▁( ▁) ▁) ▁; ▁assertThat ▁( ▁names ▁, ▁contains ▁( ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁) ▁) ▁; ▁} ▁public ▁void ▁test Unknown Properties ▁( ▁) ▁throws ▁Exception ▁{ ▁Path ▁plugin Dir ▁= ▁createTempDir ▁( ▁) ▁. ▁resolve ▁( ▁STR ▁) ▁; ▁Plugin TestUtil ▁. ▁write Plugin Properties ▁( ▁plugin Dir ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁Version ▁. ▁CURRENT ▁. ▁toString ▁( ▁) ▁, ▁STR ▁, ▁System ▁. ▁getProperty ▁( ▁STR ▁) ▁) ▁; ▁IllegalArgument Exception ▁e ▁= ▁expectThrows ▁( ▁IllegalArgument Exception ▁. ▁class ▁, ▁( ▁) ▁-> ▁PluginInfo ▁. ▁readFrom Properties ▁( ▁plugin Dir ▁) ▁) ▁; ▁assertThat ▁( ▁e ▁. ▁getMessage ▁( ▁) ▁, ▁containsString ▁( ▁STR ▁) ▁) ▁; ▁} ▁public ▁void ▁test Missing Type ▁( ▁) ▁throws ▁Exception ▁{ ▁Path ▁plugin Dir ▁= ▁createTempDir ▁( ▁) ▁. ▁resolve ▁( ▁STR ▁) ▁; ▁Plugin TestUtil ▁. ▁write Plugin Properties ▁( ▁plugin Dir ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁STR ▁, ▁Version ▁. ▁CURRENT ▁. ▁toString ▁( ▁) ▁, ▁STR ▁, ▁System ▁. ▁getProperty ▁( ▁STR ▁) ▁) ▁; ▁final ▁PluginInfo ▁plugin Info ▁= ▁PluginInfo ▁. ▁readFrom Properties ▁( ▁plugin Dir ▁) ▁; ▁assertThat ▁( ▁plugin Info ▁. ▁getType ▁( ▁) ▁, ▁equalTo ▁( ▁Plugin Type ▁. ▁IS OL ATED ▁) ▁) ▁; ▁} ▁public ▁void ▁testInvalid Type ▁( ▁) ▁throws ▁Exception ▁{ ▁Path ▁plugin Dir ▁= ▁createTempDir ▁( ▁) ▁. ▁resolve ▁( ▁STR ▁) ▁;
▁public ▁class ▁Protocol MetaInfo Server Side Translator PB ▁implements ▁Protocol MetaInfo PB ▁{ ▁RPC ▁. ▁Server ▁server ▁; ▁public ▁Protocol MetaInfo Server Side Translator PB ▁( ▁RPC ▁. ▁Server ▁server ▁) ▁{ ▁this ▁. ▁server ▁= ▁server ▁; ▁} ▁@ ▁Override ▁public ▁Get Protocol Versions ResponseProto ▁getProtocol Versions ▁( ▁Rpc Controller ▁controller ▁, ▁Get Protocol Versions RequestProto ▁request ▁) ▁throws ▁Service Exception ▁{ ▁String ▁protocol ▁= ▁request ▁. ▁getProtocol ▁( ▁) ▁; ▁Get Protocol Versions ResponseProto ▁. ▁Builder ▁builder ▁= ▁Get Protocol Versions ResponseProto ▁. ▁newBuilder ▁( ▁) ▁; ▁for ▁( ▁RPC ▁. ▁Rpc Kind ▁r ▁: ▁RPC ▁. ▁Rpc Kind ▁. ▁values ▁( ▁) ▁) ▁{ ▁long ▁[ ▁] ▁version s ▁; ▁try ▁{ ▁version s ▁= ▁getProtocol Version For Rpc Kind ▁( ▁r ▁, ▁protocol ▁) ▁; ▁} ▁catch ▁( ▁ClassNot FoundException ▁e ▁) ▁{ ▁throw ▁new ▁Service Exception ▁( ▁e ▁) ▁; ▁} ▁Protocol Version Proto ▁. ▁Builder ▁b ▁= ▁Protocol Version Proto ▁. ▁newBuilder ▁( ▁) ▁; ▁if ▁( ▁version s ▁!= ▁null ▁) ▁{ ▁b ▁. ▁set Rpc Kind ▁( ▁r ▁. ▁toString ▁( ▁) ▁) ▁; ▁for ▁( ▁long ▁v ▁: ▁version s ▁) ▁{ ▁b ▁. ▁add Versions ▁( ▁v ▁) ▁; ▁} ▁} ▁builder ▁. ▁add Protocol Versions ▁( ▁b ▁. ▁build ▁( ▁) ▁) ▁; ▁} ▁return ▁builder ▁. ▁build ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Get Protocol Signature ResponseProto ▁getProtocol Signature ▁( ▁Rpc Controller ▁controller ▁, ▁Get Protocol Signature RequestProto ▁request ▁) ▁throws ▁Service Exception ▁{ ▁Get Protocol Signature ResponseProto ▁. ▁Builder ▁builder ▁= ▁Get Protocol Signature ResponseProto ▁. ▁newBuilder ▁( ▁) ▁; ▁String ▁protocol ▁= ▁request ▁. ▁getProtocol ▁( ▁) ▁; ▁String ▁rpc Kind ▁= ▁request ▁. ▁getRpc Kind ▁( ▁) ▁; ▁long ▁[ ▁] ▁version s ▁; ▁try ▁{ ▁version s ▁= ▁getProtocol Version For Rpc Kind ▁( ▁RPC ▁. ▁Rpc Kind ▁. ▁valueOf ▁( ▁rpc Kind ▁) ▁, ▁protocol ▁) ▁; ▁} ▁catch ▁( ▁ClassNot FoundException ▁e 1 ▁) ▁{ ▁throw ▁new ▁Service Exception ▁( ▁e 1 ▁) ▁; ▁} ▁if ▁( ▁version s ▁== ▁null ▁) ▁{ ▁return ▁builder ▁. ▁build ▁( ▁) ▁; ▁} ▁for ▁( ▁long ▁v ▁: ▁version s ▁) ▁{ ▁Protocol Signature Proto ▁. ▁Builder ▁sig Builder ▁= ▁Protocol Signature Proto ▁. ▁newBuilder ▁( ▁) ▁; ▁sig Builder ▁. ▁setVersion ▁( ▁v ▁) ▁; ▁try ▁{ ▁Protocol Signature ▁signature ▁= ▁Protocol Signature ▁. ▁getProtocol Signature ▁( ▁protocol ▁, ▁v ▁) ▁; ▁for ▁( ▁int ▁m ▁: ▁signature ▁. ▁getMethods ▁( ▁) ▁) ▁{ ▁sig Builder ▁. ▁add Methods ▁( ▁m ▁) ▁; ▁} ▁} ▁catch ▁( ▁ClassNot FoundException ▁e ▁) ▁{ ▁throw ▁new ▁Service Exception ▁( ▁e ▁) ▁; ▁} ▁builder ▁. ▁add Protocol Signature ▁( ▁sig Builder ▁. ▁build ▁( ▁) ▁) ▁; ▁} ▁return ▁builder ▁. ▁build ▁( ▁) ▁; ▁} ▁private ▁long ▁[ ▁] ▁getProtocol Version For Rpc Kind ▁( ▁RPC ▁. ▁Rpc Kind ▁rpc Kind ▁, ▁String ▁protocol ▁) ▁throws ▁ClassNot FoundException ▁{ ▁Class ▁< ▁? ▁> ▁protocol Class ▁= ▁Class ▁. ▁forName ▁( ▁protocol ▁) ▁;
▁response ▁. ▁setQueue ▁( ▁STR ▁) ▁; ▁return ▁response ▁; ▁} ▁@ ▁Override ▁public ▁F inish Application Master Response ▁finish Application Master ▁( ▁F inish Application Master Request ▁request ▁) ▁throws ▁IOException ▁{ ▁F inish Application Master Response ▁response ▁= ▁Records ▁. ▁newRecord ▁( ▁F inish Application Master Response ▁. ▁class ▁) ▁; ▁return ▁response ▁; ▁} ▁@ ▁Override ▁public ▁Allocate Response ▁allocate ▁( ▁Allocate Request ▁request ▁) ▁throws ▁IOException ▁{ ▁Allocate Response ▁response ▁= ▁Records ▁. ▁newRecord ▁( ▁Allocate Response ▁. ▁class ▁) ▁; ▁List ▁< ▁Resource Request ▁> ▁ask List ▁= ▁request ▁. ▁getAs k List ▁( ▁) ▁; ▁List ▁< ▁Container ▁> ▁containers ▁= ▁new ▁ArrayList ▁< ▁Container ▁> ▁( ▁) ▁; ▁for ▁( ▁Resource Request ▁req ▁: ▁ask List ▁) ▁{ ▁if ▁( ▁! ▁Resource Request ▁. ▁is Any Location ▁( ▁req ▁. ▁getResource Name ▁( ▁) ▁) ▁) ▁{ ▁continue ▁; ▁} ▁int ▁num Containers ▁= ▁req ▁. ▁getNum Containers ▁( ▁) ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁num Containers ▁; ▁i ▁++ ▁) ▁{ ▁ContainerId ▁containerId ▁= ▁ContainerId ▁. ▁new Container Id ▁( ▁getContext ▁( ▁) ▁. ▁getApplication AttemptId ▁( ▁) ▁, ▁request ▁. ▁getResponse Id ▁( ▁) ▁+ ▁i ▁) ▁; ▁containers ▁. ▁add ▁( ▁Container ▁. ▁newInstance ▁( ▁containerId ▁, ▁NodeId ▁. ▁newInstance ▁( ▁STR ▁+ ▁containerId ▁. ▁getContainerId ▁( ▁) ▁, ▁234 5 ▁) ▁, ▁STR ▁+ ▁containerId ▁. ▁getContainerId ▁( ▁) ▁+ ▁STR ▁, ▁req ▁. ▁getCapability ▁( ▁) ▁, ▁req ▁. ▁getPriority ▁( ▁) ▁, ▁null ▁) ▁) ▁; ▁} ▁} ▁response ▁. ▁set Allocated Containers ▁( ▁containers ▁) ▁; ▁response ▁. ▁set Response Id ▁( ▁request ▁. ▁getResponse Id ▁( ▁) ▁+ ▁1 ▁) ▁; ▁response ▁. ▁setNum Cluster Nodes ▁( ▁3 50 ▁) ▁; ▁response ▁. ▁setApplication Priority ▁( ▁Priority ▁. ▁newInstance ▁( ▁100 ▁) ▁) ▁; ▁return ▁response ▁; ▁} ▁} ▁; ▁} ▁} ▁; ▁} ▁} ▁) ▁; ▁} ▁@ ▁Test ▁( ▁timeout ▁= ▁60000 ▁) ▁public ▁void ▁benchmark 2 ▁( ▁) ▁throws ▁Exception ▁{ ▁int ▁map s ▁= ▁100 ▁; ▁int ▁reduce s ▁= ▁50 ▁; ▁int ▁max Concurrent Running Tasks ▁= ▁500 ▁; ▁System ▁. ▁out ▁. ▁println ▁( ▁STR ▁+ ▁STR ▁+ ▁max Concurrent Running Tasks ▁+ ▁STR ▁+ ▁map s ▁+ ▁STR ▁+ ▁reduce s ▁) ▁; ▁run ▁( ▁new ▁Th ro tt led MR App ▁( ▁map s ▁, ▁reduce s ▁, ▁max Concurrent Running Tasks ▁) ▁) ▁; ▁} ▁public ▁static ▁void ▁main ▁( ▁String ▁[ ▁] ▁args ▁) ▁throws ▁Exception ▁{ ▁MR App Benchmark ▁benchmark ▁= ▁new ▁MR App Benchmark ▁( ▁) ▁; ▁benchmark ▁. ▁benchmark 1 ▁( ▁) ▁; ▁benchmark ▁. ▁benchmark 2 ▁( ▁) ▁; ▁} ▁}
▁if ▁( ▁task ▁!= ▁null ▁) ▁{ ▁task ▁. ▁switch To Running ▁( ▁) ▁; ▁} ▁else ▁{ ▁throw ▁new ▁IllegalArgument Exception ▁( ▁STR ▁+ ▁subtask ▁) ▁; ▁} ▁} ▁public ▁void ▁switch All Task sTo Running ▁( ▁) ▁{ ▁for ▁( ▁Test Subtask Access ▁ts a ▁: ▁subtask s ▁. ▁values ▁( ▁) ▁) ▁{ ▁ts a ▁. ▁switch To Running ▁( ▁) ▁; ▁} ▁} ▁Callable ▁< ▁Completable Future ▁< ▁Acknowledge ▁> ▁> ▁create Send Action ▁( ▁Operator Event ▁event ▁, ▁int ▁subtask ▁) ▁{ ▁return ▁( ▁) ▁-> ▁{ ▁events ▁. ▁add ▁( ▁new ▁Event With Subtask ▁( ▁event ▁, ▁subtask ▁) ▁) ▁; ▁return ▁event S ending Result ▁; ▁} ▁; ▁} ▁public ▁static ▁final ▁class ▁Event With Subtask ▁{ ▁public ▁final ▁Operator Event ▁event ▁; ▁public ▁final ▁int ▁subtask ▁; ▁public ▁Event With Subtask ▁( ▁Operator Event ▁event ▁, ▁int ▁subtask ▁) ▁{ ▁this ▁. ▁event ▁= ▁event ▁; ▁this ▁. ▁subtask ▁= ▁subtask ▁; ▁} ▁@ ▁Override ▁public ▁boolean ▁equals ▁( ▁Object ▁o ▁) ▁{ ▁if ▁( ▁this ▁== ▁o ▁) ▁{ ▁return ▁true ▁; ▁} ▁if ▁( ▁o ▁== ▁null ▁|| ▁getClass ▁( ▁) ▁!= ▁o ▁. ▁getClass ▁( ▁) ▁) ▁{ ▁return ▁false ▁; ▁} ▁final ▁Event With Subtask ▁that ▁= ▁( ▁Event With Subtask ▁) ▁o ▁; ▁return ▁subtask ▁== ▁that ▁. ▁subtask ▁&& ▁event ▁. ▁equals ▁( ▁that ▁. ▁event ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁hashCode ▁( ▁) ▁{ ▁return ▁Objects ▁. ▁hash ▁( ▁event ▁, ▁subtask ▁) ▁; ▁} ▁@ ▁Override ▁public ▁String ▁toString ▁( ▁) ▁{ ▁return ▁event ▁+ ▁STR ▁+ ▁subtask ▁; ▁} ▁} ▁private ▁final ▁class ▁Test Subtask Access ▁implements ▁Subtask Access ▁{ ▁private ▁final ▁Execution AttemptID ▁execution AttemptId ▁= ▁new ▁Execution AttemptID ▁( ▁) ▁; ▁private ▁final ▁Completable Future ▁< ▁? ▁> ▁running ▁; ▁private ▁final ▁int ▁subtaskIndex ▁; ▁private ▁Test Subtask Access ▁( ▁int ▁subtaskIndex ▁, ▁boolean ▁isRunning ▁) ▁{ ▁this ▁. ▁subtaskIndex ▁= ▁subtaskIndex ▁; ▁this ▁. ▁running ▁= ▁new ▁Completable Future ▁< ▁> ▁( ▁) ▁; ▁if ▁( ▁isRunning ▁) ▁{ ▁switch To Running ▁( ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁Callable ▁< ▁Completable Future ▁< ▁Acknowledge ▁> ▁> ▁create Event Send Action ▁( ▁SerializedValue ▁< ▁Operator Event ▁> ▁event ▁) ▁{ ▁final ▁Operator Event ▁deserialized Event ▁; ▁try ▁{ ▁deserialized Event ▁= ▁event ▁. ▁deserialize Value ▁( ▁getClass ▁( ▁) ▁. ▁getClassLoader ▁( ▁) ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁| ▁ClassNot FoundException ▁e ▁) ▁{ ▁throw ▁new ▁AssertionError ▁( ▁e ▁) ▁; ▁} ▁return ▁create Send Action ▁( ▁deserialized Event ▁, ▁subtaskIndex ▁) ▁; ▁} ▁@ ▁Override ▁public ▁int ▁getSub task Index ▁( ▁) ▁{ ▁return ▁subtaskIndex ▁; ▁} ▁@ ▁Override ▁public ▁Execution AttemptID ▁current Attempt ▁( ▁) ▁{ ▁return ▁execution AttemptId ▁; ▁} ▁@ ▁Override ▁public ▁String ▁subtask Name ▁( ▁) ▁{ ▁return ▁STR ▁+ ▁subtaskIndex ▁+ ▁STR ▁+ ▁execution AttemptId ▁; ▁} ▁@ ▁Override ▁public ▁Completable Future ▁< ▁? ▁> ▁has Sw it ched To Running ▁( ▁) ▁{ ▁return ▁running ▁; ▁}
▁@ ▁Test ▁public ▁void ▁read Pre m ature EndOf File 1 ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁FileChannel ▁fc ▁= ▁tmpFile Channel ▁( ▁) ▁; ▁final ▁Buffer ▁buffer ▁= ▁createTest Buffer ▁( ▁) ▁; ▁final ▁MemorySegment ▁read Buffer ▁= ▁MemorySegment Factory ▁. ▁allocate Un pooled Off Heap Memory ▁( ▁buffer ▁. ▁getSize ▁( ▁) ▁, ▁null ▁) ▁; ▁Buffer Reader Writer Util ▁. ▁writeTo ByteChannel ▁( ▁fc ▁, ▁buffer ▁, ▁Buffer Reader Writer Util ▁. ▁allocated Write Buffer Array ▁( ▁) ▁) ▁; ▁fc ▁. ▁truncate ▁( ▁fc ▁. ▁position ▁( ▁) ▁- ▁1 ▁) ▁; ▁fc ▁. ▁position ▁( ▁0 ▁) ▁; ▁try ▁{ ▁Buffer Reader Writer Util ▁. ▁readFrom ByteChannel ▁( ▁fc ▁, ▁Buffer Reader Writer Util ▁. ▁allocated Header Buffer ▁( ▁) ▁, ▁read Buffer ▁, ▁Free ingBuffer Recycler ▁. ▁INSTANCE ▁) ▁; ▁fail ▁( ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁} ▁} ▁@ ▁Test ▁public ▁void ▁read Pre m ature EndOf File 2 ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁FileChannel ▁fc ▁= ▁tmpFile Channel ▁( ▁) ▁; ▁final ▁Buffer ▁buffer ▁= ▁createTest Buffer ▁( ▁) ▁; ▁final ▁MemorySegment ▁read Buffer ▁= ▁MemorySegment Factory ▁. ▁allocate Un pooled Off Heap Memory ▁( ▁buffer ▁. ▁getSize ▁( ▁) ▁, ▁null ▁) ▁; ▁Buffer Reader Writer Util ▁. ▁writeTo ByteChannel ▁( ▁fc ▁, ▁buffer ▁, ▁Buffer Reader Writer Util ▁. ▁allocated Write Buffer Array ▁( ▁) ▁) ▁; ▁fc ▁. ▁truncate ▁( ▁2 ▁) ▁; ▁fc ▁. ▁position ▁( ▁0 ▁) ▁; ▁try ▁{ ▁Buffer Reader Writer Util ▁. ▁readFrom ByteChannel ▁( ▁fc ▁, ▁Buffer Reader Writer Util ▁. ▁allocated Header Buffer ▁( ▁) ▁, ▁read Buffer ▁, ▁Free ingBuffer Recycler ▁. ▁INSTANCE ▁) ▁; ▁fail ▁( ▁) ▁; ▁} ▁catch ▁( ▁IOException ▁e ▁) ▁{ ▁} ▁} ▁@ ▁Test ▁public ▁void ▁test Bulk W riting Large NumberOf Buffers ▁( ▁) ▁throws ▁Exception ▁{ ▁int ▁bufferSize ▁= ▁1024 ▁; ▁int ▁num Buffers ▁= ▁10 25 ▁; ▁try ▁( ▁FileChannel ▁file Channel ▁= ▁tmpFile Channel ▁( ▁) ▁) ▁{ ▁ByteBuffer ▁[ ▁] ▁data ▁= ▁new ▁ByteBuffer ▁[ ▁num Buffers ▁] ▁; ▁for ▁( ▁int ▁i ▁= ▁0 ▁; ▁i ▁< ▁num Buffers ▁; ▁++ ▁i ▁) ▁{ ▁data ▁[ ▁i ▁] ▁= ▁ByteBuffer ▁. ▁allocate Direct ▁( ▁bufferSize ▁) ▁; ▁} ▁int ▁bytes Expected ▁= ▁bufferSize ▁ * ▁num Buffers ▁; ▁Buffer Reader Writer Util ▁. ▁write Buffers ▁( ▁file Channel ▁, ▁bytes Expected ▁, ▁data ▁) ▁; ▁assertEquals ▁( ▁bytes Expected ▁, ▁file Channel ▁. ▁size ▁( ▁) ▁) ▁; ▁} ▁} ▁@ ▁Test ▁public ▁void ▁writeFile Read Memory Buffer ▁( ▁) ▁throws ▁Exception ▁{ ▁final ▁FileChannel ▁fc ▁= ▁tmpFile Channel ▁( ▁) ▁; ▁final ▁Buffer ▁buffer ▁= ▁createTest Buffer ▁( ▁) ▁; ▁Buffer Reader Writer Util ▁. ▁writeTo ByteChannel ▁( ▁fc ▁, ▁buffer ▁, ▁Buffer Reader Writer Util ▁. ▁allocated Write Buffer Array ▁( ▁) ▁) ▁; ▁final ▁ByteBuffer ▁bb ▁= ▁fc ▁. ▁map ▁( ▁Map Mode ▁. ▁READ _ ONLY ▁, ▁0 ▁, ▁fc ▁. ▁position ▁( ▁) ▁) ▁. ▁order ▁( ▁ByteOrder ▁. ▁native Order ▁( ▁) ▁) ▁;
▁public ▁C group ▁( ▁final ▁String ▁cpu Ac ct Control Group ▁, ▁final ▁long ▁cpu Ac ct Usage Nanos ▁, ▁final ▁String ▁cpu Control Group ▁, ▁final ▁long ▁cpu C fs Period Mic ros ▁, ▁final ▁long ▁cpu C fs Quota Mic ros ▁, ▁final ▁Cpu Stat ▁cpu Stat ▁, ▁final ▁String ▁memory Control Group ▁, ▁final ▁String ▁memory Limit InBytes ▁, ▁final ▁String ▁memory Usage InBytes ▁) ▁{ ▁this ▁. ▁cpu Ac ct Control Group ▁= ▁Objects ▁. ▁requireNonNull ▁( ▁cpu Ac ct Control Group ▁) ▁; ▁this ▁. ▁cpu Ac ct Usage Nanos ▁= ▁cpu Ac ct Usage Nanos ▁; ▁this ▁. ▁cpu Control Group ▁= ▁Objects ▁. ▁requireNonNull ▁( ▁cpu Control Group ▁) ▁; ▁this ▁. ▁cpu C fs Period Mic ros ▁= ▁cpu C fs Period Mic ros ▁; ▁this ▁. ▁cpu C fs Quota Mic ros ▁= ▁cpu C fs Quota Mic ros ▁; ▁this ▁. ▁cpu Stat ▁= ▁Objects ▁. ▁requireNonNull ▁( ▁cpu Stat ▁) ▁; ▁this ▁. ▁memory Control Group ▁= ▁memory Control Group ▁; ▁this ▁. ▁memory Limit InBytes ▁= ▁memory Limit InBytes ▁; ▁this ▁. ▁memory Usage InBytes ▁= ▁memory Usage InBytes ▁; ▁} ▁C group ▁( ▁final ▁StreamInput ▁in ▁) ▁throws ▁IOException ▁{ ▁cpu Ac ct Control Group ▁= ▁in ▁. ▁readString ▁( ▁) ▁; ▁cpu Ac ct Usage Nanos ▁= ▁in ▁. ▁readLong ▁( ▁) ▁; ▁cpu Control Group ▁= ▁in ▁. ▁readString ▁( ▁) ▁; ▁cpu C fs Period Mic ros ▁= ▁in ▁. ▁readLong ▁( ▁) ▁; ▁cpu C fs Quota Mic ros ▁= ▁in ▁. ▁readLong ▁( ▁) ▁; ▁cpu Stat ▁= ▁new ▁Cpu Stat ▁( ▁in ▁) ▁; ▁memory Control Group ▁= ▁in ▁. ▁read OptionalString ▁( ▁) ▁; ▁memory Limit InBytes ▁= ▁in ▁. ▁read OptionalString ▁( ▁) ▁; ▁memory Usage InBytes ▁= ▁in ▁. ▁read OptionalString ▁( ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁writeTo ▁( ▁final ▁StreamOutput ▁out ▁) ▁throws ▁IOException ▁{ ▁out ▁. ▁writeString ▁( ▁cpu Ac ct Control Group ▁) ▁; ▁out ▁. ▁writeLong ▁( ▁cpu Ac ct Usage Nanos ▁) ▁; ▁out ▁. ▁writeString ▁( ▁cpu Control Group ▁) ▁; ▁out ▁. ▁writeLong ▁( ▁cpu C fs Period Mic ros ▁) ▁; ▁out ▁. ▁writeLong ▁( ▁cpu C fs Quota Mic ros ▁) ▁; ▁cpu Stat ▁. ▁writeTo ▁( ▁out ▁) ▁; ▁out ▁. ▁write OptionalString ▁( ▁memory Control Group ▁) ▁; ▁out ▁. ▁write OptionalString ▁( ▁memory Limit InBytes ▁) ▁; ▁out ▁. ▁write OptionalString ▁( ▁memory Usage InBytes ▁) ▁; ▁} ▁@ ▁Override ▁public ▁XContentBuilder ▁toXContent ▁( ▁final ▁XContentBuilder ▁builder ▁, ▁final ▁Params ▁params ▁) ▁throws ▁IOException ▁{ ▁builder ▁. ▁startObject ▁( ▁STR ▁) ▁; ▁{ ▁builder ▁. ▁startObject ▁( ▁STR ▁) ▁; ▁{ ▁builder ▁. ▁field ▁( ▁STR ▁, ▁cpu Ac ct Control Group ▁) ▁; ▁builder ▁. ▁field ▁( ▁STR ▁, ▁cpu Ac ct Usage Nanos ▁) ▁; ▁} ▁builder ▁. ▁endObject ▁( ▁) ▁; ▁builder ▁. ▁startObject ▁( ▁STR ▁) ▁; ▁{ ▁builder ▁. ▁field ▁( ▁STR ▁, ▁cpu Control Group ▁) ▁;
▁@ ▁Tag ▁( ▁TagNames ▁. ▁FILE _ IO ▁) ▁@ ▁Tag ▁( ▁TagNames ▁. ▁KER AS ▁) ▁@ ▁NativeTag ▁public ▁class ▁Keras Activation Layer ▁extends ▁BaseDL 4 JTest ▁{ ▁private ▁final ▁String ▁ACTIV ATION _ KER AS ▁= ▁STR ▁; ▁private ▁final ▁String ▁ACTIV ATION _ DL 4 J ▁= ▁STR ▁; ▁private ▁final ▁String ▁LAYER _ NAME ▁= ▁STR ▁; ▁private ▁Integer ▁keras 1 ▁= ▁1 ▁; ▁private ▁Integer ▁keras 2 ▁= ▁2 ▁; ▁private ▁Keras 1 Layer Configuration ▁conf 1 ▁= ▁new ▁Keras 1 Layer Configuration ▁( ▁) ▁; ▁private ▁Keras 2 Layer Configuration ▁conf 2 ▁= ▁new ▁Keras 2 Layer Configuration ▁( ▁) ▁; ▁@ ▁Test ▁public ▁void ▁test Activation Layer ▁( ▁) ▁throws ▁Exception ▁{ ▁build Activation Layer ▁( ▁conf 1 ▁, ▁keras 1 ▁) ▁; ▁build Activation Layer ▁( ▁conf 2 ▁, ▁keras 2 ▁) ▁; ▁} ▁private ▁void ▁build Activation Layer ▁( ▁KerasLayer Configuration ▁conf ▁, ▁Integer ▁keras Version ▁) ▁throws ▁Exception ▁{ ▁Map ▁< ▁String ▁, ▁Object ▁> ▁layerConfig ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁layerConfig ▁. ▁put ▁( ▁conf ▁. ▁getLAYER _ FIELD _ CLASS _ NAME ▁( ▁) ▁, ▁conf ▁. ▁getLAYER _ FIELD _ ACT IV ATION ▁( ▁) ▁) ▁; ▁Map ▁< ▁String ▁, ▁Object ▁> ▁config ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁config ▁. ▁put ▁( ▁conf ▁. ▁getLAYER _ FIELD _ ACT IV ATION ▁( ▁) ▁, ▁ACTIV ATION _ KER AS ▁) ▁; ▁config ▁. ▁put ▁( ▁conf ▁. ▁getLAYER _ FIELD _ NAME ▁( ▁) ▁, ▁LAYER _ NAME ▁) ▁; ▁layerConfig ▁. ▁put ▁( ▁conf ▁. ▁getLAYER _ FIELD _ CONFIG ▁( ▁) ▁, ▁config ▁) ▁; ▁layerConfig ▁. ▁put ▁( ▁conf ▁. ▁getLAYER _ FIELD _ KER AS _ VERSION ▁( ▁) ▁, ▁keras Version ▁) ▁; ▁Activation Layer ▁layer ▁= ▁new ▁Keras Activation ▁( ▁layerConfig ▁) ▁. ▁getActivation Layer ▁( ▁) ▁; ▁assertEquals ▁( ▁ACTIV ATION _ DL 4 J ▁, ▁layer ▁. ▁getActivation Fn ▁( ▁) ▁. ▁toString ▁( ▁) ▁) ▁; ▁assertEquals ▁( ▁LAYER _ NAME ▁, ▁layer ▁. ▁getLayer Name ▁( ▁) ▁) ▁; ▁} ▁}
▁Mockito ▁. ▁verify ▁( ▁response ▁) ▁. ▁setStatus ▁( ▁HttpServlet Response ▁. ▁SC _ UN AUTHORI Z ED ▁) ▁; ▁} ▁@ ▁Test ▁( ▁timeout ▁= ▁60000 ▁) ▁public ▁void ▁test Request With In complete Authorization ▁( ▁) ▁throws ▁Exception ▁{ ▁HttpServlet Request ▁request ▁= ▁Mockito ▁. ▁mock ▁( ▁HttpServlet Request ▁. ▁class ▁) ▁; ▁HttpServlet Response ▁response ▁= ▁Mockito ▁. ▁mock ▁( ▁HttpServlet Response ▁. ▁class ▁) ▁; ▁Mockito ▁. ▁when ▁( ▁request ▁. ▁getHeader ▁( ▁Http Constants ▁. ▁AUTH ORI Z ATION _ HEADER ▁) ▁) ▁. ▁thenReturn ▁( ▁Http Constants ▁. ▁BASIC ▁) ▁; ▁Assert ▁. ▁assertNull ▁( ▁handler ▁. ▁authenticate ▁( ▁request ▁, ▁response ▁) ▁) ▁; ▁} ▁@ ▁Test ▁( ▁timeout ▁= ▁60000 ▁) ▁public ▁void ▁test Request With Authorization ▁( ▁) ▁throws ▁Exception ▁{ ▁HttpServlet Request ▁request ▁= ▁Mockito ▁. ▁mock ▁( ▁HttpServlet Request ▁. ▁class ▁) ▁; ▁HttpServlet Response ▁response ▁= ▁Mockito ▁. ▁mock ▁( ▁HttpServlet Response ▁. ▁class ▁) ▁; ▁final ▁Base 64 ▁base 64 ▁= ▁new ▁Base 64 ▁( ▁0 ▁) ▁; ▁String ▁credentials ▁= ▁base 64 ▁. ▁encodeToString ▁( ▁STR ▁. ▁getBytes ▁( ▁) ▁) ▁; ▁String ▁auth Header ▁= ▁Http Constants ▁. ▁BASIC ▁+ ▁STR ▁+ ▁credentials ▁; ▁Mockito ▁. ▁when ▁( ▁request ▁. ▁getHeader ▁( ▁Http Constants ▁. ▁AUTH ORI Z ATION _ HEADER ▁) ▁) ▁. ▁thenReturn ▁( ▁auth Header ▁) ▁; ▁Authentication Token ▁token ▁= ▁handler ▁. ▁authenticate ▁( ▁request ▁, ▁response ▁) ▁; ▁Assert ▁. ▁assertNotNull ▁( ▁token ▁) ▁; ▁Mockito ▁. ▁verify ▁( ▁response ▁) ▁. ▁setStatus ▁( ▁HttpServlet Response ▁. ▁SC _ OK ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁TYPE ▁, ▁token ▁. ▁getType ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁token ▁. ▁getUserName ▁( ▁) ▁) ▁; ▁Assert ▁. ▁assertEquals ▁( ▁STR ▁, ▁token ▁. ▁getName ▁( ▁) ▁) ▁; ▁} ▁@ ▁Test ▁( ▁timeout ▁= ▁60000 ▁) ▁public ▁void ▁test Request With Wrong Credentials ▁( ▁) ▁throws ▁Exception ▁{ ▁HttpServlet Request ▁request ▁= ▁Mockito ▁. ▁mock ▁( ▁HttpServlet Request ▁. ▁class ▁) ▁; ▁HttpServlet Response ▁response ▁= ▁Mockito ▁. ▁mock ▁( ▁HttpServlet Response ▁. ▁class ▁) ▁; ▁final ▁Base 64 ▁base 64 ▁= ▁new ▁Base 64 ▁( ▁0 ▁) ▁; ▁String ▁credentials ▁= ▁base 64 ▁. ▁encodeToString ▁( ▁STR ▁. ▁getBytes ▁( ▁) ▁) ▁; ▁String ▁auth Header ▁= ▁Http Constants ▁. ▁BASIC ▁+ ▁STR ▁+ ▁credentials ▁; ▁Mockito ▁. ▁when ▁( ▁request ▁. ▁getHeader ▁( ▁Http Constants ▁. ▁AUTH ORI Z ATION _ HEADER ▁) ▁) ▁. ▁thenReturn ▁( ▁auth Header ▁) ▁; ▁try ▁{ ▁handler ▁. ▁authenticate ▁( ▁request ▁, ▁response ▁) ▁; ▁Assert ▁. ▁fail ▁( ▁) ▁; ▁} ▁catch ▁( ▁Authentication Exception ▁ex ▁) ▁{ ▁} ▁catch ▁( ▁Exception ▁ex ▁) ▁{ ▁Assert ▁. ▁fail ▁( ▁) ▁; ▁} ▁} ▁}
▁@ ▁Override ▁public ▁Variable Storage ▁read XML V arnode P iece s ▁( ▁XmlElement ▁el ▁, ▁Address ▁addr ▁) ▁throws ▁Pcode XML Exception ▁, ▁Invalid InputException ▁{ ▁ArrayList ▁< ▁Varnode ▁> ▁list ▁= ▁new ▁ArrayList ▁< ▁Varnode ▁> ▁( ▁) ▁; ▁int ▁index ▁= ▁1 ▁; ▁String ▁next P iece ▁= ▁STR ▁+ ▁index ▁; ▁while ▁( ▁el ▁. ▁has Attribute ▁( ▁next P iece ▁) ▁) ▁{ ▁String ▁p iece Str ▁= ▁el ▁. ▁getAttribute ▁( ▁next P iece ▁) ▁; ▁list ▁. ▁add ▁( ▁getV arnode P iece ▁( ▁p iece Str ▁, ▁addr Factory ▁) ▁) ▁; ▁next P iece ▁= ▁STR ▁+ ▁++ ▁index ▁; ▁} ▁Varnode ▁[ ▁] ▁p iece s ▁= ▁new ▁Varnode ▁[ ▁list ▁. ▁size ▁( ▁) ▁] ▁; ▁list ▁. ▁toArray ▁( ▁p iece s ▁) ▁; ▁return ▁allocate Join Storage ▁( ▁addr ▁. ▁getOffset ▁( ▁) ▁, ▁p iece s ▁) ▁; ▁} ▁private ▁Variable Storage ▁allocate Join Storage ▁( ▁long ▁offset ▁, ▁Varnode ▁[ ▁] ▁p iece s ▁) ▁throws ▁Invalid InputException ▁{ ▁Variable Storage ▁storage ▁; ▁try ▁{ ▁storage ▁= ▁new ▁Variable Storage ▁( ▁dat atype Manager ▁. ▁getProgram ▁( ▁) ▁, ▁p iece s ▁) ▁; ▁} ▁catch ▁( ▁Invalid InputException ▁e ▁) ▁{ ▁storage ▁= ▁null ▁; ▁} ▁if ▁( ▁storage ▁== ▁null ▁) ▁{ ▁int ▁sz ▁= ▁0 ▁; ▁for ▁( ▁Varnode ▁p iece ▁: ▁p iece s ▁) ▁{ ▁sz ▁+= ▁p iece ▁. ▁getSize ▁( ▁) ▁; ▁} ▁Address ▁un i q addr ▁= ▁addr Factory ▁. ▁getUnique Space ▁( ▁) ▁. ▁getAddress ▁( ▁0 x 2 0000000 ▁) ▁; ▁storage ▁= ▁new ▁Variable Storage ▁( ▁dat atype Manager ▁. ▁getProgram ▁( ▁) ▁, ▁un i q addr ▁, ▁sz ▁) ▁; ▁} ▁Integer ▁off Object ▁; ▁int ▁round size ▁= ▁( ▁storage ▁. ▁size ▁( ▁) ▁+ ▁15 ▁) ▁& ▁0 xff ffff f 0 ▁; ▁if ▁( ▁offset ▁< ▁0 ▁) ▁{ ▁off Object ▁= ▁new ▁Integer ▁( ▁join Allocate ▁) ▁; ▁join Allocate ▁+= ▁round size ▁; ▁} ▁else ▁{ ▁off Object ▁= ▁new ▁Integer ▁( ▁( ▁int ▁) ▁offset ▁) ▁; ▁offset ▁+= ▁round size ▁; ▁if ▁( ▁offset ▁> ▁join Allocate ▁) ▁{ ▁join Allocate ▁= ▁( ▁int ▁) ▁offset ▁; ▁} ▁} ▁if ▁( ▁join map ▁== ▁null ▁) ▁{ ▁join map ▁= ▁new ▁HashMap ▁< ▁Integer ▁, ▁Variable Storage ▁> ▁( ▁) ▁; ▁} ▁join map ▁. ▁put ▁( ▁off Object ▁, ▁storage ▁) ▁; ▁return ▁storage ▁; ▁} ▁private ▁Variable Storage ▁find Join Storage ▁( ▁long ▁offset ▁) ▁{ ▁if ▁( ▁join map ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁return ▁join map ▁. ▁get ▁( ▁new ▁Integer ▁( ▁( ▁int ▁) ▁offset ▁) ▁) ▁; ▁} ▁@ ▁Override ▁public ▁Variable Storage ▁build Storage ▁( ▁Varnode ▁vn ▁) ▁throws ▁Invalid InputException ▁{ ▁Address ▁addr ▁= ▁vn ▁. ▁getAddress ▁( ▁) ▁; ▁if ▁( ▁addr ▁. ▁getAddressSpace ▁( ▁) ▁. ▁getType ▁( ▁) ▁== ▁AddressSpace ▁. ▁TYPE _ VARIABLE ▁) ▁{ ▁return ▁find Join Storage ▁( ▁addr ▁. ▁getOffset ▁( ▁) ▁) ▁; ▁}
▁public ▁void ▁set Block ▁( ▁SQLStatement ▁block ▁) ▁{ ▁if ▁( ▁block ▁!= ▁null ▁) ▁{ ▁block ▁. ▁setParent ▁( ▁this ▁) ▁; ▁} ▁this ▁. ▁block ▁= ▁block ▁; ▁} ▁public ▁SQLName ▁getAuth id ▁( ▁) ▁{ ▁return ▁auth id ▁; ▁} ▁public ▁void ▁set Auth id ▁( ▁SQLName ▁auth id ▁) ▁{ ▁if ▁( ▁auth id ▁!= ▁null ▁) ▁{ ▁auth id ▁. ▁setParent ▁( ▁this ▁) ▁; ▁} ▁this ▁. ▁auth id ▁= ▁auth id ▁; ▁} ▁public ▁String ▁getLanguage ▁( ▁) ▁{ ▁return ▁language ▁; ▁} ▁public ▁void ▁set Language ▁( ▁String ▁language ▁) ▁{ ▁this ▁. ▁language ▁= ▁language ▁; ▁} ▁public ▁boolean ▁is Or Replace ▁( ▁) ▁{ ▁return ▁or Replace ▁; ▁} ▁public ▁void ▁set Or Replace ▁( ▁boolean ▁or Replace ▁) ▁{ ▁this ▁. ▁or Replace ▁= ▁or Replace ▁; ▁} ▁public ▁SQLName ▁get Defin er ▁( ▁) ▁{ ▁return ▁def iner ▁; ▁} ▁public ▁void ▁set Defin er ▁( ▁SQLName ▁def iner ▁) ▁{ ▁this ▁. ▁def iner ▁= ▁def iner ▁; ▁} ▁public ▁boolean ▁is Create ▁( ▁) ▁{ ▁return ▁create ▁; ▁} ▁public ▁void ▁set Create ▁( ▁boolean ▁create ▁) ▁{ ▁this ▁. ▁create ▁= ▁create ▁; ▁} ▁public ▁String ▁getJava Call Spec ▁( ▁) ▁{ ▁return ▁java Call Spec ▁; ▁} ▁public ▁void ▁set Java Call Spec ▁( ▁String ▁java Call Spec ▁) ▁{ ▁this ▁. ▁java Call Spec ▁= ▁java Call Spec ▁; ▁} ▁public ▁SQLDataType ▁get Return DataType ▁( ▁) ▁{ ▁return ▁return DataType ▁; ▁} ▁public ▁void ▁set Return DataType ▁( ▁SQLDataType ▁return DataType ▁) ▁{ ▁if ▁( ▁return DataType ▁!= ▁null ▁) ▁{ ▁return DataType ▁. ▁setParent ▁( ▁this ▁) ▁; ▁} ▁this ▁. ▁return DataType ▁= ▁return DataType ▁; ▁} ▁public ▁String ▁getComment ▁( ▁) ▁{ ▁return ▁comment ▁; ▁} ▁public ▁void ▁setComment ▁( ▁String ▁comment ▁) ▁{ ▁this ▁. ▁comment ▁= ▁comment ▁; ▁} ▁public ▁boolean ▁is Deterministic ▁( ▁) ▁{ ▁return ▁determ in istic ▁; ▁} ▁public ▁void ▁set Deterministic ▁( ▁boolean ▁determ in istic ▁) ▁{ ▁this ▁. ▁determ in istic ▁= ▁determ in istic ▁; ▁} ▁public ▁String ▁getSchema ▁( ▁) ▁{ ▁SQLName ▁name ▁= ▁getName ▁( ▁) ▁; ▁if ▁( ▁name ▁== ▁null ▁) ▁{ ▁return ▁null ▁; ▁} ▁if ▁( ▁name ▁instanceof ▁SQL Property Expr ▁) ▁{ ▁return ▁( ▁( ▁SQL Property Expr ▁) ▁name ▁) ▁. ▁getOwner n Name ▁( ▁) ▁; ▁} ▁return ▁null ▁; ▁} ▁@ ▁Override ▁public ▁SQLDataType ▁getDataType ▁( ▁) ▁{ ▁return ▁return DataType ▁; ▁} ▁@ ▁Override ▁public ▁void ▁set DataType ▁( ▁SQLDataType ▁dataType ▁) ▁{ ▁this ▁. ▁set Return DataType ▁( ▁dataType ▁) ▁; ▁} ▁public ▁boolean ▁is Parallel Enable ▁( ▁) ▁{ ▁return ▁parallel Enable ▁; ▁} ▁public ▁void ▁set Parallel Enable ▁( ▁boolean ▁parallel _ enable ▁) ▁{ ▁this ▁. ▁parallel Enable ▁= ▁parallel _ enable ▁; ▁} ▁public ▁boolean ▁is Aggregate ▁( ▁) ▁{ ▁return ▁aggregate ▁; ▁} ▁public ▁void ▁set Aggregate ▁( ▁boolean ▁aggregate ▁) ▁{ ▁this ▁. ▁aggregate ▁= ▁aggregate ▁; ▁} ▁public ▁SQLName ▁get Using ▁( ▁) ▁{ ▁return ▁using ▁; ▁}
▁customer address Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData String ▁( ▁28 L ▁, ▁13 . 55 13 8 D ▁, ▁18 56 L ▁, ▁0 L ▁) ▁) ▁; ▁customer address Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData String ▁( ▁20 L ▁, ▁8 . 67 13 D ▁, ▁6 90 L ▁, ▁0 L ▁) ▁) ▁; ▁customer address Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData String ▁( ▁21 L ▁, ▁8 . 4 50 12 D ▁, ▁6 9 55 L ▁, ▁0 L ▁) ▁) ▁; ▁final ▁Catalog Column Statistics ▁customer address Catalog Column Statistics ▁= ▁new ▁Catalog Column Statistics ▁( ▁customer address Column StatisticsData ▁) ▁; ▁final ▁CatalogTable Statistics ▁customer address Catalog Table Statistics ▁= ▁new ▁CatalogTable Statistics ▁( ▁5 0000 ▁, ▁0 ▁, ▁0 ▁, ▁0 ▁) ▁; ▁final ▁CatalogTable Stats ▁customer address Catalog Table Stats ▁= ▁new ▁CatalogTable Stats ▁( ▁customer address Catalog Table Statistics ▁, ▁customer address Catalog Column Statistics ▁) ▁; ▁catalog Table Stats Map ▁. ▁put ▁( ▁STR ▁, ▁customer address Catalog Table Stats ▁) ▁; ▁final ▁Map ▁< ▁String ▁, ▁Catalog Column StatisticsData Base ▁> ▁customer de m ograph ics Column StatisticsData ▁= ▁new ▁HashMap ▁< ▁> ▁( ▁) ▁; ▁customer de m ograph ics Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData Long ▁( ▁1 L ▁, ▁19 20 8 00 L ▁, ▁19 13 32 6 L ▁, ▁0 L ▁) ▁) ▁; ▁customer de m ograph ics Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData String ▁( ▁15 L ▁, ▁9 .5 7 14 28 57 14 28 57 1 D ▁, ▁7 L ▁, ▁0 L ▁) ▁) ▁; ▁customer de m ograph ics Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData String ▁( ▁9 L ▁, ▁7 .0 D ▁, ▁4 L ▁, ▁0 L ▁) ▁) ▁; ▁customer de m ograph ics Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData Long ▁( ▁500 L ▁, ▁10000 L ▁, ▁20 L ▁, ▁0 L ▁) ▁) ▁; ▁customer de m ograph ics Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData Long ▁( ▁0 L ▁, ▁6 L ▁, ▁7 L ▁, ▁0 L ▁) ▁) ▁; ▁customer de m ograph ics Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData Long ▁( ▁0 L ▁, ▁6 L ▁, ▁7 L ▁, ▁0 L ▁) ▁) ▁; ▁customer de m ograph ics Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData String ▁( ▁1 L ▁, ▁1.0 D ▁, ▁2 L ▁, ▁0 L ▁) ▁) ▁; ▁customer de m ograph ics Column StatisticsData ▁. ▁put ▁( ▁STR ▁, ▁new ▁Catalog Column StatisticsData Long ▁( ▁0 L ▁, ▁6 L ▁, ▁7 L ▁, ▁0 L ▁) ▁) ▁;
▁public ▁final ▁class ▁Num bers ▁{ ▁private ▁Num bers ▁( ▁) ▁{ ▁} ▁public ▁static ▁boolean ▁is Floating Number ▁( ▁Object ▁number ▁) ▁{ ▁return ▁number ▁instanceof ▁Double ▁|| ▁number ▁instanceof ▁Float ▁; ▁} ▁public ▁static ▁boolean ▁isN an ▁( ▁Object ▁number ▁) ▁{ ▁return ▁number ▁. ▁equals ▁( ▁Double ▁. ▁NaN ▁) ▁|| ▁number ▁. ▁equals ▁( ▁Float ▁. ▁NaN ▁) ▁; ▁} ▁}
▁public ▁class ▁GTable Mouse Listener ▁extends ▁Mouse Adapter ▁{ ▁static ▁{ ▁Dock ingWindowManager ▁. ▁get Help Service ▁( ▁) ▁. ▁register Help ▁( ▁GTable Mouse Listener ▁. ▁class ▁, ▁new ▁HelpLocation ▁( ▁STR ▁, ▁STR ▁) ▁) ▁; ▁} ▁private ▁GTable ▁table ▁; ▁private ▁boolean ▁isD rag ged ▁; ▁private ▁boolean ▁is Popup ▁; ▁private ▁boolean ▁sort ing Enabled ▁= ▁true ▁; ▁GTable Mouse Listener ▁( ▁GTable ▁table ▁) ▁{ ▁this ▁. ▁table ▁= ▁table ▁; ▁} ▁void ▁set Sort ing Enabled ▁( ▁boolean ▁enabled ▁) ▁{ ▁this ▁. ▁sort ing Enabled ▁= ▁enabled ▁; ▁} ▁@ ▁Override ▁public ▁void ▁mouse Pressed ▁( ▁MouseEvent ▁e ▁) ▁{ ▁if ▁( ▁! ▁e ▁. ▁is Popup Trigger ▁( ▁) ▁) ▁{ ▁return ▁; ▁} ▁process Popup ▁( ▁e ▁) ▁; ▁} ▁@ ▁Override ▁public ▁void ▁mouse Released ▁( ▁MouseEvent ▁e ▁) ▁{ ▁if ▁( ▁! ▁e ▁. ▁is Popup Trigger ▁( ▁) ▁) ▁{ ▁isD rag ged ▁= ▁false ▁; ▁return ▁; ▁} ▁process Popup ▁( ▁e ▁) ▁; ▁} ▁private ▁void ▁process Popup ▁( ▁MouseEvent ▁e ▁) ▁{ ▁if ▁( ▁! ▁isD rag ged ▁) ▁{ ▁if ▁( ▁should Ignore Right Click ▁( ▁) ▁) ▁{ ▁return ▁; ▁} ▁int ▁columnIndex ▁= ▁table ▁. ▁column At Point ▁( ▁e ▁. ▁getPoint ▁( ▁) ▁) ▁; ▁J PopupMenu ▁menu ▁= ▁table ▁. ▁getTable Column PopupMenu ▁( ▁columnIndex ▁) ▁; ▁if ▁( ▁menu ▁!= ▁null ▁) ▁{ ▁is Popup ▁= ▁true ▁; ▁menu ▁. ▁show ▁( ▁e ▁. ▁getComponent ▁( ▁) ▁, ▁e ▁. ▁getX ▁( ▁) ▁, ▁e ▁. ▁getY ▁( ▁) ▁) ▁; ▁} ▁e ▁. ▁consume ▁( ▁) ▁; ▁} ▁else ▁{ ▁isD rag ged ▁= ▁false ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁mouse Clicked ▁( ▁MouseEvent ▁e ▁) ▁{ ▁boolean ▁was Popup ▁= ▁is Popup ▁; ▁is Popup ▁= ▁false ▁; ▁if ▁( ▁e ▁. ▁is Consumed ▁( ▁) ▁|| ▁was Popup ▁) ▁{ ▁return ▁; ▁} ▁TableColumn Model ▁col Model ▁= ▁table ▁. ▁getColumn Model ▁( ▁) ▁; ▁int ▁col Index ▁= ▁col Model ▁. ▁getColumn Index At X ▁( ▁e ▁. ▁getX ▁( ▁) ▁) ▁; ▁if ▁( ▁col Index ▁< ▁0 ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁is Help Click ▁( ▁) ▁) ▁{ ▁Dock ingWindowManager ▁. ▁get Help Service ▁( ▁) ▁. ▁show Help ▁( ▁getClass ▁( ▁) ▁, ▁false ▁, ▁table ▁) ▁; ▁return ▁; ▁} ▁if ▁( ▁! ▁sort ing Enabled ▁) ▁{ ▁return ▁; ▁} ▁if ▁( ▁Dock ing Utils ▁. ▁is Control Modifier ▁( ▁e ▁) ▁) ▁{ ▁Table Utils ▁. ▁column Al tern at ively Selected ▁( ▁table ▁, ▁col Index ▁) ▁; ▁} ▁else ▁{ ▁Table Utils ▁. ▁column Selected ▁( ▁table ▁, ▁col Index ▁) ▁; ▁} ▁if ▁( ▁col Model ▁instanceof ▁G TableColumn Model ▁) ▁{ ▁( ▁( ▁G TableColumn Model ▁) ▁col Model ▁) ▁. ▁saveState ▁( ▁) ▁; ▁} ▁} ▁@ ▁Override ▁public ▁void ▁mouse Drag ged ▁( ▁MouseEvent ▁e ▁) ▁{ ▁isD rag ged ▁= ▁true ▁; ▁}
